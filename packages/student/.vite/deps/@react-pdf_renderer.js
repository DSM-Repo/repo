import {
  require_jsx_runtime
} from "./chunk-2UCK2XVF.js";
import {
  require_react
} from "./chunk-QQACB65X.js";
import {
  __commonJS,
  __export,
  __require,
  __toESM
} from "./chunk-SNAQBZPT.js";

// ../../.yarn/cache/inherits-npm-2.0.4-c66b3957a0-4e531f648b.zip/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../.yarn/cache/inherits-npm-2.0.4-c66b3957a0-4e531f648b.zip/node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits3(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits3(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../.yarn/cache/queue-npm-6.0.2-ebbcf599cf-cf987476cc.zip/node_modules/queue/index.js
var require_queue = __commonJS({
  "../../.yarn/cache/queue-npm-6.0.2-ebbcf599cf-cf987476cc.zip/node_modules/queue/index.js"(exports2, module2) {
    var inherits3 = require_inherits_browser();
    var EventEmitter3 = require_events().EventEmitter;
    module2.exports = Queue;
    module2.exports.default = Queue;
    function Queue(options) {
      if (!(this instanceof Queue)) {
        return new Queue(options);
      }
      EventEmitter3.call(this);
      options = options || {};
      this.concurrency = options.concurrency || Infinity;
      this.timeout = options.timeout || 0;
      this.autostart = options.autostart || false;
      this.results = options.results || null;
      this.pending = 0;
      this.session = 0;
      this.running = false;
      this.jobs = [];
      this.timers = {};
    }
    inherits3(Queue, EventEmitter3);
    var arrayMethods = [
      "pop",
      "shift",
      "indexOf",
      "lastIndexOf"
    ];
    arrayMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        return Array.prototype[method].apply(this.jobs, arguments);
      };
    });
    Queue.prototype.slice = function(begin, end3) {
      this.jobs = this.jobs.slice(begin, end3);
      return this;
    };
    Queue.prototype.reverse = function() {
      this.jobs.reverse();
      return this;
    };
    var arrayAddMethods = [
      "push",
      "unshift",
      "splice"
    ];
    arrayAddMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        var methodResult = Array.prototype[method].apply(this.jobs, arguments);
        if (this.autostart) {
          this.start();
        }
        return methodResult;
      };
    });
    Object.defineProperty(Queue.prototype, "length", {
      get: function() {
        return this.pending + this.jobs.length;
      }
    });
    Queue.prototype.start = function(cb) {
      if (cb) {
        callOnErrorOrEnd.call(this, cb);
      }
      this.running = true;
      if (this.pending >= this.concurrency) {
        return;
      }
      if (this.jobs.length === 0) {
        if (this.pending === 0) {
          done3.call(this);
        }
        return;
      }
      var self2 = this;
      var job = this.jobs.shift();
      var once5 = true;
      var session = this.session;
      var timeoutId = null;
      var didTimeout = false;
      var resultIndex = null;
      var timeout = job.hasOwnProperty("timeout") ? job.timeout : this.timeout;
      function next(err2, result) {
        if (once5 && self2.session === session) {
          once5 = false;
          self2.pending--;
          if (timeoutId !== null) {
            delete self2.timers[timeoutId];
            clearTimeout(timeoutId);
          }
          if (err2) {
            self2.emit("error", err2, job);
          } else if (didTimeout === false) {
            if (resultIndex !== null) {
              self2.results[resultIndex] = Array.prototype.slice.call(arguments, 1);
            }
            self2.emit("success", result, job);
          }
          if (self2.session === session) {
            if (self2.pending === 0 && self2.jobs.length === 0) {
              done3.call(self2);
            } else if (self2.running) {
              self2.start();
            }
          }
        }
      }
      if (timeout) {
        timeoutId = setTimeout(function() {
          didTimeout = true;
          if (self2.listeners("timeout").length > 0) {
            self2.emit("timeout", next, job);
          } else {
            next();
          }
        }, timeout);
        this.timers[timeoutId] = timeoutId;
      }
      if (this.results) {
        resultIndex = this.results.length;
        this.results[resultIndex] = null;
      }
      this.pending++;
      self2.emit("start", job);
      var promise = job(next);
      if (promise && promise.then && typeof promise.then === "function") {
        promise.then(function(result) {
          return next(null, result);
        }).catch(function(err2) {
          return next(err2 || true);
        });
      }
      if (this.running && this.jobs.length > 0) {
        this.start();
      }
    };
    Queue.prototype.stop = function() {
      this.running = false;
    };
    Queue.prototype.end = function(err2) {
      clearTimers.call(this);
      this.jobs.length = 0;
      this.pending = 0;
      done3.call(this, err2);
    };
    function clearTimers() {
      for (var key in this.timers) {
        var timeoutId = this.timers[key];
        delete this.timers[key];
        clearTimeout(timeoutId);
      }
    }
    function callOnErrorOrEnd(cb) {
      var self2 = this;
      this.on("error", onerror);
      this.on("end", onend3);
      function onerror(err2) {
        self2.end(err2);
      }
      function onend3(err2) {
        self2.removeListener("error", onerror);
        self2.removeListener("end", onend3);
        cb(err2, this.results);
      }
    }
    function done3(err2) {
      this.session++;
      this.running = false;
      this.emit("end", err2);
    }
  }
});

// ../../.yarn/cache/is-url-npm-1.2.4-0a28aeb560-0157a79874.zip/node_modules/is-url/index.js
var require_is_url = __commonJS({
  "../../.yarn/cache/is-url-npm-1.2.4-0a28aeb560-0157a79874.zip/node_modules/is-url/index.js"(exports2, module2) {
    module2.exports = isUrl;
    var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
    var localhostDomainRE = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/;
    var nonLocalhostDomainRE = /^[^\s\.]+\.\S{2,}$/;
    function isUrl(string) {
      if (typeof string !== "string") {
        return false;
      }
      var match = string.match(protocolAndDomainRE);
      if (!match) {
        return false;
      }
      var everythingAfterProtocol = match[1];
      if (!everythingAfterProtocol) {
        return false;
      }
      if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
        return true;
      }
      return false;
    }
  }
});

// ../../.yarn/cache/cross-fetch-npm-3.1.8-71c3c05709-4c5e022ffe.zip/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "../../.yarn/cache/cross-fetch-npm-3.1.8-71c3c05709-4c5e022ffe.zip/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports2, module2) {
    var global2 = typeof self !== "undefined" ? self : exports2;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F.prototype = global2;
      return new F();
    }();
    (function(self2) {
      var irrelevant = function(exports3) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value2) {
          if (typeof value2 !== "string") {
            value2 = String(value2);
          }
          return value2;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value2 = items.shift();
              return { done: value2 === void 0, value: value2 };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value2, name2) {
              this.append(name2, value2);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers.prototype.append = function(name2, value2) {
          name2 = normalizeName(name2);
          value2 = normalizeValue(value2);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value2 : value2;
        };
        Headers.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers.prototype.set = function(name2, value2) {
          this.map[normalizeName(name2)] = normalizeValue(value2);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value2, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value2) {
            items.push(value2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value2, name2) {
            items.push([name2, value2]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve3, reject) {
            reader.onload = function() {
              resolve3(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode2);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode2(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split3 = bytes.split("=");
              var name2 = split3.shift().replace(/\+/g, " ");
              var value2 = split3.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value2));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line2) {
            var parts = line2.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value2 = parts.join(":").trim();
              headers.append(key, value2);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports3.DOMException = self2.DOMException;
        try {
          new exports3.DOMException();
        } catch (err2) {
          exports3.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports3.DOMException.prototype = Object.create(Error.prototype);
          exports3.DOMException.prototype.constructor = exports3.DOMException;
        }
        function fetch4(input, init4) {
          return new Promise(function(resolve3, reject) {
            var request = new Request(input, init4);
            if (request.signal && request.signal.aborted) {
              return reject(new exports3.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve3(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports3.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value2, name2) {
              xhr.setRequestHeader(name2, value2);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch4.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch4;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports3.Headers = Headers;
        exports3.Request = Request;
        exports3.Response = Response;
        exports3.fetch = fetch4;
        Object.defineProperty(exports3, "__esModule", { value: true });
        return exports3;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports2 = ctx.fetch;
    exports2.default = ctx.fetch;
    exports2.fetch = ctx.fetch;
    exports2.Headers = ctx.Headers;
    exports2.Request = ctx.Request;
    exports2.Response = ctx.Response;
    module2.exports = exports2;
  }
});

// ../../.yarn/cache/fast-deep-equal-npm-3.1.3-790edcfcf5-40dedc862e.zip/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../../.yarn/cache/fast-deep-equal-npm-3.1.3-790edcfcf5-40dedc862e.zip/node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal3(a2, b) {
      if (a2 === b) return true;
      if (a2 && b && typeof a2 == "object" && typeof b == "object") {
        if (a2.constructor !== b.constructor) return false;
        var length4, i, keys2;
        if (Array.isArray(a2)) {
          length4 = a2.length;
          if (length4 != b.length) return false;
          for (i = length4; i-- !== 0; )
            if (!equal3(a2[i], b[i])) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b.source && a2.flags === b.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b.toString();
        keys2 = Object.keys(a2);
        length4 = keys2.length;
        if (length4 !== Object.keys(b).length) return false;
        for (i = length4; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys2[i])) return false;
        for (i = length4; i-- !== 0; ) {
          var key = keys2[i];
          if (!equal3(a2[key], b[key])) return false;
        }
        return true;
      }
      return a2 !== a2 && b !== b;
    };
  }
});

// ../../.yarn/cache/base64-js-npm-1.5.1-b2f7275641-f23823513b.zip/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../.yarn/cache/base64-js-npm-1.5.1-b2f7275641-f23823513b.zip/node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength5;
    exports2.toByteArray = toByteArray4;
    exports2.fromByteArray = fromByteArray4;
    var lookup4 = [];
    var revLookup4 = [];
    var Arr4 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup4[i] = code[i];
      revLookup4[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup4["-".charCodeAt(0)] = 62;
    revLookup4["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength5(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray4(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr4(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup4[b64.charCodeAt(i2)] << 18 | revLookup4[b64.charCodeAt(i2 + 1)] << 12 | revLookup4[b64.charCodeAt(i2 + 2)] << 6 | revLookup4[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup4[b64.charCodeAt(i2)] << 2 | revLookup4[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup4[b64.charCodeAt(i2)] << 10 | revLookup4[b64.charCodeAt(i2 + 1)] << 4 | revLookup4[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase644(num) {
      return lookup4[num >> 18 & 63] + lookup4[num >> 12 & 63] + lookup4[num >> 6 & 63] + lookup4[num & 63];
    }
    function encodeChunk4(uint82, start3, end3) {
      var tmp;
      var output = [];
      for (var i2 = start3; i2 < end3; i2 += 3) {
        tmp = (uint82[i2] << 16 & 16711680) + (uint82[i2 + 1] << 8 & 65280) + (uint82[i2 + 2] & 255);
        output.push(tripletToBase644(tmp));
      }
      return output.join("");
    }
    function fromByteArray4(uint82) {
      var tmp;
      var len2 = uint82.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk4(uint82, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint82[len2 - 1];
        parts.push(
          lookup4[tmp >> 2] + lookup4[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint82[len2 - 2] << 8) + uint82[len2 - 1];
        parts.push(
          lookup4[tmp >> 10] + lookup4[tmp >> 4 & 63] + lookup4[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../.yarn/cache/tiny-inflate-npm-1.0.3-a7419a5c65-fab6875372.zip/node_modules/tiny-inflate/index.js
var require_tiny_inflate = __commonJS({
  "../../.yarn/cache/tiny-inflate-npm-1.0.3-a7419a5c65-fab6875372.zip/node_modules/tiny-inflate/index.js"(exports2, module2) {
    var TINF_OK = 0;
    var TINF_DATA_ERROR = -3;
    function Tree() {
      this.table = new Uint16Array(16);
      this.trans = new Uint16Array(288);
    }
    function Data(source, dest) {
      this.source = source;
      this.sourceIndex = 0;
      this.tag = 0;
      this.bitcount = 0;
      this.dest = dest;
      this.destLen = 0;
      this.ltree = new Tree();
      this.dtree = new Tree();
    }
    var sltree = new Tree();
    var sdtree = new Tree();
    var length_bits = new Uint8Array(30);
    var length_base = new Uint16Array(30);
    var dist_bits = new Uint8Array(30);
    var dist_base = new Uint16Array(30);
    var clcidx = new Uint8Array([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ]);
    var code_tree = new Tree();
    var lengths = new Uint8Array(288 + 32);
    function tinf_build_bits_base(bits, base, delta, first) {
      var i, sum;
      for (i = 0; i < delta; ++i) bits[i] = 0;
      for (i = 0; i < 30 - delta; ++i) bits[i + delta] = i / delta | 0;
      for (sum = first, i = 0; i < 30; ++i) {
        base[i] = sum;
        sum += 1 << bits[i];
      }
    }
    function tinf_build_fixed_trees(lt, dt) {
      var i;
      for (i = 0; i < 7; ++i) lt.table[i] = 0;
      lt.table[7] = 24;
      lt.table[8] = 152;
      lt.table[9] = 112;
      for (i = 0; i < 24; ++i) lt.trans[i] = 256 + i;
      for (i = 0; i < 144; ++i) lt.trans[24 + i] = i;
      for (i = 0; i < 8; ++i) lt.trans[24 + 144 + i] = 280 + i;
      for (i = 0; i < 112; ++i) lt.trans[24 + 144 + 8 + i] = 144 + i;
      for (i = 0; i < 5; ++i) dt.table[i] = 0;
      dt.table[5] = 32;
      for (i = 0; i < 32; ++i) dt.trans[i] = i;
    }
    var offs = new Uint16Array(16);
    function tinf_build_tree(t2, lengths2, off3, num) {
      var i, sum;
      for (i = 0; i < 16; ++i) t2.table[i] = 0;
      for (i = 0; i < num; ++i) t2.table[lengths2[off3 + i]]++;
      t2.table[0] = 0;
      for (sum = 0, i = 0; i < 16; ++i) {
        offs[i] = sum;
        sum += t2.table[i];
      }
      for (i = 0; i < num; ++i) {
        if (lengths2[off3 + i]) t2.trans[offs[lengths2[off3 + i]]++] = i;
      }
    }
    function tinf_getbit(d) {
      if (!d.bitcount--) {
        d.tag = d.source[d.sourceIndex++];
        d.bitcount = 7;
      }
      var bit = d.tag & 1;
      d.tag >>>= 1;
      return bit;
    }
    function tinf_read_bits(d, num, base) {
      if (!num)
        return base;
      while (d.bitcount < 24) {
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
      }
      var val = d.tag & 65535 >>> 16 - num;
      d.tag >>>= num;
      d.bitcount -= num;
      return val + base;
    }
    function tinf_decode_symbol(d, t2) {
      while (d.bitcount < 24) {
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
      }
      var sum = 0, cur = 0, len = 0;
      var tag = d.tag;
      do {
        cur = 2 * cur + (tag & 1);
        tag >>>= 1;
        ++len;
        sum += t2.table[len];
        cur -= t2.table[len];
      } while (cur >= 0);
      d.tag = tag;
      d.bitcount -= len;
      return t2.trans[sum + cur];
    }
    function tinf_decode_trees(d, lt, dt) {
      var hlit, hdist, hclen;
      var i, num, length4;
      hlit = tinf_read_bits(d, 5, 257);
      hdist = tinf_read_bits(d, 5, 1);
      hclen = tinf_read_bits(d, 4, 4);
      for (i = 0; i < 19; ++i) lengths[i] = 0;
      for (i = 0; i < hclen; ++i) {
        var clen = tinf_read_bits(d, 3, 0);
        lengths[clcidx[i]] = clen;
      }
      tinf_build_tree(code_tree, lengths, 0, 19);
      for (num = 0; num < hlit + hdist; ) {
        var sym = tinf_decode_symbol(d, code_tree);
        switch (sym) {
          case 16:
            var prev = lengths[num - 1];
            for (length4 = tinf_read_bits(d, 2, 3); length4; --length4) {
              lengths[num++] = prev;
            }
            break;
          case 17:
            for (length4 = tinf_read_bits(d, 3, 3); length4; --length4) {
              lengths[num++] = 0;
            }
            break;
          case 18:
            for (length4 = tinf_read_bits(d, 7, 11); length4; --length4) {
              lengths[num++] = 0;
            }
            break;
          default:
            lengths[num++] = sym;
            break;
        }
      }
      tinf_build_tree(lt, lengths, 0, hlit);
      tinf_build_tree(dt, lengths, hlit, hdist);
    }
    function tinf_inflate_block_data(d, lt, dt) {
      while (1) {
        var sym = tinf_decode_symbol(d, lt);
        if (sym === 256) {
          return TINF_OK;
        }
        if (sym < 256) {
          d.dest[d.destLen++] = sym;
        } else {
          var length4, dist, offs2;
          var i;
          sym -= 257;
          length4 = tinf_read_bits(d, length_bits[sym], length_base[sym]);
          dist = tinf_decode_symbol(d, dt);
          offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
          for (i = offs2; i < offs2 + length4; ++i) {
            d.dest[d.destLen++] = d.dest[i];
          }
        }
      }
    }
    function tinf_inflate_uncompressed_block(d) {
      var length4, invlength;
      var i;
      while (d.bitcount > 8) {
        d.sourceIndex--;
        d.bitcount -= 8;
      }
      length4 = d.source[d.sourceIndex + 1];
      length4 = 256 * length4 + d.source[d.sourceIndex];
      invlength = d.source[d.sourceIndex + 3];
      invlength = 256 * invlength + d.source[d.sourceIndex + 2];
      if (length4 !== (~invlength & 65535))
        return TINF_DATA_ERROR;
      d.sourceIndex += 4;
      for (i = length4; i; --i)
        d.dest[d.destLen++] = d.source[d.sourceIndex++];
      d.bitcount = 0;
      return TINF_OK;
    }
    function tinf_uncompress(source, dest) {
      var d = new Data(source, dest);
      var bfinal, btype, res;
      do {
        bfinal = tinf_getbit(d);
        btype = tinf_read_bits(d, 2, 0);
        switch (btype) {
          case 0:
            res = tinf_inflate_uncompressed_block(d);
            break;
          case 1:
            res = tinf_inflate_block_data(d, sltree, sdtree);
            break;
          case 2:
            tinf_decode_trees(d, d.ltree, d.dtree);
            res = tinf_inflate_block_data(d, d.ltree, d.dtree);
            break;
          default:
            res = TINF_DATA_ERROR;
        }
        if (res !== TINF_OK)
          throw new Error("Data error");
      } while (!bfinal);
      if (d.destLen < d.dest.length) {
        if (typeof d.dest.slice === "function")
          return d.dest.slice(0, d.destLen);
        else
          return d.dest.subarray(0, d.destLen);
      }
      return d.dest;
    }
    tinf_build_fixed_trees(sltree, sdtree);
    tinf_build_bits_base(length_bits, length_base, 4, 3);
    tinf_build_bits_base(dist_bits, dist_base, 2, 1);
    length_bits[28] = 0;
    length_base[28] = 258;
    module2.exports = tinf_uncompress;
  }
});

// ../../.yarn/cache/unicode-trie-npm-2.0.0-54e0a4dd52-2422368645.zip/node_modules/unicode-trie/swap.js
var require_swap = __commonJS({
  "../../.yarn/cache/unicode-trie-npm-2.0.0-54e0a4dd52-2422368645.zip/node_modules/unicode-trie/swap.js"(exports2, module2) {
    var isBigEndian2 = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
    var swap4 = (b, n, m2) => {
      let i = b[n];
      b[n] = b[m2];
      b[m2] = i;
    };
    var swap324 = (array) => {
      const len = array.length;
      for (let i = 0; i < len; i += 4) {
        swap4(array, i, i + 3);
        swap4(array, i + 1, i + 2);
      }
    };
    var swap32LE = (array) => {
      if (isBigEndian2) {
        swap324(array);
      }
    };
    module2.exports = {
      swap32LE
    };
  }
});

// ../../.yarn/cache/unicode-trie-npm-2.0.0-54e0a4dd52-2422368645.zip/node_modules/unicode-trie/index.js
var require_unicode_trie = __commonJS({
  "../../.yarn/cache/unicode-trie-npm-2.0.0-54e0a4dd52-2422368645.zip/node_modules/unicode-trie/index.js"(exports2, module2) {
    var inflate2 = require_tiny_inflate();
    var { swap32LE } = require_swap();
    var SHIFT_1 = 6 + 5;
    var SHIFT_2 = 5;
    var SHIFT_1_2 = SHIFT_1 - SHIFT_2;
    var OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
    var INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
    var INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
    var INDEX_SHIFT = 2;
    var DATA_BLOCK_LENGTH = 1 << SHIFT_2;
    var DATA_MASK = DATA_BLOCK_LENGTH - 1;
    var LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
    var LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
    var INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
    var UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
    var UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
    var INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
    var DATA_GRANULARITY = 1 << INDEX_SHIFT;
    var UnicodeTrie = class {
      constructor(data2) {
        const isBuffer4 = typeof data2.readUInt32BE === "function" && typeof data2.slice === "function";
        if (isBuffer4 || data2 instanceof Uint8Array) {
          let uncompressedLength;
          if (isBuffer4) {
            this.highStart = data2.readUInt32LE(0);
            this.errorValue = data2.readUInt32LE(4);
            uncompressedLength = data2.readUInt32LE(8);
            data2 = data2.slice(12);
          } else {
            const view = new DataView(data2.buffer);
            this.highStart = view.getUint32(0, true);
            this.errorValue = view.getUint32(4, true);
            uncompressedLength = view.getUint32(8, true);
            data2 = data2.subarray(12);
          }
          data2 = inflate2(data2, new Uint8Array(uncompressedLength));
          data2 = inflate2(data2, new Uint8Array(uncompressedLength));
          swap32LE(data2);
          this.data = new Uint32Array(data2.buffer);
        } else {
          ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data2);
        }
      }
      get(codePoint) {
        let index2;
        if (codePoint < 0 || codePoint > 1114111) {
          return this.errorValue;
        }
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          index2 = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index2];
        }
        if (codePoint <= 65535) {
          index2 = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index2];
        }
        if (codePoint < this.highStart) {
          index2 = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
          index2 = this.data[index2 + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
          index2 = (index2 << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index2];
        }
        return this.data[this.data.length - DATA_GRANULARITY];
      }
    };
    module2.exports = UnicodeTrie;
  }
});

// ../../.yarn/cache/dfa-npm-1.2.0-2b05ce5c5e-ad12f0bc73.zip/node_modules/dfa/index.js
var require_dfa = __commonJS({
  "../../.yarn/cache/dfa-npm-1.2.0-2b05ce5c5e-ad12f0bc73.zip/node_modules/dfa/index.js"(exports2, module2) {
    "use strict";
    var INITIAL_STATE = 1;
    var FAIL_STATE = 0;
    var StateMachine = class {
      constructor(dfa) {
        this.stateTable = dfa.stateTable;
        this.accepting = dfa.accepting;
        this.tags = dfa.tags;
      }
      /**
       * Returns an iterable object that yields pattern matches over the input sequence.
       * Matches are of the form [startIndex, endIndex, tags].
       */
      match(str) {
        var self2 = this;
        return {
          *[Symbol.iterator]() {
            var state2 = INITIAL_STATE;
            var startRun = null;
            var lastAccepting = null;
            var lastState = null;
            for (var p = 0; p < str.length; p++) {
              var c2 = str[p];
              lastState = state2;
              state2 = self2.stateTable[state2][c2];
              if (state2 === FAIL_STATE) {
                if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
                  yield [startRun, lastAccepting, self2.tags[lastState]];
                }
                state2 = self2.stateTable[INITIAL_STATE][c2];
                startRun = null;
              }
              if (state2 !== FAIL_STATE && startRun == null) {
                startRun = p;
              }
              if (self2.accepting[state2]) {
                lastAccepting = p;
              }
              if (state2 === FAIL_STATE) {
                state2 = INITIAL_STATE;
              }
            }
            if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
              yield [startRun, lastAccepting, self2.tags[state2]];
            }
          }
        };
      }
      /**
       * For each match over the input sequence, action functions matching
       * the tag definitions in the input pattern are called with the startIndex,
       * endIndex, and sub-match sequence.
       */
      apply(str, actions) {
        for (var [start3, end3, tags2] of this.match(str)) {
          for (var tag of tags2) {
            if (typeof actions[tag] === "function") {
              actions[tag](start3, end3, str.slice(start3, end3 + 1));
            }
          }
        }
      }
    };
    module2.exports = StateMachine;
  }
});

// ../../.yarn/cache/clone-npm-2.1.2-1d491c6629-ed0601cd0b.zip/node_modules/clone/clone.js
var require_clone = __commonJS({
  "../../.yarn/cache/clone-npm-2.1.2-1d491c6629-ed0601cd0b.zip/node_modules/clone/clone.js"(exports2, module2) {
    var clone = function() {
      "use strict";
      function _instanceof(obj, type2) {
        return type2 != null && obj instanceof type2;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_) {
        nativePromise = function() {
        };
      }
      function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve3, reject) {
              parent2.then(function(value2) {
                resolve3(_clone(value2, depth2 - 1));
              }, function(err2) {
                reject(_clone(err2, depth2 - 1));
              });
            });
          } else if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index2 = allParents.indexOf(parent2);
            if (index2 != -1) {
              return allChildren[index2];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value2, key) {
              var keyChild = _clone(key, depth2 - 1);
              var valueChild = _clone(value2, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value2) {
              var entryChild = _clone(value2, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent2[i], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent2);
            for (var i = 0; i < symbols.length; i++) {
              var symbol = symbols[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent2[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i = 0; i < allPropertyNames.length; i++) {
              var propertyName = allPropertyNames[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c2 = function() {
        };
        c2.prototype = parent;
        return new c2();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      clone2.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      clone2.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      clone2.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global) flags += "g";
        if (re.ignoreCase) flags += "i";
        if (re.multiline) flags += "m";
        return flags;
      }
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module2 === "object" && module2.exports) {
      module2.exports = clone;
    }
  }
});

// ../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/streams.js
var require_streams = __commonJS({
  "../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/streams.js"(exports2) {
    function BrotliInput(buffer) {
      this.buffer = buffer;
      this.pos = 0;
    }
    BrotliInput.prototype.read = function(buf, i, count) {
      if (this.pos + count > this.buffer.length) {
        count = this.buffer.length - this.pos;
      }
      for (var p = 0; p < count; p++)
        buf[i + p] = this.buffer[this.pos + p];
      this.pos += count;
      return count;
    };
    exports2.BrotliInput = BrotliInput;
    function BrotliOutput(buf) {
      this.buffer = buf;
      this.pos = 0;
    }
    BrotliOutput.prototype.write = function(buf, count) {
      if (this.pos + count > this.buffer.length)
        throw new Error("Output buffer is not large enough");
      this.buffer.set(buf.subarray(0, count), this.pos);
      this.pos += count;
      return count;
    };
    exports2.BrotliOutput = BrotliOutput;
  }
});

// ../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/bit_reader.js
var require_bit_reader = __commonJS({
  "../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/bit_reader.js"(exports2, module2) {
    var BROTLI_READ_SIZE = 4096;
    var BROTLI_IBUF_SIZE = 2 * BROTLI_READ_SIZE + 32;
    var BROTLI_IBUF_MASK = 2 * BROTLI_READ_SIZE - 1;
    var kBitMask = new Uint32Array([
      0,
      1,
      3,
      7,
      15,
      31,
      63,
      127,
      255,
      511,
      1023,
      2047,
      4095,
      8191,
      16383,
      32767,
      65535,
      131071,
      262143,
      524287,
      1048575,
      2097151,
      4194303,
      8388607,
      16777215
    ]);
    function BrotliBitReader(input) {
      this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE);
      this.input_ = input;
      this.reset();
    }
    BrotliBitReader.READ_SIZE = BROTLI_READ_SIZE;
    BrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK;
    BrotliBitReader.prototype.reset = function() {
      this.buf_ptr_ = 0;
      this.val_ = 0;
      this.pos_ = 0;
      this.bit_pos_ = 0;
      this.bit_end_pos_ = 0;
      this.eos_ = 0;
      this.readMoreInput();
      for (var i = 0; i < 4; i++) {
        this.val_ |= this.buf_[this.pos_] << 8 * i;
        ++this.pos_;
      }
      return this.bit_end_pos_ > 0;
    };
    BrotliBitReader.prototype.readMoreInput = function() {
      if (this.bit_end_pos_ > 256) {
        return;
      } else if (this.eos_) {
        if (this.bit_pos_ > this.bit_end_pos_)
          throw new Error("Unexpected end of input " + this.bit_pos_ + " " + this.bit_end_pos_);
      } else {
        var dst = this.buf_ptr_;
        var bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE);
        if (bytes_read < 0) {
          throw new Error("Unexpected end of input");
        }
        if (bytes_read < BROTLI_READ_SIZE) {
          this.eos_ = 1;
          for (var p = 0; p < 32; p++)
            this.buf_[dst + bytes_read + p] = 0;
        }
        if (dst === 0) {
          for (var p = 0; p < 32; p++)
            this.buf_[(BROTLI_READ_SIZE << 1) + p] = this.buf_[p];
          this.buf_ptr_ = BROTLI_READ_SIZE;
        } else {
          this.buf_ptr_ = 0;
        }
        this.bit_end_pos_ += bytes_read << 3;
      }
    };
    BrotliBitReader.prototype.fillBitWindow = function() {
      while (this.bit_pos_ >= 8) {
        this.val_ >>>= 8;
        this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24;
        ++this.pos_;
        this.bit_pos_ = this.bit_pos_ - 8 >>> 0;
        this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;
      }
    };
    BrotliBitReader.prototype.readBits = function(n_bits) {
      if (32 - this.bit_pos_ < n_bits) {
        this.fillBitWindow();
      }
      var val = this.val_ >>> this.bit_pos_ & kBitMask[n_bits];
      this.bit_pos_ += n_bits;
      return val;
    };
    module2.exports = BrotliBitReader;
  }
});

// ../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/dictionary.bin.js
var require_dictionary_bin = __commonJS({
  "../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/dictionary.bin.js"(exports2, module2) {
    module2.exports = "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";
  }
});

// ../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/dictionary-browser.js
var require_dictionary_browser = __commonJS({
  "../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/dictionary-browser.js"(exports2) {
    var base64 = require_base64_js();
    exports2.init = function() {
      var BrotliDecompressBuffer = require_decode().BrotliDecompressBuffer;
      var compressed = base64.toByteArray(require_dictionary_bin());
      return BrotliDecompressBuffer(compressed);
    };
  }
});

// ../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/dictionary.js
var require_dictionary = __commonJS({
  "../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/dictionary.js"(exports2) {
    var data2 = require_dictionary_browser();
    exports2.init = function() {
      exports2.dictionary = data2.init();
    };
    exports2.offsetsByLength = new Uint32Array([
      0,
      0,
      0,
      0,
      0,
      4096,
      9216,
      21504,
      35840,
      44032,
      53248,
      63488,
      74752,
      87040,
      93696,
      100864,
      104704,
      106752,
      108928,
      113536,
      115968,
      118528,
      119872,
      121280,
      122016
    ]);
    exports2.sizeBitsByLength = new Uint8Array([
      0,
      0,
      0,
      0,
      10,
      10,
      11,
      11,
      10,
      10,
      10,
      10,
      10,
      9,
      9,
      8,
      7,
      7,
      8,
      7,
      7,
      6,
      6,
      5,
      5
    ]);
    exports2.minDictionaryWordLength = 4;
    exports2.maxDictionaryWordLength = 24;
  }
});

// ../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/huffman.js
var require_huffman = __commonJS({
  "../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/huffman.js"(exports2) {
    function HuffmanCode(bits, value2) {
      this.bits = bits;
      this.value = value2;
    }
    exports2.HuffmanCode = HuffmanCode;
    var MAX_LENGTH = 15;
    function GetNextKey(key, len) {
      var step = 1 << len - 1;
      while (key & step) {
        step >>= 1;
      }
      return (key & step - 1) + step;
    }
    function ReplicateValue(table, i, step, end3, code) {
      do {
        end3 -= step;
        table[i + end3] = new HuffmanCode(code.bits, code.value);
      } while (end3 > 0);
    }
    function NextTableBitSize(count, len, root_bits) {
      var left = 1 << len - root_bits;
      while (len < MAX_LENGTH) {
        left -= count[len];
        if (left <= 0) break;
        ++len;
        left <<= 1;
      }
      return len - root_bits;
    }
    exports2.BrotliBuildHuffmanTable = function(root_table, table, root_bits, code_lengths, code_lengths_size) {
      var start_table = table;
      var code;
      var len;
      var symbol;
      var key;
      var step;
      var low;
      var mask;
      var table_bits;
      var table_size;
      var total_size;
      var sorted;
      var count = new Int32Array(MAX_LENGTH + 1);
      var offset3 = new Int32Array(MAX_LENGTH + 1);
      sorted = new Int32Array(code_lengths_size);
      for (symbol = 0; symbol < code_lengths_size; symbol++) {
        count[code_lengths[symbol]]++;
      }
      offset3[1] = 0;
      for (len = 1; len < MAX_LENGTH; len++) {
        offset3[len + 1] = offset3[len] + count[len];
      }
      for (symbol = 0; symbol < code_lengths_size; symbol++) {
        if (code_lengths[symbol] !== 0) {
          sorted[offset3[code_lengths[symbol]]++] = symbol;
        }
      }
      table_bits = root_bits;
      table_size = 1 << table_bits;
      total_size = table_size;
      if (offset3[MAX_LENGTH] === 1) {
        for (key = 0; key < total_size; ++key) {
          root_table[table + key] = new HuffmanCode(0, sorted[0] & 65535);
        }
        return total_size;
      }
      key = 0;
      symbol = 0;
      for (len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {
        for (; count[len] > 0; --count[len]) {
          code = new HuffmanCode(len & 255, sorted[symbol++] & 65535);
          ReplicateValue(root_table, table + key, step, table_size, code);
          key = GetNextKey(key, len);
        }
      }
      mask = total_size - 1;
      low = -1;
      for (len = root_bits + 1, step = 2; len <= MAX_LENGTH; ++len, step <<= 1) {
        for (; count[len] > 0; --count[len]) {
          if ((key & mask) !== low) {
            table += table_size;
            table_bits = NextTableBitSize(count, len, root_bits);
            table_size = 1 << table_bits;
            total_size += table_size;
            low = key & mask;
            root_table[start_table + low] = new HuffmanCode(table_bits + root_bits & 255, table - start_table - low & 65535);
          }
          code = new HuffmanCode(len - root_bits & 255, sorted[symbol++] & 65535);
          ReplicateValue(root_table, table + (key >> root_bits), step, table_size, code);
          key = GetNextKey(key, len);
        }
      }
      return total_size;
    };
  }
});

// ../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/context.js
var require_context = __commonJS({
  "../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/context.js"(exports2) {
    exports2.lookup = new Uint8Array([
      /* CONTEXT_UTF8, last byte. */
      /* ASCII range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      8,
      12,
      16,
      12,
      12,
      20,
      12,
      16,
      24,
      28,
      12,
      12,
      32,
      12,
      36,
      12,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      32,
      32,
      24,
      40,
      28,
      12,
      12,
      48,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      24,
      12,
      28,
      12,
      12,
      12,
      56,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      24,
      12,
      28,
      12,
      0,
      /* UTF8 continuation byte range. */
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      /* UTF8 lead byte range. */
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      /* CONTEXT_UTF8 second last byte. */
      /* ASCII range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      1,
      1,
      1,
      1,
      0,
      /* UTF8 continuation byte range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      /* UTF8 lead byte range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      /* CONTEXT_SIGNED, second last byte. */
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      7,
      /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */
      0,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      56,
      /* CONTEXT_LSB6, last byte. */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      /* CONTEXT_MSB6, last byte. */
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      7,
      7,
      7,
      7,
      8,
      8,
      8,
      8,
      9,
      9,
      9,
      9,
      10,
      10,
      10,
      10,
      11,
      11,
      11,
      11,
      12,
      12,
      12,
      12,
      13,
      13,
      13,
      13,
      14,
      14,
      14,
      14,
      15,
      15,
      15,
      15,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      22,
      22,
      22,
      22,
      23,
      23,
      23,
      23,
      24,
      24,
      24,
      24,
      25,
      25,
      25,
      25,
      26,
      26,
      26,
      26,
      27,
      27,
      27,
      27,
      28,
      28,
      28,
      28,
      29,
      29,
      29,
      29,
      30,
      30,
      30,
      30,
      31,
      31,
      31,
      31,
      32,
      32,
      32,
      32,
      33,
      33,
      33,
      33,
      34,
      34,
      34,
      34,
      35,
      35,
      35,
      35,
      36,
      36,
      36,
      36,
      37,
      37,
      37,
      37,
      38,
      38,
      38,
      38,
      39,
      39,
      39,
      39,
      40,
      40,
      40,
      40,
      41,
      41,
      41,
      41,
      42,
      42,
      42,
      42,
      43,
      43,
      43,
      43,
      44,
      44,
      44,
      44,
      45,
      45,
      45,
      45,
      46,
      46,
      46,
      46,
      47,
      47,
      47,
      47,
      48,
      48,
      48,
      48,
      49,
      49,
      49,
      49,
      50,
      50,
      50,
      50,
      51,
      51,
      51,
      51,
      52,
      52,
      52,
      52,
      53,
      53,
      53,
      53,
      54,
      54,
      54,
      54,
      55,
      55,
      55,
      55,
      56,
      56,
      56,
      56,
      57,
      57,
      57,
      57,
      58,
      58,
      58,
      58,
      59,
      59,
      59,
      59,
      60,
      60,
      60,
      60,
      61,
      61,
      61,
      61,
      62,
      62,
      62,
      62,
      63,
      63,
      63,
      63,
      /* CONTEXT_{M,L}SB6, second last byte, */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports2.lookupOffsets = new Uint16Array([
      /* CONTEXT_LSB6 */
      1024,
      1536,
      /* CONTEXT_MSB6 */
      1280,
      1536,
      /* CONTEXT_UTF8 */
      0,
      256,
      /* CONTEXT_SIGNED */
      768,
      512
    ]);
  }
});

// ../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/prefix.js
var require_prefix = __commonJS({
  "../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/prefix.js"(exports2) {
    function PrefixCodeRange(offset3, nbits) {
      this.offset = offset3;
      this.nbits = nbits;
    }
    exports2.kBlockLengthPrefixCode = [
      new PrefixCodeRange(1, 2),
      new PrefixCodeRange(5, 2),
      new PrefixCodeRange(9, 2),
      new PrefixCodeRange(13, 2),
      new PrefixCodeRange(17, 3),
      new PrefixCodeRange(25, 3),
      new PrefixCodeRange(33, 3),
      new PrefixCodeRange(41, 3),
      new PrefixCodeRange(49, 4),
      new PrefixCodeRange(65, 4),
      new PrefixCodeRange(81, 4),
      new PrefixCodeRange(97, 4),
      new PrefixCodeRange(113, 5),
      new PrefixCodeRange(145, 5),
      new PrefixCodeRange(177, 5),
      new PrefixCodeRange(209, 5),
      new PrefixCodeRange(241, 6),
      new PrefixCodeRange(305, 6),
      new PrefixCodeRange(369, 7),
      new PrefixCodeRange(497, 8),
      new PrefixCodeRange(753, 9),
      new PrefixCodeRange(1265, 10),
      new PrefixCodeRange(2289, 11),
      new PrefixCodeRange(4337, 12),
      new PrefixCodeRange(8433, 13),
      new PrefixCodeRange(16625, 24)
    ];
    exports2.kInsertLengthPrefixCode = [
      new PrefixCodeRange(0, 0),
      new PrefixCodeRange(1, 0),
      new PrefixCodeRange(2, 0),
      new PrefixCodeRange(3, 0),
      new PrefixCodeRange(4, 0),
      new PrefixCodeRange(5, 0),
      new PrefixCodeRange(6, 1),
      new PrefixCodeRange(8, 1),
      new PrefixCodeRange(10, 2),
      new PrefixCodeRange(14, 2),
      new PrefixCodeRange(18, 3),
      new PrefixCodeRange(26, 3),
      new PrefixCodeRange(34, 4),
      new PrefixCodeRange(50, 4),
      new PrefixCodeRange(66, 5),
      new PrefixCodeRange(98, 5),
      new PrefixCodeRange(130, 6),
      new PrefixCodeRange(194, 7),
      new PrefixCodeRange(322, 8),
      new PrefixCodeRange(578, 9),
      new PrefixCodeRange(1090, 10),
      new PrefixCodeRange(2114, 12),
      new PrefixCodeRange(6210, 14),
      new PrefixCodeRange(22594, 24)
    ];
    exports2.kCopyLengthPrefixCode = [
      new PrefixCodeRange(2, 0),
      new PrefixCodeRange(3, 0),
      new PrefixCodeRange(4, 0),
      new PrefixCodeRange(5, 0),
      new PrefixCodeRange(6, 0),
      new PrefixCodeRange(7, 0),
      new PrefixCodeRange(8, 0),
      new PrefixCodeRange(9, 0),
      new PrefixCodeRange(10, 1),
      new PrefixCodeRange(12, 1),
      new PrefixCodeRange(14, 2),
      new PrefixCodeRange(18, 2),
      new PrefixCodeRange(22, 3),
      new PrefixCodeRange(30, 3),
      new PrefixCodeRange(38, 4),
      new PrefixCodeRange(54, 4),
      new PrefixCodeRange(70, 5),
      new PrefixCodeRange(102, 5),
      new PrefixCodeRange(134, 6),
      new PrefixCodeRange(198, 7),
      new PrefixCodeRange(326, 8),
      new PrefixCodeRange(582, 9),
      new PrefixCodeRange(1094, 10),
      new PrefixCodeRange(2118, 24)
    ];
    exports2.kInsertRangeLut = [
      0,
      0,
      8,
      8,
      0,
      16,
      8,
      16,
      16
    ];
    exports2.kCopyRangeLut = [
      0,
      8,
      0,
      8,
      16,
      0,
      16,
      8,
      16
    ];
  }
});

// ../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/transform.js
var require_transform = __commonJS({
  "../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/transform.js"(exports2) {
    var BrotliDictionary = require_dictionary();
    var kIdentity = 0;
    var kOmitLast1 = 1;
    var kOmitLast2 = 2;
    var kOmitLast3 = 3;
    var kOmitLast4 = 4;
    var kOmitLast5 = 5;
    var kOmitLast6 = 6;
    var kOmitLast7 = 7;
    var kOmitLast8 = 8;
    var kOmitLast9 = 9;
    var kUppercaseFirst = 10;
    var kUppercaseAll = 11;
    var kOmitFirst1 = 12;
    var kOmitFirst2 = 13;
    var kOmitFirst3 = 14;
    var kOmitFirst4 = 15;
    var kOmitFirst5 = 16;
    var kOmitFirst6 = 17;
    var kOmitFirst7 = 18;
    var kOmitFirst9 = 20;
    function Transform3(prefix, transform4, suffix) {
      this.prefix = new Uint8Array(prefix.length);
      this.transform = transform4;
      this.suffix = new Uint8Array(suffix.length);
      for (var i = 0; i < prefix.length; i++)
        this.prefix[i] = prefix.charCodeAt(i);
      for (var i = 0; i < suffix.length; i++)
        this.suffix[i] = suffix.charCodeAt(i);
    }
    var kTransforms = [
      new Transform3("", kIdentity, ""),
      new Transform3("", kIdentity, " "),
      new Transform3(" ", kIdentity, " "),
      new Transform3("", kOmitFirst1, ""),
      new Transform3("", kUppercaseFirst, " "),
      new Transform3("", kIdentity, " the "),
      new Transform3(" ", kIdentity, ""),
      new Transform3("s ", kIdentity, " "),
      new Transform3("", kIdentity, " of "),
      new Transform3("", kUppercaseFirst, ""),
      new Transform3("", kIdentity, " and "),
      new Transform3("", kOmitFirst2, ""),
      new Transform3("", kOmitLast1, ""),
      new Transform3(", ", kIdentity, " "),
      new Transform3("", kIdentity, ", "),
      new Transform3(" ", kUppercaseFirst, " "),
      new Transform3("", kIdentity, " in "),
      new Transform3("", kIdentity, " to "),
      new Transform3("e ", kIdentity, " "),
      new Transform3("", kIdentity, '"'),
      new Transform3("", kIdentity, "."),
      new Transform3("", kIdentity, '">'),
      new Transform3("", kIdentity, "\n"),
      new Transform3("", kOmitLast3, ""),
      new Transform3("", kIdentity, "]"),
      new Transform3("", kIdentity, " for "),
      new Transform3("", kOmitFirst3, ""),
      new Transform3("", kOmitLast2, ""),
      new Transform3("", kIdentity, " a "),
      new Transform3("", kIdentity, " that "),
      new Transform3(" ", kUppercaseFirst, ""),
      new Transform3("", kIdentity, ". "),
      new Transform3(".", kIdentity, ""),
      new Transform3(" ", kIdentity, ", "),
      new Transform3("", kOmitFirst4, ""),
      new Transform3("", kIdentity, " with "),
      new Transform3("", kIdentity, "'"),
      new Transform3("", kIdentity, " from "),
      new Transform3("", kIdentity, " by "),
      new Transform3("", kOmitFirst5, ""),
      new Transform3("", kOmitFirst6, ""),
      new Transform3(" the ", kIdentity, ""),
      new Transform3("", kOmitLast4, ""),
      new Transform3("", kIdentity, ". The "),
      new Transform3("", kUppercaseAll, ""),
      new Transform3("", kIdentity, " on "),
      new Transform3("", kIdentity, " as "),
      new Transform3("", kIdentity, " is "),
      new Transform3("", kOmitLast7, ""),
      new Transform3("", kOmitLast1, "ing "),
      new Transform3("", kIdentity, "\n	"),
      new Transform3("", kIdentity, ":"),
      new Transform3(" ", kIdentity, ". "),
      new Transform3("", kIdentity, "ed "),
      new Transform3("", kOmitFirst9, ""),
      new Transform3("", kOmitFirst7, ""),
      new Transform3("", kOmitLast6, ""),
      new Transform3("", kIdentity, "("),
      new Transform3("", kUppercaseFirst, ", "),
      new Transform3("", kOmitLast8, ""),
      new Transform3("", kIdentity, " at "),
      new Transform3("", kIdentity, "ly "),
      new Transform3(" the ", kIdentity, " of "),
      new Transform3("", kOmitLast5, ""),
      new Transform3("", kOmitLast9, ""),
      new Transform3(" ", kUppercaseFirst, ", "),
      new Transform3("", kUppercaseFirst, '"'),
      new Transform3(".", kIdentity, "("),
      new Transform3("", kUppercaseAll, " "),
      new Transform3("", kUppercaseFirst, '">'),
      new Transform3("", kIdentity, '="'),
      new Transform3(" ", kIdentity, "."),
      new Transform3(".com/", kIdentity, ""),
      new Transform3(" the ", kIdentity, " of the "),
      new Transform3("", kUppercaseFirst, "'"),
      new Transform3("", kIdentity, ". This "),
      new Transform3("", kIdentity, ","),
      new Transform3(".", kIdentity, " "),
      new Transform3("", kUppercaseFirst, "("),
      new Transform3("", kUppercaseFirst, "."),
      new Transform3("", kIdentity, " not "),
      new Transform3(" ", kIdentity, '="'),
      new Transform3("", kIdentity, "er "),
      new Transform3(" ", kUppercaseAll, " "),
      new Transform3("", kIdentity, "al "),
      new Transform3(" ", kUppercaseAll, ""),
      new Transform3("", kIdentity, "='"),
      new Transform3("", kUppercaseAll, '"'),
      new Transform3("", kUppercaseFirst, ". "),
      new Transform3(" ", kIdentity, "("),
      new Transform3("", kIdentity, "ful "),
      new Transform3(" ", kUppercaseFirst, ". "),
      new Transform3("", kIdentity, "ive "),
      new Transform3("", kIdentity, "less "),
      new Transform3("", kUppercaseAll, "'"),
      new Transform3("", kIdentity, "est "),
      new Transform3(" ", kUppercaseFirst, "."),
      new Transform3("", kUppercaseAll, '">'),
      new Transform3(" ", kIdentity, "='"),
      new Transform3("", kUppercaseFirst, ","),
      new Transform3("", kIdentity, "ize "),
      new Transform3("", kUppercaseAll, "."),
      new Transform3("", kIdentity, ""),
      new Transform3(" ", kIdentity, ","),
      new Transform3("", kUppercaseFirst, '="'),
      new Transform3("", kUppercaseAll, '="'),
      new Transform3("", kIdentity, "ous "),
      new Transform3("", kUppercaseAll, ", "),
      new Transform3("", kUppercaseFirst, "='"),
      new Transform3(" ", kUppercaseFirst, ","),
      new Transform3(" ", kUppercaseAll, '="'),
      new Transform3(" ", kUppercaseAll, ", "),
      new Transform3("", kUppercaseAll, ","),
      new Transform3("", kUppercaseAll, "("),
      new Transform3("", kUppercaseAll, ". "),
      new Transform3(" ", kUppercaseAll, "."),
      new Transform3("", kUppercaseAll, "='"),
      new Transform3(" ", kUppercaseAll, ". "),
      new Transform3(" ", kUppercaseFirst, '="'),
      new Transform3(" ", kUppercaseAll, "='"),
      new Transform3(" ", kUppercaseFirst, "='")
    ];
    exports2.kTransforms = kTransforms;
    exports2.kNumTransforms = kTransforms.length;
    function ToUpperCase(p, i) {
      if (p[i] < 192) {
        if (p[i] >= 97 && p[i] <= 122) {
          p[i] ^= 32;
        }
        return 1;
      }
      if (p[i] < 224) {
        p[i + 1] ^= 32;
        return 2;
      }
      p[i + 2] ^= 5;
      return 3;
    }
    exports2.transformDictionaryWord = function(dst, idx, word, len, transform4) {
      var prefix = kTransforms[transform4].prefix;
      var suffix = kTransforms[transform4].suffix;
      var t2 = kTransforms[transform4].transform;
      var skip = t2 < kOmitFirst1 ? 0 : t2 - (kOmitFirst1 - 1);
      var i = 0;
      var start_idx = idx;
      var uppercase;
      if (skip > len) {
        skip = len;
      }
      var prefix_pos = 0;
      while (prefix_pos < prefix.length) {
        dst[idx++] = prefix[prefix_pos++];
      }
      word += skip;
      len -= skip;
      if (t2 <= kOmitLast9) {
        len -= t2;
      }
      for (i = 0; i < len; i++) {
        dst[idx++] = BrotliDictionary.dictionary[word + i];
      }
      uppercase = idx - len;
      if (t2 === kUppercaseFirst) {
        ToUpperCase(dst, uppercase);
      } else if (t2 === kUppercaseAll) {
        while (len > 0) {
          var step = ToUpperCase(dst, uppercase);
          uppercase += step;
          len -= step;
        }
      }
      var suffix_pos = 0;
      while (suffix_pos < suffix.length) {
        dst[idx++] = suffix[suffix_pos++];
      }
      return idx - start_idx;
    };
  }
});

// ../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/decode.js
var require_decode = __commonJS({
  "../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/dec/decode.js"(exports2) {
    var BrotliInput = require_streams().BrotliInput;
    var BrotliOutput = require_streams().BrotliOutput;
    var BrotliBitReader = require_bit_reader();
    var BrotliDictionary = require_dictionary();
    var HuffmanCode = require_huffman().HuffmanCode;
    var BrotliBuildHuffmanTable = require_huffman().BrotliBuildHuffmanTable;
    var Context = require_context();
    var Prefix = require_prefix();
    var Transform3 = require_transform();
    var kDefaultCodeLength = 8;
    var kCodeLengthRepeatCode = 16;
    var kNumLiteralCodes = 256;
    var kNumInsertAndCopyCodes = 704;
    var kNumBlockLengthCodes = 26;
    var kLiteralContextBits = 6;
    var kDistanceContextBits = 2;
    var HUFFMAN_TABLE_BITS = 8;
    var HUFFMAN_TABLE_MASK = 255;
    var HUFFMAN_MAX_TABLE_SIZE = 1080;
    var CODE_LENGTH_CODES = 18;
    var kCodeLengthCodeOrder = new Uint8Array([
      1,
      2,
      3,
      4,
      0,
      5,
      17,
      6,
      16,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15
    ]);
    var NUM_DISTANCE_SHORT_CODES = 16;
    var kDistanceShortCodeIndexOffset = new Uint8Array([
      3,
      2,
      1,
      0,
      3,
      3,
      3,
      3,
      3,
      3,
      2,
      2,
      2,
      2,
      2,
      2
    ]);
    var kDistanceShortCodeValueOffset = new Int8Array([
      0,
      0,
      0,
      0,
      -1,
      1,
      -2,
      2,
      -3,
      3,
      -1,
      1,
      -2,
      2,
      -3,
      3
    ]);
    var kMaxHuffmanTableSize = new Uint16Array([
      256,
      402,
      436,
      468,
      500,
      534,
      566,
      598,
      630,
      662,
      694,
      726,
      758,
      790,
      822,
      854,
      886,
      920,
      952,
      984,
      1016,
      1048,
      1080
    ]);
    function DecodeWindowBits(br) {
      var n;
      if (br.readBits(1) === 0) {
        return 16;
      }
      n = br.readBits(3);
      if (n > 0) {
        return 17 + n;
      }
      n = br.readBits(3);
      if (n > 0) {
        return 8 + n;
      }
      return 17;
    }
    function DecodeVarLenUint8(br) {
      if (br.readBits(1)) {
        var nbits = br.readBits(3);
        if (nbits === 0) {
          return 1;
        } else {
          return br.readBits(nbits) + (1 << nbits);
        }
      }
      return 0;
    }
    function MetaBlockLength() {
      this.meta_block_length = 0;
      this.input_end = 0;
      this.is_uncompressed = 0;
      this.is_metadata = false;
    }
    function DecodeMetaBlockLength(br) {
      var out = new MetaBlockLength();
      var size_nibbles;
      var size_bytes;
      var i;
      out.input_end = br.readBits(1);
      if (out.input_end && br.readBits(1)) {
        return out;
      }
      size_nibbles = br.readBits(2) + 4;
      if (size_nibbles === 7) {
        out.is_metadata = true;
        if (br.readBits(1) !== 0)
          throw new Error("Invalid reserved bit");
        size_bytes = br.readBits(2);
        if (size_bytes === 0)
          return out;
        for (i = 0; i < size_bytes; i++) {
          var next_byte = br.readBits(8);
          if (i + 1 === size_bytes && size_bytes > 1 && next_byte === 0)
            throw new Error("Invalid size byte");
          out.meta_block_length |= next_byte << i * 8;
        }
      } else {
        for (i = 0; i < size_nibbles; ++i) {
          var next_nibble = br.readBits(4);
          if (i + 1 === size_nibbles && size_nibbles > 4 && next_nibble === 0)
            throw new Error("Invalid size nibble");
          out.meta_block_length |= next_nibble << i * 4;
        }
      }
      ++out.meta_block_length;
      if (!out.input_end && !out.is_metadata) {
        out.is_uncompressed = br.readBits(1);
      }
      return out;
    }
    function ReadSymbol(table, index2, br) {
      var start_index = index2;
      var nbits;
      br.fillBitWindow();
      index2 += br.val_ >>> br.bit_pos_ & HUFFMAN_TABLE_MASK;
      nbits = table[index2].bits - HUFFMAN_TABLE_BITS;
      if (nbits > 0) {
        br.bit_pos_ += HUFFMAN_TABLE_BITS;
        index2 += table[index2].value;
        index2 += br.val_ >>> br.bit_pos_ & (1 << nbits) - 1;
      }
      br.bit_pos_ += table[index2].bits;
      return table[index2].value;
    }
    function ReadHuffmanCodeLengths(code_length_code_lengths, num_symbols, code_lengths, br) {
      var symbol = 0;
      var prev_code_len = kDefaultCodeLength;
      var repeat3 = 0;
      var repeat_code_len = 0;
      var space = 32768;
      var table = [];
      for (var i = 0; i < 32; i++)
        table.push(new HuffmanCode(0, 0));
      BrotliBuildHuffmanTable(table, 0, 5, code_length_code_lengths, CODE_LENGTH_CODES);
      while (symbol < num_symbols && space > 0) {
        var p = 0;
        var code_len;
        br.readMoreInput();
        br.fillBitWindow();
        p += br.val_ >>> br.bit_pos_ & 31;
        br.bit_pos_ += table[p].bits;
        code_len = table[p].value & 255;
        if (code_len < kCodeLengthRepeatCode) {
          repeat3 = 0;
          code_lengths[symbol++] = code_len;
          if (code_len !== 0) {
            prev_code_len = code_len;
            space -= 32768 >> code_len;
          }
        } else {
          var extra_bits = code_len - 14;
          var old_repeat;
          var repeat_delta;
          var new_len = 0;
          if (code_len === kCodeLengthRepeatCode) {
            new_len = prev_code_len;
          }
          if (repeat_code_len !== new_len) {
            repeat3 = 0;
            repeat_code_len = new_len;
          }
          old_repeat = repeat3;
          if (repeat3 > 0) {
            repeat3 -= 2;
            repeat3 <<= extra_bits;
          }
          repeat3 += br.readBits(extra_bits) + 3;
          repeat_delta = repeat3 - old_repeat;
          if (symbol + repeat_delta > num_symbols) {
            throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");
          }
          for (var x = 0; x < repeat_delta; x++)
            code_lengths[symbol + x] = repeat_code_len;
          symbol += repeat_delta;
          if (repeat_code_len !== 0) {
            space -= repeat_delta << 15 - repeat_code_len;
          }
        }
      }
      if (space !== 0) {
        throw new Error("[ReadHuffmanCodeLengths] space = " + space);
      }
      for (; symbol < num_symbols; symbol++)
        code_lengths[symbol] = 0;
    }
    function ReadHuffmanCode(alphabet_size, tables, table, br) {
      var table_size = 0;
      var simple_code_or_skip;
      var code_lengths = new Uint8Array(alphabet_size);
      br.readMoreInput();
      simple_code_or_skip = br.readBits(2);
      if (simple_code_or_skip === 1) {
        var i;
        var max_bits_counter = alphabet_size - 1;
        var max_bits = 0;
        var symbols = new Int32Array(4);
        var num_symbols = br.readBits(2) + 1;
        while (max_bits_counter) {
          max_bits_counter >>= 1;
          ++max_bits;
        }
        for (i = 0; i < num_symbols; ++i) {
          symbols[i] = br.readBits(max_bits) % alphabet_size;
          code_lengths[symbols[i]] = 2;
        }
        code_lengths[symbols[0]] = 1;
        switch (num_symbols) {
          case 1:
            break;
          case 3:
            if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[1] === symbols[2]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            break;
          case 2:
            if (symbols[0] === symbols[1]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            code_lengths[symbols[1]] = 1;
            break;
          case 4:
            if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[0] === symbols[3] || symbols[1] === symbols[2] || symbols[1] === symbols[3] || symbols[2] === symbols[3]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            if (br.readBits(1)) {
              code_lengths[symbols[2]] = 3;
              code_lengths[symbols[3]] = 3;
            } else {
              code_lengths[symbols[0]] = 2;
            }
            break;
        }
      } else {
        var i;
        var code_length_code_lengths = new Uint8Array(CODE_LENGTH_CODES);
        var space = 32;
        var num_codes = 0;
        var huff = [
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(3, 2),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(4, 1),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(3, 2),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(4, 5)
        ];
        for (i = simple_code_or_skip; i < CODE_LENGTH_CODES && space > 0; ++i) {
          var code_len_idx = kCodeLengthCodeOrder[i];
          var p = 0;
          var v2;
          br.fillBitWindow();
          p += br.val_ >>> br.bit_pos_ & 15;
          br.bit_pos_ += huff[p].bits;
          v2 = huff[p].value;
          code_length_code_lengths[code_len_idx] = v2;
          if (v2 !== 0) {
            space -= 32 >> v2;
            ++num_codes;
          }
        }
        if (!(num_codes === 1 || space === 0))
          throw new Error("[ReadHuffmanCode] invalid num_codes or space");
        ReadHuffmanCodeLengths(code_length_code_lengths, alphabet_size, code_lengths, br);
      }
      table_size = BrotliBuildHuffmanTable(tables, table, HUFFMAN_TABLE_BITS, code_lengths, alphabet_size);
      if (table_size === 0) {
        throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
      }
      return table_size;
    }
    function ReadBlockLength(table, index2, br) {
      var code;
      var nbits;
      code = ReadSymbol(table, index2, br);
      nbits = Prefix.kBlockLengthPrefixCode[code].nbits;
      return Prefix.kBlockLengthPrefixCode[code].offset + br.readBits(nbits);
    }
    function TranslateShortCodes(code, ringbuffer, index2) {
      var val;
      if (code < NUM_DISTANCE_SHORT_CODES) {
        index2 += kDistanceShortCodeIndexOffset[code];
        index2 &= 3;
        val = ringbuffer[index2] + kDistanceShortCodeValueOffset[code];
      } else {
        val = code - NUM_DISTANCE_SHORT_CODES + 1;
      }
      return val;
    }
    function MoveToFront(v2, index2) {
      var value2 = v2[index2];
      var i = index2;
      for (; i; --i) v2[i] = v2[i - 1];
      v2[0] = value2;
    }
    function InverseMoveToFrontTransform(v2, v_len) {
      var mtf = new Uint8Array(256);
      var i;
      for (i = 0; i < 256; ++i) {
        mtf[i] = i;
      }
      for (i = 0; i < v_len; ++i) {
        var index2 = v2[i];
        v2[i] = mtf[index2];
        if (index2) MoveToFront(mtf, index2);
      }
    }
    function HuffmanTreeGroup(alphabet_size, num_htrees) {
      this.alphabet_size = alphabet_size;
      this.num_htrees = num_htrees;
      this.codes = new Array(num_htrees + num_htrees * kMaxHuffmanTableSize[alphabet_size + 31 >>> 5]);
      this.htrees = new Uint32Array(num_htrees);
    }
    HuffmanTreeGroup.prototype.decode = function(br) {
      var i;
      var table_size;
      var next = 0;
      for (i = 0; i < this.num_htrees; ++i) {
        this.htrees[i] = next;
        table_size = ReadHuffmanCode(this.alphabet_size, this.codes, next, br);
        next += table_size;
      }
    };
    function DecodeContextMap(context_map_size, br) {
      var out = { num_htrees: null, context_map: null };
      var use_rle_for_zeros;
      var max_run_length_prefix = 0;
      var table;
      var i;
      br.readMoreInput();
      var num_htrees = out.num_htrees = DecodeVarLenUint8(br) + 1;
      var context_map = out.context_map = new Uint8Array(context_map_size);
      if (num_htrees <= 1) {
        return out;
      }
      use_rle_for_zeros = br.readBits(1);
      if (use_rle_for_zeros) {
        max_run_length_prefix = br.readBits(4) + 1;
      }
      table = [];
      for (i = 0; i < HUFFMAN_MAX_TABLE_SIZE; i++) {
        table[i] = new HuffmanCode(0, 0);
      }
      ReadHuffmanCode(num_htrees + max_run_length_prefix, table, 0, br);
      for (i = 0; i < context_map_size; ) {
        var code;
        br.readMoreInput();
        code = ReadSymbol(table, 0, br);
        if (code === 0) {
          context_map[i] = 0;
          ++i;
        } else if (code <= max_run_length_prefix) {
          var reps = 1 + (1 << code) + br.readBits(code);
          while (--reps) {
            if (i >= context_map_size) {
              throw new Error("[DecodeContextMap] i >= context_map_size");
            }
            context_map[i] = 0;
            ++i;
          }
        } else {
          context_map[i] = code - max_run_length_prefix;
          ++i;
        }
      }
      if (br.readBits(1)) {
        InverseMoveToFrontTransform(context_map, context_map_size);
      }
      return out;
    }
    function DecodeBlockType(max_block_type, trees2, tree_type, block_types, ringbuffers, indexes, br) {
      var ringbuffer = tree_type * 2;
      var index2 = tree_type;
      var type_code = ReadSymbol(trees2, tree_type * HUFFMAN_MAX_TABLE_SIZE, br);
      var block_type;
      if (type_code === 0) {
        block_type = ringbuffers[ringbuffer + (indexes[index2] & 1)];
      } else if (type_code === 1) {
        block_type = ringbuffers[ringbuffer + (indexes[index2] - 1 & 1)] + 1;
      } else {
        block_type = type_code - 2;
      }
      if (block_type >= max_block_type) {
        block_type -= max_block_type;
      }
      block_types[tree_type] = block_type;
      ringbuffers[ringbuffer + (indexes[index2] & 1)] = block_type;
      ++indexes[index2];
    }
    function CopyUncompressedBlockToOutput(output, len, pos, ringbuffer, ringbuffer_mask, br) {
      var rb_size = ringbuffer_mask + 1;
      var rb_pos = pos & ringbuffer_mask;
      var br_pos = br.pos_ & BrotliBitReader.IBUF_MASK;
      var nbytes;
      if (len < 8 || br.bit_pos_ + (len << 3) < br.bit_end_pos_) {
        while (len-- > 0) {
          br.readMoreInput();
          ringbuffer[rb_pos++] = br.readBits(8);
          if (rb_pos === rb_size) {
            output.write(ringbuffer, rb_size);
            rb_pos = 0;
          }
        }
        return;
      }
      if (br.bit_end_pos_ < 32) {
        throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");
      }
      while (br.bit_pos_ < 32) {
        ringbuffer[rb_pos] = br.val_ >>> br.bit_pos_;
        br.bit_pos_ += 8;
        ++rb_pos;
        --len;
      }
      nbytes = br.bit_end_pos_ - br.bit_pos_ >> 3;
      if (br_pos + nbytes > BrotliBitReader.IBUF_MASK) {
        var tail = BrotliBitReader.IBUF_MASK + 1 - br_pos;
        for (var x = 0; x < tail; x++)
          ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
        nbytes -= tail;
        rb_pos += tail;
        len -= tail;
        br_pos = 0;
      }
      for (var x = 0; x < nbytes; x++)
        ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
      rb_pos += nbytes;
      len -= nbytes;
      if (rb_pos >= rb_size) {
        output.write(ringbuffer, rb_size);
        rb_pos -= rb_size;
        for (var x = 0; x < rb_pos; x++)
          ringbuffer[x] = ringbuffer[rb_size + x];
      }
      while (rb_pos + len >= rb_size) {
        nbytes = rb_size - rb_pos;
        if (br.input_.read(ringbuffer, rb_pos, nbytes) < nbytes) {
          throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
        }
        output.write(ringbuffer, rb_size);
        len -= nbytes;
        rb_pos = 0;
      }
      if (br.input_.read(ringbuffer, rb_pos, len) < len) {
        throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
      }
      br.reset();
    }
    function JumpToByteBoundary(br) {
      var new_bit_pos = br.bit_pos_ + 7 & ~7;
      var pad_bits = br.readBits(new_bit_pos - br.bit_pos_);
      return pad_bits == 0;
    }
    function BrotliDecompressedSize(buffer) {
      var input = new BrotliInput(buffer);
      var br = new BrotliBitReader(input);
      DecodeWindowBits(br);
      var out = DecodeMetaBlockLength(br);
      return out.meta_block_length;
    }
    exports2.BrotliDecompressedSize = BrotliDecompressedSize;
    function BrotliDecompressBuffer(buffer, output_size) {
      var input = new BrotliInput(buffer);
      if (output_size == null) {
        output_size = BrotliDecompressedSize(buffer);
      }
      var output_buffer = new Uint8Array(output_size);
      var output = new BrotliOutput(output_buffer);
      BrotliDecompress(input, output);
      if (output.pos < output.buffer.length) {
        output.buffer = output.buffer.subarray(0, output.pos);
      }
      return output.buffer;
    }
    exports2.BrotliDecompressBuffer = BrotliDecompressBuffer;
    function BrotliDecompress(input, output) {
      var i;
      var pos = 0;
      var input_end = 0;
      var window_bits = 0;
      var max_backward_distance;
      var max_distance = 0;
      var ringbuffer_size;
      var ringbuffer_mask;
      var ringbuffer;
      var ringbuffer_end;
      var dist_rb = [16, 15, 11, 4];
      var dist_rb_idx = 0;
      var prev_byte1 = 0;
      var prev_byte2 = 0;
      var hgroup = [new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0)];
      var block_type_trees;
      var block_len_trees;
      var br;
      var kRingBufferWriteAheadSlack = 128 + BrotliBitReader.READ_SIZE;
      br = new BrotliBitReader(input);
      window_bits = DecodeWindowBits(br);
      max_backward_distance = (1 << window_bits) - 16;
      ringbuffer_size = 1 << window_bits;
      ringbuffer_mask = ringbuffer_size - 1;
      ringbuffer = new Uint8Array(ringbuffer_size + kRingBufferWriteAheadSlack + BrotliDictionary.maxDictionaryWordLength);
      ringbuffer_end = ringbuffer_size;
      block_type_trees = [];
      block_len_trees = [];
      for (var x = 0; x < 3 * HUFFMAN_MAX_TABLE_SIZE; x++) {
        block_type_trees[x] = new HuffmanCode(0, 0);
        block_len_trees[x] = new HuffmanCode(0, 0);
      }
      while (!input_end) {
        var meta_block_remaining_len = 0;
        var is_uncompressed;
        var block_length = [1 << 28, 1 << 28, 1 << 28];
        var block_type = [0];
        var num_block_types = [1, 1, 1];
        var block_type_rb = [0, 1, 0, 1, 0, 1];
        var block_type_rb_index = [0];
        var distance_postfix_bits;
        var num_direct_distance_codes;
        var distance_postfix_mask;
        var num_distance_codes;
        var context_map = null;
        var context_modes = null;
        var num_literal_htrees;
        var dist_context_map = null;
        var num_dist_htrees;
        var context_offset = 0;
        var context_map_slice = null;
        var literal_htree_index = 0;
        var dist_context_offset = 0;
        var dist_context_map_slice = null;
        var dist_htree_index = 0;
        var context_lookup_offset1 = 0;
        var context_lookup_offset2 = 0;
        var context_mode;
        var htree_command;
        for (i = 0; i < 3; ++i) {
          hgroup[i].codes = null;
          hgroup[i].htrees = null;
        }
        br.readMoreInput();
        var _out = DecodeMetaBlockLength(br);
        meta_block_remaining_len = _out.meta_block_length;
        if (pos + meta_block_remaining_len > output.buffer.length) {
          var tmp = new Uint8Array(pos + meta_block_remaining_len);
          tmp.set(output.buffer);
          output.buffer = tmp;
        }
        input_end = _out.input_end;
        is_uncompressed = _out.is_uncompressed;
        if (_out.is_metadata) {
          JumpToByteBoundary(br);
          for (; meta_block_remaining_len > 0; --meta_block_remaining_len) {
            br.readMoreInput();
            br.readBits(8);
          }
          continue;
        }
        if (meta_block_remaining_len === 0) {
          continue;
        }
        if (is_uncompressed) {
          br.bit_pos_ = br.bit_pos_ + 7 & ~7;
          CopyUncompressedBlockToOutput(
            output,
            meta_block_remaining_len,
            pos,
            ringbuffer,
            ringbuffer_mask,
            br
          );
          pos += meta_block_remaining_len;
          continue;
        }
        for (i = 0; i < 3; ++i) {
          num_block_types[i] = DecodeVarLenUint8(br) + 1;
          if (num_block_types[i] >= 2) {
            ReadHuffmanCode(num_block_types[i] + 2, block_type_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
            ReadHuffmanCode(kNumBlockLengthCodes, block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
            block_length[i] = ReadBlockLength(block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
            block_type_rb_index[i] = 1;
          }
        }
        br.readMoreInput();
        distance_postfix_bits = br.readBits(2);
        num_direct_distance_codes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distance_postfix_bits);
        distance_postfix_mask = (1 << distance_postfix_bits) - 1;
        num_distance_codes = num_direct_distance_codes + (48 << distance_postfix_bits);
        context_modes = new Uint8Array(num_block_types[0]);
        for (i = 0; i < num_block_types[0]; ++i) {
          br.readMoreInput();
          context_modes[i] = br.readBits(2) << 1;
        }
        var _o1 = DecodeContextMap(num_block_types[0] << kLiteralContextBits, br);
        num_literal_htrees = _o1.num_htrees;
        context_map = _o1.context_map;
        var _o2 = DecodeContextMap(num_block_types[2] << kDistanceContextBits, br);
        num_dist_htrees = _o2.num_htrees;
        dist_context_map = _o2.context_map;
        hgroup[0] = new HuffmanTreeGroup(kNumLiteralCodes, num_literal_htrees);
        hgroup[1] = new HuffmanTreeGroup(kNumInsertAndCopyCodes, num_block_types[1]);
        hgroup[2] = new HuffmanTreeGroup(num_distance_codes, num_dist_htrees);
        for (i = 0; i < 3; ++i) {
          hgroup[i].decode(br);
        }
        context_map_slice = 0;
        dist_context_map_slice = 0;
        context_mode = context_modes[block_type[0]];
        context_lookup_offset1 = Context.lookupOffsets[context_mode];
        context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
        htree_command = hgroup[1].htrees[0];
        while (meta_block_remaining_len > 0) {
          var cmd_code;
          var range_idx;
          var insert_code;
          var copy_code;
          var insert_length;
          var copy_length;
          var distance_code;
          var distance;
          var context;
          var j;
          var copy_dst;
          br.readMoreInput();
          if (block_length[1] === 0) {
            DecodeBlockType(
              num_block_types[1],
              block_type_trees,
              1,
              block_type,
              block_type_rb,
              block_type_rb_index,
              br
            );
            block_length[1] = ReadBlockLength(block_len_trees, HUFFMAN_MAX_TABLE_SIZE, br);
            htree_command = hgroup[1].htrees[block_type[1]];
          }
          --block_length[1];
          cmd_code = ReadSymbol(hgroup[1].codes, htree_command, br);
          range_idx = cmd_code >> 6;
          if (range_idx >= 2) {
            range_idx -= 2;
            distance_code = -1;
          } else {
            distance_code = 0;
          }
          insert_code = Prefix.kInsertRangeLut[range_idx] + (cmd_code >> 3 & 7);
          copy_code = Prefix.kCopyRangeLut[range_idx] + (cmd_code & 7);
          insert_length = Prefix.kInsertLengthPrefixCode[insert_code].offset + br.readBits(Prefix.kInsertLengthPrefixCode[insert_code].nbits);
          copy_length = Prefix.kCopyLengthPrefixCode[copy_code].offset + br.readBits(Prefix.kCopyLengthPrefixCode[copy_code].nbits);
          prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
          prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
          for (j = 0; j < insert_length; ++j) {
            br.readMoreInput();
            if (block_length[0] === 0) {
              DecodeBlockType(
                num_block_types[0],
                block_type_trees,
                0,
                block_type,
                block_type_rb,
                block_type_rb_index,
                br
              );
              block_length[0] = ReadBlockLength(block_len_trees, 0, br);
              context_offset = block_type[0] << kLiteralContextBits;
              context_map_slice = context_offset;
              context_mode = context_modes[block_type[0]];
              context_lookup_offset1 = Context.lookupOffsets[context_mode];
              context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
            }
            context = Context.lookup[context_lookup_offset1 + prev_byte1] | Context.lookup[context_lookup_offset2 + prev_byte2];
            literal_htree_index = context_map[context_map_slice + context];
            --block_length[0];
            prev_byte2 = prev_byte1;
            prev_byte1 = ReadSymbol(hgroup[0].codes, hgroup[0].htrees[literal_htree_index], br);
            ringbuffer[pos & ringbuffer_mask] = prev_byte1;
            if ((pos & ringbuffer_mask) === ringbuffer_mask) {
              output.write(ringbuffer, ringbuffer_size);
            }
            ++pos;
          }
          meta_block_remaining_len -= insert_length;
          if (meta_block_remaining_len <= 0) break;
          if (distance_code < 0) {
            var context;
            br.readMoreInput();
            if (block_length[2] === 0) {
              DecodeBlockType(
                num_block_types[2],
                block_type_trees,
                2,
                block_type,
                block_type_rb,
                block_type_rb_index,
                br
              );
              block_length[2] = ReadBlockLength(block_len_trees, 2 * HUFFMAN_MAX_TABLE_SIZE, br);
              dist_context_offset = block_type[2] << kDistanceContextBits;
              dist_context_map_slice = dist_context_offset;
            }
            --block_length[2];
            context = (copy_length > 4 ? 3 : copy_length - 2) & 255;
            dist_htree_index = dist_context_map[dist_context_map_slice + context];
            distance_code = ReadSymbol(hgroup[2].codes, hgroup[2].htrees[dist_htree_index], br);
            if (distance_code >= num_direct_distance_codes) {
              var nbits;
              var postfix;
              var offset3;
              distance_code -= num_direct_distance_codes;
              postfix = distance_code & distance_postfix_mask;
              distance_code >>= distance_postfix_bits;
              nbits = (distance_code >> 1) + 1;
              offset3 = (2 + (distance_code & 1) << nbits) - 4;
              distance_code = num_direct_distance_codes + (offset3 + br.readBits(nbits) << distance_postfix_bits) + postfix;
            }
          }
          distance = TranslateShortCodes(distance_code, dist_rb, dist_rb_idx);
          if (distance < 0) {
            throw new Error("[BrotliDecompress] invalid distance");
          }
          if (pos < max_backward_distance && max_distance !== max_backward_distance) {
            max_distance = pos;
          } else {
            max_distance = max_backward_distance;
          }
          copy_dst = pos & ringbuffer_mask;
          if (distance > max_distance) {
            if (copy_length >= BrotliDictionary.minDictionaryWordLength && copy_length <= BrotliDictionary.maxDictionaryWordLength) {
              var offset3 = BrotliDictionary.offsetsByLength[copy_length];
              var word_id = distance - max_distance - 1;
              var shift = BrotliDictionary.sizeBitsByLength[copy_length];
              var mask = (1 << shift) - 1;
              var word_idx = word_id & mask;
              var transform_idx = word_id >> shift;
              offset3 += word_idx * copy_length;
              if (transform_idx < Transform3.kNumTransforms) {
                var len = Transform3.transformDictionaryWord(ringbuffer, copy_dst, offset3, copy_length, transform_idx);
                copy_dst += len;
                pos += len;
                meta_block_remaining_len -= len;
                if (copy_dst >= ringbuffer_end) {
                  output.write(ringbuffer, ringbuffer_size);
                  for (var _x = 0; _x < copy_dst - ringbuffer_end; _x++)
                    ringbuffer[_x] = ringbuffer[ringbuffer_end + _x];
                }
              } else {
                throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
              }
            } else {
              throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
            }
          } else {
            if (distance_code > 0) {
              dist_rb[dist_rb_idx & 3] = distance;
              ++dist_rb_idx;
            }
            if (copy_length > meta_block_remaining_len) {
              throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
            }
            for (j = 0; j < copy_length; ++j) {
              ringbuffer[pos & ringbuffer_mask] = ringbuffer[pos - distance & ringbuffer_mask];
              if ((pos & ringbuffer_mask) === ringbuffer_mask) {
                output.write(ringbuffer, ringbuffer_size);
              }
              ++pos;
              --meta_block_remaining_len;
            }
          }
          prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
          prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
        }
        pos &= 1073741823;
      }
      output.write(ringbuffer, pos & ringbuffer_mask);
    }
    exports2.BrotliDecompress = BrotliDecompress;
    BrotliDictionary.init();
  }
});

// ../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/decompress.js
var require_decompress = __commonJS({
  "../../.yarn/cache/brotli-npm-1.3.3-f0b047ff51-9d24e24f8b.zip/node_modules/brotli/decompress.js"(exports2, module2) {
    module2.exports = require_decode().BrotliDecompressBuffer;
  }
});

// ../../.yarn/cache/abs-svg-path-npm-0.1.1-e563d22137-aa763f3843.zip/node_modules/abs-svg-path/index.js
var require_abs_svg_path = __commonJS({
  "../../.yarn/cache/abs-svg-path-npm-0.1.1-e563d22137-aa763f3843.zip/node_modules/abs-svg-path/index.js"(exports2, module2) {
    module2.exports = absolutize;
    function absolutize(path2) {
      var startX = 0;
      var startY = 0;
      var x = 0;
      var y = 0;
      return path2.map(function(seg) {
        seg = seg.slice();
        var type2 = seg[0];
        var command = type2.toUpperCase();
        if (type2 != command) {
          seg[0] = command;
          switch (type2) {
            case "a":
              seg[6] += x;
              seg[7] += y;
              break;
            case "v":
              seg[1] += y;
              break;
            case "h":
              seg[1] += x;
              break;
            default:
              for (var i = 1; i < seg.length; ) {
                seg[i++] += x;
                seg[i++] += y;
              }
          }
        }
        switch (command) {
          case "Z":
            x = startX;
            y = startY;
            break;
          case "H":
            x = seg[1];
            break;
          case "V":
            y = seg[1];
            break;
          case "M":
            x = startX = seg[1];
            y = startY = seg[2];
            break;
          default:
            x = seg[seg.length - 2];
            y = seg[seg.length - 1];
        }
        return seg;
      });
    }
  }
});

// ../../.yarn/cache/parse-svg-path-npm-0.1.2-8bd0732a8f-005af72d53.zip/node_modules/parse-svg-path/index.js
var require_parse_svg_path = __commonJS({
  "../../.yarn/cache/parse-svg-path-npm-0.1.2-8bd0732a8f-005af72d53.zip/node_modules/parse-svg-path/index.js"(exports2, module2) {
    module2.exports = parse3;
    var length4 = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
    var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function parse3(path2) {
      var data2 = [];
      path2.replace(segment, function(_, command, args) {
        var type2 = command.toLowerCase();
        args = parseValues(args);
        if (type2 == "m" && args.length > 2) {
          data2.push([command].concat(args.splice(0, 2)));
          type2 = "l";
          command = command == "m" ? "l" : "L";
        }
        while (true) {
          if (args.length == length4[type2]) {
            args.unshift(command);
            return data2.push(args);
          }
          if (args.length < length4[type2]) throw new Error("malformed path data");
          data2.push([command].concat(args.splice(0, length4[type2])));
        }
      });
      return data2;
    }
    var number2 = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function parseValues(args) {
      var numbers = args.match(number2);
      return numbers ? numbers.map(Number) : [];
    }
  }
});

// ../../.yarn/cache/color-name-npm-1.1.4-025792b0ea-a1a3f91415.zip/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "../../.yarn/cache/color-name-npm-1.1.4-025792b0ea-a1a3f91415.zip/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// ../../.yarn/cache/is-arrayish-npm-0.3.2-f856180f79-f59b43dc1d.zip/node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "../../.yarn/cache/is-arrayish-npm-0.3.2-f856180f79-f59b43dc1d.zip/node_modules/is-arrayish/index.js"(exports2, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// ../../.yarn/cache/simple-swizzle-npm-0.2.2-8dee37fad1-df5e4662a8.zip/node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "../../.yarn/cache/simple-swizzle-npm-0.2.2-8dee37fad1-df5e4662a8.zip/node_modules/simple-swizzle/index.js"(exports2, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat6 = Array.prototype.concat;
    var slice8 = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat6.call(results, slice8.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// ../../.yarn/cache/color-string-npm-1.9.1-dc020e56be-b0bfd74c03.zip/node_modules/color-string/index.js
var require_color_string = __commonJS({
  "../../.yarn/cache/color-string-npm-1.9.1-dc020e56be-b0bfd74c03.zip/node_modules/color-string/index.js"(exports2, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty3 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name2 in colorNames) {
      if (hasOwnProperty3.call(colorNames, name2)) {
        reverseNames[colorNames[name2]] = name2;
      }
    }
    var name2;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty3.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
        var s2 = clamp(parseFloat(match[2]), 0, 100);
        var l2 = clamp(parseFloat(match[3]), 0, 100);
        var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, s2, l2, a2];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b = clamp(parseFloat(match[3]), 0, 100);
        var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, w, b, a2];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a2 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a2 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a2 + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min3, max3) {
      return Math.min(Math.max(min3, num), max3);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// ../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/zstream.js"(exports2, module2) {
    "use strict";
    function ZStream2() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream2;
  }
});

// ../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/trees.js"(exports2, module2) {
    "use strict";
    var Z_FIXED2 = 4;
    var Z_BINARY2 = 0;
    var Z_TEXT2 = 1;
    var Z_UNKNOWN2 = 2;
    function zero2(buf) {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK2 = 0;
    var STATIC_TREES2 = 1;
    var DYN_TREES2 = 2;
    var MIN_MATCH2 = 3;
    var MAX_MATCH2 = 258;
    var LENGTH_CODES2 = 29;
    var LITERALS2 = 256;
    var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
    var D_CODES2 = 30;
    var BL_CODES2 = 19;
    var HEAP_SIZE2 = 2 * L_CODES2 + 1;
    var MAX_BITS2 = 15;
    var Buf_size2 = 16;
    var MAX_BL_BITS2 = 7;
    var END_BLOCK2 = 256;
    var REP_3_62 = 16;
    var REPZ_3_102 = 17;
    var REPZ_11_1382 = 18;
    var extra_lbits2 = (
      /* extra bits for each length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
    );
    var extra_dbits2 = (
      /* extra bits for each distance code */
      new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
    );
    var extra_blbits2 = (
      /* extra bits for each bit length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
    );
    var bl_order2 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var DIST_CODE_LEN2 = 512;
    var static_ltree2 = new Array((L_CODES2 + 2) * 2);
    zero2(static_ltree2);
    var static_dtree2 = new Array(D_CODES2 * 2);
    zero2(static_dtree2);
    var _dist_code2 = new Array(DIST_CODE_LEN2);
    zero2(_dist_code2);
    var _length_code2 = new Array(MAX_MATCH2 - MIN_MATCH2 + 1);
    zero2(_length_code2);
    var base_length2 = new Array(LENGTH_CODES2);
    zero2(base_length2);
    var base_dist2 = new Array(D_CODES2);
    zero2(base_dist2);
    function StaticTreeDesc2(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc2;
    var static_d_desc2;
    var static_bl_desc2;
    function TreeDesc2(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    var d_code2 = (dist) => {
      return dist < 256 ? _dist_code2[dist] : _dist_code2[256 + (dist >>> 7)];
    };
    var put_short2 = (s2, w) => {
      s2.pending_buf[s2.pending++] = w & 255;
      s2.pending_buf[s2.pending++] = w >>> 8 & 255;
    };
    var send_bits2 = (s2, value2, length4) => {
      if (s2.bi_valid > Buf_size2 - length4) {
        s2.bi_buf |= value2 << s2.bi_valid & 65535;
        put_short2(s2, s2.bi_buf);
        s2.bi_buf = value2 >> Buf_size2 - s2.bi_valid;
        s2.bi_valid += length4 - Buf_size2;
      } else {
        s2.bi_buf |= value2 << s2.bi_valid & 65535;
        s2.bi_valid += length4;
      }
    };
    var send_code2 = (s2, c2, tree) => {
      send_bits2(
        s2,
        tree[c2 * 2],
        tree[c2 * 2 + 1]
        /*.Len*/
      );
    };
    var bi_reverse2 = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    var bi_flush2 = (s2) => {
      if (s2.bi_valid === 16) {
        put_short2(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    };
    var gen_bitlen2 = (s2, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h2;
      let n, m2;
      let bits;
      let xbits;
      let f;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS2; bits++) {
        s2.bl_count[bits] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE2; h2++) {
        n = s2.heap[h2];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s2.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s2.opt_len += f * (bits + xbits);
        if (has_stree) {
          s2.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s2.bl_count[bits] === 0) {
          bits--;
        }
        s2.bl_count[bits]--;
        s2.bl_count[bits + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s2.bl_count[bits];
        while (n !== 0) {
          m2 = s2.heap[--h2];
          if (m2 > max_code) {
            continue;
          }
          if (tree[m2 * 2 + 1] !== bits) {
            s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
            tree[m2 * 2 + 1] = bits;
          }
          n--;
        }
      }
    };
    var gen_codes2 = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS2 + 1);
      let code = 0;
      let bits;
      let n;
      for (bits = 1; bits <= MAX_BITS2; bits++) {
        code = code + bl_count[bits - 1] << 1;
        next_code[bits] = code;
      }
      for (n = 0; n <= max_code; n++) {
        let len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse2(next_code[len]++, len);
      }
    };
    var tr_static_init2 = () => {
      let n;
      let bits;
      let length4;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS2 + 1);
      length4 = 0;
      for (code = 0; code < LENGTH_CODES2 - 1; code++) {
        base_length2[code] = length4;
        for (n = 0; n < 1 << extra_lbits2[code]; n++) {
          _length_code2[length4++] = code;
        }
      }
      _length_code2[length4 - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist2[code] = dist;
        for (n = 0; n < 1 << extra_dbits2[code]; n++) {
          _dist_code2[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES2; code++) {
        base_dist2[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits2[code] - 7; n++) {
          _dist_code2[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS2; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree2[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree2[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree2[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree2[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes2(static_ltree2, L_CODES2 + 1, bl_count);
      for (n = 0; n < D_CODES2; n++) {
        static_dtree2[n * 2 + 1] = 5;
        static_dtree2[n * 2] = bi_reverse2(n, 5);
      }
      static_l_desc2 = new StaticTreeDesc2(static_ltree2, extra_lbits2, LITERALS2 + 1, L_CODES2, MAX_BITS2);
      static_d_desc2 = new StaticTreeDesc2(static_dtree2, extra_dbits2, 0, D_CODES2, MAX_BITS2);
      static_bl_desc2 = new StaticTreeDesc2(new Array(0), extra_blbits2, 0, BL_CODES2, MAX_BL_BITS2);
    };
    var init_block2 = (s2) => {
      let n;
      for (n = 0; n < L_CODES2; n++) {
        s2.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES2; n++) {
        s2.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES2; n++) {
        s2.bl_tree[n * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK2 * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.sym_next = s2.matches = 0;
    };
    var bi_windup2 = (s2) => {
      if (s2.bi_valid > 8) {
        put_short2(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    };
    var smaller2 = (tree, n, m2, depth) => {
      const _n2 = n * 2;
      const _m2 = m2 * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m2];
    };
    var pqdownheap2 = (s2, tree, k) => {
      const v2 = s2.heap[k];
      let j = k << 1;
      while (j <= s2.heap_len) {
        if (j < s2.heap_len && smaller2(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
          j++;
        }
        if (smaller2(tree, v2, s2.heap[j], s2.depth)) {
          break;
        }
        s2.heap[k] = s2.heap[j];
        k = j;
        j <<= 1;
      }
      s2.heap[k] = v2;
    };
    var compress_block2 = (s2, ltree, dtree) => {
      let dist;
      let lc;
      let sx2 = 0;
      let code;
      let extra;
      if (s2.sym_next !== 0) {
        do {
          dist = s2.pending_buf[s2.sym_buf + sx2++] & 255;
          dist += (s2.pending_buf[s2.sym_buf + sx2++] & 255) << 8;
          lc = s2.pending_buf[s2.sym_buf + sx2++];
          if (dist === 0) {
            send_code2(s2, lc, ltree);
          } else {
            code = _length_code2[lc];
            send_code2(s2, code + LITERALS2 + 1, ltree);
            extra = extra_lbits2[code];
            if (extra !== 0) {
              lc -= base_length2[code];
              send_bits2(s2, lc, extra);
            }
            dist--;
            code = d_code2(dist);
            send_code2(s2, code, dtree);
            extra = extra_dbits2[code];
            if (extra !== 0) {
              dist -= base_dist2[code];
              send_bits2(s2, dist, extra);
            }
          }
        } while (sx2 < s2.sym_next);
      }
      send_code2(s2, END_BLOCK2, ltree);
    };
    var build_tree2 = (s2, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n, m2;
      let max_code = -1;
      let node;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE2;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n;
          s2.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s2.depth[node] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s2.heap_len >> 1; n >= 1; n--) {
        pqdownheap2(s2, tree, n);
      }
      node = elems;
      do {
        n = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[
          1
          /*SMALLEST*/
        ] = s2.heap[s2.heap_len--];
        pqdownheap2(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
        m2 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[--s2.heap_max] = n;
        s2.heap[--s2.heap_max] = m2;
        tree[node * 2] = tree[n * 2] + tree[m2 * 2];
        s2.depth[node] = (s2.depth[n] >= s2.depth[m2] ? s2.depth[n] : s2.depth[m2]) + 1;
        tree[n * 2 + 1] = tree[m2 * 2 + 1] = node;
        s2.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap2(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen2(s2, desc);
      gen_codes2(tree, max_code, s2.bl_count);
    };
    var scan_tree2 = (s2, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s2.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_62 * 2]++;
        } else if (count <= 10) {
          s2.bl_tree[REPZ_3_102 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_1382 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var send_tree2 = (s2, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code2(s2, curlen, s2.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code2(s2, curlen, s2.bl_tree);
            count--;
          }
          send_code2(s2, REP_3_62, s2.bl_tree);
          send_bits2(s2, count - 3, 2);
        } else if (count <= 10) {
          send_code2(s2, REPZ_3_102, s2.bl_tree);
          send_bits2(s2, count - 3, 3);
        } else {
          send_code2(s2, REPZ_11_1382, s2.bl_tree);
          send_bits2(s2, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var build_bl_tree2 = (s2) => {
      let max_blindex;
      scan_tree2(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree2(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree2(s2, s2.bl_desc);
      for (max_blindex = BL_CODES2 - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order2[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    var send_all_trees2 = (s2, lcodes, dcodes, blcodes) => {
      let rank2;
      send_bits2(s2, lcodes - 257, 5);
      send_bits2(s2, dcodes - 1, 5);
      send_bits2(s2, blcodes - 4, 4);
      for (rank2 = 0; rank2 < blcodes; rank2++) {
        send_bits2(s2, s2.bl_tree[bl_order2[rank2] * 2 + 1], 3);
      }
      send_tree2(s2, s2.dyn_ltree, lcodes - 1);
      send_tree2(s2, s2.dyn_dtree, dcodes - 1);
    };
    var detect_data_type2 = (s2) => {
      let block_mask = 4093624447;
      let n;
      for (n = 0; n <= 31; n++, block_mask >>>= 1) {
        if (block_mask & 1 && s2.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY2;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT2;
      }
      for (n = 32; n < LITERALS2; n++) {
        if (s2.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT2;
        }
      }
      return Z_BINARY2;
    };
    var static_init_done2 = false;
    var _tr_init2 = (s2) => {
      if (!static_init_done2) {
        tr_static_init2();
        static_init_done2 = true;
      }
      s2.l_desc = new TreeDesc2(s2.dyn_ltree, static_l_desc2);
      s2.d_desc = new TreeDesc2(s2.dyn_dtree, static_d_desc2);
      s2.bl_desc = new TreeDesc2(s2.bl_tree, static_bl_desc2);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block2(s2);
    };
    var _tr_stored_block2 = (s2, buf, stored_len, last3) => {
      send_bits2(s2, (STORED_BLOCK2 << 1) + (last3 ? 1 : 0), 3);
      bi_windup2(s2);
      put_short2(s2, stored_len);
      put_short2(s2, ~stored_len);
      if (stored_len) {
        s2.pending_buf.set(s2.window.subarray(buf, buf + stored_len), s2.pending);
      }
      s2.pending += stored_len;
    };
    var _tr_align2 = (s2) => {
      send_bits2(s2, STATIC_TREES2 << 1, 3);
      send_code2(s2, END_BLOCK2, static_ltree2);
      bi_flush2(s2);
    };
    var _tr_flush_block2 = (s2, buf, stored_len, last3) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN2) {
          s2.strm.data_type = detect_data_type2(s2);
        }
        build_tree2(s2, s2.l_desc);
        build_tree2(s2, s2.d_desc);
        max_blindex = build_bl_tree2(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block2(s2, buf, stored_len, last3);
      } else if (s2.strategy === Z_FIXED2 || static_lenb === opt_lenb) {
        send_bits2(s2, (STATIC_TREES2 << 1) + (last3 ? 1 : 0), 3);
        compress_block2(s2, static_ltree2, static_dtree2);
      } else {
        send_bits2(s2, (DYN_TREES2 << 1) + (last3 ? 1 : 0), 3);
        send_all_trees2(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block2(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block2(s2);
      if (last3) {
        bi_windup2(s2);
      }
    };
    var _tr_tally2 = (s2, dist, lc) => {
      s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist;
      s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist >> 8;
      s2.pending_buf[s2.sym_buf + s2.sym_next++] = lc;
      if (dist === 0) {
        s2.dyn_ltree[lc * 2]++;
      } else {
        s2.matches++;
        dist--;
        s2.dyn_ltree[(_length_code2[lc] + LITERALS2 + 1) * 2]++;
        s2.dyn_dtree[d_code2(dist) * 2]++;
      }
      return s2.sym_next === s2.sym_end;
    };
    module2.exports._tr_init = _tr_init2;
    module2.exports._tr_stored_block = _tr_stored_block2;
    module2.exports._tr_flush_block = _tr_flush_block2;
    module2.exports._tr_tally = _tr_tally2;
    module2.exports._tr_align = _tr_align2;
  }
});

// ../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/adler32.js"(exports2, module2) {
    "use strict";
    var adler322 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    module2.exports = adler322;
  }
});

// ../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/crc32.js"(exports2, module2) {
    "use strict";
    var makeTable2 = () => {
      let c2, table = [];
      for (var n = 0; n < 256; n++) {
        c2 = n;
        for (var k = 0; k < 8; k++) {
          c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
        }
        table[n] = c2;
      }
      return table;
    };
    var crcTable2 = new Uint32Array(makeTable2());
    var crc322 = (crc, buf, len, pos) => {
      const t2 = crcTable2;
      const end3 = pos + len;
      crc ^= -1;
      for (let i = pos; i < end3; i++) {
        crc = crc >>> 8 ^ t2[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    };
    module2.exports = crc322;
  }
});

// ../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/messages.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// ../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// ../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/deflate.js"(exports2, module2) {
    "use strict";
    var { _tr_init: _tr_init2, _tr_stored_block: _tr_stored_block2, _tr_flush_block: _tr_flush_block2, _tr_tally: _tr_tally2, _tr_align: _tr_align2 } = require_trees();
    var adler322 = require_adler32();
    var crc322 = require_crc32();
    var msg2 = require_messages();
    var {
      Z_NO_FLUSH: Z_NO_FLUSH2,
      Z_PARTIAL_FLUSH: Z_PARTIAL_FLUSH2,
      Z_FULL_FLUSH: Z_FULL_FLUSH2,
      Z_FINISH: Z_FINISH2,
      Z_BLOCK: Z_BLOCK2,
      Z_OK: Z_OK2,
      Z_STREAM_END: Z_STREAM_END2,
      Z_STREAM_ERROR: Z_STREAM_ERROR2,
      Z_DATA_ERROR: Z_DATA_ERROR2,
      Z_BUF_ERROR: Z_BUF_ERROR2,
      Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION2,
      Z_FILTERED: Z_FILTERED2,
      Z_HUFFMAN_ONLY: Z_HUFFMAN_ONLY2,
      Z_RLE: Z_RLE2,
      Z_FIXED: Z_FIXED2,
      Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY2,
      Z_UNKNOWN: Z_UNKNOWN2,
      Z_DEFLATED: Z_DEFLATED2
    } = require_constants();
    var MAX_MEM_LEVEL2 = 9;
    var MAX_WBITS2 = 15;
    var DEF_MEM_LEVEL2 = 8;
    var LENGTH_CODES2 = 29;
    var LITERALS2 = 256;
    var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
    var D_CODES2 = 30;
    var BL_CODES2 = 19;
    var HEAP_SIZE2 = 2 * L_CODES2 + 1;
    var MAX_BITS2 = 15;
    var MIN_MATCH2 = 3;
    var MAX_MATCH2 = 258;
    var MIN_LOOKAHEAD2 = MAX_MATCH2 + MIN_MATCH2 + 1;
    var PRESET_DICT2 = 32;
    var INIT_STATE2 = 42;
    var GZIP_STATE = 57;
    var EXTRA_STATE2 = 69;
    var NAME_STATE2 = 73;
    var COMMENT_STATE2 = 91;
    var HCRC_STATE2 = 103;
    var BUSY_STATE2 = 113;
    var FINISH_STATE2 = 666;
    var BS_NEED_MORE2 = 1;
    var BS_BLOCK_DONE2 = 2;
    var BS_FINISH_STARTED2 = 3;
    var BS_FINISH_DONE2 = 4;
    var OS_CODE2 = 3;
    var err2 = (strm, errorCode) => {
      strm.msg = msg2[errorCode];
      return errorCode;
    };
    var rank2 = (f) => {
      return f * 2 - (f > 4 ? 9 : 0);
    };
    var zero2 = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    var slide_hash = (s2) => {
      let n, m2;
      let p;
      let wsize = s2.w_size;
      n = s2.hash_size;
      p = n;
      do {
        m2 = s2.head[--p];
        s2.head[p] = m2 >= wsize ? m2 - wsize : 0;
      } while (--n);
      n = wsize;
      p = n;
      do {
        m2 = s2.prev[--p];
        s2.prev[p] = m2 >= wsize ? m2 - wsize : 0;
      } while (--n);
    };
    var HASH_ZLIB = (s2, prev, data2) => (prev << s2.hash_shift ^ data2) & s2.hash_mask;
    var HASH = HASH_ZLIB;
    var flush_pending2 = (strm) => {
      const s2 = strm.state;
      let len = s2.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s2.pending_buf.subarray(s2.pending_out, s2.pending_out + len), strm.next_out);
      strm.next_out += len;
      s2.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s2.pending -= len;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    };
    var flush_block_only2 = (s2, last3) => {
      _tr_flush_block2(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last3);
      s2.block_start = s2.strstart;
      flush_pending2(s2.strm);
    };
    var put_byte2 = (s2, b) => {
      s2.pending_buf[s2.pending++] = b;
    };
    var putShortMSB2 = (s2, b) => {
      s2.pending_buf[s2.pending++] = b >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b & 255;
    };
    var read_buf2 = (strm, buf, start3, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start3);
      if (strm.state.wrap === 1) {
        strm.adler = adler322(strm.adler, buf, len, start3);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc322(strm.adler, buf, len, start3);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    var longest_match2 = (s2, cur_match) => {
      let chain_length = s2.max_chain_length;
      let scan = s2.strstart;
      let match;
      let len;
      let best_len = s2.prev_length;
      let nice_match = s2.nice_match;
      const limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD2 ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD2) : 0;
      const _win = s2.window;
      const wmask = s2.w_mask;
      const prev = s2.prev;
      const strend = s2.strstart + MAX_MATCH2;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH2 - (strend - scan);
        scan = strend - MAX_MATCH2;
        if (len > best_len) {
          s2.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    };
    var fill_window2 = (s2) => {
      const _w_size = s2.w_size;
      let n, more, str;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD2)) {
          s2.window.set(s2.window.subarray(_w_size, _w_size + _w_size - more), 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          if (s2.insert > s2.strstart) {
            s2.insert = s2.strstart;
          }
          slide_hash(s2);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n = read_buf2(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n;
        if (s2.lookahead + s2.insert >= MIN_MATCH2) {
          str = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str];
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + 1]);
          while (s2.insert) {
            s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH2 - 1]);
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH2) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD2 && s2.strm.avail_in !== 0);
    };
    var deflate_stored2 = (s2, flush) => {
      let min_block = s2.pending_buf_size - 5 > s2.w_size ? s2.w_size : s2.pending_buf_size - 5;
      let len, left, have, last3 = 0;
      let used = s2.strm.avail_in;
      do {
        len = 65535;
        have = s2.bi_valid + 42 >> 3;
        if (s2.strm.avail_out < have) {
          break;
        }
        have = s2.strm.avail_out - have;
        left = s2.strstart - s2.block_start;
        if (len > left + s2.strm.avail_in) {
          len = left + s2.strm.avail_in;
        }
        if (len > have) {
          len = have;
        }
        if (len < min_block && (len === 0 && flush !== Z_FINISH2 || flush === Z_NO_FLUSH2 || len !== left + s2.strm.avail_in)) {
          break;
        }
        last3 = flush === Z_FINISH2 && len === left + s2.strm.avail_in ? 1 : 0;
        _tr_stored_block2(s2, 0, 0, last3);
        s2.pending_buf[s2.pending - 4] = len;
        s2.pending_buf[s2.pending - 3] = len >> 8;
        s2.pending_buf[s2.pending - 2] = ~len;
        s2.pending_buf[s2.pending - 1] = ~len >> 8;
        flush_pending2(s2.strm);
        if (left) {
          if (left > len) {
            left = len;
          }
          s2.strm.output.set(s2.window.subarray(s2.block_start, s2.block_start + left), s2.strm.next_out);
          s2.strm.next_out += left;
          s2.strm.avail_out -= left;
          s2.strm.total_out += left;
          s2.block_start += left;
          len -= left;
        }
        if (len) {
          read_buf2(s2.strm, s2.strm.output, s2.strm.next_out, len);
          s2.strm.next_out += len;
          s2.strm.avail_out -= len;
          s2.strm.total_out += len;
        }
      } while (last3 === 0);
      used -= s2.strm.avail_in;
      if (used) {
        if (used >= s2.w_size) {
          s2.matches = 2;
          s2.window.set(s2.strm.input.subarray(s2.strm.next_in - s2.w_size, s2.strm.next_in), 0);
          s2.strstart = s2.w_size;
          s2.insert = s2.strstart;
        } else {
          if (s2.window_size - s2.strstart <= used) {
            s2.strstart -= s2.w_size;
            s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
            if (s2.matches < 2) {
              s2.matches++;
            }
            if (s2.insert > s2.strstart) {
              s2.insert = s2.strstart;
            }
          }
          s2.window.set(s2.strm.input.subarray(s2.strm.next_in - used, s2.strm.next_in), s2.strstart);
          s2.strstart += used;
          s2.insert += used > s2.w_size - s2.insert ? s2.w_size - s2.insert : used;
        }
        s2.block_start = s2.strstart;
      }
      if (s2.high_water < s2.strstart) {
        s2.high_water = s2.strstart;
      }
      if (last3) {
        return BS_FINISH_DONE2;
      }
      if (flush !== Z_NO_FLUSH2 && flush !== Z_FINISH2 && s2.strm.avail_in === 0 && s2.strstart === s2.block_start) {
        return BS_BLOCK_DONE2;
      }
      have = s2.window_size - s2.strstart;
      if (s2.strm.avail_in > have && s2.block_start >= s2.w_size) {
        s2.block_start -= s2.w_size;
        s2.strstart -= s2.w_size;
        s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
        if (s2.matches < 2) {
          s2.matches++;
        }
        have += s2.w_size;
        if (s2.insert > s2.strstart) {
          s2.insert = s2.strstart;
        }
      }
      if (have > s2.strm.avail_in) {
        have = s2.strm.avail_in;
      }
      if (have) {
        read_buf2(s2.strm, s2.window, s2.strstart, have);
        s2.strstart += have;
        s2.insert += have > s2.w_size - s2.insert ? s2.w_size - s2.insert : have;
      }
      if (s2.high_water < s2.strstart) {
        s2.high_water = s2.strstart;
      }
      have = s2.bi_valid + 42 >> 3;
      have = s2.pending_buf_size - have > 65535 ? 65535 : s2.pending_buf_size - have;
      min_block = have > s2.w_size ? s2.w_size : have;
      left = s2.strstart - s2.block_start;
      if (left >= min_block || (left || flush === Z_FINISH2) && flush !== Z_NO_FLUSH2 && s2.strm.avail_in === 0 && left <= have) {
        len = left > have ? have : left;
        last3 = flush === Z_FINISH2 && s2.strm.avail_in === 0 && len === left ? 1 : 0;
        _tr_stored_block2(s2, s2.block_start, len, last3);
        s2.block_start += len;
        flush_pending2(s2.strm);
      }
      return last3 ? BS_FINISH_STARTED2 : BS_NEED_MORE2;
    };
    var deflate_fast2 = (s2, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD2) {
          fill_window2(s2);
          if (s2.lookahead < MIN_LOOKAHEAD2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH2) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH2 - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD2) {
          s2.match_length = longest_match2(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH2) {
          bflush = _tr_tally2(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH2);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH2) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH2 - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + 1]);
          }
        } else {
          bflush = _tr_tally2(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH2 - 1 ? s2.strstart : MIN_MATCH2 - 1;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.sym_next) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    };
    var deflate_slow2 = (s2, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD2) {
          fill_window2(s2);
          if (s2.lookahead < MIN_LOOKAHEAD2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH2) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH2 - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH2 - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD2) {
          s2.match_length = longest_match2(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED2 || s2.match_length === MIN_MATCH2 && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH2 - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH2 && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH2;
          bflush = _tr_tally2(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH2);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH2 - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH2 - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only2(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE2;
            }
          }
        } else if (s2.match_available) {
          bflush = _tr_tally2(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only2(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = _tr_tally2(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH2 - 1 ? s2.strstart : MIN_MATCH2 - 1;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.sym_next) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    };
    var deflate_rle2 = (s2, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH2) {
          fill_window2(s2);
          if (s2.lookahead <= MAX_MATCH2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH2 && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH2;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH2 - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH2) {
          bflush = _tr_tally2(s2, 1, s2.match_length - MIN_MATCH2);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = _tr_tally2(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.sym_next) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    };
    var deflate_huff2 = (s2, flush) => {
      let bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window2(s2);
          if (s2.lookahead === 0) {
            if (flush === Z_NO_FLUSH2) {
              return BS_NEED_MORE2;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = _tr_tally2(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.sym_next) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    };
    function Config2(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table2 = [
      /*      good lazy nice chain */
      new Config2(0, 0, 0, 0, deflate_stored2),
      /* 0 store only */
      new Config2(4, 4, 8, 4, deflate_fast2),
      /* 1 max speed, no lazy matches */
      new Config2(4, 5, 16, 8, deflate_fast2),
      /* 2 */
      new Config2(4, 6, 32, 32, deflate_fast2),
      /* 3 */
      new Config2(4, 4, 16, 16, deflate_slow2),
      /* 4 lazy matches */
      new Config2(8, 16, 32, 32, deflate_slow2),
      /* 5 */
      new Config2(8, 16, 128, 128, deflate_slow2),
      /* 6 */
      new Config2(8, 32, 128, 256, deflate_slow2),
      /* 7 */
      new Config2(32, 128, 258, 1024, deflate_slow2),
      /* 8 */
      new Config2(32, 258, 258, 4096, deflate_slow2)
      /* 9 max compression */
    ];
    var lm_init2 = (s2) => {
      s2.window_size = 2 * s2.w_size;
      zero2(s2.head);
      s2.max_lazy_match = configuration_table2[s2.level].max_lazy;
      s2.good_match = configuration_table2[s2.level].good_length;
      s2.nice_match = configuration_table2[s2.level].nice_length;
      s2.max_chain_length = configuration_table2[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH2 - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    };
    function DeflateState2() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED2;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new Uint16Array(HEAP_SIZE2 * 2);
      this.dyn_dtree = new Uint16Array((2 * D_CODES2 + 1) * 2);
      this.bl_tree = new Uint16Array((2 * BL_CODES2 + 1) * 2);
      zero2(this.dyn_ltree);
      zero2(this.dyn_dtree);
      zero2(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new Uint16Array(MAX_BITS2 + 1);
      this.heap = new Uint16Array(2 * L_CODES2 + 1);
      zero2(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new Uint16Array(2 * L_CODES2 + 1);
      zero2(this.depth);
      this.sym_buf = 0;
      this.lit_bufsize = 0;
      this.sym_next = 0;
      this.sym_end = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    var deflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const s2 = strm.state;
      if (!s2 || s2.strm !== strm || s2.status !== INIT_STATE2 && //#ifdef GZIP
      s2.status !== GZIP_STATE && //#endif
      s2.status !== EXTRA_STATE2 && s2.status !== NAME_STATE2 && s2.status !== COMMENT_STATE2 && s2.status !== HCRC_STATE2 && s2.status !== BUSY_STATE2 && s2.status !== FINISH_STATE2) {
        return 1;
      }
      return 0;
    };
    var deflateResetKeep2 = (strm) => {
      if (deflateStateCheck(strm)) {
        return err2(strm, Z_STREAM_ERROR2);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN2;
      const s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = //#ifdef GZIP
      s2.wrap === 2 ? GZIP_STATE : (
        //#endif
        s2.wrap ? INIT_STATE2 : BUSY_STATE2
      );
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = -2;
      _tr_init2(s2);
      return Z_OK2;
    };
    var deflateReset2 = (strm) => {
      const ret = deflateResetKeep2(strm);
      if (ret === Z_OK2) {
        lm_init2(strm.state);
      }
      return ret;
    };
    var deflateSetHeader2 = (strm, head) => {
      if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
        return Z_STREAM_ERROR2;
      }
      strm.state.gzhead = head;
      return Z_OK2;
    };
    var deflateInit22 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR2;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION2) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL2 || method !== Z_DEFLATED2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED2 || windowBits === 8 && wrap !== 1) {
        return err2(strm, Z_STREAM_ERROR2);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s2 = new DeflateState2();
      strm.state = s2;
      s2.strm = strm;
      s2.status = INIT_STATE2;
      s2.wrap = wrap;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH2 - 1) / MIN_MATCH2);
      s2.window = new Uint8Array(s2.w_size * 2);
      s2.head = new Uint16Array(s2.hash_size);
      s2.prev = new Uint16Array(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new Uint8Array(s2.pending_buf_size);
      s2.sym_buf = s2.lit_bufsize;
      s2.sym_end = (s2.lit_bufsize - 1) * 3;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset2(strm);
    };
    var deflateInit3 = (strm, level) => {
      return deflateInit22(strm, level, Z_DEFLATED2, MAX_WBITS2, DEF_MEM_LEVEL2, Z_DEFAULT_STRATEGY2);
    };
    var deflate2 = (strm, flush) => {
      if (deflateStateCheck(strm) || flush > Z_BLOCK2 || flush < 0) {
        return strm ? err2(strm, Z_STREAM_ERROR2) : Z_STREAM_ERROR2;
      }
      const s2 = strm.state;
      if (!strm.output || strm.avail_in !== 0 && !strm.input || s2.status === FINISH_STATE2 && flush !== Z_FINISH2) {
        return err2(strm, strm.avail_out === 0 ? Z_BUF_ERROR2 : Z_STREAM_ERROR2);
      }
      const old_flush = s2.last_flush;
      s2.last_flush = flush;
      if (s2.pending !== 0) {
        flush_pending2(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK2;
        }
      } else if (strm.avail_in === 0 && rank2(flush) <= rank2(old_flush) && flush !== Z_FINISH2) {
        return err2(strm, Z_BUF_ERROR2);
      }
      if (s2.status === FINISH_STATE2 && strm.avail_in !== 0) {
        return err2(strm, Z_BUF_ERROR2);
      }
      if (s2.status === INIT_STATE2 && s2.wrap === 0) {
        s2.status = BUSY_STATE2;
      }
      if (s2.status === INIT_STATE2) {
        let header = Z_DEFLATED2 + (s2.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2) {
          level_flags = 0;
        } else if (s2.level < 6) {
          level_flags = 1;
        } else if (s2.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s2.strstart !== 0) {
          header |= PRESET_DICT2;
        }
        header += 31 - header % 31;
        putShortMSB2(s2, header);
        if (s2.strstart !== 0) {
          putShortMSB2(s2, strm.adler >>> 16);
          putShortMSB2(s2, strm.adler & 65535);
        }
        strm.adler = 1;
        s2.status = BUSY_STATE2;
        flush_pending2(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK2;
        }
      }
      if (s2.status === GZIP_STATE) {
        strm.adler = 0;
        put_byte2(s2, 31);
        put_byte2(s2, 139);
        put_byte2(s2, 8);
        if (!s2.gzhead) {
          put_byte2(s2, 0);
          put_byte2(s2, 0);
          put_byte2(s2, 0);
          put_byte2(s2, 0);
          put_byte2(s2, 0);
          put_byte2(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2 ? 4 : 0);
          put_byte2(s2, OS_CODE2);
          s2.status = BUSY_STATE2;
          flush_pending2(strm);
          if (s2.pending !== 0) {
            s2.last_flush = -1;
            return Z_OK2;
          }
        } else {
          put_byte2(
            s2,
            (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
          );
          put_byte2(s2, s2.gzhead.time & 255);
          put_byte2(s2, s2.gzhead.time >> 8 & 255);
          put_byte2(s2, s2.gzhead.time >> 16 & 255);
          put_byte2(s2, s2.gzhead.time >> 24 & 255);
          put_byte2(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2 ? 4 : 0);
          put_byte2(s2, s2.gzhead.os & 255);
          if (s2.gzhead.extra && s2.gzhead.extra.length) {
            put_byte2(s2, s2.gzhead.extra.length & 255);
            put_byte2(s2, s2.gzhead.extra.length >> 8 & 255);
          }
          if (s2.gzhead.hcrc) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending, 0);
          }
          s2.gzindex = 0;
          s2.status = EXTRA_STATE2;
        }
      }
      if (s2.status === EXTRA_STATE2) {
        if (s2.gzhead.extra) {
          let beg = s2.pending;
          let left = (s2.gzhead.extra.length & 65535) - s2.gzindex;
          while (s2.pending + left > s2.pending_buf_size) {
            let copy6 = s2.pending_buf_size - s2.pending;
            s2.pending_buf.set(s2.gzhead.extra.subarray(s2.gzindex, s2.gzindex + copy6), s2.pending);
            s2.pending = s2.pending_buf_size;
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            s2.gzindex += copy6;
            flush_pending2(strm);
            if (s2.pending !== 0) {
              s2.last_flush = -1;
              return Z_OK2;
            }
            beg = 0;
            left -= copy6;
          }
          let gzhead_extra = new Uint8Array(s2.gzhead.extra);
          s2.pending_buf.set(gzhead_extra.subarray(s2.gzindex, s2.gzindex + left), s2.pending);
          s2.pending += left;
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          s2.gzindex = 0;
        }
        s2.status = NAME_STATE2;
      }
      if (s2.status === NAME_STATE2) {
        if (s2.gzhead.name) {
          let beg = s2.pending;
          let val;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending2(strm);
              if (s2.pending !== 0) {
                s2.last_flush = -1;
                return Z_OK2;
              }
              beg = 0;
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte2(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          s2.gzindex = 0;
        }
        s2.status = COMMENT_STATE2;
      }
      if (s2.status === COMMENT_STATE2) {
        if (s2.gzhead.comment) {
          let beg = s2.pending;
          let val;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending2(strm);
              if (s2.pending !== 0) {
                s2.last_flush = -1;
                return Z_OK2;
              }
              beg = 0;
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte2(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
        }
        s2.status = HCRC_STATE2;
      }
      if (s2.status === HCRC_STATE2) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending2(strm);
            if (s2.pending !== 0) {
              s2.last_flush = -1;
              return Z_OK2;
            }
          }
          put_byte2(s2, strm.adler & 255);
          put_byte2(s2, strm.adler >> 8 & 255);
          strm.adler = 0;
        }
        s2.status = BUSY_STATE2;
        flush_pending2(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK2;
        }
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH2 && s2.status !== FINISH_STATE2) {
        let bstate = s2.level === 0 ? deflate_stored2(s2, flush) : s2.strategy === Z_HUFFMAN_ONLY2 ? deflate_huff2(s2, flush) : s2.strategy === Z_RLE2 ? deflate_rle2(s2, flush) : configuration_table2[s2.level].func(s2, flush);
        if (bstate === BS_FINISH_STARTED2 || bstate === BS_FINISH_DONE2) {
          s2.status = FINISH_STATE2;
        }
        if (bstate === BS_NEED_MORE2 || bstate === BS_FINISH_STARTED2) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK2;
        }
        if (bstate === BS_BLOCK_DONE2) {
          if (flush === Z_PARTIAL_FLUSH2) {
            _tr_align2(s2);
          } else if (flush !== Z_BLOCK2) {
            _tr_stored_block2(s2, 0, 0, false);
            if (flush === Z_FULL_FLUSH2) {
              zero2(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending2(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK2;
          }
        }
      }
      if (flush !== Z_FINISH2) {
        return Z_OK2;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END2;
      }
      if (s2.wrap === 2) {
        put_byte2(s2, strm.adler & 255);
        put_byte2(s2, strm.adler >> 8 & 255);
        put_byte2(s2, strm.adler >> 16 & 255);
        put_byte2(s2, strm.adler >> 24 & 255);
        put_byte2(s2, strm.total_in & 255);
        put_byte2(s2, strm.total_in >> 8 & 255);
        put_byte2(s2, strm.total_in >> 16 & 255);
        put_byte2(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB2(s2, strm.adler >>> 16);
        putShortMSB2(s2, strm.adler & 65535);
      }
      flush_pending2(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK2 : Z_STREAM_END2;
    };
    var deflateEnd2 = (strm) => {
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR2;
      }
      const status = strm.state.status;
      strm.state = null;
      return status === BUSY_STATE2 ? err2(strm, Z_DATA_ERROR2) : Z_OK2;
    };
    var deflateSetDictionary2 = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR2;
      }
      const s2 = strm.state;
      const wrap = s2.wrap;
      if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE2 || s2.lookahead) {
        return Z_STREAM_ERROR2;
      }
      if (wrap === 1) {
        strm.adler = adler322(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap === 0) {
          zero2(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        let tmpDict = new Uint8Array(s2.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s2.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window2(s2);
      while (s2.lookahead >= MIN_MATCH2) {
        let str = s2.strstart;
        let n = s2.lookahead - (MIN_MATCH2 - 1);
        do {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH2 - 1]);
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
        } while (--n);
        s2.strstart = str;
        s2.lookahead = MIN_MATCH2 - 1;
        fill_window2(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH2 - 1;
      s2.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap;
      return Z_OK2;
    };
    module2.exports.deflateInit = deflateInit3;
    module2.exports.deflateInit2 = deflateInit22;
    module2.exports.deflateReset = deflateReset2;
    module2.exports.deflateResetKeep = deflateResetKeep2;
    module2.exports.deflateSetHeader = deflateSetHeader2;
    module2.exports.deflate = deflate2;
    module2.exports.deflateEnd = deflateEnd2;
    module2.exports.deflateSetDictionary = deflateSetDictionary2;
    module2.exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// ../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/inffast.js"(exports2, module2) {
    "use strict";
    var BAD2 = 16209;
    var TYPE2 = 16191;
    module2.exports = function inflate_fast3(strm, start3) {
      let _in;
      let last3;
      let _out;
      let beg;
      let end3;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from4;
      let from_source;
      let input, output;
      const state2 = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last3 = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start3 - strm.avail_out);
      end3 = _out + (strm.avail_out - 257);
      dmax = state2.dmax;
      wsize = state2.wsize;
      whave = state2.whave;
      wnext = state2.wnext;
      s_window = state2.window;
      hold = state2.hold;
      bits = state2.bits;
      lcode = state2.lencode;
      dcode = state2.distcode;
      lmask = (1 << state2.lenbits) - 1;
      dmask = (1 << state2.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state2.mode = BAD2;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state2.sane) {
                            strm.msg = "invalid distance too far back";
                            state2.mode = BAD2;
                            break top;
                          }
                        }
                        from4 = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from4 += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from4 += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from4++];
                              } while (--op);
                              from4 = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from4 += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from4++];
                          output[_out++] = from_source[from4++];
                          output[_out++] = from_source[from4++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from4++];
                          if (len > 1) {
                            output[_out++] = from_source[from4++];
                          }
                        }
                      } else {
                        from4 = _out - dist;
                        do {
                          output[_out++] = output[from4++];
                          output[_out++] = output[from4++];
                          output[_out++] = output[from4++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from4++];
                          if (len > 1) {
                            output[_out++] = output[from4++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state2.mode = BAD2;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state2.mode = TYPE2;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state2.mode = BAD2;
                break top;
              }
              break;
            }
        } while (_in < last3 && _out < end3);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last3 ? 5 + (last3 - _in) : 5 - (_in - last3);
      strm.avail_out = _out < end3 ? 257 + (end3 - _out) : 257 - (_out - end3);
      state2.hold = hold;
      state2.bits = bits;
      return;
    };
  }
});

// ../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/inftrees.js"(exports2, module2) {
    "use strict";
    var MAXBITS2 = 15;
    var ENOUGH_LENS2 = 852;
    var ENOUGH_DISTS2 = 592;
    var CODES2 = 0;
    var LENS2 = 1;
    var DISTS2 = 2;
    var lbase2 = new Uint16Array([
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    var lext2 = new Uint8Array([
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    var dbase2 = new Uint16Array([
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    var dext2 = new Uint8Array([
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    var inflate_table3 = (type2, lens, lens_index, codes2, table, table_index, work, opts2) => {
      const bits = opts2.bits;
      let len = 0;
      let sym = 0;
      let min3 = 0, max3 = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill5;
      let low;
      let mask;
      let next;
      let base = null;
      let match;
      const count = new Uint16Array(MAXBITS2 + 1);
      const offs = new Uint16Array(MAXBITS2 + 1);
      let extra = null;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS2; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes2; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max3 = MAXBITS2; max3 >= 1; max3--) {
        if (count[max3] !== 0) {
          break;
        }
      }
      if (root > max3) {
        root = max3;
      }
      if (max3 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts2.bits = 1;
        return 0;
      }
      for (min3 = 1; min3 < max3; min3++) {
        if (count[min3] !== 0) {
          break;
        }
      }
      if (root < min3) {
        root = min3;
      }
      left = 1;
      for (len = 1; len <= MAXBITS2; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type2 === CODES2 || max3 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS2; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes2; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type2 === CODES2) {
        base = extra = work;
        match = 20;
      } else if (type2 === LENS2) {
        base = lbase2;
        extra = lext2;
        match = 257;
      } else {
        base = dbase2;
        extra = dext2;
        match = 0;
      }
      huff = 0;
      sym = 0;
      len = min3;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type2 === LENS2 && used > ENOUGH_LENS2 || type2 === DISTS2 && used > ENOUGH_DISTS2) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] + 1 < match) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] >= match) {
          here_op = extra[work[sym] - match];
          here_val = base[work[sym] - match];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill5 = 1 << curr;
        min3 = fill5;
        do {
          fill5 -= incr;
          table[next + (huff >> drop) + fill5] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill5 !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max3) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min3;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max3) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type2 === LENS2 && used > ENOUGH_LENS2 || type2 === DISTS2 && used > ENOUGH_DISTS2) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts2.bits = root;
      return 0;
    };
    module2.exports = inflate_table3;
  }
});

// ../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../../.yarn/cache/pako-npm-2.1.0-78df11948c-8e86465814.zip/node_modules/pako/lib/zlib/inflate.js"(exports2, module2) {
    "use strict";
    var adler322 = require_adler32();
    var crc322 = require_crc32();
    var inflate_fast3 = require_inffast();
    var inflate_table3 = require_inftrees();
    var CODES2 = 0;
    var LENS2 = 1;
    var DISTS2 = 2;
    var {
      Z_FINISH: Z_FINISH2,
      Z_BLOCK: Z_BLOCK2,
      Z_TREES: Z_TREES2,
      Z_OK: Z_OK2,
      Z_STREAM_END: Z_STREAM_END2,
      Z_NEED_DICT: Z_NEED_DICT2,
      Z_STREAM_ERROR: Z_STREAM_ERROR2,
      Z_DATA_ERROR: Z_DATA_ERROR2,
      Z_MEM_ERROR: Z_MEM_ERROR2,
      Z_BUF_ERROR: Z_BUF_ERROR2,
      Z_DEFLATED: Z_DEFLATED2
    } = require_constants();
    var HEAD2 = 16180;
    var FLAGS2 = 16181;
    var TIME2 = 16182;
    var OS2 = 16183;
    var EXLEN2 = 16184;
    var EXTRA2 = 16185;
    var NAME2 = 16186;
    var COMMENT2 = 16187;
    var HCRC2 = 16188;
    var DICTID2 = 16189;
    var DICT2 = 16190;
    var TYPE2 = 16191;
    var TYPEDO2 = 16192;
    var STORED2 = 16193;
    var COPY_2 = 16194;
    var COPY2 = 16195;
    var TABLE2 = 16196;
    var LENLENS2 = 16197;
    var CODELENS2 = 16198;
    var LEN_2 = 16199;
    var LEN2 = 16200;
    var LENEXT2 = 16201;
    var DIST2 = 16202;
    var DISTEXT2 = 16203;
    var MATCH2 = 16204;
    var LIT2 = 16205;
    var CHECK2 = 16206;
    var LENGTH2 = 16207;
    var DONE2 = 16208;
    var BAD2 = 16209;
    var MEM2 = 16210;
    var SYNC2 = 16211;
    var ENOUGH_LENS2 = 852;
    var ENOUGH_DISTS2 = 592;
    var MAX_WBITS2 = 15;
    var DEF_WBITS2 = MAX_WBITS2;
    var zswap322 = (q2) => {
      return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
    };
    function InflateState2() {
      this.strm = null;
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new Uint16Array(320);
      this.work = new Uint16Array(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    var inflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const state2 = strm.state;
      if (!state2 || state2.strm !== strm || state2.mode < HEAD2 || state2.mode > SYNC2) {
        return 1;
      }
      return 0;
    };
    var inflateResetKeep2 = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR2;
      }
      const state2 = strm.state;
      strm.total_in = strm.total_out = state2.total = 0;
      strm.msg = "";
      if (state2.wrap) {
        strm.adler = state2.wrap & 1;
      }
      state2.mode = HEAD2;
      state2.last = 0;
      state2.havedict = 0;
      state2.flags = -1;
      state2.dmax = 32768;
      state2.head = null;
      state2.hold = 0;
      state2.bits = 0;
      state2.lencode = state2.lendyn = new Int32Array(ENOUGH_LENS2);
      state2.distcode = state2.distdyn = new Int32Array(ENOUGH_DISTS2);
      state2.sane = 1;
      state2.back = -1;
      return Z_OK2;
    };
    var inflateReset3 = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR2;
      }
      const state2 = strm.state;
      state2.wsize = 0;
      state2.whave = 0;
      state2.wnext = 0;
      return inflateResetKeep2(strm);
    };
    var inflateReset22 = (strm, windowBits) => {
      let wrap;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR2;
      }
      const state2 = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 5;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR2;
      }
      if (state2.window !== null && state2.wbits !== windowBits) {
        state2.window = null;
      }
      state2.wrap = wrap;
      state2.wbits = windowBits;
      return inflateReset3(strm);
    };
    var inflateInit22 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR2;
      }
      const state2 = new InflateState2();
      strm.state = state2;
      state2.strm = strm;
      state2.window = null;
      state2.mode = HEAD2;
      const ret = inflateReset22(strm, windowBits);
      if (ret !== Z_OK2) {
        strm.state = null;
      }
      return ret;
    };
    var inflateInit3 = (strm) => {
      return inflateInit22(strm, DEF_WBITS2);
    };
    var virgin2 = true;
    var lenfix2;
    var distfix2;
    var fixedtables2 = (state2) => {
      if (virgin2) {
        lenfix2 = new Int32Array(512);
        distfix2 = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state2.lens[sym++] = 8;
        }
        while (sym < 256) {
          state2.lens[sym++] = 9;
        }
        while (sym < 280) {
          state2.lens[sym++] = 7;
        }
        while (sym < 288) {
          state2.lens[sym++] = 8;
        }
        inflate_table3(LENS2, state2.lens, 0, 288, lenfix2, 0, state2.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state2.lens[sym++] = 5;
        }
        inflate_table3(DISTS2, state2.lens, 0, 32, distfix2, 0, state2.work, { bits: 5 });
        virgin2 = false;
      }
      state2.lencode = lenfix2;
      state2.lenbits = 9;
      state2.distcode = distfix2;
      state2.distbits = 5;
    };
    var updatewindow2 = (strm, src, end3, copy6) => {
      let dist;
      const state2 = strm.state;
      if (state2.window === null) {
        state2.wsize = 1 << state2.wbits;
        state2.wnext = 0;
        state2.whave = 0;
        state2.window = new Uint8Array(state2.wsize);
      }
      if (copy6 >= state2.wsize) {
        state2.window.set(src.subarray(end3 - state2.wsize, end3), 0);
        state2.wnext = 0;
        state2.whave = state2.wsize;
      } else {
        dist = state2.wsize - state2.wnext;
        if (dist > copy6) {
          dist = copy6;
        }
        state2.window.set(src.subarray(end3 - copy6, end3 - copy6 + dist), state2.wnext);
        copy6 -= dist;
        if (copy6) {
          state2.window.set(src.subarray(end3 - copy6, end3), 0);
          state2.wnext = copy6;
          state2.whave = state2.wsize;
        } else {
          state2.wnext += dist;
          if (state2.wnext === state2.wsize) {
            state2.wnext = 0;
          }
          if (state2.whave < state2.wsize) {
            state2.whave += dist;
          }
        }
      }
      return 0;
    };
    var inflate2 = (strm, flush) => {
      let state2;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy6;
      let from4;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts2;
      let n;
      const order = (
        /* permutation of code lengths */
        new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      );
      if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if (state2.mode === TYPE2) {
        state2.mode = TYPEDO2;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state2.hold;
      bits = state2.bits;
      _in = have;
      _out = left;
      ret = Z_OK2;
      inf_leave:
        for (; ; ) {
          switch (state2.mode) {
            case HEAD2:
              if (state2.wrap === 0) {
                state2.mode = TYPEDO2;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state2.wrap & 2 && hold === 35615) {
                if (state2.wbits === 0) {
                  state2.wbits = 15;
                }
                state2.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state2.mode = FLAGS2;
                break;
              }
              if (state2.head) {
                state2.head.done = false;
              }
              if (!(state2.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state2.mode = BAD2;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED2) {
                strm.msg = "unknown compression method";
                state2.mode = BAD2;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state2.wbits === 0) {
                state2.wbits = len;
              }
              if (len > 15 || len > state2.wbits) {
                strm.msg = "invalid window size";
                state2.mode = BAD2;
                break;
              }
              state2.dmax = 1 << state2.wbits;
              state2.flags = 0;
              strm.adler = state2.check = 1;
              state2.mode = hold & 512 ? DICTID2 : TYPE2;
              hold = 0;
              bits = 0;
              break;
            case FLAGS2:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.flags = hold;
              if ((state2.flags & 255) !== Z_DEFLATED2) {
                strm.msg = "unknown compression method";
                state2.mode = BAD2;
                break;
              }
              if (state2.flags & 57344) {
                strm.msg = "unknown header flags set";
                state2.mode = BAD2;
                break;
              }
              if (state2.head) {
                state2.head.text = hold >> 8 & 1;
              }
              if (state2.flags & 512 && state2.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = TIME2;
            case TIME2:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state2.head) {
                state2.head.time = hold;
              }
              if (state2.flags & 512 && state2.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state2.check = crc322(state2.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = OS2;
            case OS2:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state2.head) {
                state2.head.xflags = hold & 255;
                state2.head.os = hold >> 8;
              }
              if (state2.flags & 512 && state2.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = EXLEN2;
            case EXLEN2:
              if (state2.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.length = hold;
                if (state2.head) {
                  state2.head.extra_len = hold;
                }
                if (state2.flags & 512 && state2.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state2.check = crc322(state2.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state2.head) {
                state2.head.extra = null;
              }
              state2.mode = EXTRA2;
            case EXTRA2:
              if (state2.flags & 1024) {
                copy6 = state2.length;
                if (copy6 > have) {
                  copy6 = have;
                }
                if (copy6) {
                  if (state2.head) {
                    len = state2.head.extra_len - state2.length;
                    if (!state2.head.extra) {
                      state2.head.extra = new Uint8Array(state2.head.extra_len);
                    }
                    state2.head.extra.set(
                      input.subarray(
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        next + copy6
                      ),
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state2.flags & 512 && state2.wrap & 4) {
                    state2.check = crc322(state2.check, input, copy6, next);
                  }
                  have -= copy6;
                  next += copy6;
                  state2.length -= copy6;
                }
                if (state2.length) {
                  break inf_leave;
                }
              }
              state2.length = 0;
              state2.mode = NAME2;
            case NAME2:
              if (state2.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy6 = 0;
                do {
                  len = input[next + copy6++];
                  if (state2.head && len && state2.length < 65536) {
                    state2.head.name += String.fromCharCode(len);
                  }
                } while (len && copy6 < have);
                if (state2.flags & 512 && state2.wrap & 4) {
                  state2.check = crc322(state2.check, input, copy6, next);
                }
                have -= copy6;
                next += copy6;
                if (len) {
                  break inf_leave;
                }
              } else if (state2.head) {
                state2.head.name = null;
              }
              state2.length = 0;
              state2.mode = COMMENT2;
            case COMMENT2:
              if (state2.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy6 = 0;
                do {
                  len = input[next + copy6++];
                  if (state2.head && len && state2.length < 65536) {
                    state2.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy6 < have);
                if (state2.flags & 512 && state2.wrap & 4) {
                  state2.check = crc322(state2.check, input, copy6, next);
                }
                have -= copy6;
                next += copy6;
                if (len) {
                  break inf_leave;
                }
              } else if (state2.head) {
                state2.head.comment = null;
              }
              state2.mode = HCRC2;
            case HCRC2:
              if (state2.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state2.wrap & 4 && hold !== (state2.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state2.head) {
                state2.head.hcrc = state2.flags >> 9 & 1;
                state2.head.done = true;
              }
              strm.adler = state2.check = 0;
              state2.mode = TYPE2;
              break;
            case DICTID2:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state2.check = zswap322(hold);
              hold = 0;
              bits = 0;
              state2.mode = DICT2;
            case DICT2:
              if (state2.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state2.hold = hold;
                state2.bits = bits;
                return Z_NEED_DICT2;
              }
              strm.adler = state2.check = 1;
              state2.mode = TYPE2;
            case TYPE2:
              if (flush === Z_BLOCK2 || flush === Z_TREES2) {
                break inf_leave;
              }
            case TYPEDO2:
              if (state2.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state2.mode = CHECK2;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state2.mode = STORED2;
                  break;
                case 1:
                  fixedtables2(state2);
                  state2.mode = LEN_2;
                  if (flush === Z_TREES2) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state2.mode = TABLE2;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state2.mode = BAD2;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED2:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state2.mode = BAD2;
                break;
              }
              state2.length = hold & 65535;
              hold = 0;
              bits = 0;
              state2.mode = COPY_2;
              if (flush === Z_TREES2) {
                break inf_leave;
              }
            case COPY_2:
              state2.mode = COPY2;
            case COPY2:
              copy6 = state2.length;
              if (copy6) {
                if (copy6 > have) {
                  copy6 = have;
                }
                if (copy6 > left) {
                  copy6 = left;
                }
                if (copy6 === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy6), put);
                have -= copy6;
                next += copy6;
                left -= copy6;
                put += copy6;
                state2.length -= copy6;
                break;
              }
              state2.mode = TYPE2;
              break;
            case TABLE2:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state2.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state2.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state2.nlen > 286 || state2.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state2.mode = BAD2;
                break;
              }
              state2.have = 0;
              state2.mode = LENLENS2;
            case LENLENS2:
              while (state2.have < state2.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.lens[order[state2.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state2.have < 19) {
                state2.lens[order[state2.have++]] = 0;
              }
              state2.lencode = state2.lendyn;
              state2.lenbits = 7;
              opts2 = { bits: state2.lenbits };
              ret = inflate_table3(CODES2, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts2);
              state2.lenbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state2.mode = BAD2;
                break;
              }
              state2.have = 0;
              state2.mode = CODELENS2;
            case CODELENS2:
              while (state2.have < state2.nlen + state2.ndist) {
                for (; ; ) {
                  here = state2.lencode[hold & (1 << state2.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state2.lens[state2.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state2.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state2.mode = BAD2;
                      break;
                    }
                    len = state2.lens[state2.have - 1];
                    copy6 = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy6 = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy6 = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state2.have + copy6 > state2.nlen + state2.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state2.mode = BAD2;
                    break;
                  }
                  while (copy6--) {
                    state2.lens[state2.have++] = len;
                  }
                }
              }
              if (state2.mode === BAD2) {
                break;
              }
              if (state2.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state2.mode = BAD2;
                break;
              }
              state2.lenbits = 9;
              opts2 = { bits: state2.lenbits };
              ret = inflate_table3(LENS2, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts2);
              state2.lenbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state2.mode = BAD2;
                break;
              }
              state2.distbits = 6;
              state2.distcode = state2.distdyn;
              opts2 = { bits: state2.distbits };
              ret = inflate_table3(DISTS2, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts2);
              state2.distbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state2.mode = BAD2;
                break;
              }
              state2.mode = LEN_2;
              if (flush === Z_TREES2) {
                break inf_leave;
              }
            case LEN_2:
              state2.mode = LEN2;
            case LEN2:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state2.hold = hold;
                state2.bits = bits;
                inflate_fast3(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state2.hold;
                bits = state2.bits;
                if (state2.mode === TYPE2) {
                  state2.back = -1;
                }
                break;
              }
              state2.back = 0;
              for (; ; ) {
                here = state2.lencode[hold & (1 << state2.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state2.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state2.back += here_bits;
              state2.length = here_val;
              if (here_op === 0) {
                state2.mode = LIT2;
                break;
              }
              if (here_op & 32) {
                state2.back = -1;
                state2.mode = TYPE2;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state2.mode = BAD2;
                break;
              }
              state2.extra = here_op & 15;
              state2.mode = LENEXT2;
            case LENEXT2:
              if (state2.extra) {
                n = state2.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.length += hold & (1 << state2.extra) - 1;
                hold >>>= state2.extra;
                bits -= state2.extra;
                state2.back += state2.extra;
              }
              state2.was = state2.length;
              state2.mode = DIST2;
            case DIST2:
              for (; ; ) {
                here = state2.distcode[hold & (1 << state2.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state2.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state2.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state2.mode = BAD2;
                break;
              }
              state2.offset = here_val;
              state2.extra = here_op & 15;
              state2.mode = DISTEXT2;
            case DISTEXT2:
              if (state2.extra) {
                n = state2.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state2.offset += hold & (1 << state2.extra) - 1;
                hold >>>= state2.extra;
                bits -= state2.extra;
                state2.back += state2.extra;
              }
              if (state2.offset > state2.dmax) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD2;
                break;
              }
              state2.mode = MATCH2;
            case MATCH2:
              if (left === 0) {
                break inf_leave;
              }
              copy6 = _out - left;
              if (state2.offset > copy6) {
                copy6 = state2.offset - copy6;
                if (copy6 > state2.whave) {
                  if (state2.sane) {
                    strm.msg = "invalid distance too far back";
                    state2.mode = BAD2;
                    break;
                  }
                }
                if (copy6 > state2.wnext) {
                  copy6 -= state2.wnext;
                  from4 = state2.wsize - copy6;
                } else {
                  from4 = state2.wnext - copy6;
                }
                if (copy6 > state2.length) {
                  copy6 = state2.length;
                }
                from_source = state2.window;
              } else {
                from_source = output;
                from4 = put - state2.offset;
                copy6 = state2.length;
              }
              if (copy6 > left) {
                copy6 = left;
              }
              left -= copy6;
              state2.length -= copy6;
              do {
                output[put++] = from_source[from4++];
              } while (--copy6);
              if (state2.length === 0) {
                state2.mode = LEN2;
              }
              break;
            case LIT2:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state2.length;
              left--;
              state2.mode = LEN2;
              break;
            case CHECK2:
              if (state2.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state2.total += _out;
                if (state2.wrap & 4 && _out) {
                  strm.adler = state2.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                  state2.flags ? crc322(state2.check, output, _out, put - _out) : adler322(state2.check, output, _out, put - _out);
                }
                _out = left;
                if (state2.wrap & 4 && (state2.flags ? hold : zswap322(hold)) !== state2.check) {
                  strm.msg = "incorrect data check";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state2.mode = LENGTH2;
            case LENGTH2:
              if (state2.wrap && state2.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state2.wrap & 4 && hold !== (state2.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state2.mode = DONE2;
            case DONE2:
              ret = Z_STREAM_END2;
              break inf_leave;
            case BAD2:
              ret = Z_DATA_ERROR2;
              break inf_leave;
            case MEM2:
              return Z_MEM_ERROR2;
            case SYNC2:
            default:
              return Z_STREAM_ERROR2;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state2.hold = hold;
      state2.bits = bits;
      if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD2 && (state2.mode < CHECK2 || flush !== Z_FINISH2)) {
        if (updatewindow2(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state2.mode = MEM2;
          return Z_MEM_ERROR2;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state2.total += _out;
      if (state2.wrap & 4 && _out) {
        strm.adler = state2.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
        state2.flags ? crc322(state2.check, output, _out, strm.next_out - _out) : adler322(state2.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE2 ? 128 : 0) + (state2.mode === LEN_2 || state2.mode === COPY_2 ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH2) && ret === Z_OK2) {
        ret = Z_BUF_ERROR2;
      }
      return ret;
    };
    var inflateEnd2 = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR2;
      }
      let state2 = strm.state;
      if (state2.window) {
        state2.window = null;
      }
      strm.state = null;
      return Z_OK2;
    };
    var inflateGetHeader2 = (strm, head) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR2;
      }
      const state2 = strm.state;
      if ((state2.wrap & 2) === 0) {
        return Z_STREAM_ERROR2;
      }
      state2.head = head;
      head.done = false;
      return Z_OK2;
    };
    var inflateSetDictionary2 = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state2;
      let dictid;
      let ret;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if (state2.wrap !== 0 && state2.mode !== DICT2) {
        return Z_STREAM_ERROR2;
      }
      if (state2.mode === DICT2) {
        dictid = 1;
        dictid = adler322(dictid, dictionary, dictLength, 0);
        if (dictid !== state2.check) {
          return Z_DATA_ERROR2;
        }
      }
      ret = updatewindow2(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state2.mode = MEM2;
        return Z_MEM_ERROR2;
      }
      state2.havedict = 1;
      return Z_OK2;
    };
    module2.exports.inflateReset = inflateReset3;
    module2.exports.inflateReset2 = inflateReset22;
    module2.exports.inflateResetKeep = inflateResetKeep2;
    module2.exports.inflateInit = inflateInit3;
    module2.exports.inflateInit2 = inflateInit22;
    module2.exports.inflate = inflate2;
    module2.exports.inflateEnd = inflateEnd2;
    module2.exports.inflateGetHeader = inflateGetHeader2;
    module2.exports.inflateSetDictionary = inflateSetDictionary2;
    module2.exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../.yarn/cache/crypto-js-npm-4.2.0-d6f7744e63-8fbdf9d56f.zip/node_modules/crypto-js/core.js
var require_core = __commonJS({
  "../../.yarn/cache/crypto-js-npm-4.2.0-d6f7744e63-8fbdf9d56f.zip/node_modules/crypto-js/core.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports2, function() {
      var CryptoJS2 = CryptoJS2 || function(Math2, undefined2) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof __require === "function") {
          try {
            crypto = require_crypto();
          } catch (err2) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err2) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err2) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create2 = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C2 = {};
        var C_lib = C2.lib = {};
        var Base2 = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create2(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C2.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base2.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data2) {
            if (typeof data2 == "string") {
              data2 = Utf8.parse(data2);
            }
            this._data.concat(data2);
            this._nDataBytes += data2.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data2 = this._data;
            var dataWords = data2.words;
            var dataSigBytes = data2.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset3 = 0; offset3 < nWordsReady; offset3 += blockSize) {
                this._doProcessBlock(dataWords, offset3);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data2.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base2.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C2.algo = {};
        return C2;
      }(Math);
      return CryptoJS2;
    });
  }
});

// ../../.yarn/cache/crypto-js-npm-4.2.0-d6f7744e63-8fbdf9d56f.zip/node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "../../.yarn/cache/crypto-js-npm-4.2.0-d6f7744e63-8fbdf9d56f.zip/node_modules/crypto-js/md5.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof exports2 === "object") {
        module2.exports = exports2 = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports2, function(CryptoJS2) {
      (function(Math2) {
        var C2 = CryptoJS2;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var T2 = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T2[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD52 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M2, offset3) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset3 + i;
              var M_offset_i = M2[offset_i];
              M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H2 = this._hash.words;
            var M_offset_0 = M2[offset3 + 0];
            var M_offset_1 = M2[offset3 + 1];
            var M_offset_2 = M2[offset3 + 2];
            var M_offset_3 = M2[offset3 + 3];
            var M_offset_4 = M2[offset3 + 4];
            var M_offset_5 = M2[offset3 + 5];
            var M_offset_6 = M2[offset3 + 6];
            var M_offset_7 = M2[offset3 + 7];
            var M_offset_8 = M2[offset3 + 8];
            var M_offset_9 = M2[offset3 + 9];
            var M_offset_10 = M2[offset3 + 10];
            var M_offset_11 = M2[offset3 + 11];
            var M_offset_12 = M2[offset3 + 12];
            var M_offset_13 = M2[offset3 + 13];
            var M_offset_14 = M2[offset3 + 14];
            var M_offset_15 = M2[offset3 + 15];
            var a2 = H2[0];
            var b = H2[1];
            var c2 = H2[2];
            var d = H2[3];
            a2 = FF(a2, b, c2, d, M_offset_0, 7, T2[0]);
            d = FF(d, a2, b, c2, M_offset_1, 12, T2[1]);
            c2 = FF(c2, d, a2, b, M_offset_2, 17, T2[2]);
            b = FF(b, c2, d, a2, M_offset_3, 22, T2[3]);
            a2 = FF(a2, b, c2, d, M_offset_4, 7, T2[4]);
            d = FF(d, a2, b, c2, M_offset_5, 12, T2[5]);
            c2 = FF(c2, d, a2, b, M_offset_6, 17, T2[6]);
            b = FF(b, c2, d, a2, M_offset_7, 22, T2[7]);
            a2 = FF(a2, b, c2, d, M_offset_8, 7, T2[8]);
            d = FF(d, a2, b, c2, M_offset_9, 12, T2[9]);
            c2 = FF(c2, d, a2, b, M_offset_10, 17, T2[10]);
            b = FF(b, c2, d, a2, M_offset_11, 22, T2[11]);
            a2 = FF(a2, b, c2, d, M_offset_12, 7, T2[12]);
            d = FF(d, a2, b, c2, M_offset_13, 12, T2[13]);
            c2 = FF(c2, d, a2, b, M_offset_14, 17, T2[14]);
            b = FF(b, c2, d, a2, M_offset_15, 22, T2[15]);
            a2 = GG(a2, b, c2, d, M_offset_1, 5, T2[16]);
            d = GG(d, a2, b, c2, M_offset_6, 9, T2[17]);
            c2 = GG(c2, d, a2, b, M_offset_11, 14, T2[18]);
            b = GG(b, c2, d, a2, M_offset_0, 20, T2[19]);
            a2 = GG(a2, b, c2, d, M_offset_5, 5, T2[20]);
            d = GG(d, a2, b, c2, M_offset_10, 9, T2[21]);
            c2 = GG(c2, d, a2, b, M_offset_15, 14, T2[22]);
            b = GG(b, c2, d, a2, M_offset_4, 20, T2[23]);
            a2 = GG(a2, b, c2, d, M_offset_9, 5, T2[24]);
            d = GG(d, a2, b, c2, M_offset_14, 9, T2[25]);
            c2 = GG(c2, d, a2, b, M_offset_3, 14, T2[26]);
            b = GG(b, c2, d, a2, M_offset_8, 20, T2[27]);
            a2 = GG(a2, b, c2, d, M_offset_13, 5, T2[28]);
            d = GG(d, a2, b, c2, M_offset_2, 9, T2[29]);
            c2 = GG(c2, d, a2, b, M_offset_7, 14, T2[30]);
            b = GG(b, c2, d, a2, M_offset_12, 20, T2[31]);
            a2 = HH(a2, b, c2, d, M_offset_5, 4, T2[32]);
            d = HH(d, a2, b, c2, M_offset_8, 11, T2[33]);
            c2 = HH(c2, d, a2, b, M_offset_11, 16, T2[34]);
            b = HH(b, c2, d, a2, M_offset_14, 23, T2[35]);
            a2 = HH(a2, b, c2, d, M_offset_1, 4, T2[36]);
            d = HH(d, a2, b, c2, M_offset_4, 11, T2[37]);
            c2 = HH(c2, d, a2, b, M_offset_7, 16, T2[38]);
            b = HH(b, c2, d, a2, M_offset_10, 23, T2[39]);
            a2 = HH(a2, b, c2, d, M_offset_13, 4, T2[40]);
            d = HH(d, a2, b, c2, M_offset_0, 11, T2[41]);
            c2 = HH(c2, d, a2, b, M_offset_3, 16, T2[42]);
            b = HH(b, c2, d, a2, M_offset_6, 23, T2[43]);
            a2 = HH(a2, b, c2, d, M_offset_9, 4, T2[44]);
            d = HH(d, a2, b, c2, M_offset_12, 11, T2[45]);
            c2 = HH(c2, d, a2, b, M_offset_15, 16, T2[46]);
            b = HH(b, c2, d, a2, M_offset_2, 23, T2[47]);
            a2 = II(a2, b, c2, d, M_offset_0, 6, T2[48]);
            d = II(d, a2, b, c2, M_offset_7, 10, T2[49]);
            c2 = II(c2, d, a2, b, M_offset_14, 15, T2[50]);
            b = II(b, c2, d, a2, M_offset_5, 21, T2[51]);
            a2 = II(a2, b, c2, d, M_offset_12, 6, T2[52]);
            d = II(d, a2, b, c2, M_offset_3, 10, T2[53]);
            c2 = II(c2, d, a2, b, M_offset_10, 15, T2[54]);
            b = II(b, c2, d, a2, M_offset_1, 21, T2[55]);
            a2 = II(a2, b, c2, d, M_offset_8, 6, T2[56]);
            d = II(d, a2, b, c2, M_offset_15, 10, T2[57]);
            c2 = II(c2, d, a2, b, M_offset_6, 15, T2[58]);
            b = II(b, c2, d, a2, M_offset_13, 21, T2[59]);
            a2 = II(a2, b, c2, d, M_offset_4, 6, T2[60]);
            d = II(d, a2, b, c2, M_offset_11, 10, T2[61]);
            c2 = II(c2, d, a2, b, M_offset_2, 15, T2[62]);
            b = II(b, c2, d, a2, M_offset_9, 21, T2[63]);
            H2[0] = H2[0] + a2 | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H2 = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H2[i];
              H2[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a2, b, c2, d, x, s2, t2) {
          var n = a2 + (b & c2 | ~b & d) + x + t2;
          return (n << s2 | n >>> 32 - s2) + b;
        }
        function GG(a2, b, c2, d, x, s2, t2) {
          var n = a2 + (b & d | c2 & ~d) + x + t2;
          return (n << s2 | n >>> 32 - s2) + b;
        }
        function HH(a2, b, c2, d, x, s2, t2) {
          var n = a2 + (b ^ c2 ^ d) + x + t2;
          return (n << s2 | n >>> 32 - s2) + b;
        }
        function II(a2, b, c2, d, x, s2, t2) {
          var n = a2 + (c2 ^ (b | ~d)) + x + t2;
          return (n << s2 | n >>> 32 - s2) + b;
        }
        C2.MD5 = Hasher._createHelper(MD52);
        C2.HmacMD5 = Hasher._createHmacHelper(MD52);
      })(Math);
      return CryptoJS2.MD5;
    });
  }
});

// ../../.yarn/cache/postcss-value-parser-npm-4.2.0-3cef602a6a-f4142a4f56.zip/node_modules/postcss-value-parser/lib/parse.js
var require_parse = __commonJS({
  "../../.yarn/cache/postcss-value-parser-npm-4.2.0-3cef602a6a-f4142a4f56.zip/node_modules/postcss-value-parser/lib/parse.js"(exports2, module2) {
    var openParentheses = "(".charCodeAt(0);
    var closeParentheses = ")".charCodeAt(0);
    var singleQuote = "'".charCodeAt(0);
    var doubleQuote = '"'.charCodeAt(0);
    var backslash = "\\".charCodeAt(0);
    var slash = "/".charCodeAt(0);
    var comma = ",".charCodeAt(0);
    var colon = ":".charCodeAt(0);
    var star = "*".charCodeAt(0);
    var uLower = "u".charCodeAt(0);
    var uUpper = "U".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var isUnicodeRange = /^[a-f0-9?-]+$/i;
    module2.exports = function(input) {
      var tokens = [];
      var value2 = input;
      var next, quote, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
      var pos = 0;
      var code = value2.charCodeAt(pos);
      var max3 = value2.length;
      var stack = [{ nodes: tokens }];
      var balanced = 0;
      var parent;
      var name2 = "";
      var before = "";
      var after = "";
      while (pos < max3) {
        if (code <= 32) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          token = value2.slice(pos, next);
          prev = tokens[tokens.length - 1];
          if (code === closeParentheses && balanced) {
            after = token;
          } else if (prev && prev.type === "div") {
            prev.after = token;
            prev.sourceEndIndex += token.length;
          } else if (code === comma || code === colon || code === slash && value2.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
            before = token;
          } else {
            tokens.push({
              type: "space",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        } else if (code === singleQuote || code === doubleQuote) {
          next = pos;
          quote = code === singleQuote ? "'" : '"';
          token = {
            type: "string",
            sourceIndex: pos,
            quote
          };
          do {
            escape2 = false;
            next = value2.indexOf(quote, next + 1);
            if (~next) {
              escapePos = next;
              while (value2.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape2 = !escape2;
              }
            } else {
              value2 += quote;
              next = value2.length - 1;
              token.unclosed = true;
            }
          } while (escape2);
          token.value = value2.slice(pos + 1, next);
          token.sourceEndIndex = token.unclosed ? next : next + 1;
          tokens.push(token);
          pos = next + 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash && value2.charCodeAt(pos + 1) === star) {
          next = value2.indexOf("*/", pos);
          token = {
            type: "comment",
            sourceIndex: pos,
            sourceEndIndex: next + 2
          };
          if (next === -1) {
            token.unclosed = true;
            next = value2.length;
            token.sourceEndIndex = next;
          }
          token.value = value2.slice(pos + 2, next);
          tokens.push(token);
          pos = next + 2;
          code = value2.charCodeAt(pos);
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
          token = value2[pos];
          tokens.push({
            type: "word",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token
          });
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash || code === comma || code === colon) {
          token = value2[pos];
          tokens.push({
            type: "div",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token,
            before,
            after: ""
          });
          before = "";
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (openParentheses === code) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          parenthesesOpenPos = pos;
          token = {
            type: "function",
            sourceIndex: pos - name2.length,
            value: name2,
            before: value2.slice(parenthesesOpenPos + 1, next)
          };
          pos = next;
          if (name2 === "url" && code !== singleQuote && code !== doubleQuote) {
            next -= 1;
            do {
              escape2 = false;
              next = value2.indexOf(")", next + 1);
              if (~next) {
                escapePos = next;
                while (value2.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape2 = !escape2;
                }
              } else {
                value2 += ")";
                next = value2.length - 1;
                token.unclosed = true;
              }
            } while (escape2);
            whitespacePos = next;
            do {
              whitespacePos -= 1;
              code = value2.charCodeAt(whitespacePos);
            } while (code <= 32);
            if (parenthesesOpenPos < whitespacePos) {
              if (pos !== whitespacePos + 1) {
                token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: whitespacePos + 1,
                    value: value2.slice(pos, whitespacePos + 1)
                  }
                ];
              } else {
                token.nodes = [];
              }
              if (token.unclosed && whitespacePos + 1 !== next) {
                token.after = "";
                token.nodes.push({
                  type: "space",
                  sourceIndex: whitespacePos + 1,
                  sourceEndIndex: next,
                  value: value2.slice(whitespacePos + 1, next)
                });
              } else {
                token.after = value2.slice(whitespacePos + 1, next);
                token.sourceEndIndex = next;
              }
            } else {
              token.after = "";
              token.nodes = [];
            }
            pos = next + 1;
            token.sourceEndIndex = token.unclosed ? next : pos;
            code = value2.charCodeAt(pos);
            tokens.push(token);
          } else {
            balanced += 1;
            token.after = "";
            token.sourceEndIndex = pos + 1;
            tokens.push(token);
            stack.push(token);
            tokens = token.nodes = [];
            parent = token;
          }
          name2 = "";
        } else if (closeParentheses === code && balanced) {
          pos += 1;
          code = value2.charCodeAt(pos);
          parent.after = after;
          parent.sourceEndIndex += after.length;
          after = "";
          balanced -= 1;
          stack[stack.length - 1].sourceEndIndex = pos;
          stack.pop();
          parent = stack[balanced];
          tokens = parent.nodes;
        } else {
          next = pos;
          do {
            if (code === backslash) {
              next += 1;
            }
            next += 1;
            code = value2.charCodeAt(next);
          } while (next < max3 && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
          token = value2.slice(pos, next);
          if (openParentheses === code) {
            name2 = token;
          } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
            tokens.push({
              type: "unicode-range",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          } else {
            tokens.push({
              type: "word",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        }
      }
      for (pos = stack.length - 1; pos; pos -= 1) {
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value2.length;
      }
      return stack[0].nodes;
    };
  }
});

// ../../.yarn/cache/postcss-value-parser-npm-4.2.0-3cef602a6a-f4142a4f56.zip/node_modules/postcss-value-parser/lib/unit.js
var require_unit = __commonJS({
  "../../.yarn/cache/postcss-value-parser-npm-4.2.0-3cef602a6a-f4142a4f56.zip/node_modules/postcss-value-parser/lib/unit.js"(exports2, module2) {
    var minus = "-".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var dot = ".".charCodeAt(0);
    var exp = "e".charCodeAt(0);
    var EXP = "E".charCodeAt(0);
    function likeNumber(value2) {
      var code = value2.charCodeAt(0);
      var nextCode;
      if (code === plus || code === minus) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        var nextNextCode = value2.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code === dot) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code >= 48 && code <= 57) {
        return true;
      }
      return false;
    }
    module2.exports = function(value2) {
      var pos = 0;
      var length4 = value2.length;
      var code;
      var nextCode;
      var nextNextCode;
      if (length4 === 0 || !likeNumber(value2)) {
        return false;
      }
      code = value2.charCodeAt(pos);
      if (code === plus || code === minus) {
        pos++;
      }
      while (pos < length4) {
        code = value2.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
      code = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while (pos < length4) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      code = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      nextNextCode = value2.charCodeAt(pos + 2);
      if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while (pos < length4) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      return {
        number: value2.slice(0, pos),
        unit: value2.slice(pos)
      };
    };
  }
});

// ../../.yarn/cache/hsl-to-rgb-for-reals-npm-1.1.1-f1bc4775d6-330f63b3ae.zip/node_modules/hsl-to-rgb-for-reals/converter.js
var require_converter = __commonJS({
  "../../.yarn/cache/hsl-to-rgb-for-reals-npm-1.1.1-f1bc4775d6-330f63b3ae.zip/node_modules/hsl-to-rgb-for-reals/converter.js"(exports2, module2) {
    var hslToRgb = function(hue, saturation, lightness) {
      if (hue == void 0) {
        return [0, 0, 0];
      }
      var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
      var huePrime = hue / 60;
      var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
      huePrime = Math.floor(huePrime);
      var red;
      var green;
      var blue;
      if (huePrime === 0) {
        red = chroma;
        green = secondComponent;
        blue = 0;
      } else if (huePrime === 1) {
        red = secondComponent;
        green = chroma;
        blue = 0;
      } else if (huePrime === 2) {
        red = 0;
        green = chroma;
        blue = secondComponent;
      } else if (huePrime === 3) {
        red = 0;
        green = secondComponent;
        blue = chroma;
      } else if (huePrime === 4) {
        red = secondComponent;
        green = 0;
        blue = chroma;
      } else if (huePrime === 5) {
        red = chroma;
        green = 0;
        blue = secondComponent;
      }
      var lightnessAdjustment = lightness - chroma / 2;
      red += lightnessAdjustment;
      green += lightnessAdjustment;
      blue += lightnessAdjustment;
      return [
        Math.abs(Math.round(red * 255)),
        Math.abs(Math.round(green * 255)),
        Math.abs(Math.round(blue * 255))
      ];
    };
    module2.exports = hslToRgb;
  }
});

// ../../.yarn/cache/hsl-to-hex-npm-1.0.0-9742a194a7-f8f88e4afa.zip/node_modules/hsl-to-hex/index.js
var require_hsl_to_hex = __commonJS({
  "../../.yarn/cache/hsl-to-hex-npm-1.0.0-9742a194a7-f8f88e4afa.zip/node_modules/hsl-to-hex/index.js"(exports2, module2) {
    var toRgb = require_converter();
    function max3(val, n) {
      return val > n ? n : val;
    }
    function min3(val, n) {
      return val < n ? n : val;
    }
    function cycle(val) {
      val = max3(val, 1e7);
      val = min3(val, -1e7);
      while (val < 0) {
        val += 360;
      }
      while (val > 359) {
        val -= 360;
      }
      return val;
    }
    function hsl(hue, saturation, luminosity) {
      hue = cycle(hue);
      saturation = min3(max3(saturation, 100), 0);
      luminosity = min3(max3(luminosity, 100), 0);
      saturation /= 100;
      luminosity /= 100;
      var rgb = toRgb(hue, saturation, luminosity);
      return "#" + rgb.map(function(n) {
        return (256 + n).toString(16).substr(-2);
      }).join("");
    }
    module2.exports = hsl;
  }
});

// ../../.yarn/cache/media-engine-npm-1.0.3-95c823ed38-60e602ec36.zip/node_modules/media-engine/src/queries.js
var require_queries = __commonJS({
  "../../.yarn/cache/media-engine-npm-1.0.3-95c823ed38-60e602ec36.zip/node_modules/media-engine/src/queries.js"(exports2, module2) {
    function MaxHeight(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value >= options.height;
      };
    }
    function MinHeight(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value < options.height;
      };
    }
    function MaxWidth(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value >= options.width;
      };
    }
    function MinWidth(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value < options.width;
      };
    }
    function Orientation(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value === options.orientation;
      };
    }
    module2.exports = function Query(type2, value2) {
      switch (type2) {
        case "max-height":
          return new MaxHeight(value2);
        case "min-height":
          return new MinHeight(value2);
        case "max-width":
          return new MaxWidth(value2);
        case "min-width":
          return new MinWidth(value2);
        case "orientation":
          return new Orientation(value2);
        default:
          throw new Error(value2);
      }
    };
  }
});

// ../../.yarn/cache/media-engine-npm-1.0.3-95c823ed38-60e602ec36.zip/node_modules/media-engine/src/operators.js
var require_operators = __commonJS({
  "../../.yarn/cache/media-engine-npm-1.0.3-95c823ed38-60e602ec36.zip/node_modules/media-engine/src/operators.js"(exports2, module2) {
    function And(left, right) {
      this.left = left;
      this.right = right;
      this.match = function(options) {
        return left.match(options) && right.match(options);
      };
    }
    function Or(left, right) {
      this.left = left;
      this.right = right;
      this.match = function(options) {
        return left.match(options) || right.match(options);
      };
    }
    module2.exports = function Operator(type2, left, right) {
      switch (type2) {
        case "and":
          return new And(left, right);
        case ",":
          return new Or(left, right);
        default:
          throw new Error(value);
      }
    };
  }
});

// ../../.yarn/cache/media-engine-npm-1.0.3-95c823ed38-60e602ec36.zip/node_modules/media-engine/src/parser.js
var require_parser = __commonJS({
  "../../.yarn/cache/media-engine-npm-1.0.3-95c823ed38-60e602ec36.zip/node_modules/media-engine/src/parser.js"(exports2, module2) {
    var Query = require_queries();
    var Operator = require_operators();
    var NUMBERS = /[0-9]/;
    var LETTERS = /[a-z|\-]/i;
    var WHITESPACE = /\s/;
    var COLON = /:/;
    var COMMA = /,/;
    var AND = /and$/;
    var AT = /@/;
    function tokenizer(input) {
      var current = 0;
      var tokens = [];
      while (current < input.length) {
        var char = input[current];
        if (AT.test(char)) {
          char = input[++current];
          while (LETTERS.test(char) && char !== void 0) {
            char = input[++current];
          }
        }
        if (WHITESPACE.test(char) || char === ")" || char === "(") {
          current++;
          continue;
        }
        if (COLON.test(char) || COMMA.test(char)) {
          current++;
          tokens.push({ type: "operator", value: char });
          continue;
        }
        if (NUMBERS.test(char)) {
          var value2 = "";
          while (NUMBERS.test(char)) {
            value2 += char;
            char = input[++current];
          }
          tokens.push({ type: "number", value: value2 });
          continue;
        }
        if (LETTERS.test(char)) {
          var value2 = "";
          while (LETTERS.test(char) && char !== void 0) {
            value2 += char;
            char = input[++current];
          }
          if (AND.test(value2)) {
            tokens.push({ type: "operator", value: value2 });
          } else {
            tokens.push({ type: "literal", value: value2 });
          }
          continue;
        }
        throw new TypeError(
          "Tokenizer: I dont know what this character is: " + char
        );
      }
      return tokens;
    }
    function parser(tokens) {
      var output = [];
      var stack = [];
      while (tokens.length > 0) {
        var token = tokens.shift();
        if (token.type === "number" || token.type === "literal") {
          output.push(token);
          continue;
        }
        if (token.type === "operator") {
          if (COLON.test(token.value)) {
            token = { type: "query", key: output.pop(), value: tokens.shift() };
            output.push(token);
            continue;
          }
          while (stack.length > 0) {
            output.unshift(stack.pop());
          }
          stack.push(token);
        }
      }
      while (stack.length > 0) {
        output.unshift(stack.pop());
      }
      function walk() {
        var head = output.shift();
        if (head.type === "number") {
          return parseInt(head.value);
        }
        if (head.type === "literal") {
          return head.value;
        }
        if (head.type === "operator") {
          var l2 = walk();
          var r = walk();
          return Operator(head.value, l2, r);
        }
        if (head.type === "query") {
          var l2 = head.key.value;
          var r = head.value.value;
          return Query(l2, r);
        }
      }
      return walk();
    }
    module2.exports = {
      parse: function(query) {
        var tokens = tokenizer(query);
        var ast = parser(tokens);
        return ast;
      }
    };
  }
});

// ../../.yarn/cache/media-engine-npm-1.0.3-95c823ed38-60e602ec36.zip/node_modules/media-engine/src/index.js
var require_src = __commonJS({
  "../../.yarn/cache/media-engine-npm-1.0.3-95c823ed38-60e602ec36.zip/node_modules/media-engine/src/index.js"(exports2, module2) {
    var Parser = require_parser();
    module2.exports = function(queries, options) {
      var result = {};
      Object.keys(queries).forEach(function(query) {
        if (Parser.parse(query).match(options)) {
          Object.assign(result, queries[query]);
        }
      });
      return result;
    };
  }
});

// ../../.yarn/cache/hyphen-npm-1.10.4-51dec4187e-4828159b40.zip/node_modules/hyphen/hyphen.js
var require_hyphen = __commonJS({
  "../../.yarn/cache/hyphen-npm-1.10.4-51dec4187e-4828159b40.zip/node_modules/hyphen/hyphen.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.createHyphenator = factory();
      }
    })(exports2, function() {
      function createTextReader(setup) {
        var char1 = "";
        var char2 = "";
        var i = 0;
        var verifier = setup();
        return function(text2) {
          while (i < text2.length) {
            char1 = text2.charAt(i++);
            char2 = text2.charAt(i);
            var verified = verifier(char1, char2);
            if (verified !== void 0) {
              return verified;
            }
          }
        };
      }
      var isNotLetter = RegExp.prototype.test.bind(
        /\s|(?![\'])[\!-\@\[-\`\{-\~\u2013-\u203C]/
      );
      function createHTMLVerifier() {
        var skip = false;
        return function(accumulate, chars) {
          if (skip) {
            if (chars[0] === ">") {
              accumulate();
              skip = false;
            }
          } else if (chars[0] === "<" && (!isNotLetter(chars[1]) || chars[1] === "/")) {
            skip = true;
          }
          return skip;
        };
      }
      function createHyphenCharVerifier(hyphenChar) {
        var skip = false;
        return function(accumulate, chars) {
          if (skip) {
            if (!isNotLetter(chars[0]) && isNotLetter(chars[1])) {
              accumulate();
              skip = false;
            }
          } else if (!isNotLetter(chars[0]) && chars[1] === hyphenChar) {
            skip = true;
          }
          return skip;
        };
      }
      function createHyphenationVerifier(verifiers, minWordLength) {
        return function() {
          var accum0 = "";
          var accum = "";
          function accumulate() {
            accum0 += accum;
            accum = "";
          }
          function resolveWith(value2) {
            accum0 = "";
            accum = "";
            return value2;
          }
          return function(char1, char2) {
            accum += char1;
            var skip = verifiers.reduce(function(skip2, verify) {
              return skip2 || verify(accumulate, [char1, char2]);
            }, false);
            if (!skip) {
              if (isNotLetter(char1) && !isNotLetter(char2)) {
                accumulate();
              }
              if (!isNotLetter(char1) && isNotLetter(char2)) {
                if (accum.length >= minWordLength) {
                  return resolveWith([accum0, accum]);
                } else {
                  accumulate();
                }
              }
            }
            if (char2 === "") {
              if (accum.length < minWordLength || skip) {
                accumulate();
              }
              return resolveWith([accum0, accum]);
            }
          };
        };
      }
      function createCharIterator(str) {
        var i = 0;
        function nextChar() {
          return str[i++];
        }
        function isLastLetter() {
          return str.length === i + 1;
        }
        return [nextChar, isLastLetter];
      }
      function createStringSlicer(str) {
        var i = 0, slice8 = str;
        function next() {
          slice8 = str.slice(i++);
          if (slice8.length < 3) {
            return;
          }
          return slice8;
        }
        function isFirstCharacter() {
          return i === 2;
        }
        return [next, isFirstCharacter];
      }
      function hyphenateWord(text2, levelsTable, patternTree, debug3, hyphenChar) {
        var levels = new Array(text2.length + 1), loweredText = ("." + text2.toLocaleLowerCase() + ".").split(""), wordSlice, letter, treePtr, nextPtr, patternLevelsIndex, patternLevels, patternEntityIndex = -1, slicer, nextSlice, isFirstCharacter, charIterator, nextLetter, isLastLetter;
        for (var i = levels.length; i--; ) levels[i] = 0;
        slicer = createStringSlicer(loweredText);
        nextSlice = slicer[0];
        isFirstCharacter = slicer[1];
        while (wordSlice = nextSlice()) {
          patternEntityIndex++;
          if (isFirstCharacter()) {
            patternEntityIndex--;
          }
          treePtr = patternTree;
          charIterator = createCharIterator(wordSlice);
          nextLetter = charIterator[0];
          isLastLetter = charIterator[1];
          while (letter = nextLetter()) {
            if (treePtr[letter] === void 0) {
              break;
            }
            nextPtr = treePtr[letter];
            treePtr = nextPtr[0];
            patternLevelsIndex = nextPtr[1];
            if (treePtr === void 0) {
              treePtr = {};
              patternLevelsIndex = nextPtr;
            }
            if (isLastLetter()) {
              continue;
            }
            if (patternLevelsIndex === void 0) {
              continue;
            }
            if (!levelsTable[patternLevelsIndex].splice) {
              levelsTable[patternLevelsIndex] = levelsTable[patternLevelsIndex].slice("");
            }
            patternLevels = levelsTable[patternLevelsIndex];
            for (var k = 0; k < patternLevels.length; k++)
              levels[patternEntityIndex + k] = Math.max(
                patternLevels[k],
                levels[patternEntityIndex + k]
              );
          }
        }
        levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;
        var hyphenatedText = "";
        for (var i = 0; i < levels.length; i++) {
          hyphenatedText += (levels[i] % 2 === 1 ? hyphenChar : "") + text2.charAt(i);
        }
        return hyphenatedText;
      }
      function start3(text2, levelsTable, patterns, cache2, debug3, hyphenChar, skipHTML, minWordLength, isAsync) {
        function done3() {
          resolveNewText(newText);
        }
        var newText = "", fragments, readText = createTextReader(
          createHyphenationVerifier(
            (skipHTML ? [createHTMLVerifier()] : []).concat(
              createHyphenCharVerifier(hyphenChar)
            ),
            minWordLength
          )
        ), resolveNewText = function() {
        };
        function nextTick3() {
          var loopStart = /* @__PURE__ */ new Date();
          while ((!isAsync || /* @__PURE__ */ new Date() - loopStart < 10) && (fragments = readText(text2))) {
            if (fragments[1]) {
              var cacheKey = fragments[1].length ? "~" + fragments[1] : "";
              if (cache2[cacheKey] === void 0) {
                cache2[cacheKey] = hyphenateWord(
                  fragments[1],
                  levelsTable,
                  patterns,
                  debug3,
                  hyphenChar
                );
              }
              fragments[1] = cache2[cacheKey];
            }
            newText += fragments[0] + fragments[1];
          }
          if (!fragments) {
            done3();
          } else {
            setTimeout(nextTick3);
          }
        }
        if (isAsync) {
          setTimeout(nextTick3);
          return new Promise(function(resolve3) {
            resolveNewText = resolve3;
          });
        } else {
          nextTick3();
          return newText;
        }
      }
      var SETTING_DEFAULT_ASYNC = false;
      var SETTING_DEFAULT_DEBUG = false;
      var SETTING_DEFAULT_EXCEPTIONS = [];
      var SETTING_DEFAULT_HTML = true;
      var SETTING_DEFAULT_HYPH_CHAR = "";
      var SETTING_DEFAULT_MIN_WORD_LENGTH = 5;
      var SETTING_NAME_ASYNC = "async";
      var SETTING_NAME_DEBUG = "debug";
      var SETTING_NAME_EXCEPTIONS = "exceptions";
      var SETTING_NAME_HTML = "html";
      var SETTING_NAME_HYPH_CHAR = "hyphenChar";
      var SETTING_NAME_MIN_WORD_LENGTH = "minWordLength";
      var _global = typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : false ? void 0 : {};
      function extend(target, source) {
        target = target || {};
        for (var key in source) {
          target[key] = source[key];
        }
        return target;
      }
      function validateArray(value2) {
        return value2 instanceof Array;
      }
      function keyOrDefault(object, key, defaultValue, test) {
        if (key in object && (test ? test(object[key]) : true)) {
          return object[key];
        }
        return defaultValue;
      }
      function exceptionsFromDefinition(excetionsList, hyphenChar) {
        return excetionsList.reduce(function(exceptions, exception) {
          exceptions["~" + exception.replace(/\-/g, "")] = exception.replace(
            /\-/g,
            hyphenChar
          );
          return exceptions;
        }, {});
      }
      function createHyphenator(patternsDefinition, options) {
        options = options || {};
        var asyncMode = keyOrDefault(
          options,
          SETTING_NAME_ASYNC,
          SETTING_DEFAULT_ASYNC
        ), caches = {}, debug3 = keyOrDefault(options, SETTING_NAME_DEBUG, SETTING_DEFAULT_DEBUG), exceptions = {}, hyphenChar = keyOrDefault(
          options,
          SETTING_NAME_HYPH_CHAR,
          SETTING_DEFAULT_HYPH_CHAR
        ), levelsTable = patternsDefinition[0].split(","), patterns = JSON.parse(patternsDefinition[1]), minWordLength = keyOrDefault(
          options,
          SETTING_NAME_MIN_WORD_LENGTH,
          SETTING_DEFAULT_MIN_WORD_LENGTH
        ) >> 0, skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML), userExceptions = keyOrDefault(
          options,
          SETTING_NAME_EXCEPTIONS,
          SETTING_DEFAULT_EXCEPTIONS,
          validateArray
        );
        var cacheKey = hyphenChar + minWordLength;
        exceptions[cacheKey] = {};
        if (patternsDefinition[2]) {
          exceptions[cacheKey] = exceptionsFromDefinition(
            patternsDefinition[2],
            hyphenChar
          );
        }
        if (userExceptions && userExceptions.length) {
          exceptions[cacheKey] = extend(
            exceptions[cacheKey],
            exceptionsFromDefinition(userExceptions, hyphenChar)
          );
        }
        caches[cacheKey] = extend({}, exceptions[cacheKey]);
        if (asyncMode && !("Promise" in _global)) {
          throw new Error(
            "Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode"
          );
        }
        return function(text2, options2) {
          options2 = options2 || {};
          var localDebug = keyOrDefault(options2, SETTING_NAME_DEBUG, debug3), localHyphenChar = keyOrDefault(
            options2,
            SETTING_NAME_HYPH_CHAR,
            hyphenChar
          ), localMinWordLength = keyOrDefault(options2, SETTING_NAME_MIN_WORD_LENGTH, minWordLength) >> 0, localUserExceptions = keyOrDefault(
            options2,
            SETTING_NAME_EXCEPTIONS,
            SETTING_DEFAULT_EXCEPTIONS,
            validateArray
          ), cacheKey2 = localHyphenChar + localMinWordLength;
          if (!exceptions[cacheKey2] && patternsDefinition[2]) {
            exceptions[cacheKey2] = exceptionsFromDefinition(
              patternsDefinition[2],
              localHyphenChar
            );
            caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);
          }
          if (localUserExceptions && localUserExceptions.length) {
            exceptions[cacheKey2] = extend(
              exceptions[cacheKey2],
              exceptionsFromDefinition(localUserExceptions, localHyphenChar)
            );
            caches[cacheKey2] = extend(caches[cacheKey2], exceptions[cacheKey2]);
          }
          return start3(
            text2,
            levelsTable,
            patterns,
            caches[cacheKey2],
            localDebug,
            localHyphenChar,
            skipHTML,
            localMinWordLength,
            asyncMode
          );
        };
      }
      return createHyphenator;
    });
  }
});

// ../../.yarn/cache/hyphen-npm-1.10.4-51dec4187e-4828159b40.zip/node_modules/hyphen/patterns/en-us.js
var require_en_us = __commonJS({
  "../../.yarn/cache/hyphen-npm-1.10.4-51dec4187e-4828159b40.zip/node_modules/hyphen/patterns/en-us.js"(exports2, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.hyphenationPatternsEnUs = factory();
      }
    })(exports2, function() {
      return [
        "0004,004,001,003,005,0005,00005,000005,0002,002,0000005,0003,00003,00505,00034,0001,00055,00004,4,05,0055,04,42,03,02,2,404,3,044,01,0505,55,5,045,041,0033,000004,22,00504,5504,0042,1,21,41,402,405,4004,43,23,000054,303,3005,022,5004,000003,252,45,25,2004,000505,054,403,401,3002,0025,144,432,00054,34,12,234,0022,014,0304,012,143,503,0403,101,052,414,212,011,043,00002,0041,0024,05005,03003,00102,0404,04303,01004,0034,025,0044,00404,00025,0103,042,0205,412,104,54,344,433,5005,253,055,0402,3004,0043,204,505,454,0000004,00303,04004,552,201,4005,0255,52,444,14,44,02004,033,05004,00045,00013,0021,0405,00044,0054,50055,000303,00001,304,0204,11,301,232,122,00305,504,000043,0104,00052,000045,50004,0023,00033,00032,00202,5003,202,0401,0000505,214,102,032,000161,004101,00501,00301,0036,0052,00023,006101,006,00401,000521,0014,0063,00012,000501,000006,000604,000601,005001,005005,0010305,00006,003012,003005,0003011,0061,013,000021,000022,000105,00211,00062,00051,000112,006013,000011,0200306,1021,0050001,003003,2102,305,000015,01030005,000035,001011,00021,16330001,0234,030006,5020001,000001,00016,0031,021,21431,002305,0350014,0000012,000063,00101,106,105,00435,00063,0300061,00041,100306,003602,023,0503,0010011,10003,1005,30011,00031,0001001,0000061,0030003,30305,001201,0301,5000101,500101,00015,000401,000065,000016,0000402,0500002,000205,030201,500301,00014,5001,000002,00030011,01034,0300006,030213,00400304,050001,05003,000311,0634,00061,0006,00000604,00050013,00213,0030001,100003,000033,30002,00003632,0003004,050003,0000021,006303,0000006,00005005,30451,03001,00231,00056,00011,6,001001,00500001,03005,503005,0000010001,1002,003001,001065,300001,32011,32,0000003,0213001,0500053,021005,10001,0000011,0001041,0020016,100032,50011,0606,5002,3001,03002,0015001,0102,00003001,000000033,0000001,300101,300015,0101003,00000101,0100501,0101,0010033,00000362,000014,0005001,031",
        '{".":[{"a":[{"c":[{"h":0}],"d":[{"d":[{"e":[{"r":1}]}]}],"f":[{"t":2}],"l":[{"t":3}],"m":[{"a":[{"t":4}]}],"n":[{"c":4,"g":0,"i":[{"m":5}],"t":[{"e":3,"i":[{"s":6}]},0]}],"r":[{"s":4,"t":[{"i":[{"e":1}],"y":1}]}],"s":[{"c":3,"p":2,"s":2,"t":[{"e":[{"r":7}]}]}],"t":[{"o":[{"m":6}]}],"u":[{"d":2}],"v":[{"i":1}],"w":[{"n":0}]}],"b":[{"a":[{"g":1,"n":[{"a":4}],"s":[{"e":0}]}],"e":[{"r":[{"a":4},0],"s":[{"m":3,"t":[{"o":4}]}]}],"r":[{"i":8}],"u":[{"t":[{"t":[{"i":0}]}]}]}],"c":[{"a":[{"m":[{"p":[{"e":0}]}],"n":[{"c":5}],"p":[{"a":[{"b":6}]}],"r":[{"o":[{"l":5}]}],"t":1}],"e":[{"l":[{"a":1}]}],"h":[{"i":[{"l":[{"l":[{"i":7}]}]}]},1],"i":[{"t":[{"r":5}]},9],"o":[{"e":3,"r":[{"n":[{"e":[{"r":5}]}]},1],"n":[{"g":[{"r":5}]}]}]}],"d":[{"e":[{"m":[{"o":[{"i":1}]}],"o":3,"r":[{"a":3,"i":[{"v":[{"a":4}]},3]}],"s":[{"c":0}]}],"i":[{"c":[{"t":[{"i":[{"o":10}]}]}]}],"o":[{"t":1}],"u":[{"c":1,"m":[{"b":6}]}],"r":[{"i":[{"v":67}]}]}],"e":[{"a":[{"r":[{"t":[{"h":7}]}],"s":[{"i":11}]}],"b":1,"e":[{"r":0}],"g":9,"l":[{"d":4,"e":[{"m":3}]}],"n":[{"a":[{"m":12}],"g":3,"s":3}],"q":[{"u":[{"i":[{"t":13}]}]}],"r":[{"r":[{"i":1}]}],"s":3,"u":[{"l":[{"e":[{"r":1}]}]},3],"y":[{"e":5}],"t":[{"h":[{"y":[{"l":162}]}]}],"v":[{"e":[{"r":[{"s":[{"i":[{"b":158}]}]}]}]},9]}],"f":[{"e":[{"s":11}],"o":[{"r":[{"m":[{"e":[{"r":5}]}]}]}]}],"g":[{"a":[{"s":[{"o":[{"m":163}]}]},9],"e":[{"n":[{"t":14}],"o":[{"g":4,"m":[{"e":1}],"t":164}]},9],"i":[{"a":4,"b":1}],"o":[{"r":1}]}],"h":[{"a":[{"n":[{"d":[{"i":6}],"k":5}]}],"e":[{"r":[{"o":[{"i":6,"e":3}]}],"s":11,"t":11,"m":[{"o":165}],"p":[{"a":166}]},9],"i":[{"b":3,"e":[{"r":3}]}],"o":[{"n":[{"e":[{"y":5}],"o":11}],"v":5}]}],"i":[{"d":[{"l":1,"o":[{"l":12}]}],"m":[{"m":3,"p":[{"i":[{"n":4}]}]}],"n":[{"c":[{"i":3}],"e":8,"k":9,"s":3,"u":[{"t":167}]},2],"r":[{"r":4}],"s":[{"i":1}]}],"j":[{"u":[{"r":3}]}],"l":[{"a":[{"c":[{"y":1}],"m":1,"t":[{"e":[{"r":5}],"h":6}]}],"e":[{"g":[{"e":5}],"n":0,"p":5,"v":15,"i":[{"c":[{"e":[{"s":170}]}]}]},9],"i":[{"g":[{"a":5},1],"n":9,"o":3,"t":1}]}],"m":[{"a":[{"g":[{"a":16}],"l":[{"o":5}],"n":[{"a":5}],"r":[{"t":[{"i":5}]}]}],"e":[{"r":[{"c":11}],"t":[{"e":[{"r":4}],"a":[{"l":[{"a":0}]}]}],"g":[{"a":[{"l":171}]}]},9],"i":[{"s":[{"t":[{"i":6}],"e":[{"r":[{"s":173}]}]},15],"m":[{"i":[{"c":172}]}]}],"o":[{"n":[{"e":11}],"r":[{"o":3}]}],"u":[{"t":[{"a":[{"b":6},4]}]}]}],"n":[{"i":[{"c":1}],"e":[{"o":[{"f":174}]}],"o":[{"e":[{"t":[{"h":15}]}],"n":[{"e":[{"m":175}]}]}]}],"o":[{"d":[{"d":5},9],"f":[{"t":[{"e":4}]}],"r":[{"a":[{"t":[{"o":4}]}],"c":3,"d":2,"t":3}],"s":[{"t":[{"l":1}]},3],"t":[{"h":11}],"u":[{"t":11}]}],"p":[{"e":[{"d":[{"a":[{"l":5}]}],"t":[{"e":4,"i":[{"t":4}]}]}],"i":[{"e":1,"o":[{"n":5}],"t":9}],"r":[{"e":[{"m":11,"a":[{"m":15}]}]}],"o":[{"l":[{"y":[{"s":137}]}],"s":[{"t":[{"a":[{"m":137}]}]}]}]}],"r":[{"a":[{"c":1,"n":[{"t":0}],"t":[{"i":[{"o":[{"n":[{"a":7}]}]}]}],"v":[{"e":[{"n":[{"o":176}]}]}]}],"e":[{"e":[{"c":173},8],"m":[{"i":[{"t":4}]}],"s":[{"t":[{"a":[{"t":4}]}]},8]}],"i":[{"g":1,"t":[{"u":5}]}],"o":[{"q":1,"s":[{"t":5}],"w":[{"d":5}]}],"u":[{"d":1}]}],"s":[{"c":[{"i":[{"e":11}]}],"e":[{"l":[{"f":6,"l":6}],"n":9,"r":[{"i":[{"e":4}]}],"m":[{"i":[{"c":0,"d":177,"p":36,"r":36,"s":178,"v":36},6]}]}],"h":9,"i":[{"n":[{"g":17}]},9],"t":[{"a":[{"b":[{"l":5}]}]},1],"y":9,"p":[{"h":[{"i":[{"n":179}]}],"i":[{"n":[{"o":137}]}]}]}],"t":[{"a":[{"p":[{"e":[{"s":[{"t":[{"r":180}]}]}]}]},1],"e":[{"n":[{"a":[{"n":5}]}],"l":[{"e":[{"g":[{"r":3}]}]}]},1],"h":9,"i":[{"l":0,"m":[{"o":16}],"n":[{"g":17,"k":5}]},9],"o":[{"n":[{"a":0}],"p":[{"i":5,"o":[{"g":170}]},1],"u":[{"s":5}],"q":9}],"r":[{"i":[{"b":[{"u":[{"t":6}]}]}]}]}],"u":[{"n":[{"a":[{"t":[{"t":144}]},2],"c":[{"e":3}],"d":[{"e":[{"r":7}]}],"e":[{"r":[{"r":181}]},2],"k":4,"o":4,"u":3}],"p":3,"r":[{"e":11}],"s":[{"a":4}]}],"v":[{"e":[{"n":[{"d":[{"e":0}]}],"r":[{"a":4}]}],"i":[{"c":[{"a":[{"r":151}]}]}]}],"w":[{"i":[{"l":[{"i":5}]}],"e":[{"b":[{"l":131}]}]}],"y":[{"e":1}],"k":[{"i":[{"l":[{"n":[{"i":168}]}]}],"o":[{"r":[{"t":[{"e":169}]}]}]}]}],"a":[{"b":[{".":18,"a":[{"l":19,"n":19}],"e":[{"r":[{"d":4}]},8],"i":[{"a":5,"t":[{"a":[{"b":13}]}]}],"l":[{"a":[{"t":4}]}],"o":[{"l":[{"i":[{"z":20,"c":19}]}]}],"r":[{"o":[{"g":4}]},18],"u":[{"l":3}]}],"c":[{"a":[{"r":[{"d":4,"o":4},21],"b":[{"l":24}]}],"e":[{"o":[{"u":19}],"r":2}],"h":[{"e":[{"t":19}]}],"i":[{"e":23,"n":2,"o":23},22],"r":[{"o":[{"b":4}]}],"t":[{"i":[{"f":5}]}],"u":[{"l":3,"m":1}]}],"d":[{"d":[{"i":[{"n":1}]}],"e":[{"r":[{".":4}]}],"i":[{"a":23,"c":[{"a":3}],"e":[{"r":0}],"o":23,"t":23,"u":19},25],"l":[{"e":1}],"o":[{"w":3}],"r":[{"a":[{"n":4}]}],"s":[{"u":1}],"u":[{"c":23,"m":4},18]},24],"e":[{"r":[{"i":[{"e":17}]},1]}],"f":[{"f":[{"i":[{"s":[{"h":170}]}]},0]},24],"g":[{"a":[{"b":21,"n":0}],"e":[{"l":[{"l":4}],"o":0,"u":18}],"i":2,"l":26,"n":2,"o":[{"g":27,"n":[{"i":3}]},24],"u":[{"e":[{"r":19}],"l":4}],"y":21}],"h":[{"a":23,"e":23,"l":1,"o":23}],"i":[{"a":19,"c":[{".":23}],"l":[{"y":4}],"n":[{"i":[{"n":5}],"o":5},28],"t":[{"e":[{"n":5}]}]},9],"j":29,"k":[{"e":[{"n":2}]}],"l":[{"a":[{"b":4,"d":3,"r":21}],"d":[{"i":18}],"e":[{"n":[{"d":3,"t":[{"i":21}]}],"o":30},25],"i":[{"a":[{".":1}],"e":0},2],"l":[{"e":[{"v":4}],"i":[{"c":18}]}],"m":18,"o":[{"g":[{".":19}]}],"y":[{".":21,"s":[{"t":31},18],"t":32,"z":27}]}],"m":[{"a":[{"b":4,"g":3,"r":[{"a":5}],"s":[{"c":4}],"t":[{"i":[{"s":21}],"o":33}]},18],"e":[{"r":[{"a":4}],"n":[{"t":[{"a":[{"b":182}]}]}]}],"i":[{"c":3,"f":4,"l":[{"y":4}],"n":[{"o":0},2]}],"o":[{"n":19,"r":[{"i":6}]},24],"p":[{"e":[{"n":5}]}]}],"n":[{"a":[{"g":[{"e":3}],"l":[{"y":[{"s":183},27]}],"r":[{"c":3,"i":17},23],"t":[{"i":23}]}],"d":[{"e":[{"s":17}],"i":[{"s":3}],"l":2,"o":[{"w":1}]},18],"e":[{"e":19,"n":23,"s":[{"t":[{".":4}]}],"u":23}],"g":[{"i":[{"e":5}],"l":2},25],"i":[{"c":34,"e":[{"s":23}],"f":35,"m":[{"e":1,"i":19}],"n":[{"e":19}],"o":3,"p":23,"s":[{"h":3}],"t":3,"u":23}],"k":[{"l":[{"i":1}]}],"n":[{"i":[{"z":32}]}],"o":[{"t":[{"h":7},4],"a":[{"c":148}]},0],"s":[{"a":9,"c":[{"o":1}],"n":1,"p":[{"o":11},9],"t":1,"u":[{"r":1}],"g":[{"r":5}],"v":11}],"t":[{"a":[{"l":36}],"i":[{"e":1,"d":137,"n":184,"r":[{"e":137}]}],"o":18,"r":9,"w":1}],"u":[{"a":3,"l":3,"r":19}]},24],"o":18,"p":[{"a":[{"r":17,"t":4}],"e":[{"r":[{"o":4}],"a":[{"b":[{"l":[{"e":132}]}]}]}],"h":[{"e":[{"r":23}],"i":18}],"i":[{"l":[{"l":[{"a":[{"r":4},21]}]}],"n":3,"t":[{"a":3,"u":23}]}],"l":24,"o":[{"c":6,"l":[{"a":4}],"r":[{"i":6}],"s":[{"t":12}]}],"s":[{"e":[{"s":5}]}],"u":23}],"q":[{"u":[{"e":6}]}],"r":[{"a":[{"c":[{"t":3}],"d":[{"e":19,"i":[{"s":4}]}],"l":3,"m":[{"e":[{"t":[{"e":19}]}]}],"n":[{"g":17}],"p":11,"t":[{"i":[{"o":19,"v":4}]},1],"u":19,"v":38,"w":17}],"b":[{"a":[{"l":36}]}],"c":[{"h":[{"a":[{"n":1}],"e":[{"t":185}]}]}],"d":[{"i":[{"n":[{"e":4}]}],"r":1}],"e":[{"a":[{"s":4}],"e":23,"n":[{"t":3}],"s":[{"s":19}]}],"f":[{"i":1,"l":1}],"i":[{"a":[{"l":4,"n":3}],"e":[{"t":23}],"m":1,"n":[{"a":[{"t":4}]}],"o":3,"z":9},2],"m":[{"i":9}],"o":[{"d":20,"n":[{"i":19}],"o":23}],"p":9,"q":3,"r":[{"e":17,"a":[{"n":[{"g":[{"e":9}]}]}]}],"s":[{"a":1,"h":9}]},37],"s":[{".":18,"a":[{"b":1,"n":[{"t":3}]}],"h":[{"i":17}],"i":[{"a":[{".":19}],"b":23,"c":23,"t":39}],"k":[{"i":11}],"l":1,"o":[{"c":21}],"p":[{"h":4}],"s":[{"h":1}],"t":[{"e":[{"n":3}],"r":2}],"u":[{"r":[{"a":6}]}],"y":[{"m":[{"p":[{"t":[{"o":[{"t":4}]}]}]}]}]}],"t":[{"a":[{"b":[{"l":3}],"c":4,"l":[{"o":3}],"p":4},24],"e":[{"c":[{"h":4},5],"g":[{"o":3}],"n":[{".":3}],"r":[{"a":3,"n":[{"a":19},6]}],"s":[{"t":3}],"v":4}],"h":[{"e":[{"m":5,"n":19,"r":[{"o":[{"s":186}]}]}],"o":[{"m":5},1]},18],"i":[{".":18,"a":19,"b":20,"c":2,"f":3,"o":[{"n":[{"a":[{"r":7}]}]}],"t":[{"u":3}]}],"o":[{"g":21,"m":[{"i":[{"z":4}]},24],"p":21,"s":21}],"r":[{"o":[{"p":4}]},29],"s":[{"k":1}],"t":[{"a":[{"g":1}],"e":[{"s":[{".":170}]},4],"h":1}],"u":[{"a":4,"e":4,"l":3,"r":[{"a":3}]},24],"y":24}],"u":[{"b":1,"g":[{"h":[{"t":[{"l":17}]},12],"u":3}],"l":[{"i":[{"f":13}]},40],"n":[{"d":5}],"r":3,"s":[{"i":[{"b":4}]}],"t":[{"e":[{"n":5}],"h":2}]}],"v":[{"a":[{"g":3,"n":19},24],"e":[{"n":[{"o":0}],"r":[{"a":3,"n":4,"y":4}]}],"i":[{"e":[{"r":0}],"g":3,"o":[{"u":3}]},2],"o":[{"c":4,"r":29}]}],"w":[{"a":[{"y":27}],"i":3,"l":[{"y":1}],"s":0}],"x":[{"i":[{"c":1,"d":1}]}],"y":[{"a":[{"l":4}],"e":0,"s":0}],"z":[{"i":[{"e":[{"r":0}]}],"z":[{"i":5}]}]}],"b":[{"a":[{".":32,"d":[{"g":[{"e":[{"r":5}]}]}],"g":[{"e":1}],"l":[{"a":15}],"n":[{"d":[{"a":[{"g":5}]}],"e":0,"i":11}],"r":[{"b":[{"i":7}],"i":[{"a":17}],"o":[{"n":[{"i":[{"e":187}]}]}]}],"s":[{"s":[{"i":0}]}],"t":[{"h":[{"y":2}]},41],"z":1,"c":[{"k":[{"e":[{"r":[{".":84}]}]}]}]}],"b":[{"e":[{"r":23},24],"i":[{"n":[{"a":0}],"t":0}]},42],"d":43,"e":[{".":18,"a":[{"k":17,"t":12}],"d":[{"a":3,"e":3,"i":3},44],"g":[{"i":3,"u":4}],"l":[{"i":2,"o":3},41],"m":45,"n":[{"i":[{"g":4}],"u":4}],"s":[{"p":3,"t":[{"r":4}]},46],"t":[{"i":[{"z":5}],"r":4,"w":3},27],"w":3,"y":[{"o":4}],"v":[{"i":[{"e":9}]}]}],"f":25,"h":47,"i":[{"b":9,"d":[{"i":[{"f":167}]},1],"e":[{"n":4,"r":1},27],"f":48,"l":[{"i":[{"z":3}],"l":[{"a":[{"b":8}]}]},41],"n":[{"a":[{"r":49}],"d":0,"e":[{"t":4}]}],"o":[{"g":[{"r":3}],"u":4,"m":5,"r":[{"b":2,"h":15}]}],"t":[{"i":[{"o":50,"v":[{"e":188}]}],"r":3,"u":[{"a":51}],"z":19},9]}],"j":29,"k":1,"l":[{"a":[{"t":[{"h":7}],"n":[{"d":189}]}],"e":[{".":21,"n":17,"s":[{"p":32}]}],"i":[{"s":23,"n":[{"d":189}]}],"o":[{"n":[{"d":190}]},21],"u":[{"n":[{"t":17}]}]},52],"m":43,"n":[{"e":[{"g":5}]},47],"o":[{"d":[{"i":11},27],"e":1,"l":[{"i":[{"c":11}]}],"m":[{"b":[{"i":0}]}],"n":[{"a":[{"t":5},0]}],"o":27,"r":[{".":32,"a":43,"d":5,"e":32,"i":32,"n":[{"o":191}]}],"s":53,"t":[{"a":19,"h":6,"o":1,"u":[{"l":192}]}],"u":[{"n":[{"d":54}]}]}],"p":18,"r":[{"i":[{"t":18}],"o":[{"t":[{"h":54}]}],"u":[{"s":[{"q":17}]}]}],"s":[{"o":[{"r":17}]},55],"t":[{"l":1,"o":21,"r":23},25],"u":[{"f":[{"f":[{"e":[{"r":0}]}]}],"g":[{"a":1}],"l":[{"i":3}],"m":[{"i":17}],"n":[{"t":[{"i":17}]},1],"r":[{"e":3}],"s":[{"i":[{"e":[{"r":193,"s":193},5]}],"s":[{"e":17,"i":[{"n":[{"g":17}]}]}],"t":32}],"t":[{"a":18,"i":[{"o":27}],"o":19,"e":[{"d":[{".":8}]}],"t":[{"e":[{"d":0}]}]}]}],"v":29,"w":56,"y":[{".":32,"s":0}]}],"c":[{"a":[{"b":[{"i":[{"n":11}],"l":2}],"c":[{"h":17}],"d":[{"e":[{"n":4,"m":194}]}],"g":46,"h":57,"l":[{"a":[{"t":3}],"l":[{"a":0,"i":[{"n":6}]}],"o":18}],"n":[{"d":5,"e":0,"i":[{"c":0,"s":5,"z":11}],"t":[{"y":0}],"y":17}],"p":[{"e":[{"r":4}]}],"r":[{"o":[{"m":5}]}],"s":[{"t":[{"e":[{"r":6}],"i":[{"g":5}]}],"y":18}],"t":[{"h":1,"i":[{"v":18}],"a":[{"s":195}]}],"v":[{"a":[{"l":5}]}]},41],"c":[{"h":[{"a":6}],"i":[{"a":0}],"o":[{"m":[{"p":[{"a":10}]}],"n":17,"u":[{"t":12}]}]},23],"e":[{".":25,"d":[{".":18,"e":[{"n":18}]}],"i":27,"l":[{".":32,"l":27}],"n":[{"c":27,"e":58,"i":18,"t":27},41],"p":27,"r":[{"a":[{"m":4}]}],"s":[{"a":18,"s":[{"i":[{"b":59},27]}],"t":5}],"t":[{"a":60},0],"w":0}],"h":[{".":18,"a":[{"b":61,"n":[{"i":[{"c":32,"s":20}]}]}],"e":[{"a":[{"p":54}],"d":18,"l":[{"o":5}],"m":[{"i":27}],"n":[{"e":4}],"r":[{".":3,"s":3}]},8],"i":[{"n":[{"e":[{".":32,"s":[{"s":4}]}],"i":32},62],"o":32,"t":27,"z":8,"e":[{"v":[{"o":6}]}]}],"o":63,"t":[{"i":1}],"s":[{".":18,"h":[{"u":11}]}]},25],"i":[{"a":[{"b":64,"r":5},27],"c":4,"e":[{"r":18}],"f":[{"i":[{"c":[{".":32}]}]}],"i":18,"l":[{"a":1,"i":27}],"m":25,"n":[{"a":[{"t":27},21],"e":[{"m":11}],"g":[{".":19},29],"o":32,"q":8},25],"o":[{"n":17}],"p":[{"e":18,"h":3,"i":[{"c":18}]}],"s":[{"t":[{"a":18,"i":18}]}],"t":[{"i":[{"z":11}]},42],"z":32,"g":[{"a":[{"r":152}]}]},41],"k":[{"i":3},2],"l":[{"a":[{"r":[{"a":[{"t":[{"i":[{"o":19}]}]}],"e":32},18]}],"e":[{"m":0,"a":[{"r":0}]}],"i":[{"c":18,"m":17}],"y":0},65],"n":19,"o":[{"a":[{"g":4}],"e":8,"g":[{"r":1},25],"i":[{"n":[{"c":3}]},0],"l":[{"i":5,"o":[{"r":11},32]}],"m":[{"e":[{"r":5}]}],"n":[{"a":0,"e":21,"g":11,"t":5}],"p":[{"a":3,"i":[{"c":11}],"l":1,"h":[{"o":[{"n":196}]}]}],"r":[{"b":18,"o":[{"n":12}]}],"s":[{"e":0}],"v":[{"e":17},15],"w":[{"a":5}],"z":[{"e":5,"i":4}],"u":[{"s":[{"t":[{"i":84}]}]}]},41],"q":29,"r":[{"a":[{"s":[{"t":6}],"t":[{".":32,"i":[{"c":32}]}]}],"e":[{"a":[{"t":11}],"d":32,"t":[{"a":47}],"v":0}],"i":[{"f":5,"n":21,"s":17,"t":[{"i":[{"e":11},32]}]},8],"o":[{"p":[{"l":0,"o":6}],"s":[{"e":17}],"c":[{"o":[{"d":197}]}],"e":[{"c":[{"o":148}]}]}],"u":[{"d":0}]}],"s":66,"t":[{"a":[{"b":0,"n":[{"g":4,"t":19}]}],"e":[{"r":23},24],"i":[{"c":[{"u":21}],"m":[{"i":12}]}],"u":[{"r":0}],"w":21,"r":[{"o":[{"m":[{"e":[{"c":198}]}]}]}]},42],"u":[{"d":5,"f":21,"i":[{"t":[{"y":4}]},21],"l":[{"i":32,"t":[{"i":[{"s":0}],"u":27}]}],"m":[{"a":9,"e":23,"i":1}],"n":27,"p":[{"i":3,"y":4}],"r":[{"a":[{"b":67,"n":[{"c":[{"e":199}]}]}],"i":[{"a":4}]}],"s":[{"s":[{"i":17}]},41],"t":[{"i":[{"e":1,"v":56}],"r":18},68]}],"y":41,"z":[{"e":0}]}],"d":[{"a":[{".":32,"b":70,"c":[{"h":17}],"f":18,"g":25,"m":71,"n":[{"g":11}],"r":[{"d":6,"k":6,"y":18}],"t":[{"i":[{"v":18}],"o":18,"a":[{"b":137}]},27],"v":[{"e":5},53],"y":32,"l":[{"o":[{"n":[{"e":48}]}]}]},69],"b":29,"c":19,"d":[{"a":[{"b":20}],"i":[{"b":94}]},72],"e":[{".":25,"a":[{"f":6,"l":[{"s":[{".":1}]}]}],"b":[{"i":[{"t":5}],"o":[{"n":1}]}],"c":[{"a":[{"n":36}],"i":[{"l":1}],"o":[{"m":4}],"l":[{"a":[{"r":200}],"i":[{"n":[{"a":64}]}]}]}],"d":42,"e":[{".":18}],"i":[{"f":4}],"l":[{"i":[{"e":17,"q":16}],"o":4}],"m":[{".":32,"i":[{"c":[{".":5},27],"l":4}],"o":[{"n":[{"s":1}],"r":7,"s":9}]},21],"n":[{"a":[{"r":1}],"o":3,"t":[{"i":[{"f":7}]}],"u":3},41],"p":[{"a":3,"i":17,"u":9},2],"q":23,"r":[{"h":21,"m":32,"n":[{"i":[{"z":6}]}],"s":5}],"s":[{".":24,"c":2,"o":64,"t":[{"i":11,"r":3}],"u":1,"i":[{"c":11}]},8],"t":[{"o":9,"i":[{"c":9}]},2],"v":[{"i":[{"l":11}]},2],"y":18,"f":[{"i":[{"n":[{"i":[{"t":[{"i":201}]}]}]}]}]}],"f":43,"g":[{"a":21,"e":[{"t":73}],"i":2,"y":24}],"h":74,"i":[{".":32,"a":[{"b":5},75],"c":[{"a":[{"m":1,"i":[{"d":15}]}],"e":21,"t":27}],"d":27,"e":[{"n":76}],"f":[{"f":[{"r":[{"a":5}]}]},29],"g":[{"e":3}],"l":[{"a":[{"t":[{"o":1}]}]}],"n":[{"a":41,"e":[{".":27}],"i":[{"z":4},32]},29],"o":[{"g":5},41],"p":[{"l":1}],"r":[{"e":[{"n":9,"r":9},2],"t":[{"i":6}]},8],"s":[{"i":32,"t":77},15],"t":[{"i":24}],"v":78,"m":[{"e":[{"t":[{"h":[{"y":141}]}]}]}]}],"j":29,"k":79,"l":[{"a":56,"e":[{".":27,"d":27,"s":[{".":27,"s":18}],"a":[{"d":42}]}],"o":48,"u":56,"y":25,"i":[{"e":202}]}],"m":29,"n":80,"o":[{".":27,"d":[{"e":4}],"e":32,"f":57,"g":21,"l":[{"a":1,"i":17,"o":[{"r":4}]}],"m":[{"i":[{"z":5}]}],"n":[{"a":[{"t":3}],"i":17}],"o":[{"d":11}],"p":[{"p":0}],"r":21,"s":27,"u":[{"t":56}],"v":1,"x":27,"w":[{"o":[{"r":[{"d":203}]}]}]},41],"p":29,"r":[{"a":[{"g":[{"o":[{"n":6}]}],"i":18}],"e":[{"a":[{"r":6}],"n":[{"a":[{"l":204}]},32]},0],"i":[{"b":0,"l":17,"f":[{"t":[{"a":189}]}],"p":[{"l":[{"e":[{"g":205}]}]}]}],"o":[{"p":0,"w":18,"m":[{"e":[{"d":206}]}]}],"u":[{"p":[{"l":[{"i":32}]}]}],"y":18},41],"s":[{"p":1,"w":21,"y":21},81],"t":[{"h":24,"a":[{"b":23}]}],"u":[{"a":[{"l":[{".":9}]},82],"c":[{"a":29,"e":[{"r":5}],"t":[{".":18,"s":18}]},9],"e":[{"l":4}],"g":1,"l":[{"e":23}],"m":[{"b":[{"e":0}]}],"n":1,"p":[{"e":1},18],"o":[{"p":[{"o":[{"l":207}]}]}]},41],"v":29,"w":29,"y":[{"n":32,"s":[{"e":1,"p":5}]},24]}],"e":[{"a":[{"b":72,"c":[{"t":23}],"d":[{"i":[{"e":5}]},15],"g":[{"e":[{"r":4},1]}],"l":[{"e":[{"r":5}],"o":[{"u":11}]},1],"m":[{"e":[{"r":11}]}],"n":[{"d":19,"i":[{"e":[{"s":111}]}]}],"r":[{"a":11,"c":0,"e":[{"s":5}],"i":[{"c":0,"l":0}],"k":5,"t":[{"e":12},8]}],"s":[{"p":4,"s":23,"t":12}],"t":[{"e":[{"n":5}],"h":[{"i":12}],"i":[{"f":19}],"u":83},9],"v":[{"e":[{"n":11}],"i":5,"o":5},9]}],"b":[{"e":[{"l":[{".":21,"s":21}],"n":21}],"i":[{"t":21}],"r":23},42],"c":[{"a":[{"d":21,"n":[{"c":6}]}],"c":[{"a":6}],"e":[{"s":[{"s":[{"a":4}]}]},29],"i":[{"b":21,"f":[{"i":[{"c":[{"a":[{"t":4}]}],"e":4}],"y":4}],"m":3,"t":[{"e":19},0]},9],"l":[{"a":[{"m":21}],"u":[{"s":21}]}],"o":[{"l":24,"m":[{"m":21,"p":[{"e":21}]}],"n":[{"c":21}],"r":[{"a":3,"o":5},24]}],"r":[{"e":[{"m":21}]},29],"t":[{"a":[{"n":1}],"e":1}],"u":[{"l":[{"a":3},21]},29],"h":[{"a":[{"s":23}]}]}],"d":[{"a":37,"d":61,"e":[{"r":34,"s":0}],"i":[{"a":23,"b":3,"c":[{"a":3}],"m":3,"t":2,"z":5},18],"o":[{"l":21,"n":84},18],"r":[{"i":21}],"u":[{"l":[{"o":4,"i":[{"n":[{"g":2}]}]},21]}],"g":[{"l":15}]}],"e":[{"c":9,"d":[{"i":11}],"f":9,"l":[{"i":11,"y":1}],"m":9,"n":[{"a":1}],"p":85,"s":[{"t":17},86],"t":[{"y":1}],"x":19}],"f":[{"e":[{"r":[{"e":83}]}],"f":41,"i":[{"c":[{"i":32},21],"l":17,"n":[{"e":23,"i":[{"t":[{"e":20}]}]}],"t":27}],"o":[{"r":[{"e":[{"s":6}]}]}],"u":[{"s":[{"e":[{".":21}]}]}]},29],"g":[{"a":[{"l":18}],"e":[{"r":17}],"i":[{"b":4,"c":1,"n":[{"g":4}],"t":87}],"n":4,"o":[{".":21,"s":21}],"u":[{"l":2,"r":19}],"y":32}],"h":[{"e":[{"r":17}]},72],"i":[{"c":19,"d":4,"g":[{"l":4},8],"m":[{"b":23}],"n":[{"f":23,"g":29,"s":[{"t":19}]}],"r":[{"d":0}],"t":[{"e":11,"h":3,"y":19}]},9],"j":[{"u":[{"d":[{"i":4},21]}]},29],"k":[{"i":[{"n":0}],"l":[{"a":1}]}],"l":[{"a":[{".":21,"c":21,"n":[{"d":17}],"t":[{"i":[{"v":4}]}],"w":21,"x":[{"a":36}]},29],"e":[{"a":23,"b":[{"r":[{"a":4}]}],"c":32,"d":21,"g":[{"a":3}],"n":19,"r":34,"s":29}],"f":9,"i":[{"b":[{"e":23}],"c":[{".":33,"a":3}],"e":[{"r":23}],"g":[{"i":[{"b":4}]}],"m":19,"n":[{"g":83}],"o":23,"s":[{"h":4},24],"v":88,"t":[{"i":[{"s":208}]}]},9],"l":[{"a":[{"b":1},18],"o":17}],"o":[{"c":19,"g":4,"p":[{".":3}],"a":29}],"s":[{"h":9}],"t":[{"a":1}],"u":[{"d":19,"g":4}]}],"m":[{"a":[{"c":21,"g":21,"n":[{"a":4},19]}],"b":4,"e":[{"l":24,"t":21},29],"i":[{"c":[{"a":3}],"e":0,"g":[{"r":[{"a":4}]}],"n":[{"e":4,"i":35},89],"s":[{"h":4,"s":19},21],"z":3}],"n":[{"i":[{"z":32}]}],"o":[{"g":0,"n":[{"i":[{"o":7}]}]}],"p":[{"i":3}],"u":[{"l":[{"a":4},21],"n":11}],"y":23}],"n":[{"a":[{"m":[{"o":4}],"n":[{"t":21}]}],"c":[{"h":[{"e":[{"r":17}]}]}],"d":[{"i":[{"c":3,"x":2}]}],"e":[{"a":19,"e":19,"m":3,"r":[{"o":4}],"s":[{"i":4,"t":4}],"t":[{"r":3}],"w":23}],"i":[{"c":[{"s":4}],"e":19,"l":19,"o":23,"s":[{"h":3}],"t":3,"u":19,"z":32}],"n":18,"o":[{"g":0,"s":21,"v":3},18],"s":[{"w":1}],"t":[{"a":[{"g":[{"e":5}]}],"h":[{"e":[{"s":18}]}]}],"u":[{"a":3,"f":4}],"y":[{".":23}],"z":61}],"o":[{"f":19,"g":[{"r":[{"a":[{"p":3}]}]},9],"i":90,"l":23,"p":[{"a":[{"r":11}]}],"r":[{"e":3,"o":[{"l":4}]},29],"s":0,"t":[{"o":1},21],"u":[{"t":19}],"w":19}],"p":[{"a":[{"i":23,"n":[{"c":4}]},24],"e":[{"l":19,"n":[{"t":23}],"t":[{"i":[{"t":[{"i":[{"o":4}]}]}]}]}],"h":[{"e":17}],"l":[{"i":21}],"o":29,"r":[{"e":[{"c":[{"a":4},21],"d":21,"h":3}],"o":[{"b":21},23]}],"s":[{"h":1}],"t":[{"i":[{"b":13}]}],"u":[{"t":[{"a":4},21]}],"i":[{"n":[{"e":[{"p":[{"h":209}]}]}]}]}],"q":[{"u":[{"i":[{"l":12,"s":91}]}]},29],"r":[{"a":[{"b":0,"n":[{"d":18}],"r":3,"t":[{"i":[{".":18}]}]},2],"b":[{"l":1},25],"c":[{"h":[{"e":1},3]}],"e":[{".":25,"a":[{"l":23}],"c":[{"o":5}],"i":[{"n":11}],"l":[{".":4}],"m":[{"o":3}],"n":[{"a":4,"c":[{"e":4}],"e":18,"t":3}],"q":0,"s":[{"s":4,"t":3}],"t":17}],"h":2,"i":[{"a":[{"n":[{".":210}]},92],"c":[{"k":32}],"e":[{"n":23,"r":0}],"n":[{"e":3}],"o":29,"t":18,"u":1,"v":[{"a":21},0]},2],"m":93,"n":[{"i":[{"s":1,"t":18,"z":32}],"o":3}],"o":[{"b":4,"c":19,"r":0,"u":2},25],"s":[{"e":[{"t":3}]},2],"t":[{"e":[{"r":11}],"l":18,"w":3}],"u":[{"t":0},18],"w":[{"a":[{"u":32}]}]}],"s":[{"a":[{"g":[{"e":[{".":21,"s":21}]}]},72],"c":[{"a":[{"n":4},24],"r":23,"u":4},9],"e":[{"c":[{"r":4},24],"n":[{"c":4}],"r":[{"t":[{".":21,"s":21}],"v":[{"a":21}]}]},74],"h":[{"a":23,"e":[{"n":5}]},18],"i":[{"c":24,"d":[{"e":[{"n":4}]},24],"g":[{"n":[{"a":4}]}],"m":94,"n":95,"s":[{"t":[{"e":17}]}],"u":0},29],"k":[{"i":[{"n":19}]}],"m":[{"i":1}],"o":[{"l":[{"u":3},24],"n":[{"a":4},24]}],"p":[{"e":[{"r":3}],"i":[{"r":[{"a":4}]}],"r":[{"e":1}],"a":[{"c":[{"i":211}]}]},29],"s":[{"i":[{"b":96}]},25],"t":[{"a":[{"n":36}],"i":[{"g":3,"m":4}],"o":[{"n":23},44],"r":[{"o":19,"u":[{"c":10}]},25]}],"u":[{"r":[{"r":4},24]}],"w":1}],"t":[{"a":[{"b":0}],"e":[{"n":[{"d":17}],"o":23}],"h":[{"o":[{"d":54}],"y":[{"l":[{"e":[{"n":[{"e":162}]}]}]}]}],"i":[{"c":2,"d":[{"e":19}],"n":[{"o":0},17],"r":19,"t":[{"i":[{"o":19,"v":4}]}]}],"n":18,"o":[{"n":[{"a":4}]}],"r":[{"a":23,"e":23,"i":[{"c":3,"f":4}],"o":[{"g":3,"s":4}]}],"u":[{"a":3}],"y":[{"m":4}],"z":4}],"u":[{"n":19,"p":23,"r":[{"o":3}],"s":0,"t":[{"e":17,"i":[{"l":6}],"r":4}],"c":[{"l":[{"i":[{"d":212}]}]}]},18],"v":[{"a":[{"p":97,"s":[{"t":4},24]}],"e":[{"a":19,"l":[{"l":3,"o":12}],"n":[{"g":19,"i":17}],"r":[{"b":19},2]}],"i":[{"d":3,"l":0,"n":21,"v":0},29],"o":[{"c":19}],"u":19}],"w":[{"a":[{"g":21},29],"e":[{"e":19}],"h":23,"i":[{"l":6,"n":[{"g":3}],"t":23}]}],"x":[{"p":41}],"y":[{"c":32,"e":[{".":32}],"s":0}]}],"f":[{"a":[{"b":[{"l":3,"r":11}],"c":[{"e":1}],"g":18,"i":[{"n":17}],"l":[{"l":[{"e":6}]}],"m":[{"a":26,"i":[{"s":5}]}],"r":[{"t":[{"h":5}]},32],"t":[{"a":3,"h":[{"e":3}],"o":18}],"u":[{"l":[{"t":7}]}]},41],"b":56,"d":18,"e":[{".":18,"a":[{"s":17,"t":[{"h":54}]}],"b":[{"r":[{"u":[{"a":15}]}]},1],"c":[{"a":18,"t":32}],"d":25,"l":[{"i":3}],"m":[{"o":1}],"n":[{"d":[{"e":6},8]}],"r":[{"r":32,"m":[{"i":[{"o":213}]}]},15],"v":0}],"f":[{"e":[{"s":21}],"i":[{"e":21,"n":[{".":19}],"s":94}],"l":[{"y":21}],"y":24},43],"h":18,"i":[{"a":3,"c":[{".":48,"a":[{"l":47,"n":23,"t":[{"e":18}]}],"e":[{"n":23,"r":3}],"i":[{"a":32,"e":32},0],"s":18,"u":3,"h":27}],"d":[{"e":[{"l":4}]}],"g":[{"h":[{"t":7}]}],"l":[{"i":5,"l":[{"i":[{"n":6}]}],"y":18}],"n":[{"a":32,"d":97,"e":9,"g":98,"n":0},25],"s":[{"t":[{"i":0}]}],"t":[{"t":[{"e":[{"d":[{".":5}]}]}]}]},41],"l":[{"e":[{"s":[{"s":19}]}],"i":[{"n":17}],"o":[{"r":[{"e":11}],"w":[{"e":[{"r":[{".":84}]}]}]}],"y":100,"a":[{"g":[{"e":[{"l":214}]}]}],"u":[{"o":[{"r":27}]}]},99],"m":18,"n":18,"o":[{"n":[{"d":[{"e":0}],"t":0},32],"r":[{"a":[{"t":4,"y":5}],"e":[{"t":6}],"i":0,"t":[{"a":6}]},9],"s":5},41],"p":56,"r":[{"a":[{"t":0}],"e":[{"a":19,"s":[{"c":6}]}],"i":[{"l":17},8],"o":[{"l":6}]}],"s":48,"t":[{"o":21,"y":24},25],"u":[{"e":[{"l":4}],"g":18,"m":[{"i":[{"n":1}]}],"n":[{"e":4}],"r":[{"i":3}],"s":[{"i":17,"s":0}],"t":[{"a":18}]},27],"y":41}],"g":[{"a":[{"f":0,"l":[{".":32,"i":27,"o":3}],"m":[{"e":[{"t":4}],"o":19},25],"n":[{"i":[{"s":5,"z":[{"a":6},3]}],"o":18}],"r":[{"n":67}],"s":[{"s":17}],"t":[{"h":12,"i":[{"v":18}]}],"z":18},41],"b":23,"d":1,"e":[{".":25,"d":25,"e":[{"z":17}],"l":[{"i":[{"n":0,"s":4,"z":4}],"y":18}],"n":[{"a":[{"t":1}],"i":[{"z":4}],"o":18,"y":18,"c":[{"y":[{".":8}]}]},41],"o":[{"m":3,"d":215},41],"r":[{"y":21}],"s":[{"i":32}],"t":[{"h":6,"o":18,"y":1,"i":[{"c":[{".":8}]}]}],"v":1}],"g":[{"e":[{"r":23},24],"l":[{"u":6}],"o":0},101],"h":[{"i":[{"n":3}],"o":[{"u":[{"t":4}]}],"t":[{"o":1,"w":[{"e":15}]}]}],"i":[{".":32,"a":[{"r":5},102],"c":[{"i":[{"a":32}],"o":21},29],"e":[{"n":6,"s":[{".":32}]}],"l":0,"m":[{"e":[{"n":23}]}],"n":[{".":68,"g":[{"e":5}],"s":103}],"o":32,"r":[{"l":0},27],"s":[{"l":23}],"u":1,"v":32,"z":27}],"l":[{"a":[{"d":[{"i":6}],"s":32},0],"e":[{"a":[{"d":29}]},41],"i":[{"b":0,"g":23,"s":[{"h":43}]}],"o":[{"r":11,"b":[{"i":[{"n":106}]}]},27]},9],"m":[{"y":21},29],"n":[{"a":[{".":21,"c":69},1],"e":[{"t":[{"t":17,"i":[{"s":[{"m":137}]}]}]}],"i":[{"n":24,"o":21},29],"o":[{"n":21,"m":[{"o":5}],"r":[{".":216,"e":[{"s":[{"p":24}]}]}]},29]}],"o":[{".":27,"b":5,"e":32,"g":104,"i":[{"s":3}],"n":[{"a":105,"d":[{"o":7}],"i":[{"z":[{"a":217}]},3]},8],"o":32,"r":[{"i":[{"z":4}],"o":[{"u":5}]}],"s":[{".":32}],"v":15},41],"p":23,"r":[{"a":[{"d":[{"a":18}],"i":21,"n":84,"p":[{"h":[{".":32,"e":[{"r":[{".":7},19]}],"i":[{"c":32}],"y":18}]}],"y":18}],"e":[{"n":0,"s":[{"s":[{".":18}]}]}],"i":[{"t":18,"e":[{"v":213}]}],"o":21,"u":[{"f":17}]},41],"s":[{"t":[{"e":19}]},9],"t":[{"h":11}],"u":[{"a":[{"r":[{"d":27}]},1],"e":25,"i":[{"t":106}],"n":27,"s":27,"t":[{"a":[{"n":29}]},26]}],"w":23,"y":[{"n":107,"r":[{"a":4}]},41]}],"h":[{"a":[{"b":[{"l":73}],"c":[{"h":17}],"e":[{"m":0,"t":0}],"g":[{"u":19}],"l":[{"a":[{"m":12},3]}],"m":1,"n":[{"c":[{"i":0,"y":0}],"d":[{".":32}],"g":[{"e":[{"r":6}],"o":6},0],"i":[{"z":108}],"k":0,"t":[{"e":0}]}],"p":[{"l":11,"t":5,"a":[{"r":[{"r":218}]}]}],"r":[{"a":[{"n":3,"s":4}],"d":[{"e":12},8],"l":[{"e":0}],"p":[{"e":[{"n":6}]}],"t":[{"e":[{"r":5}]}]}],"s":[{"s":5}],"u":[{"n":17}],"z":[{"a":11},32],"i":[{"r":[{"s":137}]}],"t":[{"c":[{"h":213}]}]}],"b":29,"e":[{"a":[{"d":41,"r":27}],"c":[{"a":[{"n":1,"t":19}]}],"d":[{"o":13},21],"l":[{"i":93,"l":[{"i":[{"s":0}],"y":0}],"o":19}],"m":[{"p":0}],"n":[{"a":[{"t":5},17]},9],"o":[{"r":5}],"p":5,"r":[{"a":[{"p":12},21],"b":[{"a":0}],"e":[{"a":6}],"n":23,"o":[{"u":19}],"y":23}],"s":[{"p":64},29],"t":[{"e":[{"d":0}]},1],"u":0,"x":[{"a":168}]}],"f":29,"h":29,"i":[{"a":[{"n":4}],"c":[{"o":1}],"g":[{"h":6}],"l":109,"m":[{"e":[{"r":36}]}],"n":[{"a":21}],"o":[{"n":[{"e":17}]}],"p":[{"e":[{"l":[{"a":219}]}]},1],"r":[{"l":0,"o":3,"p":0,"r":0}],"s":[{"e":[{"l":11}],"s":0}],"t":[{"h":[{"e":[{"r":6}]}],"e":[{"s":[{"i":[{"d":12}]}]}]}],"v":9}],"k":18,"l":[{"a":[{"n":17}],"o":[{"r":[{"i":11}]},24]},80],"m":[{"e":[{"t":17}]},43],"n":[{"a":[{"u":[{"z":12}]}]},42],"o":[{"d":[{"i":[{"z":19}],"s":19}],"g":[{"e":17},1],"l":[{"a":[{"r":5}],"e":110}],"m":[{"a":1,"e":12}],"n":[{"a":0,"y":4}],"o":[{"d":27,"n":17}],"r":[{"a":[{"t":5}],"i":[{"s":4,"c":[{".":187}]}],"t":[{"e":12}],"u":4}],"s":[{"e":[{"n":4},0],"p":15}],"u":[{"s":[{"e":54},41]}],"v":[{"e":[{"l":5}]}]}],"p":56,"r":[{"e":[{"e":6}],"o":[{"n":[{"i":[{"z":5}]}],"p":[{"o":11}]}]},26],"s":[{"h":21},101],"t":[{"a":[{"r":21}],"e":[{"n":2,"s":4,"o":[{"u":216}]}],"y":21}],"u":[{"g":1,"m":[{"i":[{"n":1}]}],"n":[{"k":[{"e":5}],"t":0}],"s":[{"t":14}],"t":1}],"w":[{"a":[{"r":[{"t":21}]}]},29],"y":[{"p":[{"e":3,"h":3,"o":[{"t":[{"h":[{"a":137}]}]}]}],"s":9}]}],"i":[{"a":[{"l":24,"m":[{"e":[{"t":[{"e":5}]}]},0],"n":[{"c":18,"i":11,"t":46},24],"p":[{"e":4}],"s":[{"s":17}],"t":[{"i":[{"v":21}],"r":[{"i":[{"c":1}]}],"u":21}]},42],"b":[{"e":[{"r":[{"a":3,"t":4}]},0],"i":[{"a":4,"n":3,"t":[{".":4,"e":4}]}],"l":[{"i":3},29],"o":19,"r":[{"i":94},29],"u":[{"n":19}]}],"c":[{"a":[{"m":18,"p":32,"r":[{".":21,"a":21},18],"s":6,"y":21}],"c":[{"u":17}],"e":[{"o":18}],"h":18,"i":[{"d":19,"n":[{"a":4}],"p":[{"a":3},24]},25],"l":[{"y":21}],"o":[{"c":94}],"r":[{"a":32,"y":21},43],"t":[{"e":1,"u":[{"a":111},84]}],"u":[{"l":[{"a":3}],"m":1,"o":4,"r":23}]}],"d":[{"a":[{"i":21,"n":[{"c":4}]}],"d":4,"e":[{"a":[{"l":11}],"s":0}],"i":[{"a":[{"n":4,"r":0}],"e":19,"o":[{"u":5,"s":1},3],"t":2,"u":4},24],"l":[{"e":23}],"o":[{"m":21,"w":3}],"r":21,"u":[{"o":4},24]},25],"e":[{"d":[{"e":0}],"g":[{"a":113}],"l":[{"d":12}],"n":[{"a":67,"e":0,"n":19,"t":[{"i":23}]}],"r":[{".":29}],"s":[{"c":23,"t":29}],"t":23},112],"f":[{".":18,"e":[{"r":[{"o":4}]}],"f":[{"e":[{"n":5}],"r":1}],"i":[{"c":[{".":18}],"e":23}],"l":23,"t":18,"a":[{"c":[{"e":[{"t":137}]}]}]}],"g":[{"a":[{"b":5}],"e":[{"r":[{"a":3}]}],"h":[{"t":[{"i":12}]}],"i":[{"b":23,"l":3,"n":3,"t":3},18],"l":28,"o":[{"r":3,"t":4},24],"r":[{"e":19}],"u":[{"i":5,"r":2}],"n":[{"i":[{"t":[{"e":[{"r":213}]},0]}]}]},25],"h":23,"i":114,"j":[{"k":21},23],"k":18,"l":[{"a":[{"b":93,"d":[{"e":21}],"m":94,"r":[{"a":5}]},29],"e":[{"g":23,"r":2,"v":17}],"f":4,"i":[{"a":3,"b":9,"o":3,"s":[{"t":1}],"t":25,"z":9},2],"l":[{"a":[{"b":5}]}],"n":18,"o":[{"q":3}],"t":[{"y":1}],"u":[{"r":4}],"v":3}],"m":[{"a":[{"g":[{"e":3},21],"r":[{"y":5}]}],"e":[{"n":[{"t":[{"a":[{"r":10}]}]}],"t":18}],"i":[{"d":[{"a":4}],"l":[{"e":5}],"n":[{"i":19}],"t":18},2],"n":[{"i":1}],"o":[{"n":23}],"u":[{"l":[{"a":3}]},24],"p":[{"e":[{"d":[{"a":201}]}]}]}],"n":[{".":25,"a":[{"u":83,"v":18}],"c":[{"e":[{"l":36,"r":3}]}],"d":[{"l":[{"i":[{"n":[{"g":4}]}]}]},18],"e":[{"e":23,"r":[{"a":[{"r":17}]}],"s":[{"s":19}]},25],"g":[{"a":18,"e":[{"n":4},18],"i":18,"l":[{"i":[{"n":[{"g":4}]}]}],"o":18,"u":18}],"i":[{".":19,"a":21,"o":3,"s":2,"t":[{"e":[{".":19,"l":[{"y":[{".":19}]}]}],"i":[{"o":32}],"y":3}]},25],"k":18,"l":18,"n":25,"o":[{"c":90,"s":0,"t":21},42],"s":[{"e":3,"u":[{"r":[{"a":7}]}]},25],"t":[{".":25,"h":112}],"u":[{"s":19},2],"y":18,"f":[{"r":[{"a":[{"s":220}]}]}]}],"o":[{".":18,"g":[{"e":17,"r":9}],"l":29,"m":1,"n":[{"a":[{"t":11}],"e":[{"r":[{"y":0}]}],"i":11}],"p":[{"h":4}],"r":[{"i":11}],"s":21,"t":[{"h":4,"i":19,"o":1}],"u":[{"r":21}]},25],"p":[{"e":0,"h":[{"r":[{"a":[{"s":115}]}]}],"i":[{"c":1},3],"r":[{"e":96}],"u":[{"l":3}]},25],"q":[{"u":[{"a":23,"e":[{"f":4}],"i":[{"d":3,"t":116}]}]}],"r":[{"a":[{"b":0,"c":21},29],"d":[{"e":5}],"e":[{"d":[{"e":0}],"f":21,"l":117,"s":21}],"g":[{"i":4}],"i":[{"d":[{"e":5}],"s":1,"t":[{"u":11}],"z":118},2],"m":[{"i":[{"n":1}]}],"o":[{"g":0,"n":[{".":32}]}],"u":[{"l":4}],"r":[{"e":[{"v":[{"o":[{"c":221}]}]}]}]},18],"s":[{".":25,"a":[{"g":4,"r":3,"s":6}],"c":[{"h":3},119],"e":[{"r":3},18],"f":27,"h":[{"a":[{"n":4}],"o":[{"n":3,"p":5}]}],"i":[{"b":3,"d":0,"s":19,"t":[{"i":[{"v":4}]}]}],"k":26,"l":[{"a":[{"n":36}]}],"m":[{"s":18}],"o":[{"m":[{"e":[{"r":5}]}]},24],"p":[{"i":9,"y":1},2],"s":[{"a":[{"l":1}],"e":[{"n":36,"s":1}]},62],"t":[{"a":[{".":1}],"e":2,"i":2,"l":[{"y":0}],"r":[{"a":[{"l":18}]}]}],"u":[{"s":4},24]}],"t":[{"a":[{".":18,"b":[{"i":0}],"g":21,"m":120,"n":23,"t":23}],"e":[{"r":[{"a":3,"i":19}],"s":[{"i":[{"m":[{"a":29}]}]},1]},25],"h":[{"i":[{"l":148}]},25],"i":[{"a":18,"c":[{"a":3,"k":31},22],"g":3,"l":[{"l":4}],"m":24,"o":25,"s":[{"m":21},18],"n":[{"e":[{"r":[{"a":[{"r":158}]}]}]}]},29],"o":[{"m":121,"n":18}],"r":[{"a":[{"m":21}],"y":4}],"t":18,"u":[{"a":[{"t":3}],"d":19,"l":3}],"z":[{".":18}]}],"u":29,"v":[{"e":[{"l":[{"l":3}],"n":[{".":3}],"r":[{".":83,"s":[{".":21}]}]}],"i":[{"l":[{".":4}],"o":4,"t":2}],"o":[{"r":[{"e":19,"o":35}],"t":83}]},25],"w":56,"x":[{"o":1}],"y":18,"z":[{"a":[{"r":18}],"i":0,"o":[{"n":[{"t":32}]}]}]}],"j":[{"a":[{"c":[{"q":0}],"p":[{"a":[{"n":[{"e":[{"s":220}]}]}]},1],"n":[{"u":[{"a":12}]}]},32],"e":[{"r":[{"s":5,"e":[{"m":222}]}],"s":[{"t":[{"i":[{"e":18}],"y":18}]}],"w":11},41],"o":[{"p":1}],"u":[{"d":[{"g":32}]}]}],"k":[{"a":[{".":27,"b":23,"g":19,"i":[{"s":17}],"l":0}],"b":29,"e":[{"d":24,"e":41,"g":1,"l":[{"i":[{"n":[{"g":223}]},4]}],"n":[{"d":73}],"r":29,"s":[{"t":[{".":23}]},0],"t":[{"y":1}]}],"f":23,"h":1,"i":[{".":32,"c":122,"l":[{"l":21,"o":6}],"m":21,"n":[{".":21,"d":[{"e":0}],"e":[{"s":[{"s":19}],"t":[{"i":[{"c":224}]}]}],"g":0}],"p":1,"s":[{"h":19},0]},29],"k":1,"l":[{"e":[{"y":18}],"y":18},29],"m":29,"n":[{"e":[{"s":19}],"o":69}],"o":[{"r":4,"s":[{"h":17}],"u":23,"v":[{"i":[{"a":[{"n":41}]}]}]}],"r":[{"o":[{"n":5}]}],"s":[{"c":21,"l":1,"y":21,"h":[{"a":23}]},101],"t":19,"w":29}],"l":[{"a":[{"b":[{"i":[{"c":11}],"o":21}],"c":[{"i":[{"e":225},17]}],"d":[{"e":21,"y":3}],"g":[{"n":0}],"m":[{"o":11}],"n":[{"d":[{"l":0},27],"e":[{"t":5}],"t":[{"e":0}]}],"r":[{"g":0,"i":11,"c":[{"e":[{"n":176}]}]}],"s":[{"e":0}],"t":[{"a":[{"n":4}],"e":[{"l":[{"i":18}]}],"i":[{"v":18}]}],"v":[{"a":95},18],"i":[{"n":[{"e":[{"s":[{"s":226}]}]}]}]}],"b":[{"i":[{"n":17}]},42],"c":[{"e":0,"i":23,"h":[{"a":[{"i":23}],"i":[{"l":[{"d":227}]}]}]},101],"d":[{"e":[{"r":[{"e":1,"i":1}]},24],"i":[{"s":4},0],"r":[{"i":21},23]},25],"e":[{"a":[{"d":[{"e":[{"r":[{".":183}]}]}],"s":[{"a":228}]},9],"b":[{"i":1}],"f":[{"t":6}],"g":[{".":32,"g":32,"e":[{"n":[{"d":[{"r":[{"e":230}]}]}]}]}],"m":[{"a":[{"t":[{"i":[{"c":5}]},1]}]}],"n":[{".":18,"c":27,"e":[{".":32}],"t":41,"o":[{"i":[{"d":78}]}]}],"p":[{"h":3,"r":1}],"r":[{"a":[{"b":6}],"e":0,"g":27,"i":68,"o":21}],"s":[{"c":[{"o":4}],"q":32,"s":[{".":32},27]},8],"v":[{"a":23,"e":[{"r":[{".":0,"a":0,"s":0}]}]}],"y":[{"e":18},27],"c":[{"t":[{"a":[{"b":229}]}]}]}],"f":[{"r":19},25],"g":[{"a":[{"r":12},19],"e":[{"s":21}],"o":11},80],"h":48,"i":[{"a":[{"g":1,"m":9,"r":[{"i":[{"z":6}]}],"s":1,"t":[{"o":1}]}],"b":[{"i":4}],"c":[{"i":[{"o":32}],"o":[{"r":1}],"s":18,"t":[{".":18}],"u":21,"y":23}],"d":[{"a":23,"e":[{"r":5}],"i":27}],"f":[{"e":[{"r":11}],"f":21,"l":1}],"g":[{"a":[{"t":[{"e":32}]}],"h":27,"r":[{"a":1}]}],"k":27,"l":123,"m":[{"b":[{"l":0}],"i":11,"o":1,"p":90}],"n":[{"a":21,"e":[{"a":11},124],"i":11,"k":[{"e":[{"r":6}]}]}],"o":[{"g":4}],"q":125,"s":[{"p":0}],"t":[{".":24,"i":[{"c":[{"a":32,"s":108}]}],"h":[{"o":[{"g":204}]}]},29],"v":[{"e":[{"r":11}]}],"z":29}],"j":18,"k":[{"a":[{"l":23,"t":0},11]}],"l":[{"a":[{"w":21}],"e":[{"a":19,"c":23,"g":23,"l":23,"n":73,"t":73},24],"i":[{"n":[{"a":19},126],"s":[{"h":231}]},9],"o":[{"q":[{"u":[{"i":10}]}],"u":[{"t":4}],"w":19},1],"f":[{"l":2}]},29],"m":[{"e":[{"t":19}],"i":[{"n":[{"g":3}]}],"o":[{"d":21,"n":[{"e":[{"l":[{"l":232}]}]},17]}]},25],"n":81,"o":[{".":27,"b":[{"a":[{"l":5}],"o":[{"t":[{"o":233}]}]}],"c":[{"i":1}],"f":18,"g":[{"i":[{"c":27}],"o":19,"u":27,"e":[{"s":[{".":9}]}]}],"m":[{"e":[{"r":11}]}],"n":[{"g":32,"i":[{"z":127},0]}],"o":[{"d":6}],"p":[{"e":[{".":32}],"i":11,"m":23}],"r":[{"a":[{"t":[{"o":1}]},17],"i":[{"e":4}],"o":[{"u":5}]}],"s":[{".":32,"e":[{"t":5}],"o":[{"p":[{"h":[{"i":[{"z":32}],"y":32}]}]}],"t":0}],"t":[{"a":1}],"u":[{"n":[{"d":6}],"t":25}],"v":18,"a":[{"d":[{"e":[{"d":[{".":17}],"r":[{".":183}]}]}]}]}],"p":[{"a":[{"b":5}],"h":[{"a":23,"i":19}],"i":[{"n":[{"g":4}],"t":23}],"l":21,"r":19},25],"r":43,"s":[{"c":21,"e":24,"i":[{"e":21}]},81],"t":[{"a":[{"g":4,"n":[{"e":7}]}],"e":[{"n":17,"r":[{"a":36}],"a":23},29],"h":[{"i":[{"l":[{"y":148}]},11]}],"i":[{"e":[{"s":[{".":19}]}],"s":17}],"r":29,"u":[{"r":[{"a":12}]},8]},18],"u":[{"a":4,"b":[{"r":3}],"c":[{"h":17,"i":3}],"e":[{"n":3,"p":15}],"f":0,"i":[{"d":4}],"m":[{"a":1,"i":32,"n":[{".":19,"i":[{"a":32}]}],"b":[{"i":[{"a":[{".":235}]}]}]}],"o":[{"r":11},3],"p":18,"s":[{"s":17,"t":[{"e":11}]}],"t":41,"n":[{"k":[{"e":[{"r":234}]}]}]}],"v":[{"e":[{"n":19,"t":128}]}],"w":42,"y":[{"a":18,"b":18,"m":[{"e":4}],"n":[{"o":3}],"s":[{"e":19,"t":[{"y":[{"r":4}]}]},58],"g":[{"a":[{"m":[{"i":236}]}]}]},41]}],"m":[{"a":[{"b":25,"c":[{"a":9,"h":[{"i":[{"n":[{"e":4}]}]}],"l":1}],"g":[{"i":[{"n":5}],"n":32}],"h":25,"i":[{"d":6}],"l":[{"d":18,"i":[{"g":3,"n":4}],"l":[{"i":0}],"t":[{"y":0}],"a":[{"p":222}]}],"n":[{"i":[{"a":32,"s":5,"z":11}],".":24,"u":[{"s":[{"c":237}]}]}],"p":[{"h":[{"r":[{"o":244}]}]},18],"r":[{"i":[{"n":[{"e":[{".":4}]}],"z":4}],"l":[{"y":0}],"v":11,"g":[{"i":[{"n":238}]}]}],"s":[{"c":[{"e":4}],"e":0,"t":15}],"t":[{"e":32,"h":12,"i":[{"s":3,"z":[{"a":18}]}]}]},41],"b":[{"a":[{"t":129}],"i":[{"l":19,"n":[{"g":83}],"v":0}]},43],"c":56,"e":[{".":18,"d":[{".":18,"i":[{"a":32,"e":3,"c":[{"i":[{"n":152}]},84],"o":[{"c":239}]}],"y":108},25],"g":[{"r":[{"a":[{"n":240}]}]},9],"l":[{"o":[{"n":5}],"t":0}],"m":[{"o":130},9],"n":[{"a":[{"c":5},0],"d":[{"e":0}],"e":18,"i":0,"s":[{"u":7},17],"t":[{"e":0},27],".":24},41],"o":[{"n":4}],"r":[{"s":[{"a":19}]}],"s":[{"t":[{"i":27}]},25],"t":[{"a":[{"l":11},1],"e":2,"h":[{"i":4}],"r":[{"i":[{"c":32,"e":4}],"y":3},21]}],"v":1}],"f":43,"h":25,"i":[{".":32,"a":3,"d":[{"a":[{"b":241},0],"g":0}],"g":0,"l":[{"i":[{"a":27,"e":108,"t":[{"a":27}]}],"l":[{"a":[{"g":208}],"i":[{"l":[{"i":59}]}]},21]}],"n":[{"a":0,"d":27,"e":[{"e":19}],"g":[{"l":[{"i":5,"y":19},21]}],"t":0,"u":[{"t":[{"e":[{"r":242,"s":[{"t":242}]}]}]},21],"i":[{"s":[{".":174}]}]}],"o":[{"t":17}],"s":[{"e":[{"r":[{".":0}]}],"l":5,"t":[{"i":0,"r":[{"y":19}]}]},24],"t":[{"h":18}],"z":24}],"k":18,"l":43,"m":[{"a":[{"r":[{"y":5}],"b":243}]},29],"n":[{"a":1,"i":[{"n":21}],"o":1},43],"o":[{"c":[{"r":[{"a":[{"t":[{"i":[{"z":32}]},245]}]},18]}],"d":131,"g":[{"o":1}],"i":[{"s":[{"e":5},84]}],"k":18,"l":[{"e":[{"s":[{"t":4}],"c":246}]}],"m":[{"e":3}],"n":[{"e":[{"t":5,"y":[{"l":247}]}],"g":[{"e":5}],"i":[{"a":12,"s":[{"m":0,"t":0}],"z":3}],"o":[{"l":36,"c":[{"h":12}],"e":[{"n":171}],"s":249}],"y":[{".":3}]}],"r":[{"a":[{".":18}],"o":[{"n":[{"i":[{"s":248}]}]}]},9],"s":[{"e":[{"y":4}],"p":3},8],"t":[{"h":[{"e":[{"t":250}]},12]}],"u":[{"f":19,"s":[{"i":[{"n":98}]},27]}],"v":9,"e":[{"l":[{"a":[{"s":167}]}]}]},41],"p":[{"a":[{"r":[{"a":[{"b":5},7],"i":6}]}],"e":[{"t":23}],"h":[{"a":[{"s":36}]}],"i":[{"a":0,"e":[{"s":4}],"n":34,"r":19,"s":4},24],"o":[{"r":[{"i":11}],"s":[{"i":[{"t":[{"e":6}]}]}],"u":[{"s":21}],"v":6}],"t":[{"r":1}],"y":24},43],"r":47,"s":[{"h":[{"a":[{"c":[{"k":251}]}]},21],"i":19},101],"t":18,"u":[{"l":[{"a":[{"r":49}],"t":[{"i":[{"u":252},54]},32]}],"m":27,"n":8,"p":18,"u":1,"d":[{"r":[{"o":9}]}]},41],"w":18}],"n":[{"a":[{"b":[{"u":21},81],"c":[{".":18,"a":1,"t":19}],"g":[{"e":[{"r":[{".":5}]}]}],"k":0,"l":[{"i":[{"a":4},1],"t":18}],"m":[{"i":[{"t":4}]}],"n":[{"c":[{"i":36}],"i":[{"t":0}],"k":17},24],"r":[{"c":[{"h":[{"s":[{".":73}]}]},11],"e":18,"i":11,"l":0,"m":19}],"s":[{"c":0,"t":[{"i":5}]},21],"t":[{"a":[{"l":3}],"o":[{"m":[{"i":[{"z":6}]}]}]},24],"u":[{"s":[{"e":11}],"t":27},24],"v":[{"e":0}]},41],"b":80,"c":[{"a":[{"r":6}],"e":[{"s":[{".":21}]}],"h":[{"a":23,"e":[{"o":19,"s":[{"t":253}]}],"i":[{"l":19,"s":23}]}],"i":[{"n":2,"t":1}],"o":[{"u":[{"r":[{"a":7}]}]}],"r":29,"u":29}],"d":[{"a":[{"i":21,"n":19}],"e":[{"s":[{"t":[{".":4}]}]},29],"i":[{"b":0,"f":79,"t":29,"z":23,"e":[{"c":[{"k":29}]}]}],"u":[{"c":19,"r":0}],"w":[{"e":9}],"t":[{"h":[{"r":3}]}]}],"e":[{".":25,"a":[{"r":23}],"b":[{"u":11,"a":[{"c":[{"k":3}]}]},9],"c":[{"k":32},9],"d":25,"g":[{"a":[{"t":[{"i":[{"v":5}]},1]}],"e":32}],"l":[{"a":1,"i":[{"z":5}]}],"m":[{"i":4,"o":1}],"n":[{"e":18},41],"o":27,"p":[{"o":1}],"q":9,"r":[{"a":[{"b":6,"r":21}],"e":24,"i":132,"r":0},29],"s":[{".":25,"p":18,"t":25,"w":18,"k":[{"i":119}]},41],"t":[{"i":[{"c":27}]}],"v":[{"e":19},1],"w":1}],"f":[{"i":[{"n":[{"i":[{"t":[{"e":[{"s":226}]}]}]}]}]},23],"g":[{"a":[{"b":21}],"e":[{"l":23,"n":[{"e":[{"s":5},133]}],"r":[{"e":19,"i":23}]}],"h":[{"a":4,"o":2}],"i":[{"b":23,"n":2,"t":19}],"l":[{"a":21}],"o":[{"v":17}],"s":[{"h":4,"p":[{"r":2}]}],"u":[{"m":21},29],"y":24}],"h":[{"a":[{"b":12},0],"e":0},80],"i":[{"a":[{"n":[{".":114},3],"p":1},68],"b":[{"a":3,"l":1}],"d":[{"i":4},1],"e":[{"r":1}],"f":[{"i":[{"c":[{"a":[{"t":4}]}]},9]}],"g":[{"r":19}],"k":0,"m":[{"i":[{"z":3}]},29],"n":[{"e":[{".":32}],"g":0},29],"o":1,"s":[{".":32,"t":[{"a":0}]}],"t":[{"h":21,"i":[{"o":27}],"o":[{"r":23}],"r":3},24]}],"j":29,"k":[{"e":[{"r":[{"o":19}],"t":23}],"i":[{"n":3}],"l":29,"r":[{"u":[{"p":3}]}]},44],"l":[{"e":[{"s":[{"s":19}]}]},43],"m":[{"e":[{"t":17},0]},19],"n":[{"e":0,"i":[{"a":[{"l":11}],"v":0}]},101],"o":[{"b":[{"l":[{"e":3},0]}],"c":[{"l":19,"e":[{"r":[{"o":[{"s":254}]}]}]}],"d":66,"e":27,"g":[{"e":17},18],"i":[{"s":[{"i":6}]}],"l":[{"i":134,"o":[{"g":[{"i":[{"s":32}]}]}]}],"m":[{"i":[{"c":27,"z":108,"s":[{"t":82}]}],"o":1,"y":3,"a":[{"l":214}],"e":[{"n":[{"o":194}]}]}],"n":[{"a":[{"g":0}],"i":[{"z":19,"s":[{"o":255}]},5],"e":[{"q":15}]},1],"p":[{"o":[{"l":[{"i":135,"y":[{".":256}]}]}]},18],"r":[{"a":[{"b":5,"r":[{"y":1}]}]}],"s":[{"c":18,"e":0,"t":5}],"t":[{"a":4}],"u":[{"n":27},41],"v":[{"e":[{"l":136,"m":[{"b":2}]}]}],"w":[{"l":12}]}],"p":[{"i":0,"r":[{"e":[{"c":17}]}]},72],"q":29,"r":[{"u":0},29],"s":[{"a":[{"b":4,"t":[{"i":36}]}],"c":[{"e":[{"i":[{"v":4}]}]},1],"e":[{"s":83},24],"i":[{"d":137,"g":17}],"l":24,"m":[{"o":[{"o":1}]},3],"o":[{"c":21}],"p":[{"e":1,"i":19}],"t":[{"a":[{"b":[{"l":6}]}]}]},81],"t":[{"a":[{"b":0}],"e":[{"r":[{"s":12}]}],"i":[{"b":19,"e":[{"r":0}],"f":8,"n":[{"e":23,"g":83}],"p":0},9],"r":[{"o":[{"l":[{"l":[{"i":7}]}]}],"e":[{"p":137}]}],"s":1,"u":[{"m":[{"e":11}]}]},29],"u":[{"a":2,"d":1,"e":[{"n":4}],"f":[{"f":[{"e":0}]}],"i":[{"n":23,"t":50}],"m":[{"e":2,"i":19},21],"n":138,"o":23,"t":[{"r":3}]}],"v":74,"w":72,"y":[{"m":0,"p":0}],"z":[{"a":23},18]}],"o":[{"a":[{"d":11,"l":[{"e":[{"s":108}]}],"r":[{"d":12}],"s":[{"e":0,"t":[{"e":6}]}],"t":[{"i":5}]},18],"b":[{"a":[{"b":35,"r":19}],"e":[{"l":0}],"i":[{"n":[{"g":4},24]},29],"r":23,"u":[{"l":3}],"l":[{"i":[{"g":189}]}]}],"c":[{"e":29,"h":[{"e":[{"t":23}],"a":[{"s":23}]},0],"i":[{"f":12,"l":21}],"l":[{"a":[{"m":21}]}],"o":[{"d":21}],"r":[{"a":[{"c":3,"t":[{"i":[{"z":4}]}]}],"e":12,"i":[{"t":32}]}],"t":[{"o":[{"r":[{"a":7}]}]}],"u":[{"l":[{"a":3}],"r":[{"e":19}]}]}],"d":[{"d":[{"e":[{"d":4}]}],"i":[{"c":3,"o":11,"t":[{"i":[{"c":137}]}]}],"o":[{"r":12},139],"u":[{"c":[{"t":[{".":4,"s":4}]}]}],"e":[{"l":[{"l":[{"i":12}]}]}]}],"e":[{"l":21,"n":[{"g":19}],"r":[{"s":[{"t":257}]},23],"t":[{"a":1}],"v":23}],"f":[{"i":[{"t":[{"e":4,"t":17}]},24]}],"g":[{"a":[{"r":121,"t":[{"i":[{"v":4}],"o":21}]}],"e":[{"n":[{"e":19}],"o":19,"r":21},29],"i":[{"e":23,"s":140,"t":3}],"l":[{"y":79},21],"n":[{"i":[{"z":27}]}],"r":[{"o":21}],"u":[{"i":5}],"y":[{"n":25},41]}],"h":[{"a":[{"b":6}]},74],"i":[{"c":[{"e":[{"s":11}]}],"d":[{"e":[{"r":3}]}],"f":[{"f":17}],"g":0,"l":[{"e":[{"t":4}]}],"n":[{"g":23,"t":[{"e":[{"r":6}]}]}],"s":[{"m":19,"o":[{"n":4}],"t":[{"e":[{"n":6}]}]}],"t":[{"e":[{"r":3}]}]},9],"j":19,"k":[{"e":[{"n":23,"s":[{"t":15}]}],"i":[{"e":4}]},25],"l":[{"a":[{"n":21,"s":[{"s":36}]},29],"d":[{"e":15},9],"e":[{"r":3,"s":[{"c":23,"t":[{"e":[{"r":88}]}]}],"t":23}],"f":[{"i":1}],"i":[{"a":23,"c":[{"e":23}],"d":[{".":4}],"f":73,"l":19,"n":[{"g":3}],"o":19,"s":[{".":19,"h":3}],"t":[{"e":19,"i":[{"o":19}]}],"v":19,"g":[{"o":[{"p":[{"o":258}]}]}]},9],"l":[{"i":[{"e":17}]}],"o":[{"g":[{"i":[{"z":4}]}],"r":0,"n":[{"o":[{"m":259}]}]}],"p":[{"l":4}],"t":9,"u":[{"b":3,"m":[{"e":3}],"n":3,"s":19}],"v":9,"y":24}],"m":[{"a":[{"h":4,"l":5,"t":[{"i":[{"z":4}]}]}],"b":[{"e":9,"l":1}],"e":[{"n":[{"a":3}],"r":[{"s":[{"e":4}]}],"t":[{"r":[{"y":4}]},21],"c":[{"h":[{"a":260}]}]},24],"i":[{"a":23,"c":[{".":3,"a":3}],"d":19,"n":[{"i":19},2]}],"m":[{"e":[{"n":[{"d":32}]}]}],"o":[{"g":[{"e":0}],"n":21}],"p":[{"i":3,"r":[{"o":7}]}]}],"n":[{"a":[{"c":1,"n":23},2],"c":[{"i":[{"l":27}]},2],"d":[{"o":4},25],"e":[{"n":23,"s":[{"t":4}]}],"g":[{"u":1}],"i":[{"c":2,"o":23,"s":2,"u":19}],"k":[{"e":[{"y":3}]}],"o":[{"d":[{"i":1}],"m":[{"y":3,"i":[{"c":137}]}],"r":[{"m":[{"a":23}]}],"t":[{"o":[{"n":261}]}],"u":23}],"s":[{"p":[{"i":[{"r":[{"a":10}]},36]}],"u":17},3],"t":[{"e":[{"n":36}],"i":[{"f":7},93]}],"u":[{"m":4}],"v":[{"a":6}]},24],"o":[{"d":[{"e":5,"i":5}],"k":1,"p":[{"i":11}],"r":[{"d":23}],"s":[{"t":6}]},9],"p":[{"a":24,"e":[{"d":5,"r":[{"a":[{"g":18},27]},2]}],"h":[{"a":[{"n":19}],"e":[{"r":19}]},25],"i":[{"n":[{"g":3}],"t":23,"s":[{"m":[{".":2}]}]}],"o":[{"n":19,"s":[{"i":21}]}],"r":29,"u":2,"y":5}],"q":29,"r":[{"a":[{".":19,"g":83,"l":[{"i":[{"z":4}]}],"n":[{"g":[{"e":4}]}]},29],"e":[{"a":[{"l":19},5],"i":3,"s":[{"h":5,"t":[{".":4}]}],"w":17}],"g":[{"u":1}],"i":[{"a":56,"c":[{"a":3}],"l":19,"n":2,"o":29,"t":[{"y":3}],"u":23}],"m":[{"i":9}],"n":[{"e":8}],"o":[{"f":19,"u":[{"g":3}]}],"p":[{"e":4}],"r":[{"h":27}],"s":[{"e":[{"n":5},1],"t":17}],"t":[{"h":[{"i":3,"y":3,"o":[{"n":[{"i":[{"t":262}]}]}],"r":[{"i":137}]}],"y":1,"i":[{"v":[{"e":[{"l":[{"y":4}]}]}]}]}],"u":[{"m":19}],"y":29}],"s":[{"a":[{"l":3}],"c":[{"e":1,"o":[{"p":[{"i":18},23]}],"r":19},9],"i":[{"e":95,"t":[{"i":[{"v":4}],"o":3,"y":3}],"u":0}],"l":1,"o":24,"p":[{"a":1,"o":1,"h":[{"e":[{"r":83}]}]}],"t":[{"a":[{"t":[{"i":19}]},9],"i":[{"l":4,"t":4}]}]}],"t":[{"a":[{"n":21}],"e":[{"l":[{"e":[{"g":36}]}],"r":[{".":3,"s":4}],"s":[{"t":[{"e":[{"r":263}],"o":[{"r":264}]}]},21]}],"h":[{"e":[{"s":[{"i":5}],"o":[{"s":265}]}],"i":14},18],"i":[{"c":[{".":3,"a":4,"e":23}],"f":23,"s":23}],"o":[{"s":5}]}],"u":[{"b":[{"l":3,"a":[{"d":[{"o":116}]}]}],"c":[{"h":[{"i":6}]}],"e":[{"t":4}],"l":1,"n":[{"c":[{"e":[{"r":6}]}],"d":8}],"v":4},9],"v":[{"e":[{"n":1,"r":[{"n":[{"e":17}],"s":12,"t":1}]}],"i":[{"s":23,"t":[{"i":36}],"a":[{"n":[{".":266}]}]}],"o":[{"l":60}]}],"w":[{"d":[{"e":[{"r":3}]}],"e":[{"l":3,"s":[{"t":4}]}],"i":2,"n":[{"i":5}],"o":21}],"y":[{"a":2}],"x":[{"i":[{"d":[{"i":[{"c":267}]}]}]}]}],"p":[{"a":[{"c":[{"a":1,"e":1,"t":0}],"d":21,"g":[{"a":[{"n":32,"t":23}]}],"i":[{"n":17},21],"l":[{"m":[{"a":[{"t":268}]}]},21],"n":[{"a":0,"e":[{"l":11}],"t":[{"y":0}],"y":3}],"p":[{"u":1},2],"r":[{"a":[{"b":[{"l":6}],"g":[{"e":5,"r":[{"a":269}]}],"l":[{"e":228}],"m":[{"e":12},36]}],"d":[{"i":5}],"e":[{"l":5},27],"i":[{"s":0},28]}],"t":[{"e":[{"r":4},9],"h":[{"i":[{"c":32}],"y":4}],"r":[{"i":[{"c":1}]}]}],"v":0,"y":27},41],"b":43,"d":1,"e":[{".":18,"a":[{"r":[{"l":17}]},138],"c":9,"d":[{"e":27,"i":[{"a":36,"c":0},27]},37],"e":[{"d":0,"v":208},21],"k":0,"l":[{"a":1,"i":[{"e":17}]}],"n":[{"a":[{"n":1}],"c":21,"t":[{"h":0}]}],"o":[{"n":4}],"r":[{"a":[{".":21,"b":[{"l":6}],"g":21}],"i":[{"s":[{"t":6}]},21],"m":[{"a":[{"l":0}],"e":7}],"n":21,"o":11,"t":[{"i":11}],"u":4,"v":15}],"t":[{"e":[{"n":4}],"i":[{"z":4}]},9]}],"f":18,"g":18,"h":[{".":18,"a":[{"r":[{"i":6}]}],"e":[{"n":[{"o":11}],"r":1,"s":[{".":1}]}],"i":[{"c":2,"e":32,"n":[{"g":4}],"s":[{"t":[{"i":32}]}],"z":27,"l":[{"a":[{"n":[{"t":168}],"t":[{"e":[{"l":270}]}]}]}]}],"l":9,"o":[{"b":27,"n":[{"e":27,"i":32}],"r":0}],"s":18,"t":3,"u":32,"y":41}],"i":[{"a":[{"n":17},3],"c":[{"i":[{"e":1}],"y":1,"a":[{"d":271}]}],"d":[{"a":19,"e":3,"i":32},21],"e":[{"c":27,"n":3}],"g":[{"r":[{"a":[{"p":1}]}]}],"l":[{"o":3}],"n":[{".":21,"d":17,"o":21},9],"o":[{"n":17},141],"t":[{"h":[{"a":4},23],"u":9}]}],"k":142,"l":[{"a":[{"n":27,"s":[{"t":6}]}],"i":[{"a":11,"e":[{"r":5}],"g":18,"n":[{"a":[{"r":5}]},0],"c":[{"a":[{"b":208}]}]}],"o":[{"i":17}],"u":[{"m":[{"b":17},0]}]},143],"m":43,"n":48,"o":[{"c":1,"d":[{".":32}],"e":[{"m":4,"t":144}],"g":145,"i":[{"n":[{"t":32,"c":[{"a":12}]},84]}],"l":[{"y":[{"t":6,"e":137,"p":[{"h":[{"o":[{"n":[{"o":272}]}]}]}]}],"e":[{".":41}]}],"n":[{"i":1}],"p":1,"r":[{"y":1},124],"s":[{"s":15},41],"t":[{"a":1},21],"u":[{"n":32}]}],"p":[{"a":[{"r":[{"a":5}]}],"e":[{"d":21,"l":19,"n":23,"r":23,"t":23},24],"o":[{"s":[{"i":[{"t":[{"e":5}]}]}]}]},43],"r":[{"a":[{"y":[{"e":17}]}],"e":[{"c":[{"i":32,"o":5}],"e":[{"m":11}],"f":[{"a":[{"c":6}]}],"l":[{"a":0}],"r":11,"s":[{"e":23,"s":27,"p":[{"l":[{"i":84}]}]}],"t":[{"e":[{"n":5}]}],"v":11,"m":[{"a":[{"c":273}]}],"n":[{"e":[{"u":15}]}]}],"i":[{"e":53,"n":[{"t":146}],"s":[{"o":12},0]}],"o":[{"c":[{"a":23,"e":[{"s":[{"s":8}]}],"i":[{"t":[{"y":[{".":274}]}]}]}],"f":[{"i":[{"t":6}]}],"l":11,"s":[{"e":12}],"t":15,"g":[{"e":208}]}]},9],"s":[{"e":[{"u":[{"d":[{"o":[{"d":276,"f":276}]},275]}]},24],"h":1,"i":[{"b":21}]},81],"t":[{"a":[{"b":134}],"e":24,"h":24,"i":[{"m":11}],"u":[{"r":0}],"w":21,"o":[{"m":[{"a":[{"t":277}]}]}],"r":[{"o":[{"l":278}]}]},42],"u":[{"b":[{"e":[{"s":[{"c":181}]}]},11],"e":0,"f":0,"l":[{"c":11}],"m":1,"n":9,"r":[{"r":0}],"s":32,"t":[{"e":[{"r":11},32],"r":3,"t":[{"e":[{"d":0}],"i":[{"n":0}]}]},9]}],"w":23}],"q":[{"u":[{"a":[{"v":5,"i":[{"n":[{"t":[{"e":279}]}]}],"s":[{"i":[{"r":281,"s":281},280]}]}],"e":[{".":25,"r":27,"t":27}],"i":[{"n":[{"t":[{"e":[{"s":[{"s":282}]}]}]}],"v":[{"a":[{"r":14}]}]}]},9]}],"r":[{"a":[{"b":[{"i":3,"o":[{"l":[{"i":[{"c":29}],"o":[{"i":236}]}]}]},25],"c":[{"h":[{"e":17,"u":3}],"l":19}],"f":[{"f":[{"i":5}],"t":0}],"i":24,"l":[{"o":1}],"m":[{"e":[{"t":[{"r":[{"i":[{"z":283}]}]},11],"n":24}],"i":24,"o":[{"u":3}]}],"n":[{"e":[{"o":6}],"g":[{"e":0}],"i":21,"o":4,"h":[{"a":[{"s":167}]}]}],"p":[{"e":[{"r":11}],"h":[{"y":27}]}],"r":[{"c":5,"e":[{"f":5},17],"i":[{"l":18}]}],"s":24,"t":[{"i":[{"o":[{"n":115}]}]}],"u":[{"t":0}],"v":[{"a":[{"i":4}],"e":[{"l":11}]}],"z":[{"i":[{"e":4}]}],"d":[{"i":[{"g":127,"o":[{"g":249}]}]}],"o":[{"r":2}]}],"b":[{"a":[{"b":21,"g":21}],"i":[{"f":0,"n":[{"e":19,"g":[{".":4,"e":284}]},24]},8],"o":1},29],"c":[{"e":[{"n":17},24],"h":[{"a":23,"e":[{"r":0}]}],"i":[{"b":90,"t":1}],"u":[{"m":12}]},29],"d":[{"a":[{"l":21}],"i":[{"a":0,"e":[{"r":0}],"n":[{"g":3},17]},9]}],"e":[{".":25,"a":[{"l":2,"n":3,"r":[{"r":4}],"v":32,"w":1}],"b":[{"r":[{"a":[{"t":19}]}]}],"c":[{"o":[{"l":[{"l":5}],"m":[{"p":[{"e":5}]}]}],"r":[{"e":1}],"i":[{"p":[{"r":285}]}],"t":[{"a":[{"n":[{"g":286}]}]}]}],"d":[{"e":2,"i":[{"s":3,"t":5}]},37],"f":[{"a":[{"c":1}],"e":[{"r":[{".":4}]},9],"i":3,"y":1}],"g":[{"i":[{"s":11}]}],"i":[{"t":4}],"l":[{"i":2,"u":4}],"n":[{"t":[{"a":90,"e":0}]}],"o":2,"p":[{"i":[{"n":4}],"o":[{"s":[{"i":1}]}],"u":2}],"r":[{"i":21,"o":17,"u":4},147],"s":[{".":21,"p":[{"i":1}],"s":[{"i":[{"b":6}]}],"t":[{"a":[{"l":4}],"r":3},8]}],"t":[{"e":[{"r":1}],"i":[{"z":96}],"r":[{"i":[{"b":[{"u":85}]},3]}]}],"u":[{"t":[{"i":4}]},8],"v":[{"a":[{"l":1}],"e":[{"l":11,"r":[{".":30,"s":4,"t":4}]}],"i":[{"l":4}],"o":[{"l":[{"u":5}]}]},8],"w":[{"h":1}]}],"f":[{"u":0,"y":21},29],"g":[{"e":[{"r":3,"t":23}],"i":[{"c":23,"n":[{"g":3},0],"s":19,"t":19}],"l":29,"o":[{"n":0}],"u":23},9],"h":[{".":18,"a":[{"l":18}]},1],"i":[{"a":[{"b":0,"g":1,"l":[{".":23}]},3],"b":[{"a":11},21],"c":[{"a":[{"s":5}],"e":21,"i":[{"d":32,"e":1},18],"o":21}],"d":[{"e":[{"r":5}]}],"e":[{"n":[{"c":3,"t":3}],"r":2,"t":4}],"g":[{"a":[{"n":5}],"i":32}],"l":[{"i":[{"z":11}]}],"m":[{"a":[{"n":32}],"i":5,"o":27,"p":[{"e":0}]}],"n":[{"a":[{".":32},24],"d":0,"e":0,"g":0}],"o":2,"p":[{"h":[{"e":6},32],"l":[{"i":[{"c":5}]},9]}],"q":21,"s":[{".":21,"c":0,"h":23,"p":0},24],"t":[{"a":[{"b":116}],"e":[{"d":[{".":19}],"r":[{".":5,"s":5}]}],"i":[{"c":11}],"u":[{"r":5},9]}],"v":[{"e":[{"l":5,"t":11}],"i":11,"o":[{"l":287}]}]}],"j":23,"k":[{"e":[{"t":23}],"l":[{"e":1,"i":[{"n":1}]}],".":288,"h":[{"o":2}],"r":[{"a":[{"u":29}]}],"s":[{".":288}]}],"l":[{"e":[{"d":24,"q":[{"u":30}]},0],"i":[{"g":21,"s":[{"h":4},21]}],"o":73},29],"m":[{"a":[{"c":5}],"e":[{"n":23,"r":[{"s":4}]},24],"i":[{"n":[{"g":[{".":21},3]}],"o":21,"t":23}],"y":21},29],"n":[{"a":[{"r":21}],"e":[{"l":23,"r":21,"t":19,"y":23}],"i":[{"c":19,"s":92,"t":23,"v":23}],"o":[{"u":21},0],"u":23}],"o":[{"b":[{"l":11,"o":[{"t":289}]}],"c":[{"r":3},24],"e":[{"l":[{"a":[{"s":167}]}],"p":[{"i":[{"d":[{"e":290}]}]}]},1],"f":[{"e":2,"i":[{"l":4}]}],"k":[{"e":[{"r":4}]},8],"l":[{"e":[{".":32}]}],"m":[{"e":[{"t":[{"e":5}],"s":[{"h":3}]}],"i":0,"p":0}],"n":[{"a":[{"l":0}],"e":0,"i":[{"s":134}],"t":[{"a":0}]}],"o":[{"m":41,"t":32}],"p":[{"e":[{"l":3}],"i":[{"c":11}]}],"r":[{"i":11,"o":4}],"s":[{"p":[{"e":[{"r":5}]}],"s":0}],"t":[{"h":[{"e":1}],"y":1,"r":[{"o":[{"n":2}]}]}],"v":[{"a":1,"e":[{"l":5}]}],"x":5}],"p":[{"e":[{"a":21,"n":[{"t":19}],"r":[{".":4}],"t":23}],"h":95,"i":[{"n":[{"g":3}]}],"o":23,"a":[{"u":[{"l":[{"i":291}]}]}]},29],"r":[{"e":[{"c":0,"f":0,"o":21,"s":[{"t":0}]}],"i":[{"o":0,"v":0}],"o":[{"n":17,"s":17}],"y":[{"s":17}]},72],"s":[{"a":[{"t":[{"i":5}]},29],"c":1,"e":[{"c":[{"r":0},23],"r":[{".":4,"a":[{"d":[{"i":238}]}]}],"s":3,"v":148},24],"h":[{"a":19},29],"i":[{"b":90},29],"o":[{"n":12}],"p":29,"w":19},44],"t":[{"a":[{"c":[{"h":36}],"g":21}],"e":[{"b":23,"n":[{"d":17}],"o":5}],"i":[{"b":4,"d":0,"e":[{"r":21}],"g":23,"l":[{"i":12,"l":17,"y":21}],"s":[{"t":21}],"v":21},29],"r":[{"i":23,"o":[{"p":[{"h":115}]}],"e":[{"u":29}]}],"s":[{"h":1}],"h":[{"o":[{"u":29}]}]}],"u":[{"a":3,"e":[{"l":93,"n":3}],"g":[{"l":1}],"i":[{"n":3}],"m":[{"p":[{"l":11}]}],"n":[{"k":6,"t":[{"y":0}]},9],"s":[{"c":19}],"t":[{"i":[{"n":6}]}]}],"v":[{"e":[{"l":[{"i":17}],"n":23,"r":[{".":4}],"s":[{"t":19}],"y":23,"i":[{"l":29}]},1],"i":[{"c":23,"v":0}],"o":23}],"w":29,"y":[{"c":1,"n":[{"g":[{"e":32}]}],"t":3}],"z":[{"s":[{"c":2}]}]}],"s":[{"a":[{"b":42,"c":[{"k":32,"r":[{"i":11}],"t":23}],"i":32,"l":[{"a":[{"r":36}],"m":0,"o":4,"t":0,"e":[{"s":[{"c":54,"w":7}]}]}],"n":[{"c":27,"d":[{"e":0}]}],"p":[{"a":[{"r":[{"i":[{"l":292}]}]}]},29],"t":[{"a":4,"i":[{"o":76}],"u":11}],"u":0,"v":[{"o":[{"r":4}]}],"w":32},9],"b":56,"c":[{"a":[{"n":[{"t":149}],"p":[{"e":[{"r":267}]},0],"v":6,"t":[{"o":[{"l":208}]}]}],"e":[{"d":21,"i":18,"s":21}],"h":[{"o":21,"i":[{"t":[{"z":21}]}],"r":[{"o":[{"d":[{"i":[{"n":[{"g":293}]}]}]}]}]},8],"i":[{"e":68,"n":[{"d":150}],"u":[{"t":[{"t":294}]}]}],"l":[{"e":6,"i":21}],"o":[{"f":17,"p":[{"y":18}],"u":[{"r":[{"a":7}]}]}],"u":29,"r":[{"a":[{"p":[{"e":[{"r":[{".":36}]}]}]}]}],"y":[{"t":[{"h":247}]}]}],"d":56,"e":[{".":18,"a":[{"s":17,"w":5},1],"c":[{"o":151,"t":27}],"d":[{"e":95,"l":19},125],"g":[{"r":11},9],"i":32,"l":[{"e":2,"f":32,"v":32}],"m":[{"e":[{"s":[{"t":295}]},18],"o":[{"l":1}],"a":[{"p":[{"h":287}]}],"i":[{"t":[{"i":[{"c":296}]}]}]}],"n":[{"a":[{"t":5}],"c":18,"d":0,"e":[{"d":19}],"g":5,"i":[{"n":19}],"t":[{"d":18,"l":18}]}],"p":[{"a":152,"t":[{"e":[{"m":[{"b":11}]}]}]}],"r":[{".":43,"l":21,"o":0,"v":[{"o":18}]}],"s":[{"h":4,"t":5},72],"u":[{"m":113}],"v":[{"e":[{"n":11}]},32],"w":[{"i":0}],"x":32}],"f":47,"g":48,"h":[{".":25,"e":[{"r":2,"v":32}],"i":[{"n":2,"o":3,"p":27,"v":6}],"o":[{"l":[{"d":4}],"n":12,"r":[{"t":7},17],"e":[{"s":[{"t":137}]}]},0],"w":18},24],"i":[{"b":2,"c":[{"c":19}],"d":[{"e":[{".":27,"s":[{"t":6,"w":6},32],"d":[{".":8}]}],"i":[{"z":4},32]}],"g":[{"n":[{"a":18}]}],"l":[{"e":0,"y":18}],"n":[{"a":24,"e":[{".":32}],"g":23},42],"o":[{"n":[{"a":6},32]},41],"r":[{"a":5,"e":[{"s":[{"i":[{"d":4}]}]}]},9],"s":41,"t":[{"i":[{"o":27}]}],"u":32,"v":41,"z":32}],"k":[{"e":[{"t":23},18],"i":[{"n":[{"e":4,"g":4}]}],"y":[{"s":[{"c":15}]}]},9],"l":[{"a":[{"t":23}],"e":24,"i":[{"t":[{"h":7}]}],"o":[{"v":[{"a":[{"k":[{"i":[{"a":297}]}]}]}]}]},74],"m":[{"a":[{"l":[{"l":54}],"n":12},23],"e":[{"l":17,"n":19}],"i":[{"t":[{"h":32}]}],"o":[{"l":[{"d":49}]}]},42],"n":72,"o":[{"c":[{"e":1}],"f":[{"t":12}],"l":[{"a":[{"b":1}],"d":153,"i":[{"c":3}],"v":32,"u":[{"t":[{"e":9}]}]}],"m":27,"n":[{".":68,"a":17,"g":0}],"p":[{"h":[{"i":[{"c":32,"z":19}],"y":19}]},21],"r":[{"c":5,"d":5}],"v":[{"i":4},18],"g":[{"a":[{"m":[{"y":298}]}]}]},41],"p":[{"a":[{"i":32,"n":0,"c":[{"e":299,"i":[{"n":69}]}]},25],"e":[{"n":[{"d":17}],"o":57,"r":25,"c":[{"i":[{"o":11}]}]}],"h":[{"e":[{"r":[{"o":213},27]},24],"o":6}],"i":[{"l":17,"n":[{"g":4}],"o":18,"c":[{"i":[{"l":208}]}]}],"l":[{"y":21}],"o":[{"n":21,"r":[{"t":[{"s":[{"c":300,"w":300}]}]},17],"t":18,"k":[{"e":[{"s":[{"w":10}]}]}]}]}],"q":[{"u":[{"a":[{"l":[{"l":36}]}],"i":[{"t":[{"o":88}]}]}]}],"r":29,"s":[{"a":[{"s":12,"c":[{"h":[{"u":301}]}]},29],"c":94,"e":[{"l":23,"n":[{"g":19}],"s":[{".":21}],"t":19}],"i":[{"e":[{"r":0},21],"l":[{"y":4}],"a":[{"n":[{".":210}]}],"g":[{"n":[{"a":[{"b":302}]}]}]},29],"l":[{"i":1},21],"n":21,"p":[{"e":[{"n":[{"d":115}]}]}],"t":9,"u":[{"r":[{"a":6}]}],"w":4,"h":[{"a":[{"t":3}]}]},25],"t":[{".":25,"a":[{"g":24,"l":24,"m":[{"i":17,"p":69}],"n":[{"d":32,"t":[{"s":[{"h":[{"i":303}]}]}]}],"p":90,"t":[{".":32,"i":15}],"r":[{"t":[{"l":[{"i":12}]}]}]}],"e":[{"d":21,"r":[{"n":[{"i":7}],"o":19}],"w":[{"a":6},8]}],"h":[{"e":23}],"i":[{".":21,"a":19,"c":[{"k":32},29],"e":21,"f":23,"n":[{"g":3}],"r":32},9],"l":[{"e":29}],"o":[{"c":[{"k":32}],"m":[{"a":12}],"n":[{"e":32}],"p":21,"r":[{"e":27,"a":[{"b":304}]}]}],"r":[{"a":[{"d":21,"t":[{"u":32,"a":[{"g":305}]}],"y":21}],"i":[{"d":21,"b":[{"u":[{"t":7}]}]}],"y":18},1],"w":61,"y":[{"l":[{"i":[{"s":137}]}]},24],"b":4,"s":[{"c":[{"r":4}]}],"u":[{"p":[{"i":[{"d":306}]}]}]}],"u":[{"a":[{"l":2}],"b":111,"g":151,"i":[{"s":4,"t":12}],"l":21,"m":[{"i":11},9],"n":9,"r":9,"p":[{"e":[{"r":[{"e":307}]}]}]},41],"v":18,"w":[{"o":18,"i":[{"m":[{"m":177}]}]},9],"y":[{"c":18,"l":27,"n":[{"o":5,"c":41}],"r":[{"i":[{"n":4}]}],"t":[{"h":[{"i":308}]}]},21]}],"t":[{"a":[{".":27,"b":[{"l":[{"e":[{"s":4}]}],"o":[{"l":[{"i":[{"z":32,"s":[{"m":309}]}]}]}]},25],"c":[{"i":18}],"d":[{"o":4}],"f":46,"i":[{"l":[{"o":5}]}],"l":[{"a":4,"e":[{"n":5}],"i":11,"k":[{"a":204},18],"l":[{"i":[{"s":0}]}],"o":[{"g":4}]},9],"m":[{"o":4,"i":[{"n":82}]}],"n":[{"d":[{"e":0}],"t":[{"a":54}]}],"p":[{"e":[{"r":4}],"l":4,"a":[{"t":[{"h":310}]}]}],"r":[{"a":0,"c":18,"e":18,"i":[{"z":3}],"r":[{"h":311}]}],"s":[{"e":0,"y":4}],"t":[{"i":[{"c":18}],"u":[{"r":1}]}],"u":[{"n":17}],"v":0,"w":25,"x":[{"i":[{"s":0}]}],"g":[{"o":[{"n":[{".":3}]}]}]},41],"b":42,"c":[{"h":[{"e":[{"t":5}],"c":15,"i":[{"e":[{"r":237}]}]},21],"r":29},18],"d":43,"e":[{".":18,"a":[{"d":[{"i":17}],"t":18,"c":[{"h":[{"e":[{"r":[{".":36}]}]}]}]}],"c":[{"e":17,"t":32}],"d":[{"i":4},42],"e":41,"g":[{"e":[{"r":4}],"i":4},0],"l":[{".":27,"i":17,"s":32,"e":[{"g":84,"r":[{"o":249}]}]}],"m":[{"a":[{"t":11},154]}],"n":[{"a":[{"n":27}],"c":27,"d":27,"e":[{"s":18}],"t":[{"a":[{"g":0}]},41]}],"o":41,"p":[{"e":4},1],"r":[{"c":11,"d":155,"i":[{"e":[{"s":5}],"s":11,"z":[{"a":6}],"c":[{".":8}]},41],"n":[{"i":[{"t":32}]}],"v":5,"g":[{"e":[{"i":312}]}]}],"s":[{".":18,"s":[{".":23,"e":[{"s":313}]},18]}],"t":[{"h":[{"e":6}]}],"u":27,"x":27,"y":18}],"f":42,"g":43,"h":[{".":25,"a":[{"n":17,"l":[{"a":[{"m":228}]}]}],"e":[{"a":[{"s":3,"t":5},18],"i":[{"s":11}],"t":27},9],"i":[{"c":[{".":4,"a":4}],"l":18,"n":[{"k":32}]}],"l":18,"o":[{"d":[{"e":4,"i":[{"c":32}],"o":[{"n":11}]}],"o":18,"r":[{"i":[{"t":6,"z":5}]}],"g":[{"e":[{"n":[{"i":314}]}]}],"k":[{"e":[{"r":175}]}]}],"s":25,"y":[{"l":[{"a":[{"n":228}]}],"s":[{"c":11}]}]}],"i":[{"a":[{"b":1,"t":[{"o":1}],"n":[{".":70}]},41],"b":156,"c":[{"k":18,"o":21,"u":157}],"d":[{"i":32}],"e":[{"n":27}],"f":[{"y":4},8],"g":[{"u":32},25],"l":[{"l":[{"i":[{"n":6}]}]}],"m":[{"p":18,"u":[{"l":5}]},41],"n":[{"a":24,"e":[{".":27}],"i":27,"o":[{"m":285}]},42],"o":[{"c":4,"n":[{"e":[{"e":6}]}]},41],"q":32,"s":[{"a":3,"e":27,"m":0,"o":4,"p":0,"t":[{"i":[{"c":[{"a":32}]}]}]}],"t":[{"l":3}],"u":1,"v":[{"a":0},41],"z":[{"a":3,"e":[{"n":3}]},41]}],"l":[{"a":[{"n":17},19],"e":[{".":27,"d":27,"s":[{".":27}],"t":[{".":19}]}],"o":19,"i":[{"e":[{"r":315}]}]},25],"m":[{"e":0},43],"n":81,"o":[{"b":3,"c":[{"r":[{"a":[{"t":4}]}]}],"d":[{"o":18}],"f":25,"g":[{"r":9}],"i":[{"c":4}],"m":[{"a":9,"b":0,"y":3}],"n":[{"a":[{"l":[{"i":0}],"t":3}],"o":18,"y":18}],"r":[{"a":9,"i":[{"e":3,"z":5}]}],"s":8,"u":[{"r":32,"t":18}],"w":[{"a":[{"r":3}]}],"l":[{"o":[{"g":[{"y":84}]}]}],"t":[{"i":[{"c":11}]}]},41],"p":43,"r":[{"a":[{"b":11,"c":[{"h":5,"i":[{"t":17},36],"t":[{"e":17}]}],"s":17,"v":[{"e":[{"n":5,"s":158,"r":[{"s":[{"a":[{"b":317}]},15]}]}]}],"i":[{"t":[{"o":[{"r":316}]}]}]},41],"e":[{"f":5,"m":[{"i":6},0],"a":[{"c":[{"h":[{"e":318}]}]}]}],"i":[{"a":[{"l":[{".":1}]},32],"c":[{"e":[{"s":5}],"i":[{"a":32}],"s":18}],"m":25,"v":0}],"o":[{"m":[{"i":5}],"n":[{"i":6,"y":18}],"p":[{"h":[{"e":5}],"i":[{"s":175}],"o":[{"l":[{"e":[{"s":320}],"i":[{"s":320,"t":321}]}]}]}],"s":[{"p":11}],"v":11,"l":[{"e":[{"u":[{"m":319}]}]}],"f":[{"i":[{"c":[{".":17}],"t":11}]}]}],"u":[{"i":5,"s":17}]}],"s":[{"c":[{"h":[{"i":[{"e":12}]}]},21],"h":0,"w":21},101],"t":[{"e":[{"s":21}],"o":19,"u":0,"r":[{"i":[{"b":[{"u":[{"t":322}]}]}]}]},66],"u":[{"a":[{"r":3},2],"b":[{"i":1}],"d":8,"e":18,"f":46,"i":76,"m":27,"n":[{"i":[{"s":1}]}],"p":[{".":48}],"r":[{"e":27,"i":[{"s":11},32],"o":5,"y":4,"n":[{"a":[{"r":12}]}]}],"s":27},41],"v":18,"w":[{"a":43,"i":[{"s":17}],"o":18,"h":29},1],"y":[{"a":18,"l":25,"p":[{"e":12,"h":4,"a":[{"l":64}]}]},41],"z":[{"e":1},18]}],"u":[{"a":[{"b":18,"c":0,"n":[{"a":4,"i":0}],"r":[{"a":[{"n":[{"t":5}]}],"d":8,"i":11,"t":11}],"t":29,"v":0,"d":[{"r":[{"a":[{"t":[{"i":3,"u":15}]}]}]}]}],"b":[{"e":[{"l":21,"r":[{"o":21},23]},1],"i":[{"n":[{"g":33}]},72],"l":[{"e":[{".":23}]}]}],"c":[{"a":23,"i":[{"b":0,"t":1}],"l":[{"e":12}],"r":23,"u":23,"y":21}],"d":[{"d":4,"e":[{"r":3,"s":[{"t":4}],"v":17}],"i":[{"c":29,"e":[{"d":3,"s":3}],"s":4,"t":19}],"o":[{"n":[{"y":232},21]}],"s":[{"i":1}],"u":21}],"e":[{"n":[{"e":21,"s":17,"t":[{"e":0}]}],"r":[{"i":[{"l":0}]}],"a":[{"m":15}]}],"f":[{"a":27,"l":23}],"g":[{"h":[{"e":[{"n":11}]}],"i":[{"n":4}]}],"i":[{"l":[{"i":[{"z":5}]}],"n":[{"g":29},1],"r":[{"m":0}],"t":[{"a":17}],"v":[{"e":[{"r":[{".":0}]}]},11]},156],"j":19,"k":18,"l":[{"a":[{"b":5,"t":[{"i":19}]},29],"c":[{"h":[{"e":32},17]}],"d":[{"e":[{"r":3}]}],"e":[{"n":29},1],"g":[{"i":1}],"i":[{"a":19,"n":[{"g":3}],"s":[{"h":4}]},9],"l":[{"a":[{"r":1}],"i":[{"b":96,"s":1}]}],"m":61,"o":72,"s":[{"e":[{"s":5}]},18],"t":[{"i":2,"r":[{"a":54}],"u":18}],"u":[{"l":4},23],"v":4}],"m":[{"a":[{"b":4}],"b":[{"i":1,"l":[{"y":1}]}],"i":[{"n":[{"g":83}]},29],"o":[{"r":[{"o":6}]}],"p":9}],"n":[{"a":[{"t":17}],"e":[{"r":1},24],"i":[{"m":1,"n":24,"s":[{"h":4}],"v":11},29],"s":[{"w":1},93],"t":[{"a":[{"b":11}],"e":[{"r":[{".":1}],"s":1}]}],"u":0,"y":4,"z":4}],"o":[{"r":[{"s":21}],"s":19,"u":29}],"p":[{"e":[{"r":[{"s":6}]},29],"i":[{"a":19,"n":[{"g":3}]}],"l":23,"p":[{"o":[{"r":[{"t":10}]}]},3],"t":[{"i":[{"b":5}],"u":17}]}],"r":[{"a":[{".":18,"g":21,"s":21,"l":[{".":216}]},29],"b":[{"e":1}],"c":0,"d":2,"e":[{"a":[{"t":5}]}],"f":[{"e":[{"r":1}],"r":1}],"i":[{"f":[{"i":[{"c":0}]},23],"n":2,"o":23,"t":29,"z":3,"a":[{"l":[{".":0}]}]}],"l":[{"i":[{"n":[{"g":[{".":5}]}]}]},9],"n":[{"o":1}],"o":[{"s":17}],"p":[{"e":1,"i":1}],"s":[{"e":[{"r":5}]}],"t":[{"e":[{"s":4}],"h":[{"e":3}],"i":[{"e":1},17]}],"u":23}],"s":[{"a":[{"d":19,"n":19,"p":1}],"c":[{"i":3},8],"e":[{"a":5,"r":[{".":9}]}],"i":[{"a":19,"c":23}],"l":[{"i":[{"n":1}]}],"p":2,"s":[{"l":4}],"t":[{"e":[{"r":[{"e":4}]}],"r":2}],"u":[{"r":17},24]},25],"t":[{"a":[{"b":0,"t":23}],"e":[{".":18,"l":18,"n":[{"i":17},18]}],"i":[{"l":[{"i":[{"z":5}]}],"n":[{"e":23,"g":3}],"o":[{"n":[{"a":7}]}],"s":21,"z":31},101],"l":34,"o":[{"f":4,"g":5,"m":[{"a":[{"t":[{"i":[{"c":5}]}]}]}],"n":19,"u":21}],"s":0}],"u":[{"m":1},23],"v":74,"x":[{"u":11}],"z":[{"e":1}]}],"v":[{"a":[{".":32,"b":159,"c":[{"i":[{"l":5}],"u":11}],"g":[{"e":1,"u":[{"e":[{"r":170}]}]},0],"l":[{"i":[{"e":4}],"o":5,"u":15}],"m":[{"o":4}],"n":[{"i":[{"z":4}]}],"p":[{"i":4}],"r":[{"i":[{"e":[{"d":5}]}]}],"t":[{"i":[{"v":29}]},27],"u":[{"d":[{"e":[{"v":54}]}]}]},41],"e":[{".":18,"d":18,"g":11,"l":[{".":23,"l":[{"i":11}],"o":1,"y":21}],"n":[{"o":[{"m":11}],"u":[{"e":19}]}],"r":[{"d":21,"e":[{".":32,"l":[{"y":[{".":41}]},21],"n":[{"c":5},23],"s":21,"i":[{"g":324}]}],"i":[{"e":11}],"m":[{"i":[{"n":36}]}],"s":[{"e":27}],"t":[{"h":11}]}],"s":[{".":18,"t":[{"e":0,"i":[{"t":[{"e":15}]}]}]},99],"t":[{"e":[{"r":11},1],"y":1}]}],"i":[{"a":[{"l":[{"i":4}],"n":32}],"d":[{"e":[{".":32,"d":32,"n":47,"s":32}],"i":32}],"f":23,"g":[{"n":4}],"k":0,"l":[{"i":[{"t":32,"z":127}]},25],"n":[{"a":26,"c":24,"d":5,"g":18},29],"o":[{"l":11,"r":73,"u":2}],"p":1,"r":[{"o":4}],"s":[{"i":[{"t":11}],"o":3,"u":3}],"t":[{"i":18,"r":11,"y":18}],"v":[{"i":[{"p":[{"a":[{"r":325}]}]}]},27]}],"o":[{".":32,"i":[{"r":[{"d":[{"u":323}]}],"c":[{"e":[{"p":213}]}]},0],"k":27,"l":[{"a":1,"e":19,"t":32,"v":27}],"m":[{"i":5}],"r":[{"a":[{"b":5}],"i":17,"y":1}],"t":[{"a":1,"e":[{"e":18}]}]}],"v":26,"y":21}],"w":[{"a":[{"b":[{"l":19}],"c":25,"g":[{"e":[{"r":4}],"o":5}],"i":[{"t":6}],"l":[{".":19}],"m":0,"r":[{"t":0}],"s":[{"t":[{"e":[{"w":[{"a":326}]}]},0]}],"t":[{"e":2}],"v":[{"e":[{"r":4,"g":327}]}]}],"b":29,"e":[{"a":[{"r":[{"i":[{"e":5}]}],"t":[{"h":54}]}],"d":[{"n":0}],"e":[{"t":12,"v":5,"k":[{"n":137}]}],"l":[{"l":0}],"r":29,"s":[{"t":12}],"v":23}],"h":[{"i":0}],"i":[{"l":[{"l":[{"i":[{"n":6}]}]},8],"n":[{"d":[{"e":0}],"g":0}],"r":0,"s":[{"e":27}],"t":[{"h":12}],"z":5,"d":[{"e":[{"s":[{"p":6}]}]}]},9],"k":21,"l":[{"e":[{"s":1}],"i":[{"n":3}]}],"n":[{"o":21}],"o":[{"m":15,"v":[{"e":[{"n":4}]}],"k":[{"e":[{"n":85}]}]},160],"p":19,"r":[{"a":[{"p":[{"a":[{"r":[{"o":12}]}]}]},0],"i":[{"t":[{"a":36,"e":[{"r":[{".":183}]}]}]},0]}],"s":[{"h":23,"l":1,"p":[{"e":1}],"t":60}],"t":18,"y":1,"c":23}],"x":[{"a":[{"c":[{"e":5}],"g":[{"o":21}],"m":11,"p":21,"s":5},29],"c":161,"e":[{"c":[{"u":[{"t":[{"o":1}]}]}],"d":24,"r":[{"i":0,"o":4}]},29],"h":[{"i":[{"l":6},8],"u":0},29],"i":[{"a":4,"c":4,"d":[{"i":4}],"m":[{"e":21,"i":[{"z":4}]}]},23],"o":[{"b":21},23],"p":[{"a":[{"n":[{"d":17}]}],"e":[{"c":[{"t":[{"o":10}]}],"d":11}]},23],"t":[{"i":23},74],"u":[{"a":3},29],"x":1,"q":[{"u":[{"i":[{"s":54}]}]},29]}],"y":[{"a":[{"c":19,"r":110,"t":19}],"b":29,"c":[{"e":[{"r":4},24],"h":[{"e":[{"d":264},0]},23],"o":[{"m":17,"t":17}]},29],"d":29,"e":[{"e":19,"r":[{"f":21},29],"s":[{"t":[{"e":[{"r":[{"y":328}]}]}]},0],"t":1}],"g":[{"i":19}],"h":47,"i":29,"l":[{"a":23,"l":[{"a":[{"b":[{"l":6}]}]}],"o":23,"u":19}],"m":[{"b":[{"o":[{"l":7}]}],"e":[{"t":[{"r":[{"y":20}]}]},0],"p":[{"a":12}]}],"n":[{"c":[{"h":[{"r":3}]}],"d":4,"g":4,"i":[{"c":4}],"x":32}],"o":[{"d":4,"g":33,"m":0,"n":[{"e":[{"t":4}],"s":21}],"s":21},72],"p":[{"e":[{"d":21,"r":6}],"i":3,"o":[{"c":21},23],"t":[{"a":9}],"u":19}],"r":[{"a":[{"m":5}],"i":[{"a":4}],"o":23,"r":1}],"s":[{"c":1,"e":161,"i":[{"c":[{"a":3}],"o":3,"s":27}],"o":21,"s":0,"t":[{"a":3,"r":[{"o":29}]},2],"u":[{"r":17}]}],"t":[{"h":[{"i":[{"n":23}]}],"i":[{"c":3}]}],"w":29}],"z":[{"a":[{"b":79,"r":8},2],"b":18,"e":[{"n":1,"p":1,"r":[{"o":3},29],"t":0},25],"i":[{"l":21,"s":21,"a":[{"n":[{".":23}]}]},42],"l":32,"m":18,"o":[{"m":1,"o":[{"l":4}],"p":[{"h":[{"r":329}]}]},41],"t":[{"e":0}],"z":[{"y":21,"w":231},101]}]}',
        [
          "as-so-ciate",
          "as-so-ciates",
          "dec-li-na-tion",
          "oblig-a-tory",
          "phil-an-thropic",
          "present",
          "presents",
          "project",
          "projects",
          "reci-procity",
          "re-cog-ni-zance",
          "ref-or-ma-tion",
          "ret-ri-bu-tion",
          "ta-ble"
        ]
      ];
    });
  }
});

// ../../.yarn/unplugged/yoga-layout-npm-2.0.1-d25883a49a/node_modules/yoga-layout/src/generated/YGEnums.js
var require_YGEnums = __commonJS({
  "../../.yarn/unplugged/yoga-layout-npm-2.0.1-d25883a49a/node_modules/yoga-layout/src/generated/YGEnums.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.Wrap = exports2.Unit = exports2.PrintOptions = exports2.PositionType = exports2.Overflow = exports2.NodeType = exports2.MeasureMode = exports2.LogLevel = exports2.Justify = exports2.Gutter = exports2.FlexDirection = exports2.ExperimentalFeature = exports2.Errata = exports2.Edge = exports2.Display = exports2.Direction = exports2.Dimension = exports2.Align = void 0;
    var Align2 = function(Align3) {
      Align3[Align3["Auto"] = 0] = "Auto";
      Align3[Align3["FlexStart"] = 1] = "FlexStart";
      Align3[Align3["Center"] = 2] = "Center";
      Align3[Align3["FlexEnd"] = 3] = "FlexEnd";
      Align3[Align3["Stretch"] = 4] = "Stretch";
      Align3[Align3["Baseline"] = 5] = "Baseline";
      Align3[Align3["SpaceBetween"] = 6] = "SpaceBetween";
      Align3[Align3["SpaceAround"] = 7] = "SpaceAround";
      return Align3;
    }({});
    exports2.Align = Align2;
    var Dimension = function(Dimension2) {
      Dimension2[Dimension2["Width"] = 0] = "Width";
      Dimension2[Dimension2["Height"] = 1] = "Height";
      return Dimension2;
    }({});
    exports2.Dimension = Dimension;
    var Direction = function(Direction2) {
      Direction2[Direction2["Inherit"] = 0] = "Inherit";
      Direction2[Direction2["LTR"] = 1] = "LTR";
      Direction2[Direction2["RTL"] = 2] = "RTL";
      return Direction2;
    }({});
    exports2.Direction = Direction;
    var Display2 = function(Display3) {
      Display3[Display3["Flex"] = 0] = "Flex";
      Display3[Display3["None"] = 1] = "None";
      return Display3;
    }({});
    exports2.Display = Display2;
    var Edge2 = function(Edge3) {
      Edge3[Edge3["Left"] = 0] = "Left";
      Edge3[Edge3["Top"] = 1] = "Top";
      Edge3[Edge3["Right"] = 2] = "Right";
      Edge3[Edge3["Bottom"] = 3] = "Bottom";
      Edge3[Edge3["Start"] = 4] = "Start";
      Edge3[Edge3["End"] = 5] = "End";
      Edge3[Edge3["Horizontal"] = 6] = "Horizontal";
      Edge3[Edge3["Vertical"] = 7] = "Vertical";
      Edge3[Edge3["All"] = 8] = "All";
      return Edge3;
    }({});
    exports2.Edge = Edge2;
    var Errata = function(Errata2) {
      Errata2[Errata2["None"] = 0] = "None";
      Errata2[Errata2["StretchFlexBasis"] = 1] = "StretchFlexBasis";
      Errata2[Errata2["All"] = 2147483647] = "All";
      Errata2[Errata2["Classic"] = 2147483646] = "Classic";
      return Errata2;
    }({});
    exports2.Errata = Errata;
    var ExperimentalFeature = function(ExperimentalFeature2) {
      ExperimentalFeature2[ExperimentalFeature2["WebFlexBasis"] = 0] = "WebFlexBasis";
      ExperimentalFeature2[ExperimentalFeature2["AbsolutePercentageAgainstPaddingEdge"] = 1] = "AbsolutePercentageAgainstPaddingEdge";
      ExperimentalFeature2[ExperimentalFeature2["FixJNILocalRefOverflows"] = 2] = "FixJNILocalRefOverflows";
      return ExperimentalFeature2;
    }({});
    exports2.ExperimentalFeature = ExperimentalFeature;
    var FlexDirection2 = function(FlexDirection3) {
      FlexDirection3[FlexDirection3["Column"] = 0] = "Column";
      FlexDirection3[FlexDirection3["ColumnReverse"] = 1] = "ColumnReverse";
      FlexDirection3[FlexDirection3["Row"] = 2] = "Row";
      FlexDirection3[FlexDirection3["RowReverse"] = 3] = "RowReverse";
      return FlexDirection3;
    }({});
    exports2.FlexDirection = FlexDirection2;
    var Gutter2 = function(Gutter3) {
      Gutter3[Gutter3["Column"] = 0] = "Column";
      Gutter3[Gutter3["Row"] = 1] = "Row";
      Gutter3[Gutter3["All"] = 2] = "All";
      return Gutter3;
    }({});
    exports2.Gutter = Gutter2;
    var Justify2 = function(Justify3) {
      Justify3[Justify3["FlexStart"] = 0] = "FlexStart";
      Justify3[Justify3["Center"] = 1] = "Center";
      Justify3[Justify3["FlexEnd"] = 2] = "FlexEnd";
      Justify3[Justify3["SpaceBetween"] = 3] = "SpaceBetween";
      Justify3[Justify3["SpaceAround"] = 4] = "SpaceAround";
      Justify3[Justify3["SpaceEvenly"] = 5] = "SpaceEvenly";
      return Justify3;
    }({});
    exports2.Justify = Justify2;
    var LogLevel = function(LogLevel2) {
      LogLevel2[LogLevel2["Error"] = 0] = "Error";
      LogLevel2[LogLevel2["Warn"] = 1] = "Warn";
      LogLevel2[LogLevel2["Info"] = 2] = "Info";
      LogLevel2[LogLevel2["Debug"] = 3] = "Debug";
      LogLevel2[LogLevel2["Verbose"] = 4] = "Verbose";
      LogLevel2[LogLevel2["Fatal"] = 5] = "Fatal";
      return LogLevel2;
    }({});
    exports2.LogLevel = LogLevel;
    var MeasureMode2 = function(MeasureMode3) {
      MeasureMode3[MeasureMode3["Undefined"] = 0] = "Undefined";
      MeasureMode3[MeasureMode3["Exactly"] = 1] = "Exactly";
      MeasureMode3[MeasureMode3["AtMost"] = 2] = "AtMost";
      return MeasureMode3;
    }({});
    exports2.MeasureMode = MeasureMode2;
    var NodeType = function(NodeType2) {
      NodeType2[NodeType2["Default"] = 0] = "Default";
      NodeType2[NodeType2["Text"] = 1] = "Text";
      return NodeType2;
    }({});
    exports2.NodeType = NodeType;
    var Overflow2 = function(Overflow3) {
      Overflow3[Overflow3["Visible"] = 0] = "Visible";
      Overflow3[Overflow3["Hidden"] = 1] = "Hidden";
      Overflow3[Overflow3["Scroll"] = 2] = "Scroll";
      return Overflow3;
    }({});
    exports2.Overflow = Overflow2;
    var PositionType2 = function(PositionType3) {
      PositionType3[PositionType3["Static"] = 0] = "Static";
      PositionType3[PositionType3["Relative"] = 1] = "Relative";
      PositionType3[PositionType3["Absolute"] = 2] = "Absolute";
      return PositionType3;
    }({});
    exports2.PositionType = PositionType2;
    var PrintOptions = function(PrintOptions2) {
      PrintOptions2[PrintOptions2["Layout"] = 1] = "Layout";
      PrintOptions2[PrintOptions2["Style"] = 2] = "Style";
      PrintOptions2[PrintOptions2["Children"] = 4] = "Children";
      return PrintOptions2;
    }({});
    exports2.PrintOptions = PrintOptions;
    var Unit = function(Unit2) {
      Unit2[Unit2["Undefined"] = 0] = "Undefined";
      Unit2[Unit2["Point"] = 1] = "Point";
      Unit2[Unit2["Percent"] = 2] = "Percent";
      Unit2[Unit2["Auto"] = 3] = "Auto";
      return Unit2;
    }({});
    exports2.Unit = Unit;
    var Wrap2 = function(Wrap3) {
      Wrap3[Wrap3["NoWrap"] = 0] = "NoWrap";
      Wrap3[Wrap3["Wrap"] = 1] = "Wrap";
      Wrap3[Wrap3["WrapReverse"] = 2] = "WrapReverse";
      return Wrap3;
    }({});
    exports2.Wrap = Wrap2;
    var constants2 = {
      ALIGN_AUTO: Align2.Auto,
      ALIGN_FLEX_START: Align2.FlexStart,
      ALIGN_CENTER: Align2.Center,
      ALIGN_FLEX_END: Align2.FlexEnd,
      ALIGN_STRETCH: Align2.Stretch,
      ALIGN_BASELINE: Align2.Baseline,
      ALIGN_SPACE_BETWEEN: Align2.SpaceBetween,
      ALIGN_SPACE_AROUND: Align2.SpaceAround,
      DIMENSION_WIDTH: Dimension.Width,
      DIMENSION_HEIGHT: Dimension.Height,
      DIRECTION_INHERIT: Direction.Inherit,
      DIRECTION_LTR: Direction.LTR,
      DIRECTION_RTL: Direction.RTL,
      DISPLAY_FLEX: Display2.Flex,
      DISPLAY_NONE: Display2.None,
      EDGE_LEFT: Edge2.Left,
      EDGE_TOP: Edge2.Top,
      EDGE_RIGHT: Edge2.Right,
      EDGE_BOTTOM: Edge2.Bottom,
      EDGE_START: Edge2.Start,
      EDGE_END: Edge2.End,
      EDGE_HORIZONTAL: Edge2.Horizontal,
      EDGE_VERTICAL: Edge2.Vertical,
      EDGE_ALL: Edge2.All,
      ERRATA_NONE: Errata.None,
      ERRATA_STRETCH_FLEX_BASIS: Errata.StretchFlexBasis,
      ERRATA_ALL: Errata.All,
      ERRATA_CLASSIC: Errata.Classic,
      EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS: ExperimentalFeature.WebFlexBasis,
      EXPERIMENTAL_FEATURE_ABSOLUTE_PERCENTAGE_AGAINST_PADDING_EDGE: ExperimentalFeature.AbsolutePercentageAgainstPaddingEdge,
      EXPERIMENTAL_FEATURE_FIX_JNILOCAL_REF_OVERFLOWS: ExperimentalFeature.FixJNILocalRefOverflows,
      FLEX_DIRECTION_COLUMN: FlexDirection2.Column,
      FLEX_DIRECTION_COLUMN_REVERSE: FlexDirection2.ColumnReverse,
      FLEX_DIRECTION_ROW: FlexDirection2.Row,
      FLEX_DIRECTION_ROW_REVERSE: FlexDirection2.RowReverse,
      GUTTER_COLUMN: Gutter2.Column,
      GUTTER_ROW: Gutter2.Row,
      GUTTER_ALL: Gutter2.All,
      JUSTIFY_FLEX_START: Justify2.FlexStart,
      JUSTIFY_CENTER: Justify2.Center,
      JUSTIFY_FLEX_END: Justify2.FlexEnd,
      JUSTIFY_SPACE_BETWEEN: Justify2.SpaceBetween,
      JUSTIFY_SPACE_AROUND: Justify2.SpaceAround,
      JUSTIFY_SPACE_EVENLY: Justify2.SpaceEvenly,
      LOG_LEVEL_ERROR: LogLevel.Error,
      LOG_LEVEL_WARN: LogLevel.Warn,
      LOG_LEVEL_INFO: LogLevel.Info,
      LOG_LEVEL_DEBUG: LogLevel.Debug,
      LOG_LEVEL_VERBOSE: LogLevel.Verbose,
      LOG_LEVEL_FATAL: LogLevel.Fatal,
      MEASURE_MODE_UNDEFINED: MeasureMode2.Undefined,
      MEASURE_MODE_EXACTLY: MeasureMode2.Exactly,
      MEASURE_MODE_AT_MOST: MeasureMode2.AtMost,
      NODE_TYPE_DEFAULT: NodeType.Default,
      NODE_TYPE_TEXT: NodeType.Text,
      OVERFLOW_VISIBLE: Overflow2.Visible,
      OVERFLOW_HIDDEN: Overflow2.Hidden,
      OVERFLOW_SCROLL: Overflow2.Scroll,
      POSITION_TYPE_STATIC: PositionType2.Static,
      POSITION_TYPE_RELATIVE: PositionType2.Relative,
      POSITION_TYPE_ABSOLUTE: PositionType2.Absolute,
      PRINT_OPTIONS_LAYOUT: PrintOptions.Layout,
      PRINT_OPTIONS_STYLE: PrintOptions.Style,
      PRINT_OPTIONS_CHILDREN: PrintOptions.Children,
      UNIT_UNDEFINED: Unit.Undefined,
      UNIT_POINT: Unit.Point,
      UNIT_PERCENT: Unit.Percent,
      UNIT_AUTO: Unit.Auto,
      WRAP_NO_WRAP: Wrap2.NoWrap,
      WRAP_WRAP: Wrap2.Wrap,
      WRAP_WRAP_REVERSE: Wrap2.WrapReverse
    };
    var _default = constants2;
    exports2.default = _default;
  }
});

// ../../.yarn/unplugged/yoga-layout-npm-2.0.1-d25883a49a/node_modules/yoga-layout/src/wrapAssembly.js
var require_wrapAssembly = __commonJS({
  "../../.yarn/unplugged/yoga-layout-npm-2.0.1-d25883a49a/node_modules/yoga-layout/src/wrapAssembly.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = wrapAssembly;
    var _YGEnums = _interopRequireWildcard(require_YGEnums());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache2 = _getRequireWildcardCache(nodeInterop);
      if (cache2 && cache2.has(obj)) {
        return cache2.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache2) {
        cache2.set(obj, newObj);
      }
      return newObj;
    }
    function wrapAssembly(lib4) {
      function patch(prototype, name2, fn) {
        const original = prototype[name2];
        prototype[name2] = function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return fn.call(this, original, ...args);
        };
      }
      for (const fnName of ["setPosition", "setMargin", "setFlexBasis", "setWidth", "setHeight", "setMinWidth", "setMinHeight", "setMaxWidth", "setMaxHeight", "setPadding"]) {
        const methods = {
          [_YGEnums.Unit.Point]: lib4.Node.prototype[fnName],
          [_YGEnums.Unit.Percent]: lib4.Node.prototype[`${fnName}Percent`],
          [_YGEnums.Unit.Auto]: lib4.Node.prototype[`${fnName}Auto`]
        };
        patch(lib4.Node.prototype, fnName, function(original) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          const value2 = args.pop();
          let unit, asNumber;
          if (value2 === "auto") {
            unit = _YGEnums.Unit.Auto;
            asNumber = void 0;
          } else if (typeof value2 === "object") {
            unit = value2.unit;
            asNumber = value2.valueOf();
          } else {
            unit = typeof value2 === "string" && value2.endsWith("%") ? _YGEnums.Unit.Percent : _YGEnums.Unit.Point;
            asNumber = parseFloat(value2);
            if (!Number.isNaN(value2) && Number.isNaN(asNumber)) {
              throw new Error(`Invalid value ${value2} for ${fnName}`);
            }
          }
          if (!methods[unit]) throw new Error(`Failed to execute "${fnName}": Unsupported unit '${value2}'`);
          if (asNumber !== void 0) {
            return methods[unit].call(this, ...args, asNumber);
          } else {
            return methods[unit].call(this, ...args);
          }
        });
      }
      function wrapMeasureFunction(measureFunction) {
        return lib4.MeasureCallback.implement({
          measure: function() {
            const {
              width,
              height: height5
            } = measureFunction(...arguments);
            return {
              width: width ?? NaN,
              height: height5 ?? NaN
            };
          }
        });
      }
      patch(lib4.Node.prototype, "setMeasureFunc", function(original, measureFunc) {
        if (measureFunc) {
          return original.call(this, wrapMeasureFunction(measureFunc));
        } else {
          return this.unsetMeasureFunc();
        }
      });
      function wrapDirtiedFunc(dirtiedFunction) {
        return lib4.DirtiedCallback.implement({
          dirtied: dirtiedFunction
        });
      }
      patch(lib4.Node.prototype, "setDirtiedFunc", function(original, dirtiedFunc) {
        original.call(this, wrapDirtiedFunc(dirtiedFunc));
      });
      patch(lib4.Config.prototype, "free", function() {
        lib4.Config.destroy(this);
      });
      patch(lib4.Node, "create", (_, config3) => {
        return config3 ? lib4.Node.createWithConfig(config3) : lib4.Node.createDefault();
      });
      patch(lib4.Node.prototype, "free", function() {
        lib4.Node.destroy(this);
      });
      patch(lib4.Node.prototype, "freeRecursive", function() {
        for (let t2 = 0, T2 = this.getChildCount(); t2 < T2; ++t2) {
          this.getChild(0).freeRecursive();
        }
        this.free();
      });
      patch(lib4.Node.prototype, "calculateLayout", function(original) {
        let width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
        let height5 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
        let direction = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : _YGEnums.Direction.LTR;
        return original.call(this, width, height5, direction);
      });
      return {
        Config: lib4.Config,
        Node: lib4.Node,
        ..._YGEnums.default
      };
    }
  }
});

// ../../.yarn/unplugged/yoga-layout-npm-2.0.1-d25883a49a/node_modules/yoga-layout/binaries/wasm-async-web.js
var require_wasm_async_web = __commonJS({
  "../../.yarn/unplugged/yoga-layout-npm-2.0.1-d25883a49a/node_modules/yoga-layout/binaries/wasm-async-web.js"(exports2, module2) {
    var loadYoga3 = (() => {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      return function(loadYoga4) {
        loadYoga4 = loadYoga4 || {};
        var h2;
        h2 || (h2 = typeof loadYoga4 !== "undefined" ? loadYoga4 : {});
        var ba, ca;
        h2.ready = new Promise(function(a2, b) {
          ba = a2;
          ca = b;
        });
        var da = Object.assign({}, h2), q2 = "";
        "undefined" != typeof document && document.currentScript && (q2 = document.currentScript.src);
        _scriptDir && (q2 = _scriptDir);
        0 !== q2.indexOf("blob:") ? q2 = q2.substr(0, q2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : q2 = "";
        var ea = h2.print || console.log.bind(console), v2 = h2.printErr || console.warn.bind(console);
        Object.assign(h2, da);
        da = null;
        var w;
        h2.wasmBinary && (w = h2.wasmBinary);
        var noExitRuntime = h2.noExitRuntime || true;
        "object" != typeof WebAssembly && x("no native wasm support detected");
        var fa, ha = false;
        function ia(a2, b, c2) {
          c2 = b + c2;
          for (var d = ""; !(b >= c2); ) {
            var e = a2[b++];
            if (!e) break;
            if (e & 128) {
              var f = a2[b++] & 63;
              if (192 == (e & 224)) d += String.fromCharCode((e & 31) << 6 | f);
              else {
                var g = a2[b++] & 63;
                e = 224 == (e & 240) ? (e & 15) << 12 | f << 6 | g : (e & 7) << 18 | f << 12 | g << 6 | a2[b++] & 63;
                65536 > e ? d += String.fromCharCode(e) : (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023));
              }
            } else d += String.fromCharCode(e);
          }
          return d;
        }
        var ja, ka, z2, A2, la, C2, D, ma, na;
        function oa() {
          var a2 = fa.buffer;
          ja = a2;
          h2.HEAP8 = ka = new Int8Array(a2);
          h2.HEAP16 = A2 = new Int16Array(a2);
          h2.HEAP32 = C2 = new Int32Array(a2);
          h2.HEAPU8 = z2 = new Uint8Array(a2);
          h2.HEAPU16 = la = new Uint16Array(a2);
          h2.HEAPU32 = D = new Uint32Array(a2);
          h2.HEAPF32 = ma = new Float32Array(a2);
          h2.HEAPF64 = na = new Float64Array(a2);
        }
        var pa, qa = [], ra = [], sa = [];
        function ta() {
          var a2 = h2.preRun.shift();
          qa.unshift(a2);
        }
        var E = 0, ua = null, F = null;
        function x(a2) {
          if (h2.onAbort) h2.onAbort(a2);
          a2 = "Aborted(" + a2 + ")";
          v2(a2);
          ha = true;
          a2 = new WebAssembly.RuntimeError(a2 + ". Build with -sASSERTIONS for more info.");
          ca(a2);
          throw a2;
        }
        function va(a2) {
          return a2.startsWith("data:application/octet-stream;base64,");
        }
        var G2;
        G2 = "data:application/octet-stream;base64,AGFzbQEAAAABvgM4YAF/AGACf38AYAF/AX9gA39/fwBgAn98AGACf38Bf2ADf39/AX9gAABgA39/fABgAX8BfGADf399AX1gBX9/f39/AX9gAn9/AXxgAAF/YAZ/f31/fX8AYAR/f39/AX9gAn9/AX1gBn9/f39/fwF/YAV/f39/fwBgBH9/f38AYAN/fn8BfmAHf39/f39/fwBgBn9/f39/fwBgAn19AX1gAX0Bf2ABfwF9YAZ/fH9/f38Bf2ACf30AYAR/fHx/AGAIf39/f39/f38AYA1/f39/f39/f39/f39/AGAKf39/f39/f39/fwBgBX9/f39/AXxgBH9/fX0BfWAEfHx/fwF9YA5/fX1/f399fX9/f39/fwF/YAZ/f319f38AYAJ+fwF/YAR/fX1/AX1gA399fQF9YAF8AXxgBH98fHwAYAV/f319fQF9YA5/fX1/f399fX9/f39/fwBgB39/fX99f38AYA1/fX99f31/fX19fX1/AX9gBX9/fX19AGAEf39+fgBgB39/f39/f38Bf2ACfH8BfGAFf398fH8AYAN/f38BfWADf39/AXxgBH9/f3wAYAN/f30AYAZ/f31/fX8BfwKvAR0BYQFhAB0BYQFiAAMBYQFjABUBYQFkABIBYQFlAAcBYQFmAB4BYQFnAAABYQFoAB8BYQFpAAMBYQFqAAABYQFrABYBYQFsAAUBYQFtAAMBYQFuAAEBYQFvABYBYQFwAAYBYQFxAAABYQFyAAABYQFzACABYQF0ABMBYQF1AAsBYQF2ABUBYQF3AAIBYQF4AAMBYQF5AA8BYQF6AAIBYQFBAAEBYQFCABIBYQFDAAEDgwKBAgIXChAQCgoKIQIDEgAGBgcBBRgiGAYPCgMGIwMDBSQDGSUBDwoZAwMKAgUAAAIDAQMGAgcBCAwAFygHAAUAKQIBKistAwMGAgECAAEuCgUKLwcFEwIwCzECBwIAAgEGEwECAgEFAQAHAQURAQEBAQgIAQEAAg0CAgIFAQEBGwMNAQEBCwsGFAIBGhQGAgcCDgAAAAUyMzQMBQYINQUCAwUNDQ02AgMCAgIDBgICNwIMDAwBCQkJCQkJHAIAAAABAA4BBQICAQMCEAMMCQEBAQEBAQkJAQICAwICAgICAgMCCAEICAgEBAQEBAQEBAQABAQABAQEBAAEBAQBAQEICAEBBAcB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ABAAQQgQHSIAQQA2AgQgAEHxADYCAEGbN0GUC0EDQbglQe4kQecAIABBABAAQQgQHSIAQQA2AgQgAEHyADYCAEGbN0GdEUECQYAlQbgiQdMAIABBABAAQQgQHSIAQQA2AgQgAEHzADYCAEGbN0GxFEEDQbglQe4kQecAIABBABAAQQgQHSIAQQA2AgQgAEH0ADYCAEGbN0GUDEEDQbglQe4kQecAIABBABAAQQgQHSIAQQA2AgQgAEH1ADYCAEGbN0GHDUEDQbglQe4kQecAIABBABAAQQgQHSIAQQA2AgQgAEH2ADYCAEGbN0GlC0EDQbglQe4kQecAIABBABAAQQgQHSIAQQA2AgQgAEH3ADYCAEGbN0GHFEEDQbglQe4kQecAIABBABAAQQgQHSIAQQA2AgQgAEH4ADYCAEGbN0HxC0EDQbglQe4kQecAIABBABAAQQgQHSIAQQA2AgQgAEH5ADYCAEGbN0HZDEEDQbglQe4kQecAIABBABAAQQgQHSIAQQA2AgQgAEH6ADYCAEGbN0GAC0EDQbglQe4kQecAIABBABAAQQgQHSIAQQA2AgQgAEH7ADYCAEGbN0GBEkEDQbglQe4kQecAIABBABAAQQgQHSIAQQA2AgQgAEH8ADYCAEGbN0GtEEEEQaAlQbAlQdkAIABBABAAQQgQHSIAQQA2AgQgAEH9ADYCAEGbN0GfFUEEQaAlQbAlQdkAIABBABAAQQgQHSIAQQA2AgQgAEH+ADYCAEGbN0GnDEEEQaAlQbAlQdkAIABBABAAQQgQHSIAQQA2AgQgAEH/ADYCAEGbN0GMEUEEQaAlQbAlQdkAIABBABAAQQgQHSIAQQA2AgQgAEGAATYCAEGbN0GCF0ECQcQlQcQiQYEBIABBABAAQQgQHSIAQQA2AgQgAEGCATYCAEGbN0GrEkEDQcwlQaAjQYMBIABBABAAQQgQHSIAQQA2AgQgAEGEATYCAEGbN0HcCkECQcQlQcQiQYEBIABBABAAQQgQHSIAQQA2AgQgAEGFATYCAEGbN0GoDkECQcQlQcQiQYEBIABBABAAQQgQHSIAQQA2AgQgAEGGATYCAEGbN0HFFkECQcQlQcQiQYEBIABBABAAQQgQHSIAQQA2AgQgAEGHATYCAEGbN0HcEkECQcQlQcQiQYEBIABBABAAQQgQHSIAQQA2AgQgAEGI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ADoAACAAIAAoAiwiATYCHCAAIAE2AhQgAgsEAEIACwQAQQALigUCBn4CfyABIAEoAgBBB2pBeHEiAUEQajYCACAAIQkgASkDACEDIAEpAwghBiMAQSBrIggkAAJAIAZC////////////AIMiBEKAgICAgIDAgDx9IARCgICAgICAwP/DAH1UBEAgBkIEhiADQjyIhCEEIANC//////////8PgyIDQoGAgICAgICACFoEQCAEQoGAgICAgICAwAB8IQIMAgsgBEKAgICAgICAgEB9IQIgA0KAgICAgICAgAhSDQEgAiAEQgGDfCECDAELIANQIARCgICAgICAwP//AFQgBEKAgICAgIDA//8AURtFBEAgBkIEhiADQjyIhEL/////////A4NCgICAgICAgPz/AIQhAgwBC0KAgICAgICA+P8AIQIgBEL///////+//8MAVg0AQgAhAiAEQjCIpyIAQZH3AEkNACADIQIgBkL///////8/g0KAgICAgIDAAIQiBSEHAkAgAEGB9wBrIgFBwABxBEAgAiABQUBqrYYhB0IAIQIMAQsgAUUNACAHIAGtIgSGIAJBwAAgAWutiIQhByACIASGIQILIAggAjcDECAIIAc3AxgCQEGB+AAgAGsiAEHAAHEEQCAFIABBQGqtiCEDQgAhBQwBCyAARQ0AIAVBwAAgAGuthiADIACtIgKIhCEDIAUgAoghBQsgCCADNwMAIAggBTcDCCAIKQMIQgSGIAgpAwAiA0I8iIQhAiAIKQMQIAgpAxiEQgBSrSADQv//////////D4OEIgNCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyADQoCAgICAgICACFINACACQgGDIAJ8IQILIAhBIGokACAJIAIgBkKAgICAgICAgIB/g4S/OQMAC5gYAxJ/AXwDfiMAQbAEayIMJAAgDEEANgIsAkAgAb0iGUIAUwRAQQEhEUGZCSETIAGaIgG9IRkMAQsgBEGAEHEEQEEBIRFBnAkhEwwBC0GfCUGaCSAEQQFxIhEbIRMgEUUhFQsCQCAZQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEEgIAIgEUEDaiIDIARB//97cRAoIAAgEyARECcgAEGTE0GDGyAFQSBxIgUbQbQWQYcbIAUbIAEgAWIbQQMQJyAAQSAgAiADIARBgMAAcxAo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ABECAAsFAEGbNwsPACABIAAoAgBqIAI2AgALDQAgASAAKAIAaigCAAsYAQF/QRAQHSIAQgA3AwggAEEANgIAIAALGAEBf0EQEB0iAEIANwMAIABCADcDCCAACwwAQTAQHUEAQTAQKgs3AQF/IAEgACgCBCIDQQF1aiEBIAAoAgAhACABIAIgA0EBcQR/IAEoAgAgAGooAgAFIAALERsACwUAQZY3CyEAIAAgASgCACABIAEsAAtBAEgbQZM3IAIoAgAQDzYCAAsqAQF/QQwQHSIBQQA6AAQgASAAKAIANgIIIABBADYCACABQcgjNgIAIAELBQBBkzcLBQBBkDcLIQAgACABKAIAIAEgASwAC0EASBtB/DYgAigCABAPNgIAC9gBAQR/IwBBIGsiAyQAIAEoAgAiBEHw////B0kEQAJAAkAgBEELTwRAIARBD3JBAWoiBRAdIQYgAyAFQYCAgIB4cjYCECADIAY2AgggAyAENgIMIAQgBmohBQwBCyADIAQ6ABMgA0EIaiIGIARqIQUgBEUNAQsgBiABQQRqIAQQKxoLIAVBADoAACADIAI2AgAgA0EYaiADQQhqIAMgABEDACADKAIYEBAgAygCGCIAEAYgAygCABAGIAMsABNBAEgEQCADKAIIECkLIANBIGokACAADwsQBAALKgEBf0EMEB0iAUEAOgAEIAEgACgCADYCCCAAQQA2AgAgAUHQIjYCACABCwUAQfw2C2kBAn8jAEEQayIGJAAgASAAKAIEIgdBAXVqIQEgACgCACEAIAYgASACIAMgBCAFIAdBAXEEfyABKAIAIABqKAIABSAACxEOAEEQEB0iACAGKQMINwMIIAAgBikDADcDACAGQRBqJAAgAAsFAEH4NgubAQIBfwF9IwBBEGsiAiQAIAAoAgAhACABQQZIBEACfwJAAkACQCABQQRrDgIAAQILIABBpAJqIAAtAKwCQQNxQQJGDQIaIABBnAJqDAILIABBnAJqIAAtAKwCQQNxQQJGDQEaIABBpAJqDAELIAAgAUECdGpBnAJqCyoCACEDIAJBEGokACADuw8LIAJB0A42AgAgACACEC0QLAALmwECAX8BfSMAQRBrIgIkACAAKAIAIQAgAUEGSARAAn8CQAJAAkAgAUEEaw4CAAECCyAAQZQCaiAALQCsAkEDcUECRg0CGiAAQYwC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bXNlbHZlcyBhcyBkaXJ0eQBpc0RpcnR5AG1hcmtEaXJ0eQBkZXN0cm95AHNldERpc3BsYXkAZ2V0RGlzcGxheQBzZXRGbGV4AC0rICAgMFgweAAtMFgrMFggMFgtMHgrMHggMHgAc2V0RmxleEdyb3cAZ2V0RmxleEdyb3cAc2V0T3ZlcmZsb3cAZ2V0T3ZlcmZsb3cAY2FsY3VsYXRlTGF5b3V0AGdldENvbXB1dGVkTGF5b3V0AHVuc2lnbmVkIHNob3J0AGdldENoaWxkQ291bnQAdW5zaWduZWQgaW50AHNldEp1c3RpZnlDb250ZW50AGdldEp1c3RpZnlDb250ZW50AHNldEFsaWduQ29udGVudABnZXRBbGlnbkNvbnRlbnQAZ2V0UGFyZW50AGltcGxlbWVudABzZXRNYXhIZWlnaHRQZXJjZW50AHNldEhlaWdodFBlcmNlbnQAc2V0TWluSGVpZ2h0UGVyY2VudABzZXRGbGV4QmFzaXNQZXJjZW50AHNldFBvc2l0aW9uUGVyY2VudABzZXRNYXJnaW5QZXJjZW50AHNldE1heFdpZHRoUGVyY2VudABzZXRXaWR0aFBlcmNlbnQAc2V0TWluV2lkdGhQZXJjZW50AHNldFBhZGRpbmdQZXJjZW50AGNyZWF0ZURlZmF1bHQAdW5pdAByaWdodABoZWlnaHQAc2V0TWF4SGVpZ2h0AGdldE1heEhlaWdodABzZXRIZWlnaHQAZ2V0SGVpZ2h0AHNldE1pbkhlaWdodABnZXRNaW5IZWlnaHQAZ2V0Q29tcHV0ZWRIZWlnaHQAZ2V0Q29tcHV0ZWRSaWdodABsZWZ0AGdldENvbXB1dGVkTGVmdAByZXNldABfX2Rlc3RydWN0AGZsb2F0AHVpbnQ2NF90AHVzZVdlYkRlZmF1bHRzAHNldFVzZVdlYkRlZmF1bHRzAHNldEFsaWduSXRlbXMAZ2V0QWxpZ25JdGVtcwBzZXRGbGV4QmFzaXMAZ2V0RmxleEJhc2lzAENhbm5vdCBnZXQgbGF5b3V0IHByb3BlcnRpZXMgb2YgbXVsdGktZWRnZSBzaG9ydGhhbmRzAHVzZUxlZ2FjeVN0cmV0Y2hCZWhhdmlvdXIAc2V0VXNlTGVnYWN5U3RyZXRjaEJlaGF2aW91cgBzZXRQb2ludFNjYWxlRmFjdG9yAE1lYXN1cmVDYWxsYmFja1dyYXBwZXIARGlydGllZENhbGxiYWNrV3JhcHBlcgBDYW5ub3QgcmVzZXQgYSBub2RlIHN0aWxsIGF0dGFjaGVkIHRvIGEgb3duZXIAc2V0Qm9yZGVyAGdldEJvcmRlcgBnZXRDb21wdXRlZEJvcmRlcgB1bnNpZ25lZCBjaGFyAHRvcABnZXRDb21wdXRlZFRvcABzZXRGbGV4V3JhcABnZXRGbGV4V3JhcABzZXRHYXAAZ2V0R2FwACVwAHNldEhlaWdodEF1dG8Ac2V0RmxleEJhc2lzQXV0bwBzZXRNYXJnaW5BdXRvAHNldFdpZHRoQXV0bwBTY2FsZSBmYWN0b3Igc2hvdWxkIG5vdCBiZSBsZXNzIHRoYW4gemVybwBzZXRBc3BlY3RSYXRpbwBnZXRBc3BlY3RSYXRpbwBzZXRQb3NpdGlvbgBnZXRQb3NpdGlvbgBub3RpZnlPbkRlc3RydWN0aW9uAHNldEZsZXhEaXJlY3Rpb24AZ2V0RmxleERpcmVjdGlvbgBzZXRNYXJnaW4AZ2V0TWFyZ2luAGdldENvbXB1dGVkTWFyZ2luAG5hbgBib3R0b20AZ2V0Q29tcHV0ZWRCb3R0b20AYm9vbABlbXNjcmlwdGVuOjp2YWwAc2V0RmxleFNocmluawBnZXRGbGV4U2hyaW5rAE1lYXN1cmVDYWxsYmFjawBEaXJ0aWVkQ2FsbGJhY2sAd2lkdGgAc2V0TWF4V2lkdGgAZ2V0TWF4V2lkdGgAc2V0V2lkdGgAZ2V0V2lkdGgAc2V0TWluV2lkdGgAZ2V0TWluV2lkdGgAZ2V0Q29tcHV0ZWRXaWR0aAB1bnNpZ25lZCBsb25nAHN0ZDo6d3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBzZXRQYWRkaW5nAGdldFBhZGRpbmcAZ2V0Q29tcHV0ZWRQYWRkaW5nAEF0dGVtcHRpbmcgdG8gY29uc3RydWN0IFlHTm9kZSB3aXRoIG51bGwgY29uZmlnAFRyaWVkIHRvIGNvbnN0cnVjdCBZR05vZGUgd2l0aCBudWxsIGNvbmZpZwBjcmVhdGVXaXRoQ29uZmlnAGluZgBzZXRBbGlnblNlbGYAZ2V0QWxpZ25TZWxmAFNpemUAdmFsdWUAVmFsdWUAY3JlYXRlAG1lYXN1cmUAc2V0UG9zaXRpb25UeXBlAGdldFBvc2l0aW9uVHlwZQBpc1JlZmVyZW5jZUJhc2VsaW5lAHNldElzUmVmZXJlbmNlQmFzZWxpbmUAY29weVN0eWxlAGRvdWJsZQBOb2RlAGV4dGVuZABpbnNlcnRDaGlsZABnZXRDaGlsZAByZW1vdmVDaGlsZAB2b2lkAGF2YWlsYWJsZUhlaWdodCBpcyBpbmRlZmluaXRlIHNvIGhlaWdodE1lYXN1cmVNb2RlIG11c3QgYmUgWUdNZWFzdXJlTW9kZVVuZGVmaW5lZABhdmFpbGFibGVXaWR0aCBpcyBpbmRlZmluaXRlIHNvIHdpZHRoTWVhc3VyZU1vZGUgbXVzdCBiZSBZR01lYXN1cmVNb2RlVW5kZWZpbmVkAHNldEV4cGVyaW1lbnRhbEZlYXR1cmVFbmFibGVkAGlzRXhwZXJpbWVudGFsRmVhdHVyZUVuYWJsZWQAZGlydGllZABDYW5ub3QgcmVzZXQgYSBub2RlIHdoaWNoIHN0aWxsIGhhcyBjaGlsZHJlbiBhdHRhY2hlZAB1bnNldE1lYXN1cmVGdW5jAHVuc2V0RGlydGllZEZ1bmMAc2V0RXJyYXRhAGdldEVycmF0YQBFeHBlY3QgY3VzdG9tIGJhc2VsaW5lIGZ1bmN0aW9uIHRvIG5vdCByZXR1cm4gTmFOAE5BTgBJTkYAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVp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";
        if (!va(G2)) {
          var wa = G2;
          G2 = h2.locateFile ? h2.locateFile(wa, q2) : q2 + wa;
        }
        function xa() {
          var a2 = G2;
          try {
            if (a2 == G2 && w) return new Uint8Array(w);
            if (va(a2)) try {
              var b = ya(a2.slice(37)), c2 = new Uint8Array(b.length);
              for (a2 = 0; a2 < b.length; ++a2) c2[a2] = b.charCodeAt(a2);
              var d = c2;
            } catch (f) {
              throw Error("Converting base64 string to bytes failed.");
            }
            else d = void 0;
            var e = d;
            if (e) return e;
            throw "both async and sync fetching of the wasm failed";
          } catch (f) {
            x(f);
          }
        }
        function za() {
          return w || "function" != typeof fetch ? Promise.resolve().then(function() {
            return xa();
          }) : fetch(G2, { credentials: "same-origin" }).then(function(a2) {
            if (!a2.ok) throw "failed to load wasm binary file at '" + G2 + "'";
            return a2.arrayBuffer();
          }).catch(function() {
            return xa();
          });
        }
        function Aa(a2) {
          for (; 0 < a2.length; ) a2.shift()(h2);
        }
        function Ba(a2) {
          if (void 0 === a2) return "_unknown";
          a2 = a2.replace(/[^a-zA-Z0-9_]/g, "$");
          var b = a2.charCodeAt(0);
          return 48 <= b && 57 >= b ? "_" + a2 : a2;
        }
        function Ca(a2, b) {
          a2 = Ba(a2);
          return function() {
            return b.apply(this, arguments);
          };
        }
        var H2 = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }], Da = [];
        function Ea(a2) {
          var b = Error, c2 = Ca(a2, function(d) {
            this.name = a2;
            this.message = d;
            d = Error(d).stack;
            void 0 !== d && (this.stack = this.toString() + "\n" + d.replace(/^Error(:[^\n]*)?\n/, ""));
          });
          c2.prototype = Object.create(b.prototype);
          c2.prototype.constructor = c2;
          c2.prototype.toString = function() {
            return void 0 === this.message ? this.name : this.name + ": " + this.message;
          };
          return c2;
        }
        var J = void 0;
        function K(a2) {
          throw new J(a2);
        }
        var L2 = (a2) => {
          a2 || K("Cannot use deleted val. handle = " + a2);
          return H2[a2].value;
        }, Fa = (a2) => {
          switch (a2) {
            case void 0:
              return 1;
            case null:
              return 2;
            case true:
              return 3;
            case false:
              return 4;
            default:
              var b = Da.length ? Da.pop() : H2.length;
              H2[b] = { fa: 1, value: a2 };
              return b;
          }
        }, Ga = void 0, Ha = void 0;
        function M2(a2) {
          for (var b = ""; z2[a2]; ) b += Ha[z2[a2++]];
          return b;
        }
        var N = [];
        function Ia() {
          for (; N.length; ) {
            var a2 = N.pop();
            a2.L.Z = false;
            a2["delete"]();
          }
        }
        var O = void 0, P = {};
        function Ja(a2, b) {
          for (void 0 === b && K("ptr should not be undefined"); a2.P; ) b = a2.aa(b), a2 = a2.P;
          return b;
        }
        var Q2 = {};
        function Ka(a2) {
          a2 = La(a2);
          var b = M2(a2);
          R(a2);
          return b;
        }
        function Ma(a2, b) {
          var c2 = Q2[a2];
          void 0 === c2 && K(b + " has unknown type " + Ka(a2));
          return c2;
        }
        function Na() {
        }
        var Oa = false;
        function Pa(a2) {
          --a2.count.value;
          0 === a2.count.value && (a2.S ? a2.T.V(a2.S) : a2.O.M.V(a2.N));
        }
        function Qa(a2, b, c2) {
          if (b === c2) return a2;
          if (void 0 === c2.P) return null;
          a2 = Qa(a2, b, c2.P);
          return null === a2 ? null : c2.ma(a2);
        }
        var Ra = {};
        function Sa(a2, b) {
          b = Ja(a2, b);
          return P[b];
        }
        var Ta = void 0;
        function Ua(a2) {
          throw new Ta(a2);
        }
        function Va(a2, b) {
          b.O && b.N || Ua("makeClassHandle requires ptr and ptrType");
          !!b.T !== !!b.S && Ua("Both smartPtrType and smartPtr must be specified");
          b.count = { value: 1 };
          return S2(Object.create(a2, { L: { value: b } }));
        }
        function S2(a2) {
          if ("undefined" === typeof FinalizationRegistry) return S2 = (b) => b, a2;
          Oa = new FinalizationRegistry((b) => {
            Pa(b.L);
          });
          S2 = (b) => {
            var c2 = b.L;
            c2.S && Oa.register(b, { L: c2 }, b);
            return b;
          };
          Na = (b) => {
            Oa.unregister(b);
          };
          return S2(a2);
        }
        var Wa = {};
        function Xa(a2) {
          for (; a2.length; ) {
            var b = a2.pop();
            a2.pop()(b);
          }
        }
        function T2(a2) {
          return this.fromWireType(C2[a2 >> 2]);
        }
        var U = {}, Ya = {};
        function V2(a2, b, c2) {
          function d(k) {
            k = c2(k);
            k.length !== a2.length && Ua("Mismatched type converter count");
            for (var m2 = 0; m2 < a2.length; ++m2) W(a2[m2], k[m2]);
          }
          a2.forEach(function(k) {
            Ya[k] = b;
          });
          var e = Array(b.length), f = [], g = 0;
          b.forEach((k, m2) => {
            Q2.hasOwnProperty(k) ? e[m2] = Q2[k] : (f.push(k), U.hasOwnProperty(k) || (U[k] = []), U[k].push(() => {
              e[m2] = Q2[k];
              ++g;
              g === f.length && d(e);
            }));
          });
          0 === f.length && d(e);
        }
        function Za(a2) {
          switch (a2) {
            case 1:
              return 0;
            case 2:
              return 1;
            case 4:
              return 2;
            case 8:
              return 3;
            default:
              throw new TypeError("Unknown type size: " + a2);
          }
        }
        function W(a2, b, c2 = {}) {
          if (!("argPackAdvance" in b)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
          var d = b.name;
          a2 || K('type "' + d + '" must have a positive integer typeid pointer');
          if (Q2.hasOwnProperty(a2)) {
            if (c2.ta) return;
            K("Cannot register type '" + d + "' twice");
          }
          Q2[a2] = b;
          delete Ya[a2];
          U.hasOwnProperty(a2) && (b = U[a2], delete U[a2], b.forEach((e) => e()));
        }
        function $a(a2) {
          K(a2.L.O.M.name + " instance already deleted");
        }
        function X() {
        }
        function ab(a2, b, c2) {
          if (void 0 === a2[b].R) {
            var d = a2[b];
            a2[b] = function() {
              a2[b].R.hasOwnProperty(arguments.length) || K("Function '" + c2 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a2[b].R + ")!");
              return a2[b].R[arguments.length].apply(this, arguments);
            };
            a2[b].R = [];
            a2[b].R[d.Y] = d;
          }
        }
        function bb(a2, b) {
          h2.hasOwnProperty(a2) ? (K("Cannot register public name '" + a2 + "' twice"), ab(h2, a2, a2), h2.hasOwnProperty(void 0) && K("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), h2[a2].R[void 0] = b) : h2[a2] = b;
        }
        function cb(a2, b, c2, d, e, f, g, k) {
          this.name = a2;
          this.constructor = b;
          this.W = c2;
          this.V = d;
          this.P = e;
          this.oa = f;
          this.aa = g;
          this.ma = k;
          this.ia = [];
        }
        function db(a2, b, c2) {
          for (; b !== c2; ) b.aa || K("Expected null or instance of " + c2.name + ", got an instance of " + b.name), a2 = b.aa(a2), b = b.P;
          return a2;
        }
        function eb(a2, b) {
          if (null === b) return this.da && K("null is not a valid " + this.name), 0;
          b.L || K('Cannot pass "' + fb(b) + '" as a ' + this.name);
          b.L.N || K("Cannot pass deleted object as a pointer of type " + this.name);
          return db(b.L.N, b.L.O.M, this.M);
        }
        function gb(a2, b) {
          if (null === b) {
            this.da && K("null is not a valid " + this.name);
            if (this.ca) {
              var c2 = this.ea();
              null !== a2 && a2.push(this.V, c2);
              return c2;
            }
            return 0;
          }
          b.L || K('Cannot pass "' + fb(b) + '" as a ' + this.name);
          b.L.N || K("Cannot pass deleted object as a pointer of type " + this.name);
          !this.ba && b.L.O.ba && K("Cannot convert argument of type " + (b.L.T ? b.L.T.name : b.L.O.name) + " to parameter type " + this.name);
          c2 = db(b.L.N, b.L.O.M, this.M);
          if (this.ca) switch (void 0 === b.L.S && K("Passing raw pointer to smart pointer is illegal"), this.Aa) {
            case 0:
              b.L.T === this ? c2 = b.L.S : K("Cannot convert argument of type " + (b.L.T ? b.L.T.name : b.L.O.name) + " to parameter type " + this.name);
              break;
            case 1:
              c2 = b.L.S;
              break;
            case 2:
              if (b.L.T === this) c2 = b.L.S;
              else {
                var d = b.clone();
                c2 = this.wa(c2, Fa(function() {
                  d["delete"]();
                }));
                null !== a2 && a2.push(this.V, c2);
              }
              break;
            default:
              K("Unsupporting sharing policy");
          }
          return c2;
        }
        function hb(a2, b) {
          if (null === b) return this.da && K("null is not a valid " + this.name), 0;
          b.L || K('Cannot pass "' + fb(b) + '" as a ' + this.name);
          b.L.N || K("Cannot pass deleted object as a pointer of type " + this.name);
          b.L.O.ba && K("Cannot convert argument of type " + b.L.O.name + " to parameter type " + this.name);
          return db(b.L.N, b.L.O.M, this.M);
        }
        function Y(a2, b, c2, d) {
          this.name = a2;
          this.M = b;
          this.da = c2;
          this.ba = d;
          this.ca = false;
          this.V = this.wa = this.ea = this.ja = this.Aa = this.va = void 0;
          void 0 !== b.P ? this.toWireType = gb : (this.toWireType = d ? eb : hb, this.U = null);
        }
        function ib(a2, b) {
          h2.hasOwnProperty(a2) || Ua("Replacing nonexistant public symbol");
          h2[a2] = b;
          h2[a2].Y = void 0;
        }
        function jb(a2, b) {
          var c2 = [];
          return function() {
            c2.length = 0;
            Object.assign(c2, arguments);
            if (a2.includes("j")) {
              var d = h2["dynCall_" + a2];
              d = c2 && c2.length ? d.apply(null, [b].concat(c2)) : d.call(null, b);
            } else d = pa.get(b).apply(null, c2);
            return d;
          };
        }
        function Z2(a2, b) {
          a2 = M2(a2);
          var c2 = a2.includes("j") ? jb(a2, b) : pa.get(b);
          "function" != typeof c2 && K("unknown function pointer with signature " + a2 + ": " + b);
          return c2;
        }
        var mb = void 0;
        function nb(a2, b) {
          function c2(f) {
            e[f] || Q2[f] || (Ya[f] ? Ya[f].forEach(c2) : (d.push(f), e[f] = true));
          }
          var d = [], e = {};
          b.forEach(c2);
          throw new mb(a2 + ": " + d.map(Ka).join([", "]));
        }
        function ob(a2, b, c2, d, e) {
          var f = b.length;
          2 > f && K("argTypes array size mismatch! Must at least get return value and 'this' types!");
          var g = null !== b[1] && null !== c2, k = false;
          for (c2 = 1; c2 < b.length; ++c2) if (null !== b[c2] && void 0 === b[c2].U) {
            k = true;
            break;
          }
          var m2 = "void" !== b[0].name, l2 = f - 2, n = Array(l2), p = [], r = [];
          return function() {
            arguments.length !== l2 && K("function " + a2 + " called with " + arguments.length + " arguments, expected " + l2 + " args!");
            r.length = 0;
            p.length = g ? 2 : 1;
            p[0] = e;
            if (g) {
              var u = b[1].toWireType(r, this);
              p[1] = u;
            }
            for (var t2 = 0; t2 < l2; ++t2) n[t2] = b[t2 + 2].toWireType(r, arguments[t2]), p.push(n[t2]);
            t2 = d.apply(null, p);
            if (k) Xa(r);
            else for (var y = g ? 1 : 2; y < b.length; y++) {
              var B = 1 === y ? u : n[y - 2];
              null !== b[y].U && b[y].U(B);
            }
            u = m2 ? b[0].fromWireType(t2) : void 0;
            return u;
          };
        }
        function pb(a2, b) {
          for (var c2 = [], d = 0; d < a2; d++) c2.push(D[b + 4 * d >> 2]);
          return c2;
        }
        function qb(a2) {
          4 < a2 && 0 === --H2[a2].fa && (H2[a2] = void 0, Da.push(a2));
        }
        function fb(a2) {
          if (null === a2) return "null";
          var b = typeof a2;
          return "object" === b || "array" === b || "function" === b ? a2.toString() : "" + a2;
        }
        function rb(a2, b) {
          switch (b) {
            case 2:
              return function(c2) {
                return this.fromWireType(ma[c2 >> 2]);
              };
            case 3:
              return function(c2) {
                return this.fromWireType(na[c2 >> 3]);
              };
            default:
              throw new TypeError("Unknown float type: " + a2);
          }
        }
        function sb(a2, b, c2) {
          switch (b) {
            case 0:
              return c2 ? function(d) {
                return ka[d];
              } : function(d) {
                return z2[d];
              };
            case 1:
              return c2 ? function(d) {
                return A2[d >> 1];
              } : function(d) {
                return la[d >> 1];
              };
            case 2:
              return c2 ? function(d) {
                return C2[d >> 2];
              } : function(d) {
                return D[d >> 2];
              };
            default:
              throw new TypeError("Unknown integer type: " + a2);
          }
        }
        function tb(a2, b) {
          for (var c2 = "", d = 0; !(d >= b / 2); ++d) {
            var e = A2[a2 + 2 * d >> 1];
            if (0 == e) break;
            c2 += String.fromCharCode(e);
          }
          return c2;
        }
        function ub(a2, b, c2) {
          void 0 === c2 && (c2 = 2147483647);
          if (2 > c2) return 0;
          c2 -= 2;
          var d = b;
          c2 = c2 < 2 * a2.length ? c2 / 2 : a2.length;
          for (var e = 0; e < c2; ++e) A2[b >> 1] = a2.charCodeAt(e), b += 2;
          A2[b >> 1] = 0;
          return b - d;
        }
        function vb(a2) {
          return 2 * a2.length;
        }
        function wb(a2, b) {
          for (var c2 = 0, d = ""; !(c2 >= b / 4); ) {
            var e = C2[a2 + 4 * c2 >> 2];
            if (0 == e) break;
            ++c2;
            65536 <= e ? (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023)) : d += String.fromCharCode(e);
          }
          return d;
        }
        function xb(a2, b, c2) {
          void 0 === c2 && (c2 = 2147483647);
          if (4 > c2) return 0;
          var d = b;
          c2 = d + c2 - 4;
          for (var e = 0; e < a2.length; ++e) {
            var f = a2.charCodeAt(e);
            if (55296 <= f && 57343 >= f) {
              var g = a2.charCodeAt(++e);
              f = 65536 + ((f & 1023) << 10) | g & 1023;
            }
            C2[b >> 2] = f;
            b += 4;
            if (b + 4 > c2) break;
          }
          C2[b >> 2] = 0;
          return b - d;
        }
        function yb(a2) {
          for (var b = 0, c2 = 0; c2 < a2.length; ++c2) {
            var d = a2.charCodeAt(c2);
            55296 <= d && 57343 >= d && ++c2;
            b += 4;
          }
          return b;
        }
        var zb = {};
        function Ab(a2) {
          var b = zb[a2];
          return void 0 === b ? M2(a2) : b;
        }
        var Bb = [];
        function Cb(a2) {
          var b = Bb.length;
          Bb.push(a2);
          return b;
        }
        function Db(a2, b) {
          for (var c2 = Array(a2), d = 0; d < a2; ++d) c2[d] = Ma(D[b + 4 * d >> 2], "parameter " + d);
          return c2;
        }
        var Eb = [], Fb = [null, [], []];
        J = h2.BindingError = Ea("BindingError");
        h2.count_emval_handles = function() {
          for (var a2 = 0, b = 5; b < H2.length; ++b) void 0 !== H2[b] && ++a2;
          return a2;
        };
        h2.get_first_emval = function() {
          for (var a2 = 5; a2 < H2.length; ++a2) if (void 0 !== H2[a2]) return H2[a2];
          return null;
        };
        Ga = h2.PureVirtualError = Ea("PureVirtualError");
        for (var Gb = Array(256), Hb = 0; 256 > Hb; ++Hb) Gb[Hb] = String.fromCharCode(Hb);
        Ha = Gb;
        h2.getInheritedInstanceCount = function() {
          return Object.keys(P).length;
        };
        h2.getLiveInheritedInstances = function() {
          var a2 = [], b;
          for (b in P) P.hasOwnProperty(b) && a2.push(P[b]);
          return a2;
        };
        h2.flushPendingDeletes = Ia;
        h2.setDelayFunction = function(a2) {
          O = a2;
          N.length && O && O(Ia);
        };
        Ta = h2.InternalError = Ea("InternalError");
        X.prototype.isAliasOf = function(a2) {
          if (!(this instanceof X && a2 instanceof X)) return false;
          var b = this.L.O.M, c2 = this.L.N, d = a2.L.O.M;
          for (a2 = a2.L.N; b.P; ) c2 = b.aa(c2), b = b.P;
          for (; d.P; ) a2 = d.aa(a2), d = d.P;
          return b === d && c2 === a2;
        };
        X.prototype.clone = function() {
          this.L.N || $a(this);
          if (this.L.$) return this.L.count.value += 1, this;
          var a2 = S2, b = Object, c2 = b.create, d = Object.getPrototypeOf(this), e = this.L;
          a2 = a2(c2.call(b, d, { L: { value: { count: e.count, Z: e.Z, $: e.$, N: e.N, O: e.O, S: e.S, T: e.T } } }));
          a2.L.count.value += 1;
          a2.L.Z = false;
          return a2;
        };
        X.prototype["delete"] = function() {
          this.L.N || $a(this);
          this.L.Z && !this.L.$ && K("Object already scheduled for deletion");
          Na(this);
          Pa(this.L);
          this.L.$ || (this.L.S = void 0, this.L.N = void 0);
        };
        X.prototype.isDeleted = function() {
          return !this.L.N;
        };
        X.prototype.deleteLater = function() {
          this.L.N || $a(this);
          this.L.Z && !this.L.$ && K("Object already scheduled for deletion");
          N.push(this);
          1 === N.length && O && O(Ia);
          this.L.Z = true;
          return this;
        };
        Y.prototype.pa = function(a2) {
          this.ja && (a2 = this.ja(a2));
          return a2;
        };
        Y.prototype.ga = function(a2) {
          this.V && this.V(a2);
        };
        Y.prototype.argPackAdvance = 8;
        Y.prototype.readValueFromPointer = T2;
        Y.prototype.deleteObject = function(a2) {
          if (null !== a2) a2["delete"]();
        };
        Y.prototype.fromWireType = function(a2) {
          function b() {
            return this.ca ? Va(this.M.W, { O: this.va, N: c2, T: this, S: a2 }) : Va(this.M.W, { O: this, N: a2 });
          }
          var c2 = this.pa(a2);
          if (!c2) return this.ga(a2), null;
          var d = Sa(this.M, c2);
          if (void 0 !== d) {
            if (0 === d.L.count.value) return d.L.N = c2, d.L.S = a2, d.clone();
            d = d.clone();
            this.ga(a2);
            return d;
          }
          d = this.M.oa(c2);
          d = Ra[d];
          if (!d) return b.call(this);
          d = this.ba ? d.ka : d.pointerType;
          var e = Qa(c2, this.M, d.M);
          return null === e ? b.call(this) : this.ca ? Va(d.M.W, { O: d, N: e, T: this, S: a2 }) : Va(d.M.W, { O: d, N: e });
        };
        mb = h2.UnboundTypeError = Ea("UnboundTypeError");
        var ya = "function" == typeof atob ? atob : function(a2) {
          var b = "", c2 = 0;
          a2 = a2.replace(/[^A-Za-z0-9\+\/=]/g, "");
          do {
            var d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
            var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
            var f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
            var g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
            d = d << 2 | e >> 4;
            e = (e & 15) << 4 | f >> 2;
            var k = (f & 3) << 6 | g;
            b += String.fromCharCode(d);
            64 !== f && (b += String.fromCharCode(e));
            64 !== g && (b += String.fromCharCode(k));
          } while (c2 < a2.length);
          return b;
        }, Jb = {
          p: function(a2, b, c2) {
            a2 = M2(a2);
            b = Ma(b, "wrapper");
            c2 = L2(c2);
            var d = [].slice, e = b.M, f = e.W, g = e.P.W, k = e.P.constructor;
            a2 = Ca(a2, function() {
              e.P.ia.forEach((function(l2) {
                if (this[l2] === g[l2]) throw new Ga("Pure virtual function " + l2 + " must be implemented in JavaScript");
              }).bind(this));
              Object.defineProperty(this, "__parent", { value: f });
              this.__construct.apply(this, d.call(arguments));
            });
            f.__construct = function() {
              this === f && K("Pass correct 'this' to __construct");
              var l2 = k.implement.apply(void 0, [this].concat(d.call(arguments)));
              Na(l2);
              var n = l2.L;
              l2.notifyOnDestruction();
              n.$ = true;
              Object.defineProperties(this, { L: { value: n } });
              S2(this);
              l2 = n.N;
              l2 = Ja(e, l2);
              P.hasOwnProperty(l2) ? K("Tried to register registered instance: " + l2) : P[l2] = this;
            };
            f.__destruct = function() {
              this === f && K("Pass correct 'this' to __destruct");
              Na(this);
              var l2 = this.L.N;
              l2 = Ja(e, l2);
              P.hasOwnProperty(l2) ? delete P[l2] : K("Tried to unregister unregistered instance: " + l2);
            };
            a2.prototype = Object.create(f);
            for (var m2 in c2) a2.prototype[m2] = c2[m2];
            return Fa(a2);
          },
          j: function(a2) {
            var b = Wa[a2];
            delete Wa[a2];
            var c2 = b.ea, d = b.V, e = b.ha, f = e.map((g) => g.sa).concat(e.map((g) => g.ya));
            V2([a2], f, (g) => {
              var k = {};
              e.forEach((m2, l2) => {
                var n = g[l2], p = m2.qa, r = m2.ra, u = g[l2 + e.length], t2 = m2.xa, y = m2.za;
                k[m2.na] = { read: (B) => n.fromWireType(p(r, B)), write: (B, aa) => {
                  var I = [];
                  t2(y, B, u.toWireType(I, aa));
                  Xa(I);
                } };
              });
              return [{ name: b.name, fromWireType: function(m2) {
                var l2 = {}, n;
                for (n in k) l2[n] = k[n].read(m2);
                d(m2);
                return l2;
              }, toWireType: function(m2, l2) {
                for (var n in k) if (!(n in l2)) throw new TypeError('Missing field:  "' + n + '"');
                var p = c2();
                for (n in k) k[n].write(p, l2[n]);
                null !== m2 && m2.push(d, p);
                return p;
              }, argPackAdvance: 8, readValueFromPointer: T2, U: d }];
            });
          },
          v: function() {
          },
          B: function(a2, b, c2, d, e) {
            var f = Za(c2);
            b = M2(b);
            W(a2, { name: b, fromWireType: function(g) {
              return !!g;
            }, toWireType: function(g, k) {
              return k ? d : e;
            }, argPackAdvance: 8, readValueFromPointer: function(g) {
              if (1 === c2) var k = ka;
              else if (2 === c2) k = A2;
              else if (4 === c2) k = C2;
              else throw new TypeError("Unknown boolean type size: " + b);
              return this.fromWireType(k[g >> f]);
            }, U: null });
          },
          f: function(a2, b, c2, d, e, f, g, k, m2, l2, n, p, r) {
            n = M2(n);
            f = Z2(e, f);
            k && (k = Z2(g, k));
            l2 && (l2 = Z2(m2, l2));
            r = Z2(p, r);
            var u = Ba(n);
            bb(u, function() {
              nb("Cannot construct " + n + " due to unbound types", [d]);
            });
            V2([a2, b, c2], d ? [d] : [], function(t2) {
              t2 = t2[0];
              if (d) {
                var y = t2.M;
                var B = y.W;
              } else B = X.prototype;
              t2 = Ca(u, function() {
                if (Object.getPrototypeOf(this) !== aa) throw new J("Use 'new' to construct " + n);
                if (void 0 === I.X) throw new J(n + " has no accessible constructor");
                var kb = I.X[arguments.length];
                if (void 0 === kb) throw new J("Tried to invoke ctor of " + n + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(I.X).toString() + ") parameters instead!");
                return kb.apply(this, arguments);
              });
              var aa = Object.create(B, { constructor: { value: t2 } });
              t2.prototype = aa;
              var I = new cb(n, t2, aa, r, y, f, k, l2);
              y = new Y(n, I, true, false);
              B = new Y(n + "*", I, false, false);
              var lb = new Y(n + " const*", I, false, true);
              Ra[a2] = { pointerType: B, ka: lb };
              ib(u, t2);
              return [y, B, lb];
            });
          },
          c: function(a2, b, c2, d, e, f, g) {
            var k = pb(c2, d);
            b = M2(b);
            f = Z2(e, f);
            V2([], [a2], function(m2) {
              function l2() {
                nb("Cannot call " + n + " due to unbound types", k);
              }
              m2 = m2[0];
              var n = m2.name + "." + b;
              b.startsWith("@@") && (b = Symbol[b.substring(2)]);
              var p = m2.M.constructor;
              void 0 === p[b] ? (l2.Y = c2 - 1, p[b] = l2) : (ab(p, b, n), p[b].R[c2 - 1] = l2);
              V2([], k, function(r) {
                r = ob(n, [r[0], null].concat(r.slice(1)), null, f, g);
                void 0 === p[b].R ? (r.Y = c2 - 1, p[b] = r) : p[b].R[c2 - 1] = r;
                return [];
              });
              return [];
            });
          },
          o: function(a2, b, c2, d, e, f) {
            0 < b || x();
            var g = pb(b, c2);
            e = Z2(d, e);
            V2([], [a2], function(k) {
              k = k[0];
              var m2 = "constructor " + k.name;
              void 0 === k.M.X && (k.M.X = []);
              if (void 0 !== k.M.X[b - 1]) throw new J("Cannot register multiple constructors with identical number of parameters (" + (b - 1) + ") for class '" + k.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
              k.M.X[b - 1] = () => {
                nb("Cannot construct " + k.name + " due to unbound types", g);
              };
              V2([], g, function(l2) {
                l2.splice(1, 0, null);
                k.M.X[b - 1] = ob(m2, l2, null, e, f);
                return [];
              });
              return [];
            });
          },
          a: function(a2, b, c2, d, e, f, g, k) {
            var m2 = pb(c2, d);
            b = M2(b);
            f = Z2(e, f);
            V2([], [a2], function(l2) {
              function n() {
                nb("Cannot call " + p + " due to unbound types", m2);
              }
              l2 = l2[0];
              var p = l2.name + "." + b;
              b.startsWith("@@") && (b = Symbol[b.substring(2)]);
              k && l2.M.ia.push(b);
              var r = l2.M.W, u = r[b];
              void 0 === u || void 0 === u.R && u.className !== l2.name && u.Y === c2 - 2 ? (n.Y = c2 - 2, n.className = l2.name, r[b] = n) : (ab(r, b, p), r[b].R[c2 - 2] = n);
              V2([], m2, function(t2) {
                t2 = ob(p, t2, l2, f, g);
                void 0 === r[b].R ? (t2.Y = c2 - 2, r[b] = t2) : r[b].R[c2 - 2] = t2;
                return [];
              });
              return [];
            });
          },
          A: function(a2, b) {
            b = M2(b);
            W(a2, { name: b, fromWireType: function(c2) {
              var d = L2(c2);
              qb(c2);
              return d;
            }, toWireType: function(c2, d) {
              return Fa(d);
            }, argPackAdvance: 8, readValueFromPointer: T2, U: null });
          },
          m: function(a2, b, c2) {
            c2 = Za(c2);
            b = M2(b);
            W(a2, {
              name: b,
              fromWireType: function(d) {
                return d;
              },
              toWireType: function(d, e) {
                return e;
              },
              argPackAdvance: 8,
              readValueFromPointer: rb(b, c2),
              U: null
            });
          },
          d: function(a2, b, c2, d, e) {
            b = M2(b);
            -1 === e && (e = 4294967295);
            e = Za(c2);
            var f = (k) => k;
            if (0 === d) {
              var g = 32 - 8 * c2;
              f = (k) => k << g >>> g;
            }
            c2 = b.includes("unsigned") ? function(k, m2) {
              return m2 >>> 0;
            } : function(k, m2) {
              return m2;
            };
            W(a2, { name: b, fromWireType: f, toWireType: c2, argPackAdvance: 8, readValueFromPointer: sb(b, e, 0 !== d), U: null });
          },
          b: function(a2, b, c2) {
            function d(f) {
              f >>= 2;
              var g = D;
              return new e(ja, g[f + 1], g[f]);
            }
            var e = [
              Int8Array,
              Uint8Array,
              Int16Array,
              Uint16Array,
              Int32Array,
              Uint32Array,
              Float32Array,
              Float64Array
            ][b];
            c2 = M2(c2);
            W(a2, { name: c2, fromWireType: d, argPackAdvance: 8, readValueFromPointer: d }, { ta: true });
          },
          n: function(a2, b) {
            b = M2(b);
            var c2 = "std::string" === b;
            W(a2, { name: b, fromWireType: function(d) {
              var e = D[d >> 2], f = d + 4;
              if (c2) for (var g = f, k = 0; k <= e; ++k) {
                var m2 = f + k;
                if (k == e || 0 == z2[m2]) {
                  g = g ? ia(z2, g, m2 - g) : "";
                  if (void 0 === l2) var l2 = g;
                  else l2 += String.fromCharCode(0), l2 += g;
                  g = m2 + 1;
                }
              }
              else {
                l2 = Array(e);
                for (k = 0; k < e; ++k) l2[k] = String.fromCharCode(z2[f + k]);
                l2 = l2.join("");
              }
              R(d);
              return l2;
            }, toWireType: function(d, e) {
              e instanceof ArrayBuffer && (e = new Uint8Array(e));
              var f, g = "string" == typeof e;
              g || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int8Array || K("Cannot pass non-string to std::string");
              if (c2 && g) {
                var k = 0;
                for (f = 0; f < e.length; ++f) {
                  var m2 = e.charCodeAt(f);
                  127 >= m2 ? k++ : 2047 >= m2 ? k += 2 : 55296 <= m2 && 57343 >= m2 ? (k += 4, ++f) : k += 3;
                }
                f = k;
              } else f = e.length;
              k = Ib(4 + f + 1);
              m2 = k + 4;
              D[k >> 2] = f;
              if (c2 && g) {
                if (g = m2, m2 = f + 1, f = z2, 0 < m2) {
                  m2 = g + m2 - 1;
                  for (var l2 = 0; l2 < e.length; ++l2) {
                    var n = e.charCodeAt(l2);
                    if (55296 <= n && 57343 >= n) {
                      var p = e.charCodeAt(++l2);
                      n = 65536 + ((n & 1023) << 10) | p & 1023;
                    }
                    if (127 >= n) {
                      if (g >= m2) break;
                      f[g++] = n;
                    } else {
                      if (2047 >= n) {
                        if (g + 1 >= m2) break;
                        f[g++] = 192 | n >> 6;
                      } else {
                        if (65535 >= n) {
                          if (g + 2 >= m2) break;
                          f[g++] = 224 | n >> 12;
                        } else {
                          if (g + 3 >= m2) break;
                          f[g++] = 240 | n >> 18;
                          f[g++] = 128 | n >> 12 & 63;
                        }
                        f[g++] = 128 | n >> 6 & 63;
                      }
                      f[g++] = 128 | n & 63;
                    }
                  }
                  f[g] = 0;
                }
              } else if (g) for (g = 0; g < f; ++g) l2 = e.charCodeAt(g), 255 < l2 && (R(m2), K("String has UTF-16 code units that do not fit in 8 bits")), z2[m2 + g] = l2;
              else for (g = 0; g < f; ++g) z2[m2 + g] = e[g];
              null !== d && d.push(R, k);
              return k;
            }, argPackAdvance: 8, readValueFromPointer: T2, U: function(d) {
              R(d);
            } });
          },
          i: function(a2, b, c2) {
            c2 = M2(c2);
            if (2 === b) {
              var d = tb;
              var e = ub;
              var f = vb;
              var g = () => la;
              var k = 1;
            } else 4 === b && (d = wb, e = xb, f = yb, g = () => D, k = 2);
            W(a2, {
              name: c2,
              fromWireType: function(m2) {
                for (var l2 = D[m2 >> 2], n = g(), p, r = m2 + 4, u = 0; u <= l2; ++u) {
                  var t2 = m2 + 4 + u * b;
                  if (u == l2 || 0 == n[t2 >> k]) r = d(r, t2 - r), void 0 === p ? p = r : (p += String.fromCharCode(0), p += r), r = t2 + b;
                }
                R(m2);
                return p;
              },
              toWireType: function(m2, l2) {
                "string" != typeof l2 && K("Cannot pass non-string to C++ string type " + c2);
                var n = f(l2), p = Ib(4 + n + b);
                D[p >> 2] = n >> k;
                e(l2, p + 4, n + b);
                null !== m2 && m2.push(R, p);
                return p;
              },
              argPackAdvance: 8,
              readValueFromPointer: T2,
              U: function(m2) {
                R(m2);
              }
            });
          },
          k: function(a2, b, c2, d, e, f) {
            Wa[a2] = { name: M2(b), ea: Z2(c2, d), V: Z2(e, f), ha: [] };
          },
          h: function(a2, b, c2, d, e, f, g, k, m2, l2) {
            Wa[a2].ha.push({ na: M2(b), sa: c2, qa: Z2(d, e), ra: f, ya: g, xa: Z2(k, m2), za: l2 });
          },
          C: function(a2, b) {
            b = M2(b);
            W(a2, { ua: true, name: b, argPackAdvance: 0, fromWireType: function() {
            }, toWireType: function() {
            } });
          },
          s: function(a2, b, c2, d, e) {
            a2 = Bb[a2];
            b = L2(b);
            c2 = Ab(c2);
            var f = [];
            D[d >> 2] = Fa(f);
            return a2(b, c2, f, e);
          },
          t: function(a2, b, c2, d) {
            a2 = Bb[a2];
            b = L2(b);
            c2 = Ab(c2);
            a2(b, c2, null, d);
          },
          g: qb,
          l: function(a2, b) {
            var c2 = Db(a2, b), d = c2[0];
            b = d.name + "_$" + c2.slice(1).map(function(g) {
              return g.name;
            }).join("_") + "$";
            var e = Eb[b];
            if (void 0 !== e) return e;
            var f = Array(a2 - 1);
            e = Cb((g, k, m2, l2) => {
              for (var n = 0, p = 0; p < a2 - 1; ++p) f[p] = c2[p + 1].readValueFromPointer(l2 + n), n += c2[p + 1].argPackAdvance;
              g = g[k].apply(g, f);
              for (p = 0; p < a2 - 1; ++p) c2[p + 1].la && c2[p + 1].la(f[p]);
              if (!d.ua) return d.toWireType(m2, g);
            });
            return Eb[b] = e;
          },
          q: function(a2) {
            4 < a2 && (H2[a2].fa += 1);
          },
          r: function(a2) {
            var b = L2(a2);
            Xa(b);
            qb(a2);
          },
          e: function() {
            x("");
          },
          x: function(a2, b, c2) {
            z2.copyWithin(a2, b, b + c2);
          },
          w: function(a2) {
            var b = z2.length;
            a2 >>>= 0;
            if (2147483648 < a2) return false;
            for (var c2 = 1; 4 >= c2; c2 *= 2) {
              var d = b * (1 + 0.2 / c2);
              d = Math.min(d, a2 + 100663296);
              var e = Math;
              d = Math.max(a2, d);
              e = e.min.call(e, 2147483648, d + (65536 - d % 65536) % 65536);
              a: {
                try {
                  fa.grow(e - ja.byteLength + 65535 >>> 16);
                  oa();
                  var f = 1;
                  break a;
                } catch (g) {
                }
                f = void 0;
              }
              if (f) return true;
            }
            return false;
          },
          z: function() {
            return 52;
          },
          u: function() {
            return 70;
          },
          y: function(a2, b, c2, d) {
            for (var e = 0, f = 0; f < c2; f++) {
              var g = D[b >> 2], k = D[b + 4 >> 2];
              b += 8;
              for (var m2 = 0; m2 < k; m2++) {
                var l2 = z2[g + m2], n = Fb[a2];
                0 === l2 || 10 === l2 ? ((1 === a2 ? ea : v2)(ia(n, 0)), n.length = 0) : n.push(l2);
              }
              e += k;
            }
            D[d >> 2] = e;
            return 0;
          }
        };
        (function() {
          function a2(e) {
            h2.asm = e.exports;
            fa = h2.asm.D;
            oa();
            pa = h2.asm.I;
            ra.unshift(h2.asm.E);
            E--;
            h2.monitorRunDependencies && h2.monitorRunDependencies(E);
            0 == E && (null !== ua && (clearInterval(ua), ua = null), F && (e = F, F = null, e()));
          }
          function b(e) {
            a2(e.instance);
          }
          function c2(e) {
            return za().then(function(f) {
              return WebAssembly.instantiate(f, d);
            }).then(function(f) {
              return f;
            }).then(e, function(f) {
              v2("failed to asynchronously prepare wasm: " + f);
              x(f);
            });
          }
          var d = { a: Jb };
          E++;
          h2.monitorRunDependencies && h2.monitorRunDependencies(E);
          if (h2.instantiateWasm) try {
            return h2.instantiateWasm(
              d,
              a2
            );
          } catch (e) {
            v2("Module.instantiateWasm callback failed with error: " + e), ca(e);
          }
          (function() {
            return w || "function" != typeof WebAssembly.instantiateStreaming || va(G2) || "function" != typeof fetch ? c2(b) : fetch(G2, { credentials: "same-origin" }).then(function(e) {
              return WebAssembly.instantiateStreaming(e, d).then(b, function(f) {
                v2("wasm streaming compile failed: " + f);
                v2("falling back to ArrayBuffer instantiation");
                return c2(b);
              });
            });
          })().catch(ca);
          return {};
        })();
        h2.___wasm_call_ctors = function() {
          return (h2.___wasm_call_ctors = h2.asm.E).apply(null, arguments);
        };
        var La = h2.___getTypeName = function() {
          return (La = h2.___getTypeName = h2.asm.F).apply(null, arguments);
        };
        h2.__embind_initialize_bindings = function() {
          return (h2.__embind_initialize_bindings = h2.asm.G).apply(null, arguments);
        };
        var Ib = h2._malloc = function() {
          return (Ib = h2._malloc = h2.asm.H).apply(null, arguments);
        }, R = h2._free = function() {
          return (R = h2._free = h2.asm.J).apply(null, arguments);
        };
        h2.dynCall_jiji = function() {
          return (h2.dynCall_jiji = h2.asm.K).apply(null, arguments);
        };
        var Kb;
        F = function Lb() {
          Kb || Mb();
          Kb || (F = Lb);
        };
        function Mb() {
          function a2() {
            if (!Kb && (Kb = true, h2.calledRun = true, !ha)) {
              Aa(ra);
              ba(h2);
              if (h2.onRuntimeInitialized) h2.onRuntimeInitialized();
              if (h2.postRun) for ("function" == typeof h2.postRun && (h2.postRun = [h2.postRun]); h2.postRun.length; ) {
                var b = h2.postRun.shift();
                sa.unshift(b);
              }
              Aa(sa);
            }
          }
          if (!(0 < E)) {
            if (h2.preRun) for ("function" == typeof h2.preRun && (h2.preRun = [h2.preRun]); h2.preRun.length; ) ta();
            Aa(qa);
            0 < E || (h2.setStatus ? (h2.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                h2.setStatus("");
              }, 1);
              a2();
            }, 1)) : a2());
          }
        }
        if (h2.preInit) for ("function" == typeof h2.preInit && (h2.preInit = [h2.preInit]); 0 < h2.preInit.length; ) h2.preInit.pop()();
        Mb();
        return loadYoga4.ready;
      };
    })();
    if (typeof exports2 === "object" && typeof module2 === "object")
      module2.exports = loadYoga3;
    else if (typeof define === "function" && define["amd"])
      define([], function() {
        return loadYoga3;
      });
    else if (typeof exports2 === "object")
      exports2["loadYoga"] = loadYoga3;
  }
});

// ../../.yarn/unplugged/yoga-layout-npm-2.0.1-d25883a49a/node_modules/yoga-layout/src/entrypoint/wasm-async-web.js
var require_wasm_async_web2 = __commonJS({
  "../../.yarn/unplugged/yoga-layout-npm-2.0.1-d25883a49a/node_modules/yoga-layout/src/entrypoint/wasm-async-web.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _exportNames = {
      loadYoga: true
    };
    exports2.loadYoga = loadYoga3;
    var _wrapAssembly = _interopRequireDefault(require_wrapAssembly());
    var _YGEnums = require_YGEnums();
    Object.keys(_YGEnums).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _YGEnums[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _YGEnums[key];
        }
      });
    });
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var loadAssembly = require_wasm_async_web();
    async function loadYoga3() {
      return (0, _wrapAssembly.default)(await loadAssembly());
    }
  }
});

// ../../.yarn/cache/object-assign-npm-4.1.1-1004ad6dec-1f4df99451.zip/node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "../../.yarn/cache/object-assign-npm-4.1.1-1004ad6dec-1f4df99451.zip/node_modules/object-assign/index.js"(exports2, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty3 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err2) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from4;
      var to = toObject(target);
      var symbols;
      for (var s2 = 1; s2 < arguments.length; s2++) {
        from4 = Object(arguments[s2]);
        for (var key in from4) {
          if (hasOwnProperty3.call(from4, key)) {
            to[key] = from4[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from4);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from4, symbols[i])) {
              to[symbols[i]] = from4[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// ../../.yarn/cache/scheduler-npm-0.17.0-5c42088cec-662a665a47.zip/node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "../../.yarn/cache/scheduler-npm-0.17.0-5c42088cec-662a665a47.zip/node_modules/scheduler/cjs/scheduler.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        var enableSchedulerDebugging = false;
        var enableIsInputPending = false;
        var enableMessageLoopImplementation = true;
        var enableProfiling = true;
        var requestHostCallback;
        var requestHostTimeout;
        var cancelHostTimeout;
        var shouldYieldToHost;
        var requestPaint;
        if (
          // If Scheduler runs in a non-DOM environment, it falls back to a naive
          // implementation using setTimeout.
          typeof window === "undefined" || // Check if MessageChannel is supported, too.
          typeof MessageChannel !== "function"
        ) {
          var _callback = null;
          var _timeoutID = null;
          var _flushCallback = function() {
            if (_callback !== null) {
              try {
                var currentTime = exports2.unstable_now();
                var hasRemainingTime = true;
                _callback(hasRemainingTime, currentTime);
                _callback = null;
              } catch (e) {
                setTimeout(_flushCallback, 0);
                throw e;
              }
            }
          };
          var initialTime = Date.now();
          exports2.unstable_now = function() {
            return Date.now() - initialTime;
          };
          requestHostCallback = function(cb) {
            if (_callback !== null) {
              setTimeout(requestHostCallback, 0, cb);
            } else {
              _callback = cb;
              setTimeout(_flushCallback, 0);
            }
          };
          requestHostTimeout = function(cb, ms) {
            _timeoutID = setTimeout(cb, ms);
          };
          cancelHostTimeout = function() {
            clearTimeout(_timeoutID);
          };
          shouldYieldToHost = function() {
            return false;
          };
          requestPaint = exports2.unstable_forceFrameRate = function() {
          };
        } else {
          var performance3 = window.performance;
          var _Date = window.Date;
          var _setTimeout = window.setTimeout;
          var _clearTimeout = window.clearTimeout;
          var requestAnimationFrame = window.requestAnimationFrame;
          var cancelAnimationFrame = window.cancelAnimationFrame;
          if (typeof console !== "undefined") {
            if (typeof requestAnimationFrame !== "function") {
              console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
            }
            if (typeof cancelAnimationFrame !== "function") {
              console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
            }
          }
          if (typeof performance3 === "object" && typeof performance3.now === "function") {
            exports2.unstable_now = function() {
              return performance3.now();
            };
          } else {
            var _initialTime = _Date.now();
            exports2.unstable_now = function() {
              return _Date.now() - _initialTime;
            };
          }
          var isRAFLoopRunning = false;
          var isMessageLoopRunning = false;
          var scheduledHostCallback = null;
          var rAFTimeoutID = -1;
          var taskTimeoutID = -1;
          var frameLength = enableMessageLoopImplementation ? (
            // We won't attempt to align with the vsync. Instead we'll yield multiple
            // times per frame, often enough to keep it responsive even at really
            // high frame rates > 120.
            5
          ) : (
            // Use a heuristic to measure the frame rate and yield at the end of the
            // frame. We start out assuming that we run at 30fps but then the
            // heuristic tracking will adjust this value to a faster fps if we get
            // more frequent animation frames.
            33.33
          );
          var prevRAFTime = -1;
          var prevRAFInterval = -1;
          var frameDeadline = 0;
          var fpsLocked = false;
          var maxFrameLength = 300;
          var needsPaint = false;
          if (enableIsInputPending && navigator !== void 0 && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0) {
            var scheduling = navigator.scheduling;
            shouldYieldToHost = function() {
              var currentTime = exports2.unstable_now();
              if (currentTime >= frameDeadline) {
                if (needsPaint || scheduling.isInputPending()) {
                  return true;
                }
                return currentTime >= frameDeadline + maxFrameLength;
              } else {
                return false;
              }
            };
            requestPaint = function() {
              needsPaint = true;
            };
          } else {
            shouldYieldToHost = function() {
              return exports2.unstable_now() >= frameDeadline;
            };
            requestPaint = function() {
            };
          }
          exports2.unstable_forceFrameRate = function(fps) {
            if (fps < 0 || fps > 125) {
              console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported");
              return;
            }
            if (fps > 0) {
              frameLength = Math.floor(1e3 / fps);
              fpsLocked = true;
            } else {
              frameLength = 33.33;
              fpsLocked = false;
            }
          };
          var performWorkUntilDeadline = function() {
            if (enableMessageLoopImplementation) {
              if (scheduledHostCallback !== null) {
                var currentTime = exports2.unstable_now();
                frameDeadline = currentTime + frameLength;
                var hasTimeRemaining = true;
                try {
                  var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                  if (!hasMoreWork) {
                    isMessageLoopRunning = false;
                    scheduledHostCallback = null;
                  } else {
                    port.postMessage(null);
                  }
                } catch (error) {
                  port.postMessage(null);
                  throw error;
                }
              } else {
                isMessageLoopRunning = false;
              }
              needsPaint = false;
            } else {
              if (scheduledHostCallback !== null) {
                var _currentTime = exports2.unstable_now();
                var _hasTimeRemaining = frameDeadline - _currentTime > 0;
                try {
                  var _hasMoreWork = scheduledHostCallback(_hasTimeRemaining, _currentTime);
                  if (!_hasMoreWork) {
                    scheduledHostCallback = null;
                  }
                } catch (error) {
                  port.postMessage(null);
                  throw error;
                }
              }
              needsPaint = false;
            }
          };
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          var onAnimationFrame = function(rAFTime) {
            if (scheduledHostCallback === null) {
              prevRAFTime = -1;
              prevRAFInterval = -1;
              isRAFLoopRunning = false;
              return;
            }
            isRAFLoopRunning = true;
            requestAnimationFrame(function(nextRAFTime) {
              _clearTimeout(rAFTimeoutID);
              onAnimationFrame(nextRAFTime);
            });
            var onTimeout = function() {
              frameDeadline = exports2.unstable_now() + frameLength / 2;
              performWorkUntilDeadline();
              rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);
            };
            rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);
            if (prevRAFTime !== -1 && // Make sure this rAF time is different from the previous one. This check
            // could fail if two rAFs fire in the same frame.
            rAFTime - prevRAFTime > 0.1) {
              var rAFInterval = rAFTime - prevRAFTime;
              if (!fpsLocked && prevRAFInterval !== -1) {
                if (rAFInterval < frameLength && prevRAFInterval < frameLength) {
                  frameLength = rAFInterval < prevRAFInterval ? prevRAFInterval : rAFInterval;
                  if (frameLength < 8.33) {
                    frameLength = 8.33;
                  }
                }
              }
              prevRAFInterval = rAFInterval;
            }
            prevRAFTime = rAFTime;
            frameDeadline = rAFTime + frameLength;
            port.postMessage(null);
          };
          requestHostCallback = function(callback) {
            scheduledHostCallback = callback;
            if (enableMessageLoopImplementation) {
              if (!isMessageLoopRunning) {
                isMessageLoopRunning = true;
                port.postMessage(null);
              }
            } else {
              if (!isRAFLoopRunning) {
                isRAFLoopRunning = true;
                requestAnimationFrame(function(rAFTime) {
                  onAnimationFrame(rAFTime);
                });
              }
            }
          };
          requestHostTimeout = function(callback, ms) {
            taskTimeoutID = _setTimeout(function() {
              callback(exports2.unstable_now());
            }, ms);
          };
          cancelHostTimeout = function() {
            _clearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
          };
        }
        function push(heap, node) {
          var index2 = heap.length;
          heap.push(node);
          siftUp(heap, node, index2);
        }
        function peek(heap) {
          var first = heap[0];
          return first === void 0 ? null : first;
        }
        function pop(heap) {
          var first = heap[0];
          if (first !== void 0) {
            var last3 = heap.pop();
            if (last3 !== first) {
              heap[0] = last3;
              siftDown(heap, last3, 0);
            }
            return first;
          } else {
            return null;
          }
        }
        function siftUp(heap, node, i) {
          var index2 = i;
          while (true) {
            var parentIndex = Math.floor((index2 - 1) / 2);
            var parent = heap[parentIndex];
            if (parent !== void 0 && compare9(parent, node) > 0) {
              heap[parentIndex] = node;
              heap[index2] = parent;
              index2 = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node, i) {
          var index2 = i;
          var length4 = heap.length;
          while (index2 < length4) {
            var leftIndex = (index2 + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            if (left !== void 0 && compare9(left, node) < 0) {
              if (right !== void 0 && compare9(right, left) < 0) {
                heap[index2] = right;
                heap[rightIndex] = node;
                index2 = rightIndex;
              } else {
                heap[index2] = left;
                heap[leftIndex] = node;
                index2 = leftIndex;
              }
            } else if (right !== void 0 && compare9(right, node) < 0) {
              heap[index2] = right;
              heap[rightIndex] = node;
              index2 = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare9(a2, b) {
          var diff = a2.sortIndex - b.sortIndex;
          return diff !== 0 ? diff : a2.id - b.id;
        }
        var NoPriority = 0;
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        var runIdCounter = 0;
        var mainThreadIdCounter = 0;
        var profilingStateSize = 4;
        var sharedProfilingBuffer = enableProfiling ? (
          // $FlowFixMe Flow doesn't know about SharedArrayBuffer
          typeof SharedArrayBuffer === "function" ? new SharedArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : (
            // $FlowFixMe Flow doesn't know about ArrayBuffer
            typeof ArrayBuffer === "function" ? new ArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : null
          )
        ) : null;
        var profilingState = enableProfiling && sharedProfilingBuffer !== null ? new Int32Array(sharedProfilingBuffer) : [];
        var PRIORITY = 0;
        var CURRENT_TASK_ID = 1;
        var CURRENT_RUN_ID = 2;
        var QUEUE_SIZE = 3;
        if (enableProfiling) {
          profilingState[PRIORITY] = NoPriority;
          profilingState[QUEUE_SIZE] = 0;
          profilingState[CURRENT_TASK_ID] = 0;
        }
        var INITIAL_EVENT_LOG_SIZE = 131072;
        var MAX_EVENT_LOG_SIZE = 524288;
        var eventLogSize = 0;
        var eventLogBuffer = null;
        var eventLog = null;
        var eventLogIndex = 0;
        var TaskStartEvent = 1;
        var TaskCompleteEvent = 2;
        var TaskErrorEvent = 3;
        var TaskCancelEvent = 4;
        var TaskRunEvent = 5;
        var TaskYieldEvent = 6;
        var SchedulerSuspendEvent = 7;
        var SchedulerResumeEvent = 8;
        function logEvent(entries) {
          if (eventLog !== null) {
            var offset3 = eventLogIndex;
            eventLogIndex += entries.length;
            if (eventLogIndex + 1 > eventLogSize) {
              eventLogSize *= 2;
              if (eventLogSize > MAX_EVENT_LOG_SIZE) {
                console.error("Scheduler Profiling: Event log exceeded maximum size. Don't forget to call `stopLoggingProfilingEvents()`.");
                stopLoggingProfilingEvents();
                return;
              }
              var newEventLog = new Int32Array(eventLogSize * 4);
              newEventLog.set(eventLog);
              eventLogBuffer = newEventLog.buffer;
              eventLog = newEventLog;
            }
            eventLog.set(entries, offset3);
          }
        }
        function startLoggingProfilingEvents() {
          eventLogSize = INITIAL_EVENT_LOG_SIZE;
          eventLogBuffer = new ArrayBuffer(eventLogSize * 4);
          eventLog = new Int32Array(eventLogBuffer);
          eventLogIndex = 0;
        }
        function stopLoggingProfilingEvents() {
          var buffer = eventLogBuffer;
          eventLogSize = 0;
          eventLogBuffer = null;
          eventLog = null;
          eventLogIndex = 0;
          return buffer;
        }
        function markTaskStart(task, ms) {
          if (enableProfiling) {
            profilingState[QUEUE_SIZE]++;
            if (eventLog !== null) {
              logEvent([TaskStartEvent, ms * 1e3, task.id, task.priorityLevel]);
            }
          }
        }
        function markTaskCompleted(task, ms) {
          if (enableProfiling) {
            profilingState[PRIORITY] = NoPriority;
            profilingState[CURRENT_TASK_ID] = 0;
            profilingState[QUEUE_SIZE]--;
            if (eventLog !== null) {
              logEvent([TaskCompleteEvent, ms * 1e3, task.id]);
            }
          }
        }
        function markTaskCanceled(task, ms) {
          if (enableProfiling) {
            profilingState[QUEUE_SIZE]--;
            if (eventLog !== null) {
              logEvent([TaskCancelEvent, ms * 1e3, task.id]);
            }
          }
        }
        function markTaskErrored(task, ms) {
          if (enableProfiling) {
            profilingState[PRIORITY] = NoPriority;
            profilingState[CURRENT_TASK_ID] = 0;
            profilingState[QUEUE_SIZE]--;
            if (eventLog !== null) {
              logEvent([TaskErrorEvent, ms * 1e3, task.id]);
            }
          }
        }
        function markTaskRun(task, ms) {
          if (enableProfiling) {
            runIdCounter++;
            profilingState[PRIORITY] = task.priorityLevel;
            profilingState[CURRENT_TASK_ID] = task.id;
            profilingState[CURRENT_RUN_ID] = runIdCounter;
            if (eventLog !== null) {
              logEvent([TaskRunEvent, ms * 1e3, task.id, runIdCounter]);
            }
          }
        }
        function markTaskYield(task, ms) {
          if (enableProfiling) {
            profilingState[PRIORITY] = NoPriority;
            profilingState[CURRENT_TASK_ID] = 0;
            profilingState[CURRENT_RUN_ID] = 0;
            if (eventLog !== null) {
              logEvent([TaskYieldEvent, ms * 1e3, task.id, runIdCounter]);
            }
          }
        }
        function markSchedulerSuspended(ms) {
          if (enableProfiling) {
            mainThreadIdCounter++;
            if (eventLog !== null) {
              logEvent([SchedulerSuspendEvent, ms * 1e3, mainThreadIdCounter]);
            }
          }
        }
        function markSchedulerUnsuspended(ms) {
          if (enableProfiling) {
            if (eventLog !== null) {
              logEvent([SchedulerResumeEvent, ms * 1e3, mainThreadIdCounter]);
            }
          }
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var isSchedulerPaused = false;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
              if (enableProfiling) {
                markTaskStart(timer, currentTime);
                timer.isQueued = true;
              }
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          if (enableProfiling) {
            markSchedulerUnsuspended(initialTime2);
          }
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime2);
              } catch (error) {
                if (currentTask !== null) {
                  var currentTime = exports2.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error;
              }
            } else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
            if (enableProfiling) {
              var _currentTime = exports2.unstable_now();
              markSchedulerSuspended(_currentTime);
            }
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !(enableSchedulerDebugging && isSchedulerPaused)) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (callback !== null) {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              markTaskRun(currentTask, currentTime);
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports2.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
                markTaskYield(currentTask, currentTime);
              } else {
                if (enableProfiling) {
                  markTaskCompleted(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function timeoutForPriorityLevel(priorityLevel) {
          switch (priorityLevel) {
            case ImmediatePriority:
              return IMMEDIATE_PRIORITY_TIMEOUT;
            case UserBlockingPriority:
              return USER_BLOCKING_PRIORITY;
            case IdlePriority:
              return IDLE_PRIORITY;
            case LowPriority:
              return LOW_PRIORITY_TIMEOUT;
            case NormalPriority:
            default:
              return NORMAL_PRIORITY_TIMEOUT;
          }
        }
        function unstable_scheduleCallback2(priorityLevel, callback, options) {
          var currentTime = exports2.unstable_now();
          var startTime3;
          var timeout;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime3 = currentTime + delay;
            } else {
              startTime3 = currentTime;
            }
            timeout = typeof options.timeout === "number" ? options.timeout : timeoutForPriorityLevel(priorityLevel);
          } else {
            timeout = timeoutForPriorityLevel(priorityLevel);
            startTime3 = currentTime;
          }
          var expirationTime = startTime3 + timeout;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime3,
            expirationTime,
            sortIndex: -1
          };
          if (enableProfiling) {
            newTask.isQueued = false;
          }
          if (startTime3 > currentTime) {
            newTask.sortIndex = startTime3;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime3 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (enableProfiling) {
              markTaskStart(newTask, currentTime);
              newTask.isQueued = true;
            }
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
          isSchedulerPaused = true;
        }
        function unstable_continueExecution() {
          isSchedulerPaused = false;
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback2(task) {
          if (enableProfiling) {
            if (task.isQueued) {
              var currentTime = exports2.unstable_now();
              markTaskCanceled(task, currentTime);
              task.isQueued = false;
            }
          }
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        function unstable_shouldYield() {
          var currentTime = exports2.unstable_now();
          advanceTimers(currentTime);
          var firstTask = peek(taskQueue);
          return firstTask !== currentTask && currentTask !== null && firstTask !== null && firstTask.callback !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = enableProfiling ? {
          startLoggingProfilingEvents,
          stopLoggingProfilingEvents,
          sharedProfilingBuffer
        } : null;
        exports2.unstable_ImmediatePriority = ImmediatePriority;
        exports2.unstable_UserBlockingPriority = UserBlockingPriority;
        exports2.unstable_NormalPriority = NormalPriority;
        exports2.unstable_IdlePriority = IdlePriority;
        exports2.unstable_LowPriority = LowPriority;
        exports2.unstable_runWithPriority = unstable_runWithPriority;
        exports2.unstable_next = unstable_next;
        exports2.unstable_scheduleCallback = unstable_scheduleCallback2;
        exports2.unstable_cancelCallback = unstable_cancelCallback2;
        exports2.unstable_wrapCallback = unstable_wrapCallback;
        exports2.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports2.unstable_shouldYield = unstable_shouldYield;
        exports2.unstable_requestPaint = unstable_requestPaint;
        exports2.unstable_continueExecution = unstable_continueExecution;
        exports2.unstable_pauseExecution = unstable_pauseExecution;
        exports2.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports2.unstable_Profiling = unstable_Profiling;
      })();
    }
  }
});

// ../../.yarn/cache/scheduler-npm-0.17.0-5c42088cec-662a665a47.zip/node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "../../.yarn/cache/scheduler-npm-0.17.0-5c42088cec-662a665a47.zip/node_modules/scheduler/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_scheduler_development();
    }
  }
});

// ../../.yarn/cache/@babel-runtime-npm-7.25.0-a7bca33687-bd3faf2461.zip/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t2 = arguments[e];
      for (var r in t2) ({}).hasOwnProperty.call(t2, r) && (n[r] = t2[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// ../../.yarn/cache/@react-pdf-primitives-npm-3.1.1-3033dff230-da8453f923.zip/node_modules/@react-pdf/primitives/src/index.js
var src_exports = {};
__export(src_exports, {
  Canvas: () => Canvas,
  Circle: () => Circle,
  ClipPath: () => ClipPath,
  Defs: () => Defs,
  Document: () => Document,
  Ellipse: () => Ellipse,
  G: () => G,
  Image: () => Image,
  Line: () => Line,
  LinearGradient: () => LinearGradient,
  Link: () => Link,
  Note: () => Note,
  Page: () => Page,
  Path: () => Path,
  Polygon: () => Polygon,
  Polyline: () => Polyline,
  RadialGradient: () => RadialGradient,
  Rect: () => Rect,
  Stop: () => Stop,
  Svg: () => Svg,
  Text: () => Text,
  TextInstance: () => TextInstance,
  Tspan: () => Tspan,
  View: () => View
});
var G = "G";
var Svg = "SVG";
var View = "VIEW";
var Text = "TEXT";
var Link = "LINK";
var Page = "PAGE";
var Note = "NOTE";
var Path = "PATH";
var Rect = "RECT";
var Line = "LINE";
var Stop = "STOP";
var Defs = "DEFS";
var Image = "IMAGE";
var Tspan = "TSPAN";
var Canvas = "CANVAS";
var Circle = "CIRCLE";
var Ellipse = "ELLIPSE";
var Polygon = "POLYGON";
var Document = "DOCUMENT";
var Polyline = "POLYLINE";
var ClipPath = "CLIP_PATH";
var TextInstance = "TEXT_INSTANCE";
var LinearGradient = "LINEAR_GRADIENT";
var RadialGradient = "RADIAL_GRADIENT";

// ../../.yarn/__virtual__/@react-pdf-renderer-virtual-d7c75e74a5/0/cache/@react-pdf-renderer-npm-3.4.4-a00abab2ca-b5feebcf97.zip/node_modules/@react-pdf/renderer/lib/react-pdf.browser.js
var import_queue = __toESM(require_queue());
var import_react = __toESM(require_react());

// ../../.yarn/cache/@babel-runtime-npm-7.25.0-a7bca33687-bd3faf2461.zip/node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// ../../.yarn/cache/@babel-runtime-npm-7.25.0-a7bca33687-bd3faf2461.zip/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js
function _regeneratorRuntime() {
  "use strict";
  _regeneratorRuntime = function _regeneratorRuntime2() {
    return e;
  };
  var t2, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t3, e2, r2) {
    t3[e2] = r2.value;
  }, i = "function" == typeof Symbol ? Symbol : {}, a2 = i.iterator || "@@iterator", c2 = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
  function define2(t3, e2, r2) {
    return Object.defineProperty(t3, e2, {
      value: r2,
      enumerable: true,
      configurable: true,
      writable: true
    }), t3[e2];
  }
  try {
    define2({}, "");
  } catch (t3) {
    define2 = function define3(t4, e2, r2) {
      return t4[e2] = r2;
    };
  }
  function wrap(t3, e2, r2, n2) {
    var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a3 = Object.create(i2.prototype), c3 = new Context(n2 || []);
    return o(a3, "_invoke", {
      value: makeInvokeMethod(t3, r2, c3)
    }), a3;
  }
  function tryCatch(t3, e2, r2) {
    try {
      return {
        type: "normal",
        arg: t3.call(e2, r2)
      };
    } catch (t4) {
      return {
        type: "throw",
        arg: t4
      };
    }
  }
  e.wrap = wrap;
  var h2 = "suspendedStart", l2 = "suspendedYield", f = "executing", s2 = "completed", y = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var p = {};
  define2(p, a2, function() {
    return this;
  });
  var d = Object.getPrototypeOf, v2 = d && d(d(values([])));
  v2 && v2 !== r && n.call(v2, a2) && (p = v2);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t3) {
    ["next", "throw", "return"].forEach(function(e2) {
      define2(t3, e2, function(t4) {
        return this._invoke(e2, t4);
      });
    });
  }
  function AsyncIterator(t3, e2) {
    function invoke(r3, o2, i2, a3) {
      var c3 = tryCatch(t3[r3], t3, o2);
      if ("throw" !== c3.type) {
        var u2 = c3.arg, h3 = u2.value;
        return h3 && "object" == _typeof(h3) && n.call(h3, "__await") ? e2.resolve(h3.__await).then(function(t4) {
          invoke("next", t4, i2, a3);
        }, function(t4) {
          invoke("throw", t4, i2, a3);
        }) : e2.resolve(h3).then(function(t4) {
          u2.value = t4, i2(u2);
        }, function(t4) {
          return invoke("throw", t4, i2, a3);
        });
      }
      a3(c3.arg);
    }
    var r2;
    o(this, "_invoke", {
      value: function value2(t4, n2) {
        function callInvokeWithMethodAndArg() {
          return new e2(function(e3, r3) {
            invoke(t4, n2, e3, r3);
          });
        }
        return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e2, r2, n2) {
    var o2 = h2;
    return function(i2, a3) {
      if (o2 === f) throw Error("Generator is already running");
      if (o2 === s2) {
        if ("throw" === i2) throw a3;
        return {
          value: t2,
          done: true
        };
      }
      for (n2.method = i2, n2.arg = a3; ; ) {
        var c3 = n2.delegate;
        if (c3) {
          var u2 = maybeInvokeDelegate(c3, n2);
          if (u2) {
            if (u2 === y) continue;
            return u2;
          }
        }
        if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
        else if ("throw" === n2.method) {
          if (o2 === h2) throw o2 = s2, n2.arg;
          n2.dispatchException(n2.arg);
        } else "return" === n2.method && n2.abrupt("return", n2.arg);
        o2 = f;
        var p2 = tryCatch(e2, r2, n2);
        if ("normal" === p2.type) {
          if (o2 = n2.done ? s2 : l2, p2.arg === y) continue;
          return {
            value: p2.arg,
            done: n2.done
          };
        }
        "throw" === p2.type && (o2 = s2, n2.method = "throw", n2.arg = p2.arg);
      }
    };
  }
  function maybeInvokeDelegate(e2, r2) {
    var n2 = r2.method, o2 = e2.iterator[n2];
    if (o2 === t2) return r2.delegate = null, "throw" === n2 && e2.iterator["return"] && (r2.method = "return", r2.arg = t2, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
    var i2 = tryCatch(o2, e2.iterator, r2.arg);
    if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
    var a3 = i2.arg;
    return a3 ? a3.done ? (r2[e2.resultName] = a3.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t2), r2.delegate = null, y) : a3 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
  }
  function pushTryEntry(t3) {
    var e2 = {
      tryLoc: t3[0]
    };
    1 in t3 && (e2.catchLoc = t3[1]), 2 in t3 && (e2.finallyLoc = t3[2], e2.afterLoc = t3[3]), this.tryEntries.push(e2);
  }
  function resetTryEntry(t3) {
    var e2 = t3.completion || {};
    e2.type = "normal", delete e2.arg, t3.completion = e2;
  }
  function Context(t3) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t3.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(e2) {
    if (e2 || "" === e2) {
      var r2 = e2[a2];
      if (r2) return r2.call(e2);
      if ("function" == typeof e2.next) return e2;
      if (!isNaN(e2.length)) {
        var o2 = -1, i2 = function next() {
          for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
          return next.value = t2, next.done = true, next;
        };
        return i2.next = i2;
      }
    }
    throw new TypeError(_typeof(e2) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t3) {
    var e2 = "function" == typeof t3 && t3.constructor;
    return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
  }, e.mark = function(t3) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t3, GeneratorFunctionPrototype) : (t3.__proto__ = GeneratorFunctionPrototype, define2(t3, u, "GeneratorFunction")), t3.prototype = Object.create(g), t3;
  }, e.awrap = function(t3) {
    return {
      __await: t3
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c2, function() {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function(t3, r2, n2, o2, i2) {
    void 0 === i2 && (i2 = Promise);
    var a3 = new AsyncIterator(wrap(t3, r2, n2, o2), i2);
    return e.isGeneratorFunction(r2) ? a3 : a3.next().then(function(t4) {
      return t4.done ? t4.value : a3.next();
    });
  }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a2, function() {
    return this;
  }), define2(g, "toString", function() {
    return "[object Generator]";
  }), e.keys = function(t3) {
    var e2 = Object(t3), r2 = [];
    for (var n2 in e2) r2.push(n2);
    return r2.reverse(), function next() {
      for (; r2.length; ) {
        var t4 = r2.pop();
        if (t4 in e2) return next.value = t4, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e2) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t2, this.done = false, this.delegate = null, this.method = "next", this.arg = t2, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t2);
    },
    stop: function stop() {
      this.done = true;
      var t3 = this.tryEntries[0].completion;
      if ("throw" === t3.type) throw t3.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e2) {
      if (this.done) throw e2;
      var r2 = this;
      function handle(n2, o3) {
        return a3.type = "throw", a3.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t2), !!o3;
      }
      for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
        var i2 = this.tryEntries[o2], a3 = i2.completion;
        if ("root" === i2.tryLoc) return handle("end");
        if (i2.tryLoc <= this.prev) {
          var c3 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
          if (c3 && u2) {
            if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
          } else if (c3) {
            if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
          } else {
            if (!u2) throw Error("try statement without catch or finally");
            if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t3, e2) {
      for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
        var o2 = this.tryEntries[r2];
        if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
          var i2 = o2;
          break;
        }
      }
      i2 && ("break" === t3 || "continue" === t3) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
      var a3 = i2 ? i2.completion : {};
      return a3.type = t3, a3.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a3);
    },
    complete: function complete(t3, e2) {
      if ("throw" === t3.type) throw t3.arg;
      return "break" === t3.type || "continue" === t3.type ? this.next = t3.arg : "return" === t3.type ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : "normal" === t3.type && e2 && (this.next = e2), y;
    },
    finish: function finish(t3) {
      for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
        var r2 = this.tryEntries[e2];
        if (r2.finallyLoc === t3) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
      }
    },
    "catch": function _catch(t3) {
      for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
        var r2 = this.tryEntries[e2];
        if (r2.tryLoc === t3) {
          var n2 = r2.completion;
          if ("throw" === n2.type) {
            var o2 = n2.arg;
            resetTryEntry(r2);
          }
          return o2;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e2, r2, n2) {
      return this.delegate = {
        iterator: values(e2),
        resultName: r2,
        nextLoc: n2
      }, "next" === this.method && (this.arg = t2), y;
    }
  }, e;
}

// ../../.yarn/cache/@babel-runtime-npm-7.25.0-a7bca33687-bd3faf2461.zip/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(n, t2, e, r, o, a2, c2) {
  try {
    var i = n[a2](c2), u = i.value;
  } catch (n2) {
    return void e(n2);
  }
  i.done ? t2(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function() {
    var t2 = this, e = arguments;
    return new Promise(function(r, o) {
      var a2 = n.apply(t2, e);
      function _next(n2) {
        asyncGeneratorStep(a2, r, o, _next, _throw, "next", n2);
      }
      function _throw(n2) {
        asyncGeneratorStep(a2, r, o, _next, _throw, "throw", n2);
      }
      _next(void 0);
    });
  };
}

// ../../.yarn/cache/@babel-runtime-npm-7.25.0-a7bca33687-bd3faf2461.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t2 = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    t2[n] = r[n];
  }
  return t2;
}

// ../../.yarn/cache/@react-pdf-font-npm-2.5.1-14fbe6682c-140c4b9bbb.zip/node_modules/@react-pdf/font/lib/index.browser.js
var import_is_url = __toESM(require_is_url());
var import_cross_fetch = __toESM(require_browser_ponyfill());

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/DecodeStream.js
var ENCODING_MAPPING = {
  utf16le: "utf-16le",
  ucs2: "utf-16le",
  utf16be: "utf-16be"
};
var DecodeStream = class {
  constructor(buffer) {
    this.buffer = buffer;
    this.view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    this.pos = 0;
    this.length = this.buffer.length;
  }
  readString(length4, encoding = "ascii") {
    encoding = ENCODING_MAPPING[encoding] || encoding;
    let buf = this.readBuffer(length4);
    try {
      let decoder2 = new TextDecoder(encoding);
      return decoder2.decode(buf);
    } catch (err2) {
      return buf;
    }
  }
  readBuffer(length4) {
    return this.buffer.slice(this.pos, this.pos += length4);
  }
  readUInt24BE() {
    return (this.readUInt16BE() << 8) + this.readUInt8();
  }
  readUInt24LE() {
    return this.readUInt16LE() + (this.readUInt8() << 16);
  }
  readInt24BE() {
    return (this.readInt16BE() << 8) + this.readUInt8();
  }
  readInt24LE() {
    return this.readUInt16LE() + (this.readInt8() << 16);
  }
};
DecodeStream.TYPES = {
  UInt8: 1,
  UInt16: 2,
  UInt24: 3,
  UInt32: 4,
  Int8: 1,
  Int16: 2,
  Int24: 3,
  Int32: 4,
  Float: 4,
  Double: 8
};
for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (key.slice(0, 3) === "get") {
    let type2 = key.slice(3).replace("Ui", "UI");
    if (type2 === "Float32") {
      type2 = "Float";
    } else if (type2 === "Float64") {
      type2 = "Double";
    }
    let bytes = DecodeStream.TYPES[type2];
    DecodeStream.prototype["read" + type2 + (bytes === 1 ? "" : "BE")] = function() {
      const ret = this.view[key](this.pos, false);
      this.pos += bytes;
      return ret;
    };
    if (bytes !== 1) {
      DecodeStream.prototype["read" + type2 + "LE"] = function() {
        const ret = this.view[key](this.pos, true);
        this.pos += bytes;
        return ret;
      };
    }
  }
}

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/EncodeStream.js
var textEncoder = new TextEncoder();
var isBigEndian = new Uint8Array(new Uint16Array([4660]).buffer)[0] == 18;
var EncodeStream = class {
  constructor(buffer) {
    this.buffer = buffer;
    this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
    this.pos = 0;
  }
  writeBuffer(buffer) {
    this.buffer.set(buffer, this.pos);
    this.pos += buffer.length;
  }
  writeString(string, encoding = "ascii") {
    let buf;
    switch (encoding) {
      case "utf16le":
      case "utf16-le":
      case "ucs2":
        buf = stringToUtf16(string, isBigEndian);
        break;
      case "utf16be":
      case "utf16-be":
        buf = stringToUtf16(string, !isBigEndian);
        break;
      case "utf8":
        buf = textEncoder.encode(string);
        break;
      case "ascii":
        buf = stringToAscii(string);
        break;
      default:
        throw new Error(`Unsupported encoding: ${encoding}`);
    }
    this.writeBuffer(buf);
  }
  writeUInt24BE(val) {
    this.buffer[this.pos++] = val >>> 16 & 255;
    this.buffer[this.pos++] = val >>> 8 & 255;
    this.buffer[this.pos++] = val & 255;
  }
  writeUInt24LE(val) {
    this.buffer[this.pos++] = val & 255;
    this.buffer[this.pos++] = val >>> 8 & 255;
    this.buffer[this.pos++] = val >>> 16 & 255;
  }
  writeInt24BE(val) {
    if (val >= 0) {
      this.writeUInt24BE(val);
    } else {
      this.writeUInt24BE(val + 16777215 + 1);
    }
  }
  writeInt24LE(val) {
    if (val >= 0) {
      this.writeUInt24LE(val);
    } else {
      this.writeUInt24LE(val + 16777215 + 1);
    }
  }
  fill(val, length4) {
    if (length4 < this.buffer.length) {
      this.buffer.fill(val, this.pos, this.pos + length4);
      this.pos += length4;
    } else {
      const buf = new Uint8Array(length4);
      buf.fill(val);
      this.writeBuffer(buf);
    }
  }
};
function stringToUtf16(string, swap4) {
  let buf = new Uint16Array(string.length);
  for (let i = 0; i < string.length; i++) {
    let code = string.charCodeAt(i);
    if (swap4) {
      code = code >> 8 | (code & 255) << 8;
    }
    buf[i] = code;
  }
  return new Uint8Array(buf.buffer);
}
function stringToAscii(string) {
  let buf = new Uint8Array(string.length);
  for (let i = 0; i < string.length; i++) {
    buf[i] = string.charCodeAt(i);
  }
  return buf;
}
for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (key.slice(0, 3) === "set") {
    let type2 = key.slice(3).replace("Ui", "UI");
    if (type2 === "Float32") {
      type2 = "Float";
    } else if (type2 === "Float64") {
      type2 = "Double";
    }
    let bytes = DecodeStream.TYPES[type2];
    EncodeStream.prototype["write" + type2 + (bytes === 1 ? "" : "BE")] = function(value2) {
      this.view[key](this.pos, value2, false);
      this.pos += bytes;
    };
    if (bytes !== 1) {
      EncodeStream.prototype["write" + type2 + "LE"] = function(value2) {
        this.view[key](this.pos, value2, true);
        this.pos += bytes;
      };
    }
  }
}

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/Base.js
var Base = class {
  fromBuffer(buffer) {
    let stream2 = new DecodeStream(buffer);
    return this.decode(stream2);
  }
  toBuffer(value2) {
    let size = this.size(value2);
    let buffer = new Uint8Array(size);
    let stream2 = new EncodeStream(buffer);
    this.encode(stream2, value2);
    return buffer;
  }
};

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/Number.js
var NumberT = class extends Base {
  constructor(type2, endian = "BE") {
    super();
    this.type = type2;
    this.endian = endian;
    this.fn = this.type;
    if (this.type[this.type.length - 1] !== "8") {
      this.fn += this.endian;
    }
  }
  size() {
    return DecodeStream.TYPES[this.type];
  }
  decode(stream2) {
    return stream2[`read${this.fn}`]();
  }
  encode(stream2, val) {
    return stream2[`write${this.fn}`](val);
  }
};
var uint8 = new NumberT("UInt8");
var uint16be = new NumberT("UInt16", "BE");
var uint16 = uint16be;
var uint16le = new NumberT("UInt16", "LE");
var uint24be = new NumberT("UInt24", "BE");
var uint24 = uint24be;
var uint24le = new NumberT("UInt24", "LE");
var uint32be = new NumberT("UInt32", "BE");
var uint32 = uint32be;
var uint32le = new NumberT("UInt32", "LE");
var int8 = new NumberT("Int8");
var int16be = new NumberT("Int16", "BE");
var int16 = int16be;
var int16le = new NumberT("Int16", "LE");
var int24be = new NumberT("Int24", "BE");
var int24le = new NumberT("Int24", "LE");
var int32be = new NumberT("Int32", "BE");
var int32 = int32be;
var int32le = new NumberT("Int32", "LE");
var floatbe = new NumberT("Float", "BE");
var floatle = new NumberT("Float", "LE");
var doublebe = new NumberT("Double", "BE");
var doublele = new NumberT("Double", "LE");
var Fixed = class extends NumberT {
  constructor(size, endian, fracBits = size >> 1) {
    super(`Int${size}`, endian);
    this._point = 1 << fracBits;
  }
  decode(stream2) {
    return super.decode(stream2) / this._point;
  }
  encode(stream2, val) {
    return super.encode(stream2, val * this._point | 0);
  }
};
var fixed16be = new Fixed(16, "BE");
var fixed16 = fixed16be;
var fixed16le = new Fixed(16, "LE");
var fixed32be = new Fixed(32, "BE");
var fixed32 = fixed32be;
var fixed32le = new Fixed(32, "LE");

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/utils.js
function resolveLength(length4, stream2, parent) {
  let res;
  if (typeof length4 === "number") {
    res = length4;
  } else if (typeof length4 === "function") {
    res = length4.call(parent, parent);
  } else if (parent && typeof length4 === "string") {
    res = parent[length4];
  } else if (stream2 && length4 instanceof NumberT) {
    res = length4.decode(stream2);
  }
  if (isNaN(res)) {
    throw new Error("Not a fixed size");
  }
  return res;
}
var PropertyDescriptor = class {
  constructor(opts2 = {}) {
    this.enumerable = true;
    this.configurable = true;
    for (let key in opts2) {
      const val = opts2[key];
      this[key] = val;
    }
  }
};

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/Array.js
var ArrayT = class extends Base {
  constructor(type2, length4, lengthType = "count") {
    super();
    this.type = type2;
    this.length = length4;
    this.lengthType = lengthType;
  }
  decode(stream2, parent) {
    let length4;
    const { pos } = stream2;
    const res = [];
    let ctx = parent;
    if (this.length != null) {
      length4 = resolveLength(this.length, stream2, parent);
    }
    if (this.length instanceof NumberT) {
      Object.defineProperties(res, {
        parent: { value: parent },
        _startOffset: { value: pos },
        _currentOffset: { value: 0, writable: true },
        _length: { value: length4 }
      });
      ctx = res;
    }
    if (length4 == null || this.lengthType === "bytes") {
      const target = length4 != null ? stream2.pos + length4 : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream2.length;
      while (stream2.pos < target) {
        res.push(this.type.decode(stream2, ctx));
      }
    } else {
      for (let i = 0, end3 = length4; i < end3; i++) {
        res.push(this.type.decode(stream2, ctx));
      }
    }
    return res;
  }
  size(array, ctx, includePointers = true) {
    if (!array) {
      return this.type.size(null, ctx) * resolveLength(this.length, null, ctx);
    }
    let size = 0;
    if (this.length instanceof NumberT) {
      size += this.length.size();
      ctx = { parent: ctx, pointerSize: 0 };
    }
    for (let item of array) {
      size += this.type.size(item, ctx);
    }
    if (ctx && includePointers && this.length instanceof NumberT) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, array, parent) {
    let ctx = parent;
    if (this.length instanceof NumberT) {
      ctx = {
        pointers: [],
        startOffset: stream2.pos,
        parent
      };
      ctx.pointerOffset = stream2.pos + this.size(array, ctx, false);
      this.length.encode(stream2, array.length);
    }
    for (let item of array) {
      this.type.encode(stream2, item, ctx);
    }
    if (this.length instanceof NumberT) {
      let i = 0;
      while (i < ctx.pointers.length) {
        const ptr = ctx.pointers[i++];
        ptr.type.encode(stream2, ptr.val, ptr.parent);
      }
    }
  }
};

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/LazyArray.js
var LazyArray = class extends ArrayT {
  decode(stream2, parent) {
    const { pos } = stream2;
    const length4 = resolveLength(this.length, stream2, parent);
    if (this.length instanceof NumberT) {
      parent = {
        parent,
        _startOffset: pos,
        _currentOffset: 0,
        _length: length4
      };
    }
    const res = new LazyArrayValue(this.type, length4, stream2, parent);
    stream2.pos += length4 * this.type.size(null, parent);
    return res;
  }
  size(val, ctx) {
    if (val instanceof LazyArrayValue) {
      val = val.toArray();
    }
    return super.size(val, ctx);
  }
  encode(stream2, val, ctx) {
    if (val instanceof LazyArrayValue) {
      val = val.toArray();
    }
    return super.encode(stream2, val, ctx);
  }
};
var LazyArrayValue = class {
  constructor(type2, length4, stream2, ctx) {
    this.type = type2;
    this.length = length4;
    this.stream = stream2;
    this.ctx = ctx;
    this.base = this.stream.pos;
    this.items = [];
  }
  get(index2) {
    if (index2 < 0 || index2 >= this.length) {
      return void 0;
    }
    if (this.items[index2] == null) {
      const { pos } = this.stream;
      this.stream.pos = this.base + this.type.size(null, this.ctx) * index2;
      this.items[index2] = this.type.decode(this.stream, this.ctx);
      this.stream.pos = pos;
    }
    return this.items[index2];
  }
  toArray() {
    const result = [];
    for (let i = 0, end3 = this.length; i < end3; i++) {
      result.push(this.get(i));
    }
    return result;
  }
};

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/Bitfield.js
var Bitfield = class extends Base {
  constructor(type2, flags = []) {
    super();
    this.type = type2;
    this.flags = flags;
  }
  decode(stream2) {
    const val = this.type.decode(stream2);
    const res = {};
    for (let i = 0; i < this.flags.length; i++) {
      const flag = this.flags[i];
      if (flag != null) {
        res[flag] = !!(val & 1 << i);
      }
    }
    return res;
  }
  size() {
    return this.type.size();
  }
  encode(stream2, keys2) {
    let val = 0;
    for (let i = 0; i < this.flags.length; i++) {
      const flag = this.flags[i];
      if (flag != null) {
        if (keys2[flag]) {
          val |= 1 << i;
        }
      }
    }
    return this.type.encode(stream2, val);
  }
};

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/Buffer.js
var BufferT = class extends Base {
  constructor(length4) {
    super();
    this.length = length4;
  }
  decode(stream2, parent) {
    const length4 = resolveLength(this.length, stream2, parent);
    return stream2.readBuffer(length4);
  }
  size(val, parent) {
    if (!val) {
      return resolveLength(this.length, null, parent);
    }
    let len = val.length;
    if (this.length instanceof NumberT) {
      len += this.length.size();
    }
    return len;
  }
  encode(stream2, buf, parent) {
    if (this.length instanceof NumberT) {
      this.length.encode(stream2, buf.length);
    }
    return stream2.writeBuffer(buf);
  }
};

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/Optional.js
var Optional = class extends Base {
  constructor(type2, condition = true) {
    super();
    this.type = type2;
    this.condition = condition;
  }
  decode(stream2, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.decode(stream2, parent);
    }
  }
  size(val, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.size(val, parent);
    } else {
      return 0;
    }
  }
  encode(stream2, val, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.encode(stream2, val, parent);
    }
  }
};

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/Reserved.js
var Reserved = class extends Base {
  constructor(type2, count = 1) {
    super();
    this.type = type2;
    this.count = count;
  }
  decode(stream2, parent) {
    stream2.pos += this.size(null, parent);
    return void 0;
  }
  size(data2, parent) {
    const count = resolveLength(this.count, null, parent);
    return this.type.size() * count;
  }
  encode(stream2, val, parent) {
    return stream2.fill(0, this.size(val, parent));
  }
};

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/String.js
var StringT = class extends Base {
  constructor(length4, encoding = "ascii") {
    super();
    this.length = length4;
    this.encoding = encoding;
  }
  decode(stream2, parent) {
    let length4, pos;
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent, parent) || "ascii";
    }
    let width = encodingWidth(encoding);
    if (this.length != null) {
      length4 = resolveLength(this.length, stream2, parent);
    } else {
      let buffer;
      ({ buffer, length: length4, pos } = stream2);
      while (pos < length4 - width + 1 && (buffer[pos] !== 0 || width === 2 && buffer[pos + 1] !== 0)) {
        pos += width;
      }
      length4 = pos - stream2.pos;
    }
    const string = stream2.readString(length4, encoding);
    if (this.length == null && stream2.pos < stream2.length) {
      stream2.pos += width;
    }
    return string;
  }
  size(val, parent) {
    if (val === void 0 || val === null) {
      return resolveLength(this.length, null, parent);
    }
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
    }
    if (encoding === "utf16be") {
      encoding = "utf16le";
    }
    let size = byteLength(val, encoding);
    if (this.length instanceof NumberT) {
      size += this.length.size();
    }
    if (this.length == null) {
      size += encodingWidth(encoding);
    }
    return size;
  }
  encode(stream2, val, parent) {
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
    }
    if (this.length instanceof NumberT) {
      this.length.encode(stream2, byteLength(val, encoding));
    }
    stream2.writeString(val, encoding);
    if (this.length == null) {
      return encodingWidth(encoding) == 2 ? stream2.writeUInt16LE(0) : stream2.writeUInt8(0);
    }
  }
};
function encodingWidth(encoding) {
  switch (encoding) {
    case "ascii":
    case "utf8":
      return 1;
    case "utf16le":
    case "utf16-le":
    case "utf-16be":
    case "utf-16le":
    case "utf16be":
    case "utf16-be":
    case "ucs2":
      return 2;
    default:
      return 1;
  }
}
function byteLength(string, encoding) {
  switch (encoding) {
    case "ascii":
      return string.length;
    case "utf8":
      let len = 0;
      for (let i = 0; i < string.length; i++) {
        let c2 = string.charCodeAt(i);
        if (c2 >= 55296 && c2 <= 56319 && i < string.length - 1) {
          let c22 = string.charCodeAt(++i);
          if ((c22 & 64512) === 56320) {
            c2 = ((c2 & 1023) << 10) + (c22 & 1023) + 65536;
          } else {
            i--;
          }
        }
        if ((c2 & 4294967168) === 0) {
          len++;
        } else if ((c2 & 4294965248) === 0) {
          len += 2;
        } else if ((c2 & 4294901760) === 0) {
          len += 3;
        } else if ((c2 & 4292870144) === 0) {
          len += 4;
        }
      }
      return len;
    case "utf16le":
    case "utf16-le":
    case "utf16be":
    case "utf16-be":
    case "ucs2":
      return string.length * 2;
    default:
      throw new Error("Unknown encoding " + encoding);
  }
}

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/Struct.js
var Struct = class extends Base {
  constructor(fields = {}) {
    super();
    this.fields = fields;
  }
  decode(stream2, parent, length4 = 0) {
    const res = this._setup(stream2, parent, length4);
    this._parseFields(stream2, res, this.fields);
    if (this.process != null) {
      this.process.call(res, stream2);
    }
    return res;
  }
  _setup(stream2, parent, length4) {
    const res = {};
    Object.defineProperties(res, {
      parent: { value: parent },
      _startOffset: { value: stream2.pos },
      _currentOffset: { value: 0, writable: true },
      _length: { value: length4 }
    });
    return res;
  }
  _parseFields(stream2, res, fields) {
    for (let key in fields) {
      var val;
      const type2 = fields[key];
      if (typeof type2 === "function") {
        val = type2.call(res, res);
      } else {
        val = type2.decode(stream2, res);
      }
      if (val !== void 0) {
        if (val instanceof PropertyDescriptor) {
          Object.defineProperty(res, key, val);
        } else {
          res[key] = val;
        }
      }
      res._currentOffset = stream2.pos - res._startOffset;
    }
  }
  size(val, parent, includePointers = true) {
    if (val == null) {
      val = {};
    }
    const ctx = {
      parent,
      val,
      pointerSize: 0
    };
    if (this.preEncode != null) {
      this.preEncode.call(val);
    }
    let size = 0;
    for (let key in this.fields) {
      const type2 = this.fields[key];
      if (type2.size != null) {
        size += type2.size(val[key], ctx);
      }
    }
    if (includePointers) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, val, parent) {
    let type2;
    if (this.preEncode != null) {
      this.preEncode.call(val, stream2);
    }
    const ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
    for (let key in this.fields) {
      type2 = this.fields[key];
      if (type2.encode != null) {
        type2.encode(stream2, val[key], ctx);
      }
    }
    let i = 0;
    while (i < ctx.pointers.length) {
      const ptr = ctx.pointers[i++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
  }
};

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/VersionedStruct.js
var getPath = (object, pathArray) => {
  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);
};
var VersionedStruct = class _VersionedStruct extends Struct {
  constructor(type2, versions3 = {}) {
    super();
    this.type = type2;
    this.versions = versions3;
    if (typeof type2 === "string") {
      this.versionPath = type2.split(".");
    }
  }
  decode(stream2, parent, length4 = 0) {
    const res = this._setup(stream2, parent, length4);
    if (typeof this.type === "string") {
      res.version = getPath(parent, this.versionPath);
    } else {
      res.version = this.type.decode(stream2);
    }
    if (this.versions.header) {
      this._parseFields(stream2, res, this.versions.header);
    }
    const fields = this.versions[res.version];
    if (fields == null) {
      throw new Error(`Unknown version ${res.version}`);
    }
    if (fields instanceof _VersionedStruct) {
      return fields.decode(stream2, parent);
    }
    this._parseFields(stream2, res, fields);
    if (this.process != null) {
      this.process.call(res, stream2);
    }
    return res;
  }
  size(val, parent, includePointers = true) {
    let key, type2;
    if (!val) {
      throw new Error("Not a fixed size");
    }
    if (this.preEncode != null) {
      this.preEncode.call(val);
    }
    const ctx = {
      parent,
      val,
      pointerSize: 0
    };
    let size = 0;
    if (typeof this.type !== "string") {
      size += this.type.size(val.version, ctx);
    }
    if (this.versions.header) {
      for (key in this.versions.header) {
        type2 = this.versions.header[key];
        if (type2.size != null) {
          size += type2.size(val[key], ctx);
        }
      }
    }
    const fields = this.versions[val.version];
    if (fields == null) {
      throw new Error(`Unknown version ${val.version}`);
    }
    for (key in fields) {
      type2 = fields[key];
      if (type2.size != null) {
        size += type2.size(val[key], ctx);
      }
    }
    if (includePointers) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, val, parent) {
    let key, type2;
    if (this.preEncode != null) {
      this.preEncode.call(val, stream2);
    }
    const ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
    if (typeof this.type !== "string") {
      this.type.encode(stream2, val.version);
    }
    if (this.versions.header) {
      for (key in this.versions.header) {
        type2 = this.versions.header[key];
        if (type2.encode != null) {
          type2.encode(stream2, val[key], ctx);
        }
      }
    }
    const fields = this.versions[val.version];
    for (key in fields) {
      type2 = fields[key];
      if (type2.encode != null) {
        type2.encode(stream2, val[key], ctx);
      }
    }
    let i = 0;
    while (i < ctx.pointers.length) {
      const ptr = ctx.pointers[i++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
  }
};

// ../../.yarn/cache/restructure-npm-3.0.2-d74eb43026-f13536c094.zip/node_modules/restructure/src/Pointer.js
var Pointer = class extends Base {
  constructor(offsetType, type2, options = {}) {
    super();
    this.offsetType = offsetType;
    this.type = type2;
    this.options = options;
    if (this.type === "void") {
      this.type = null;
    }
    if (this.options.type == null) {
      this.options.type = "local";
    }
    if (this.options.allowNull == null) {
      this.options.allowNull = true;
    }
    if (this.options.nullValue == null) {
      this.options.nullValue = 0;
    }
    if (this.options.lazy == null) {
      this.options.lazy = false;
    }
    if (this.options.relativeTo) {
      if (typeof this.options.relativeTo !== "function") {
        throw new Error("relativeTo option must be a function");
      }
      this.relativeToGetter = options.relativeTo;
    }
  }
  decode(stream2, ctx) {
    const offset3 = this.offsetType.decode(stream2, ctx);
    if (offset3 === this.options.nullValue && this.options.allowNull) {
      return null;
    }
    let relative;
    switch (this.options.type) {
      case "local":
        relative = ctx._startOffset;
        break;
      case "immediate":
        relative = stream2.pos - this.offsetType.size();
        break;
      case "parent":
        relative = ctx.parent._startOffset;
        break;
      default:
        var c2 = ctx;
        while (c2.parent) {
          c2 = c2.parent;
        }
        relative = c2._startOffset || 0;
    }
    if (this.options.relativeTo) {
      relative += this.relativeToGetter(ctx);
    }
    const ptr = offset3 + relative;
    if (this.type != null) {
      let val = null;
      const decodeValue = () => {
        if (val != null) {
          return val;
        }
        const { pos } = stream2;
        stream2.pos = ptr;
        val = this.type.decode(stream2, ctx);
        stream2.pos = pos;
        return val;
      };
      if (this.options.lazy) {
        return new PropertyDescriptor({
          get: decodeValue
        });
      }
      return decodeValue();
    } else {
      return ptr;
    }
  }
  size(val, ctx) {
    const parent = ctx;
    switch (this.options.type) {
      case "local":
      case "immediate":
        break;
      case "parent":
        ctx = ctx.parent;
        break;
      default:
        while (ctx.parent) {
          ctx = ctx.parent;
        }
    }
    let { type: type2 } = this;
    if (type2 == null) {
      if (!(val instanceof VoidPointer)) {
        throw new Error("Must be a VoidPointer");
      }
      ({ type: type2 } = val);
      val = val.value;
    }
    if (val && ctx) {
      let size = type2.size(val, parent);
      ctx.pointerSize += size;
    }
    return this.offsetType.size();
  }
  encode(stream2, val, ctx) {
    let relative;
    const parent = ctx;
    if (val == null) {
      this.offsetType.encode(stream2, this.options.nullValue);
      return;
    }
    switch (this.options.type) {
      case "local":
        relative = ctx.startOffset;
        break;
      case "immediate":
        relative = stream2.pos + this.offsetType.size(val, parent);
        break;
      case "parent":
        ctx = ctx.parent;
        relative = ctx.startOffset;
        break;
      default:
        relative = 0;
        while (ctx.parent) {
          ctx = ctx.parent;
        }
    }
    if (this.options.relativeTo) {
      relative += this.relativeToGetter(parent.val);
    }
    this.offsetType.encode(stream2, ctx.pointerOffset - relative);
    let { type: type2 } = this;
    if (type2 == null) {
      if (!(val instanceof VoidPointer)) {
        throw new Error("Must be a VoidPointer");
      }
      ({ type: type2 } = val);
      val = val.value;
    }
    ctx.pointers.push({
      type: type2,
      val,
      parent
    });
    return ctx.pointerOffset += type2.size(val, parent);
  }
};
var VoidPointer = class {
  constructor(type2, value2) {
    this.type = type2;
    this.value = value2;
  }
};

// ../../.yarn/cache/@swc-helpers-npm-0.4.36-507abd5d2a-b3b12d0305.zip/node_modules/@swc/helpers/esm/_define_property.js
function _define_property(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else obj[key] = value2;
  return obj;
}

// ../../.yarn/cache/tslib-npm-2.6.3-0fd136b3be-2598aef53d.zip/node_modules/tslib/tslib.es6.mjs
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
}

// ../../.yarn/cache/fontkit-npm-2.0.2-d65b0dc942-e7c762eef9.zip/node_modules/fontkit/dist/browser-module.mjs
var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);

// ../../.yarn/cache/unicode-properties-npm-1.4.1-122054452f-1d140b7945.zip/node_modules/unicode-properties/dist/module.mjs
var import_base64_js = __toESM(require_base64_js(), 1);
var import_unicode_trie = __toESM(require_unicode_trie(), 1);
function $parcel$interopDefault(a2) {
  return a2 && a2.__esModule ? a2.default : a2;
}
var $f4087201da764553$exports = {};
$f4087201da764553$exports = JSON.parse('{"categories":["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"],"combiningClasses":["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"],"scripts":["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Osage","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Hanifi_Rohingya","Old_Sogdian","Sogdian","Elymaic","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Newa","Tirhuta","Siddham","Modi","Takri","Ahom","Dogra","Warang_Citi","Nandinagari","Zanabazar_Square","Soyombo","Pau_Cin_Hau","Bhaiksuki","Marchen","Masaram_Gondi","Gunjala_Gondi","Makasar","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Medefaidrin","Miao","Tangut","Nushu","Duployan","SignWriting","Nyiakeng_Puachue_Hmong","Wancho","Mende_Kikakui","Adlam"],"eaw":["N","Na","A","W","H","F"]}');
var $747425b437e121da$var$trie = new (0, import_unicode_trie.default)((0, import_base64_js.default).toByteArray("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"));
var $747425b437e121da$var$log2 = Math.log2 || ((n) => Math.log(n) / Math.LN2);
var $747425b437e121da$var$bits = (n) => $747425b437e121da$var$log2(n) + 1 | 0;
var $747425b437e121da$var$CATEGORY_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).categories.length - 1);
var $747425b437e121da$var$COMBINING_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).combiningClasses.length - 1);
var $747425b437e121da$var$SCRIPT_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).scripts.length - 1);
var $747425b437e121da$var$EAW_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).eaw.length - 1);
var $747425b437e121da$var$NUMBER_BITS = 10;
var $747425b437e121da$var$CATEGORY_SHIFT = $747425b437e121da$var$COMBINING_BITS + $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$COMBINING_SHIFT = $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$SCRIPT_SHIFT = $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$EAW_SHIFT = $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$CATEGORY_MASK = (1 << $747425b437e121da$var$CATEGORY_BITS) - 1;
var $747425b437e121da$var$COMBINING_MASK = (1 << $747425b437e121da$var$COMBINING_BITS) - 1;
var $747425b437e121da$var$SCRIPT_MASK = (1 << $747425b437e121da$var$SCRIPT_BITS) - 1;
var $747425b437e121da$var$EAW_MASK = (1 << $747425b437e121da$var$EAW_BITS) - 1;
var $747425b437e121da$var$NUMBER_MASK = (1 << $747425b437e121da$var$NUMBER_BITS) - 1;
function $747425b437e121da$export$410364bbb673ddbc(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).categories[val >> $747425b437e121da$var$CATEGORY_SHIFT & $747425b437e121da$var$CATEGORY_MASK];
}
function $747425b437e121da$export$c03b919c6651ed55(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).combiningClasses[val >> $747425b437e121da$var$COMBINING_SHIFT & $747425b437e121da$var$COMBINING_MASK];
}
function $747425b437e121da$export$941569448d136665(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).scripts[val >> $747425b437e121da$var$SCRIPT_SHIFT & $747425b437e121da$var$SCRIPT_MASK];
}
function $747425b437e121da$export$92f6187db8ca6d26(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).eaw[val >> $747425b437e121da$var$EAW_SHIFT & $747425b437e121da$var$EAW_MASK];
}
function $747425b437e121da$export$7d1258ebb7625a0d(codePoint) {
  let val = $747425b437e121da$var$trie.get(codePoint);
  let num = val & $747425b437e121da$var$NUMBER_MASK;
  if (num === 0) return null;
  else if (num <= 50) return num - 1;
  else if (num < 480) {
    const numerator = (num >> 4) - 12;
    const denominator = (num & 15) + 1;
    return numerator / denominator;
  } else if (num < 768) {
    val = (num >> 5) - 14;
    let exp = (num & 31) + 2;
    while (exp > 0) {
      val *= 10;
      exp--;
    }
    return val;
  } else {
    val = (num >> 2) - 191;
    let exp = (num & 3) + 1;
    while (exp > 0) {
      val *= 60;
      exp--;
    }
    return val;
  }
}
function $747425b437e121da$export$52c8ea63abd07594(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Nl";
}
function $747425b437e121da$export$727d9dbc4fbb948f(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Nd";
}
function $747425b437e121da$export$a5b49f4dc6a07d2c(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Pc" || category === "Pd" || category === "Pe" || category === "Pf" || category === "Pi" || category === "Po" || category === "Ps";
}
function $747425b437e121da$export$7b6804e8df61fcf5(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Ll";
}
function $747425b437e121da$export$aebd617640818cda(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lu";
}
function $747425b437e121da$export$de8b4ee23b2cf823(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lt";
}
function $747425b437e121da$export$3c52dd84024ae72c(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Zs" || category === "Zl" || category === "Zp";
}
function $747425b437e121da$export$a11bdcffe109e74b(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Nd" || category === "No" || category === "Nl" || category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Me" || category === "Mc";
}
function $747425b437e121da$export$e33ad6871e762338(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Mn" || category === "Me" || category === "Mc";
}
var $747425b437e121da$export$2e2bcd8739ae039 = {
  getCategory: $747425b437e121da$export$410364bbb673ddbc,
  getCombiningClass: $747425b437e121da$export$c03b919c6651ed55,
  getScript: $747425b437e121da$export$941569448d136665,
  getEastAsianWidth: $747425b437e121da$export$92f6187db8ca6d26,
  getNumericValue: $747425b437e121da$export$7d1258ebb7625a0d,
  isAlphabetic: $747425b437e121da$export$52c8ea63abd07594,
  isDigit: $747425b437e121da$export$727d9dbc4fbb948f,
  isPunctuation: $747425b437e121da$export$a5b49f4dc6a07d2c,
  isLowerCase: $747425b437e121da$export$7b6804e8df61fcf5,
  isUpperCase: $747425b437e121da$export$aebd617640818cda,
  isTitleCase: $747425b437e121da$export$de8b4ee23b2cf823,
  isWhiteSpace: $747425b437e121da$export$3c52dd84024ae72c,
  isBaseForm: $747425b437e121da$export$a11bdcffe109e74b,
  isMark: $747425b437e121da$export$e33ad6871e762338
};

// ../../.yarn/cache/fontkit-npm-2.0.2-d65b0dc942-e7c762eef9.zip/node_modules/fontkit/dist/browser-module.mjs
var import_unicode_trie2 = __toESM(require_unicode_trie(), 1);
var import_dfa = __toESM(require_dfa(), 1);
var import_clone = __toESM(require_clone(), 1);
var import_tiny_inflate = __toESM(require_tiny_inflate(), 1);
var import_decompress = __toESM(require_decompress(), 1);
function $parcel$export(e, n, v2, s2) {
  Object.defineProperty(e, n, { get: v2, set: s2, enumerable: true, configurable: true });
}
function $parcel$interopDefault2(a2) {
  return a2 && a2.__esModule ? a2.default : a2;
}
var $d636bc798e7178db$exports = {};
$parcel$export($d636bc798e7178db$exports, "logErrors", () => $d636bc798e7178db$export$bd5c5d8b8dcafd78);
$parcel$export($d636bc798e7178db$exports, "registerFormat", () => $d636bc798e7178db$export$36b2f24e97d43be);
$parcel$export($d636bc798e7178db$exports, "create", () => $d636bc798e7178db$export$185802fd694ee1f5);
$parcel$export($d636bc798e7178db$exports, "defaultLanguage", () => $d636bc798e7178db$export$42940898df819940);
$parcel$export($d636bc798e7178db$exports, "setDefaultLanguage", () => $d636bc798e7178db$export$5157e7780d44cc36);
var $d636bc798e7178db$export$bd5c5d8b8dcafd78 = false;
var $d636bc798e7178db$var$formats = [];
function $d636bc798e7178db$export$36b2f24e97d43be(format3) {
  $d636bc798e7178db$var$formats.push(format3);
}
function $d636bc798e7178db$export$185802fd694ee1f5(buffer, postscriptName) {
  for (let i = 0; i < $d636bc798e7178db$var$formats.length; i++) {
    let format3 = $d636bc798e7178db$var$formats[i];
    if (format3.probe(buffer)) {
      let font2 = new format3(new (0, DecodeStream)(buffer));
      if (postscriptName) return font2.getFont(postscriptName);
      return font2;
    }
  }
  throw new Error("Unknown font format");
}
var $d636bc798e7178db$export$42940898df819940 = "en";
function $d636bc798e7178db$export$5157e7780d44cc36(lang = "en") {
  $d636bc798e7178db$export$42940898df819940 = lang;
}
function $e71565f2ce09cb6b$export$69a3209f1a06c04d(target, key1, descriptor) {
  if (descriptor.get) {
    let get16 = descriptor.get;
    descriptor.get = function() {
      let value2 = get16.call(this);
      Object.defineProperty(this, key1, {
        value: value2
      });
      return value2;
    };
  } else if (typeof descriptor.value === "function") {
    let fn = descriptor.value;
    return {
      get() {
        let cache1 = /* @__PURE__ */ new Map();
        function memoized(...args) {
          let key = args.length > 0 ? args[0] : "value";
          if (cache1.has(key)) return cache1.get(key);
          let result = fn.apply(this, args);
          cache1.set(key, result);
          return result;
        }
        Object.defineProperty(this, key1, {
          value: memoized
        });
        return memoized;
      }
    };
  }
}
var $26a62205ad06574e$var$SubHeader = new Struct({
  firstCode: uint16,
  entryCount: uint16,
  idDelta: int16,
  idRangeOffset: uint16
});
var $26a62205ad06574e$var$CmapGroup = new Struct({
  startCharCode: uint32,
  endCharCode: uint32,
  glyphID: uint32
});
var $26a62205ad06574e$var$UnicodeValueRange = new Struct({
  startUnicodeValue: uint24,
  additionalCount: uint8
});
var $26a62205ad06574e$var$UVSMapping = new Struct({
  unicodeValue: uint24,
  glyphID: uint16
});
var $26a62205ad06574e$var$DefaultUVS = new ArrayT($26a62205ad06574e$var$UnicodeValueRange, uint32);
var $26a62205ad06574e$var$NonDefaultUVS = new ArrayT($26a62205ad06574e$var$UVSMapping, uint32);
var $26a62205ad06574e$var$VarSelectorRecord = new Struct({
  varSelector: uint24,
  defaultUVS: new Pointer(uint32, $26a62205ad06574e$var$DefaultUVS, {
    type: "parent"
  }),
  nonDefaultUVS: new Pointer(uint32, $26a62205ad06574e$var$NonDefaultUVS, {
    type: "parent"
  })
});
var $26a62205ad06574e$var$CmapSubtable = new VersionedStruct(uint16, {
  0: {
    length: uint16,
    language: uint16,
    codeMap: new LazyArray(uint8, 256)
  },
  2: {
    length: uint16,
    language: uint16,
    subHeaderKeys: new ArrayT(uint16, 256),
    subHeaderCount: (t2) => Math.max.apply(Math, t2.subHeaderKeys),
    subHeaders: new LazyArray($26a62205ad06574e$var$SubHeader, "subHeaderCount"),
    glyphIndexArray: new LazyArray(uint16, "subHeaderCount")
  },
  4: {
    length: uint16,
    language: uint16,
    segCountX2: uint16,
    segCount: (t2) => t2.segCountX2 >> 1,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    endCode: new LazyArray(uint16, "segCount"),
    reservedPad: new Reserved(uint16),
    startCode: new LazyArray(uint16, "segCount"),
    idDelta: new LazyArray(int16, "segCount"),
    idRangeOffset: new LazyArray(uint16, "segCount"),
    glyphIndexArray: new LazyArray(uint16, (t2) => (t2.length - t2._currentOffset) / 2)
  },
  6: {
    length: uint16,
    language: uint16,
    firstCode: uint16,
    entryCount: uint16,
    glyphIndices: new LazyArray(uint16, "entryCount")
  },
  8: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint16,
    is32: new LazyArray(uint8, 8192),
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  10: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    firstCode: uint32,
    entryCount: uint32,
    glyphIndices: new LazyArray(uint16, "numChars")
  },
  12: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  13: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  14: {
    length: uint32,
    numRecords: uint32,
    varSelectors: new LazyArray($26a62205ad06574e$var$VarSelectorRecord, "numRecords")
  }
});
var $26a62205ad06574e$var$CmapEntry = new Struct({
  platformID: uint16,
  encodingID: uint16,
  table: new Pointer(uint32, $26a62205ad06574e$var$CmapSubtable, {
    type: "parent",
    lazy: true
  })
});
var $26a62205ad06574e$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numSubtables: uint16,
  tables: new ArrayT($26a62205ad06574e$var$CmapEntry, "numSubtables")
});
var $f2612a29f92ac062$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  revision: int32,
  checkSumAdjustment: uint32,
  magicNumber: uint32,
  flags: uint16,
  unitsPerEm: uint16,
  created: new ArrayT(int32, 2),
  modified: new ArrayT(int32, 2),
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16,
  macStyle: new Bitfield(uint16, [
    "bold",
    "italic",
    "underline",
    "outline",
    "shadow",
    "condensed",
    "extended"
  ]),
  lowestRecPPEM: uint16,
  fontDirectionHint: int16,
  indexToLocFormat: int16,
  glyphDataFormat: int16
  // 0 for current format
});
var $2c179dd593583073$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  ascent: int16,
  descent: int16,
  lineGap: int16,
  advanceWidthMax: uint16,
  minLeftSideBearing: int16,
  minRightSideBearing: int16,
  xMaxExtent: int16,
  caretSlopeRise: int16,
  caretSlopeRun: int16,
  caretOffset: int16,
  reserved: new Reserved(int16, 4),
  metricDataFormat: int16,
  numberOfMetrics: uint16
  // Number of advance widths in 'hmtx' table
});
var $bdc9060542264b85$var$HmtxEntry = new Struct({
  advance: uint16,
  bearing: int16
});
var $bdc9060542264b85$export$2e2bcd8739ae039 = new Struct({
  metrics: new LazyArray($bdc9060542264b85$var$HmtxEntry, (t2) => t2.parent.hhea.numberOfMetrics),
  bearings: new LazyArray(int16, (t2) => t2.parent.maxp.numGlyphs - t2.parent.hhea.numberOfMetrics)
});
var $dbf51cb3d3fe409d$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  numGlyphs: uint16,
  maxPoints: uint16,
  maxContours: uint16,
  maxComponentPoints: uint16,
  maxComponentContours: uint16,
  maxZones: uint16,
  maxTwilightPoints: uint16,
  maxStorage: uint16,
  maxFunctionDefs: uint16,
  maxInstructionDefs: uint16,
  maxStackElements: uint16,
  maxSizeOfInstructions: uint16,
  maxComponentElements: uint16,
  maxComponentDepth: uint16
  // Maximum levels of recursion; 1 for simple components
});
function $e449ad78d50845fe$export$badc544e0651b6b1(platformID, encodingID, languageID = 0) {
  if (platformID === 1 && $e449ad78d50845fe$export$479e671907f486d1[languageID]) return $e449ad78d50845fe$export$479e671907f486d1[languageID];
  return $e449ad78d50845fe$export$6fef87b7618bdf0b[platformID][encodingID];
}
var $e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS = /* @__PURE__ */ new Set([
  "x-mac-roman",
  "x-mac-cyrillic",
  "iso-8859-6",
  "iso-8859-8"
]);
var $e449ad78d50845fe$var$MAC_ENCODINGS = {
  "x-mac-croatian": " ",
  "x-mac-gaelic": " ",
  "x-mac-greek": " ",
  "x-mac-icelandic": " ",
  "x-mac-inuit": " ",
  "x-mac-ce": " ",
  "x-mac-romanian": " ",
  "x-mac-turkish": " "
};
var $e449ad78d50845fe$var$encodingCache = /* @__PURE__ */ new Map();
function $e449ad78d50845fe$export$1dceb3c14ed68bee(encoding) {
  let cached = $e449ad78d50845fe$var$encodingCache.get(encoding);
  if (cached) return cached;
  let mapping = $e449ad78d50845fe$var$MAC_ENCODINGS[encoding];
  if (mapping) {
    let res = /* @__PURE__ */ new Map();
    for (let i = 0; i < mapping.length; i++) res.set(mapping.charCodeAt(i), 128 + i);
    $e449ad78d50845fe$var$encodingCache.set(encoding, res);
    return res;
  }
  if ($e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS.has(encoding)) {
    let decoder2 = new TextDecoder(encoding);
    let mapping2 = new Uint8Array(128);
    for (let i = 0; i < 128; i++) mapping2[i] = 128 + i;
    let res = /* @__PURE__ */ new Map();
    let s2 = decoder2.decode(mapping2);
    for (let i1 = 0; i1 < 128; i1++) res.set(s2.charCodeAt(i1), 128 + i1);
    $e449ad78d50845fe$var$encodingCache.set(encoding, res);
    return res;
  }
}
var $e449ad78d50845fe$export$6fef87b7618bdf0b = [
  // unicode
  [
    "utf16be",
    "utf16be",
    "utf16be",
    "utf16be",
    "utf16be",
    "utf16be"
  ],
  // macintosh
  // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/
  // 0	Roman                 17	Malayalam
  // 1	Japanese	            18	Sinhalese
  // 2	Traditional Chinese	  19	Burmese
  // 3	Korean	              20	Khmer
  // 4	Arabic	              21	Thai
  // 5	Hebrew	              22	Laotian
  // 6	Greek	                23	Georgian
  // 7	Russian	              24	Armenian
  // 8	RSymbol	              25	Simplified Chinese
  // 9	Devanagari	          26	Tibetan
  // 10	Gurmukhi	            27	Mongolian
  // 11	Gujarati	            28	Geez
  // 12	Oriya	                29	Slavic
  // 13	Bengali	              30	Vietnamese
  // 14	Tamil	                31	Sindhi
  // 15	Telugu	              32	(Uninterpreted)
  // 16	Kannada
  [
    "x-mac-roman",
    "shift-jis",
    "big5",
    "euc-kr",
    "iso-8859-6",
    "iso-8859-8",
    "x-mac-greek",
    "x-mac-cyrillic",
    "x-mac-symbol",
    "x-mac-devanagari",
    "x-mac-gurmukhi",
    "x-mac-gujarati",
    "Oriya",
    "Bengali",
    "Tamil",
    "Telugu",
    "Kannada",
    "Malayalam",
    "Sinhalese",
    "Burmese",
    "Khmer",
    "iso-8859-11",
    "Laotian",
    "Georgian",
    "Armenian",
    "hz-gb-2312",
    "Tibetan",
    "Mongolian",
    "Geez",
    "x-mac-ce",
    "Vietnamese",
    "Sindhi"
  ],
  // ISO (deprecated)
  [
    "ascii"
  ],
  // windows
  // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx
  [
    "symbol",
    "utf16be",
    "shift-jis",
    "gb18030",
    "big5",
    "x-cp20949",
    "johab",
    null,
    null,
    null,
    "utf16be"
  ]
];
var $e449ad78d50845fe$export$479e671907f486d1 = {
  15: "x-mac-icelandic",
  17: "x-mac-turkish",
  18: "x-mac-croatian",
  24: "x-mac-ce",
  25: "x-mac-ce",
  26: "x-mac-ce",
  27: "x-mac-ce",
  28: "x-mac-ce",
  30: "x-mac-icelandic",
  37: "x-mac-romanian",
  38: "x-mac-ce",
  39: "x-mac-ce",
  40: "x-mac-ce",
  143: "x-mac-inuit",
  146: "x-mac-gaelic"
};
var $e449ad78d50845fe$export$2092376fd002e13 = [
  // unicode
  [],
  {
    0: "en",
    30: "fo",
    60: "ks",
    90: "rw",
    1: "fr",
    31: "fa",
    61: "ku",
    91: "rn",
    2: "de",
    32: "ru",
    62: "sd",
    92: "ny",
    3: "it",
    33: "zh",
    63: "bo",
    93: "mg",
    4: "nl",
    34: "nl-BE",
    64: "ne",
    94: "eo",
    5: "sv",
    35: "ga",
    65: "sa",
    128: "cy",
    6: "es",
    36: "sq",
    66: "mr",
    129: "eu",
    7: "da",
    37: "ro",
    67: "bn",
    130: "ca",
    8: "pt",
    38: "cz",
    68: "as",
    131: "la",
    9: "no",
    39: "sk",
    69: "gu",
    132: "qu",
    10: "he",
    40: "si",
    70: "pa",
    133: "gn",
    11: "ja",
    41: "yi",
    71: "or",
    134: "ay",
    12: "ar",
    42: "sr",
    72: "ml",
    135: "tt",
    13: "fi",
    43: "mk",
    73: "kn",
    136: "ug",
    14: "el",
    44: "bg",
    74: "ta",
    137: "dz",
    15: "is",
    45: "uk",
    75: "te",
    138: "jv",
    16: "mt",
    46: "be",
    76: "si",
    139: "su",
    17: "tr",
    47: "uz",
    77: "my",
    140: "gl",
    18: "hr",
    48: "kk",
    78: "km",
    141: "af",
    19: "zh-Hant",
    49: "az-Cyrl",
    79: "lo",
    142: "br",
    20: "ur",
    50: "az-Arab",
    80: "vi",
    143: "iu",
    21: "hi",
    51: "hy",
    81: "id",
    144: "gd",
    22: "th",
    52: "ka",
    82: "tl",
    145: "gv",
    23: "ko",
    53: "mo",
    83: "ms",
    146: "ga",
    24: "lt",
    54: "ky",
    84: "ms-Arab",
    147: "to",
    25: "pl",
    55: "tg",
    85: "am",
    148: "el-polyton",
    26: "hu",
    56: "tk",
    86: "ti",
    149: "kl",
    27: "es",
    57: "mn-CN",
    87: "om",
    150: "az",
    28: "lv",
    58: "mn",
    88: "so",
    151: "nn",
    29: "se",
    59: "ps",
    89: "sw"
  },
  // ISO (deprecated)
  [],
  {
    1078: "af",
    16393: "en-IN",
    1159: "rw",
    1074: "tn",
    1052: "sq",
    6153: "en-IE",
    1089: "sw",
    1115: "si",
    1156: "gsw",
    8201: "en-JM",
    1111: "kok",
    1051: "sk",
    1118: "am",
    17417: "en-MY",
    1042: "ko",
    1060: "sl",
    5121: "ar-DZ",
    5129: "en-NZ",
    1088: "ky",
    11274: "es-AR",
    15361: "ar-BH",
    13321: "en-PH",
    1108: "lo",
    16394: "es-BO",
    3073: "ar",
    18441: "en-SG",
    1062: "lv",
    13322: "es-CL",
    2049: "ar-IQ",
    7177: "en-ZA",
    1063: "lt",
    9226: "es-CO",
    11265: "ar-JO",
    11273: "en-TT",
    2094: "dsb",
    5130: "es-CR",
    13313: "ar-KW",
    2057: "en-GB",
    1134: "lb",
    7178: "es-DO",
    12289: "ar-LB",
    1033: "en",
    1071: "mk",
    12298: "es-EC",
    4097: "ar-LY",
    12297: "en-ZW",
    2110: "ms-BN",
    17418: "es-SV",
    6145: "ary",
    1061: "et",
    1086: "ms",
    4106: "es-GT",
    8193: "ar-OM",
    1080: "fo",
    1100: "ml",
    18442: "es-HN",
    16385: "ar-QA",
    1124: "fil",
    1082: "mt",
    2058: "es-MX",
    1025: "ar-SA",
    1035: "fi",
    1153: "mi",
    19466: "es-NI",
    10241: "ar-SY",
    2060: "fr-BE",
    1146: "arn",
    6154: "es-PA",
    7169: "aeb",
    3084: "fr-CA",
    1102: "mr",
    15370: "es-PY",
    14337: "ar-AE",
    1036: "fr",
    1148: "moh",
    10250: "es-PE",
    9217: "ar-YE",
    5132: "fr-LU",
    1104: "mn",
    20490: "es-PR",
    1067: "hy",
    6156: "fr-MC",
    2128: "mn-CN",
    3082: "es",
    1101: "as",
    4108: "fr-CH",
    1121: "ne",
    1034: "es",
    2092: "az-Cyrl",
    1122: "fy",
    1044: "nb",
    21514: "es-US",
    1068: "az",
    1110: "gl",
    2068: "nn",
    14346: "es-UY",
    1133: "ba",
    1079: "ka",
    1154: "oc",
    8202: "es-VE",
    1069: "eu",
    3079: "de-AT",
    1096: "or",
    2077: "sv-FI",
    1059: "be",
    1031: "de",
    1123: "ps",
    1053: "sv",
    2117: "bn",
    5127: "de-LI",
    1045: "pl",
    1114: "syr",
    1093: "bn-IN",
    4103: "de-LU",
    1046: "pt",
    1064: "tg",
    8218: "bs-Cyrl",
    2055: "de-CH",
    2070: "pt-PT",
    2143: "tzm",
    5146: "bs",
    1032: "el",
    1094: "pa",
    1097: "ta",
    1150: "br",
    1135: "kl",
    1131: "qu-BO",
    1092: "tt",
    1026: "bg",
    1095: "gu",
    2155: "qu-EC",
    1098: "te",
    1027: "ca",
    1128: "ha",
    3179: "qu",
    1054: "th",
    3076: "zh-HK",
    1037: "he",
    1048: "ro",
    1105: "bo",
    5124: "zh-MO",
    1081: "hi",
    1047: "rm",
    1055: "tr",
    2052: "zh",
    1038: "hu",
    1049: "ru",
    1090: "tk",
    4100: "zh-SG",
    1039: "is",
    9275: "smn",
    1152: "ug",
    1028: "zh-TW",
    1136: "ig",
    4155: "smj-NO",
    1058: "uk",
    1155: "co",
    1057: "id",
    5179: "smj",
    1070: "hsb",
    1050: "hr",
    1117: "iu",
    3131: "se-FI",
    1056: "ur",
    4122: "hr-BA",
    2141: "iu-Latn",
    1083: "se",
    2115: "uz-Cyrl",
    1029: "cs",
    2108: "ga",
    2107: "se-SE",
    1091: "uz",
    1030: "da",
    1076: "xh",
    8251: "sms",
    1066: "vi",
    1164: "prs",
    1077: "zu",
    6203: "sma-NO",
    1106: "cy",
    1125: "dv",
    1040: "it",
    7227: "sms",
    1160: "wo",
    2067: "nl-BE",
    2064: "it-CH",
    1103: "sa",
    1157: "sah",
    1043: "nl",
    1041: "ja",
    7194: "sr-Cyrl-BA",
    1144: "ii",
    3081: "en-AU",
    1099: "kn",
    3098: "sr",
    1130: "yo",
    10249: "en-BZ",
    1087: "kk",
    6170: "sr-Latn-BA",
    4105: "en-CA",
    1107: "km",
    2074: "sr-Latn",
    9225: "en-029",
    1158: "quc",
    1132: "nso"
  }
];
var $2bcf221753ec8e32$var$NameRecord = new Struct({
  platformID: uint16,
  encodingID: uint16,
  languageID: uint16,
  nameID: uint16,
  length: uint16,
  string: new Pointer(uint16, new StringT("length", (t2) => (0, $e449ad78d50845fe$export$badc544e0651b6b1)(t2.platformID, t2.encodingID, t2.languageID)), {
    type: "parent",
    relativeTo: (ctx) => ctx.parent.stringOffset,
    allowNull: false
  })
});
var $2bcf221753ec8e32$var$LangTagRecord = new Struct({
  length: uint16,
  tag: new Pointer(uint16, new StringT("length", "utf16be"), {
    type: "parent",
    relativeTo: (ctx) => ctx.stringOffset
  })
});
var $2bcf221753ec8e32$var$NameTable = new VersionedStruct(uint16, {
  0: {
    count: uint16,
    stringOffset: uint16,
    records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count")
  },
  1: {
    count: uint16,
    stringOffset: uint16,
    records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count"),
    langTagCount: uint16,
    langTags: new ArrayT($2bcf221753ec8e32$var$LangTagRecord, "langTagCount")
  }
});
var $2bcf221753ec8e32$export$2e2bcd8739ae039 = $2bcf221753ec8e32$var$NameTable;
var $2bcf221753ec8e32$var$NAMES = [
  "copyright",
  "fontFamily",
  "fontSubfamily",
  "uniqueSubfamily",
  "fullName",
  "version",
  "postscriptName",
  "trademark",
  "manufacturer",
  "designer",
  "description",
  "vendorURL",
  "designerURL",
  "license",
  "licenseURL",
  null,
  "preferredFamily",
  "preferredSubfamily",
  "compatibleFull",
  "sampleText",
  "postscriptCIDFontName",
  "wwsFamilyName",
  "wwsSubfamilyName"
];
$2bcf221753ec8e32$var$NameTable.process = function(stream2) {
  var records = {};
  for (let record of this.records) {
    let language = (0, $e449ad78d50845fe$export$2092376fd002e13)[record.platformID][record.languageID];
    if (language == null && this.langTags != null && record.languageID >= 32768) language = this.langTags[record.languageID - 32768].tag;
    if (language == null) language = record.platformID + "-" + record.languageID;
    let key = record.nameID >= 256 ? "fontFeatures" : $2bcf221753ec8e32$var$NAMES[record.nameID] || record.nameID;
    if (records[key] == null) records[key] = {};
    let obj = records[key];
    if (record.nameID >= 256) obj = obj[record.nameID] || (obj[record.nameID] = {});
    if (typeof record.string === "string" || typeof obj[language] !== "string") obj[language] = record.string;
  }
  this.records = records;
};
$2bcf221753ec8e32$var$NameTable.preEncode = function() {
  if (Array.isArray(this.records)) return;
  this.version = 0;
  let records = [];
  for (let key in this.records) {
    let val = this.records[key];
    if (key === "fontFeatures") continue;
    records.push({
      platformID: 3,
      encodingID: 1,
      languageID: 1033,
      nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
      length: val.en.length * 2,
      string: val.en
    });
    if (key === "postscriptName") records.push({
      platformID: 1,
      encodingID: 0,
      languageID: 0,
      nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
      length: val.en.length,
      string: val.en
    });
  }
  this.records = records;
  this.count = records.length;
  this.stringOffset = $2bcf221753ec8e32$var$NameTable.size(this, null, false);
};
var $84b272aa31b70606$var$OS2 = new VersionedStruct(uint16, {
  header: {
    xAvgCharWidth: int16,
    usWeightClass: uint16,
    usWidthClass: uint16,
    fsType: new Bitfield(uint16, [
      null,
      "noEmbedding",
      "viewOnly",
      "editable",
      null,
      null,
      null,
      null,
      "noSubsetting",
      "bitmapOnly"
    ]),
    ySubscriptXSize: int16,
    ySubscriptYSize: int16,
    ySubscriptXOffset: int16,
    ySubscriptYOffset: int16,
    ySuperscriptXSize: int16,
    ySuperscriptYSize: int16,
    ySuperscriptXOffset: int16,
    ySuperscriptYOffset: int16,
    yStrikeoutSize: int16,
    yStrikeoutPosition: int16,
    sFamilyClass: int16,
    panose: new ArrayT(uint8, 10),
    ulCharRange: new ArrayT(uint32, 4),
    vendorID: new StringT(4),
    fsSelection: new Bitfield(uint16, [
      "italic",
      "underscore",
      "negative",
      "outlined",
      "strikeout",
      "bold",
      "regular",
      "useTypoMetrics",
      "wws",
      "oblique"
    ]),
    usFirstCharIndex: uint16,
    usLastCharIndex: uint16
    // The maximum Unicode index in this font
  },
  // The Apple version of this table ends here, but the Microsoft one continues on...
  0: {},
  1: {
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2)
  },
  2: {
    // these should be common with version 1 somehow
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2),
    xHeight: int16,
    capHeight: int16,
    defaultChar: uint16,
    breakChar: uint16,
    maxContent: uint16
  },
  5: {
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2),
    xHeight: int16,
    capHeight: int16,
    defaultChar: uint16,
    breakChar: uint16,
    maxContent: uint16,
    usLowerOpticalPointSize: uint16,
    usUpperOpticalPointSize: uint16
  }
});
var $84b272aa31b70606$var$versions = $84b272aa31b70606$var$OS2.versions;
$84b272aa31b70606$var$versions[3] = $84b272aa31b70606$var$versions[4] = $84b272aa31b70606$var$versions[2];
var $84b272aa31b70606$export$2e2bcd8739ae039 = $84b272aa31b70606$var$OS2;
var $32d9e2eb9565d93c$export$2e2bcd8739ae039 = new VersionedStruct(fixed32, {
  header: {
    italicAngle: fixed32,
    underlinePosition: int16,
    underlineThickness: int16,
    isFixedPitch: uint32,
    minMemType42: uint32,
    maxMemType42: uint32,
    minMemType1: uint32,
    maxMemType1: uint32
    // Maximum memory usage when a TrueType font is downloaded as a Type 1 font
  },
  1: {},
  2: {
    numberOfGlyphs: uint16,
    glyphNameIndex: new ArrayT(uint16, "numberOfGlyphs"),
    names: new ArrayT(new StringT(uint8))
  },
  2.5: {
    numberOfGlyphs: uint16,
    offsets: new ArrayT(uint8, "numberOfGlyphs")
  },
  3: {},
  4: {
    map: new ArrayT(uint32, (t2) => t2.parent.maxp.numGlyphs)
  }
});
var $5202bd9d9ad8eaac$export$2e2bcd8739ae039 = new Struct({
  controlValues: new ArrayT(int16)
});
var $5c0f37ca5ffb1850$export$2e2bcd8739ae039 = new Struct({
  instructions: new ArrayT(uint8)
});
var $2b2b260902b1c57e$var$loca = new VersionedStruct("head.indexToLocFormat", {
  0: {
    offsets: new ArrayT(uint16)
  },
  1: {
    offsets: new ArrayT(uint32)
  }
});
$2b2b260902b1c57e$var$loca.process = function() {
  if (this.version === 0 && !this._processed) {
    for (let i = 0; i < this.offsets.length; i++) this.offsets[i] <<= 1;
    this._processed = true;
  }
};
$2b2b260902b1c57e$var$loca.preEncode = function() {
  if (this.version === 0 && this._processed !== false) {
    for (let i = 0; i < this.offsets.length; i++) this.offsets[i] >>>= 1;
    this._processed = false;
  }
};
var $2b2b260902b1c57e$export$2e2bcd8739ae039 = $2b2b260902b1c57e$var$loca;
var $7afb878c7bea4f66$export$2e2bcd8739ae039 = new Struct({
  controlValueProgram: new ArrayT(uint8)
});
var $6c92b6371bce8bd9$export$2e2bcd8739ae039 = new ArrayT(new BufferT());
var $43e9821ef3717eec$export$2e2bcd8739ae039 = class {
  getCFFVersion(ctx) {
    while (ctx && !ctx.hdrSize) ctx = ctx.parent;
    return ctx ? ctx.version : -1;
  }
  decode(stream2, parent) {
    let version4 = this.getCFFVersion(parent);
    let count = version4 >= 2 ? stream2.readUInt32BE() : stream2.readUInt16BE();
    if (count === 0) return [];
    let offSize = stream2.readUInt8();
    let offsetType;
    if (offSize === 1) offsetType = uint8;
    else if (offSize === 2) offsetType = uint16;
    else if (offSize === 3) offsetType = uint24;
    else if (offSize === 4) offsetType = uint32;
    else throw new Error(`Bad offset size in CFFIndex: ${offSize} ${stream2.pos}`);
    let ret = [];
    let startPos = stream2.pos + (count + 1) * offSize - 1;
    let start3 = offsetType.decode(stream2);
    for (let i = 0; i < count; i++) {
      let end3 = offsetType.decode(stream2);
      if (this.type != null) {
        let pos = stream2.pos;
        stream2.pos = startPos + start3;
        parent.length = end3 - start3;
        ret.push(this.type.decode(stream2, parent));
        stream2.pos = pos;
      } else ret.push({
        offset: startPos + start3,
        length: end3 - start3
      });
      start3 = end3;
    }
    stream2.pos = startPos + start3;
    return ret;
  }
  size(arr, parent) {
    let size = 2;
    if (arr.length === 0) return size;
    let type2 = this.type || new BufferT();
    let offset3 = 1;
    for (let i = 0; i < arr.length; i++) {
      let item = arr[i];
      offset3 += type2.size(item, parent);
    }
    let offsetType;
    if (offset3 <= 255) offsetType = uint8;
    else if (offset3 <= 65535) offsetType = uint16;
    else if (offset3 <= 16777215) offsetType = uint24;
    else if (offset3 <= 4294967295) offsetType = uint32;
    else throw new Error("Bad offset in CFFIndex");
    size += 1 + offsetType.size() * (arr.length + 1);
    size += offset3 - 1;
    return size;
  }
  encode(stream2, arr, parent) {
    stream2.writeUInt16BE(arr.length);
    if (arr.length === 0) return;
    let type2 = this.type || new BufferT();
    let sizes = [];
    let offset3 = 1;
    for (let item of arr) {
      let s2 = type2.size(item, parent);
      sizes.push(s2);
      offset3 += s2;
    }
    let offsetType;
    if (offset3 <= 255) offsetType = uint8;
    else if (offset3 <= 65535) offsetType = uint16;
    else if (offset3 <= 16777215) offsetType = uint24;
    else if (offset3 <= 4294967295) offsetType = uint32;
    else throw new Error("Bad offset in CFFIndex");
    stream2.writeUInt8(offsetType.size());
    offset3 = 1;
    offsetType.encode(stream2, offset3);
    for (let size of sizes) {
      offset3 += size;
      offsetType.encode(stream2, offset3);
    }
    for (let item1 of arr) type2.encode(stream2, item1, parent);
    return;
  }
  constructor(type2) {
    this.type = type2;
  }
};
var $c2d28e92708f99da$var$FLOAT_EOF = 15;
var $c2d28e92708f99da$var$FLOAT_LOOKUP = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  ".",
  "E",
  "E-",
  null,
  "-"
];
var $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP = {
  ".": 10,
  "E": 11,
  "E-": 12,
  "-": 14
};
var $c2d28e92708f99da$export$2e2bcd8739ae039 = class {
  static decode(stream2, value2) {
    if (32 <= value2 && value2 <= 246) return value2 - 139;
    if (247 <= value2 && value2 <= 250) return (value2 - 247) * 256 + stream2.readUInt8() + 108;
    if (251 <= value2 && value2 <= 254) return -(value2 - 251) * 256 - stream2.readUInt8() - 108;
    if (value2 === 28) return stream2.readInt16BE();
    if (value2 === 29) return stream2.readInt32BE();
    if (value2 === 30) {
      let str = "";
      while (true) {
        let b = stream2.readUInt8();
        let n1 = b >> 4;
        if (n1 === $c2d28e92708f99da$var$FLOAT_EOF) break;
        str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n1];
        let n2 = b & 15;
        if (n2 === $c2d28e92708f99da$var$FLOAT_EOF) break;
        str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n2];
      }
      return parseFloat(str);
    }
    return null;
  }
  static size(value2) {
    if (value2.forceLarge) value2 = 32768;
    if ((value2 | 0) !== value2) {
      let str = "" + value2;
      return 1 + Math.ceil((str.length + 1) / 2);
    } else if (-107 <= value2 && value2 <= 107) return 1;
    else if (108 <= value2 && value2 <= 1131 || -1131 <= value2 && value2 <= -108) return 2;
    else if (-32768 <= value2 && value2 <= 32767) return 3;
    else return 5;
  }
  static encode(stream2, value2) {
    let val = Number(value2);
    if (value2.forceLarge) {
      stream2.writeUInt8(29);
      return stream2.writeInt32BE(val);
    } else if ((val | 0) !== val) {
      stream2.writeUInt8(30);
      let str = "" + val;
      for (let i = 0; i < str.length; i += 2) {
        let c1 = str[i];
        let n1 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c1] || +c1;
        if (i === str.length - 1) var n2 = $c2d28e92708f99da$var$FLOAT_EOF;
        else {
          let c2 = str[i + 1];
          var n2 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c2] || +c2;
        }
        stream2.writeUInt8(n1 << 4 | n2 & 15);
      }
      if (n2 !== $c2d28e92708f99da$var$FLOAT_EOF) return stream2.writeUInt8($c2d28e92708f99da$var$FLOAT_EOF << 4);
    } else if (-107 <= val && val <= 107) return stream2.writeUInt8(val + 139);
    else if (108 <= val && val <= 1131) {
      val -= 108;
      stream2.writeUInt8((val >> 8) + 247);
      return stream2.writeUInt8(val & 255);
    } else if (-1131 <= val && val <= -108) {
      val = -val - 108;
      stream2.writeUInt8((val >> 8) + 251);
      return stream2.writeUInt8(val & 255);
    } else if (-32768 <= val && val <= 32767) {
      stream2.writeUInt8(28);
      return stream2.writeInt16BE(val);
    } else {
      stream2.writeUInt8(29);
      return stream2.writeInt32BE(val);
    }
  }
};
var $61aa549f16d58b9b$export$2e2bcd8739ae039 = class {
  decodeOperands(type2, stream2, ret, operands) {
    if (Array.isArray(type2)) return operands.map((op, i) => this.decodeOperands(type2[i], stream2, ret, [
      op
    ]));
    else if (type2.decode != null) return type2.decode(stream2, ret, operands);
    else switch (type2) {
      case "number":
      case "offset":
      case "sid":
        return operands[0];
      case "boolean":
        return !!operands[0];
      default:
        return operands;
    }
  }
  encodeOperands(type2, stream2, ctx, operands) {
    if (Array.isArray(type2)) return operands.map((op, i) => this.encodeOperands(type2[i], stream2, ctx, op)[0]);
    else if (type2.encode != null) return type2.encode(stream2, operands, ctx);
    else if (typeof operands === "number") return [
      operands
    ];
    else if (typeof operands === "boolean") return [
      +operands
    ];
    else if (Array.isArray(operands)) return operands;
    else return [
      operands
    ];
  }
  decode(stream2, parent) {
    let end3 = stream2.pos + parent.length;
    let ret = {};
    let operands = [];
    Object.defineProperties(ret, {
      parent: {
        value: parent
      },
      _startOffset: {
        value: stream2.pos
      }
    });
    for (let key in this.fields) {
      let field = this.fields[key];
      ret[field[1]] = field[3];
    }
    while (stream2.pos < end3) {
      let b = stream2.readUInt8();
      if (b < 28) {
        if (b === 12) b = b << 8 | stream2.readUInt8();
        let field = this.fields[b];
        if (!field) throw new Error(`Unknown operator ${b}`);
        let val = this.decodeOperands(field[2], stream2, ret, operands);
        if (val != null) {
          if (val instanceof (0, PropertyDescriptor)) Object.defineProperty(ret, field[1], val);
          else ret[field[1]] = val;
        }
        operands = [];
      } else operands.push((0, $c2d28e92708f99da$export$2e2bcd8739ae039).decode(stream2, b));
    }
    return ret;
  }
  size(dict, parent, includePointers = true) {
    let ctx = {
      parent,
      val: dict,
      pointerSize: 0,
      startOffset: parent.startOffset || 0
    };
    let len = 0;
    for (let k in this.fields) {
      let field = this.fields[k];
      let val = dict[field[1]];
      if (val == null || (0, import_fast_deep_equal.default)(val, field[3])) continue;
      let operands = this.encodeOperands(field[2], null, ctx, val);
      for (let op of operands) len += (0, $c2d28e92708f99da$export$2e2bcd8739ae039).size(op);
      let key = Array.isArray(field[0]) ? field[0] : [
        field[0]
      ];
      len += key.length;
    }
    if (includePointers) len += ctx.pointerSize;
    return len;
  }
  encode(stream2, dict, parent) {
    let ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val: dict,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(dict, ctx, false);
    for (let field of this.ops) {
      let val = dict[field[1]];
      if (val == null || (0, import_fast_deep_equal.default)(val, field[3])) continue;
      let operands = this.encodeOperands(field[2], stream2, ctx, val);
      for (let op of operands) (0, $c2d28e92708f99da$export$2e2bcd8739ae039).encode(stream2, op);
      let key = Array.isArray(field[0]) ? field[0] : [
        field[0]
      ];
      for (let op1 of key) stream2.writeUInt8(op1);
    }
    let i = 0;
    while (i < ctx.pointers.length) {
      let ptr = ctx.pointers[i++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
    return;
  }
  constructor(ops = []) {
    this.ops = ops;
    this.fields = {};
    for (let field of ops) {
      let key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
      this.fields[key] = field;
    }
  }
};
var $0e34a43d05bde82c$export$2e2bcd8739ae039 = class extends Pointer {
  decode(stream2, parent, operands) {
    this.offsetType = {
      decode: () => operands[0]
    };
    return super.decode(stream2, parent, operands);
  }
  encode(stream2, value2, ctx) {
    if (!stream2) {
      this.offsetType = {
        size: () => 0
      };
      this.size(value2, ctx);
      return [
        new $0e34a43d05bde82c$var$Ptr(0)
      ];
    }
    let ptr = null;
    this.offsetType = {
      encode: (stream3, val) => ptr = val
    };
    super.encode(stream2, value2, ctx);
    return [
      new $0e34a43d05bde82c$var$Ptr(ptr)
    ];
  }
  constructor(type2, options = {}) {
    if (options.type == null) options.type = "global";
    super(null, type2, options);
  }
};
var $0e34a43d05bde82c$var$Ptr = class {
  valueOf() {
    return this.val;
  }
  constructor(val) {
    this.val = val;
    this.forceLarge = true;
  }
};
var $6d59db2e29cc77b3$var$CFFBlendOp = class {
  static decode(stream2, parent, operands) {
    let numBlends = operands.pop();
    while (operands.length > numBlends) operands.pop();
  }
};
var $6d59db2e29cc77b3$export$2e2bcd8739ae039 = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                    type                                          default
  [
    6,
    "BlueValues",
    "delta",
    null
  ],
  [
    7,
    "OtherBlues",
    "delta",
    null
  ],
  [
    8,
    "FamilyBlues",
    "delta",
    null
  ],
  [
    9,
    "FamilyOtherBlues",
    "delta",
    null
  ],
  [
    [
      12,
      9
    ],
    "BlueScale",
    "number",
    0.039625
  ],
  [
    [
      12,
      10
    ],
    "BlueShift",
    "number",
    7
  ],
  [
    [
      12,
      11
    ],
    "BlueFuzz",
    "number",
    1
  ],
  [
    10,
    "StdHW",
    "number",
    null
  ],
  [
    11,
    "StdVW",
    "number",
    null
  ],
  [
    [
      12,
      12
    ],
    "StemSnapH",
    "delta",
    null
  ],
  [
    [
      12,
      13
    ],
    "StemSnapV",
    "delta",
    null
  ],
  [
    [
      12,
      14
    ],
    "ForceBold",
    "boolean",
    false
  ],
  [
    [
      12,
      17
    ],
    "LanguageGroup",
    "number",
    0
  ],
  [
    [
      12,
      18
    ],
    "ExpansionFactor",
    "number",
    0.06
  ],
  [
    [
      12,
      19
    ],
    "initialRandomSeed",
    "number",
    0
  ],
  [
    20,
    "defaultWidthX",
    "number",
    0
  ],
  [
    21,
    "nominalWidthX",
    "number",
    0
  ],
  [
    22,
    "vsindex",
    "number",
    0
  ],
  [
    23,
    "blend",
    $6d59db2e29cc77b3$var$CFFBlendOp,
    null
  ],
  [
    19,
    "Subrs",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(), {
      type: "local"
    }),
    null
  ]
]);
var $229224aec43783c5$export$2e2bcd8739ae039 = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall",
  "001.000",
  "001.001",
  "001.002",
  "001.003",
  "Black",
  "Bold",
  "Book",
  "Light",
  "Medium",
  "Regular",
  "Roman",
  "Semibold"
];
var $bc0433d9b7e41f5f$export$dee0027060fa13bd = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "",
  "questiondown",
  "",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "",
  "ring",
  "cedilla",
  "",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "AE",
  "",
  "ordfeminine",
  "",
  "",
  "",
  "",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "",
  "",
  "",
  "",
  "",
  "ae",
  "",
  "",
  "",
  "dotlessi",
  "",
  "",
  "lslash",
  "oslash",
  "oe",
  "germandbls"
];
var $bc0433d9b7e41f5f$export$4f58f497e14a53c3 = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "",
  "",
  "isuperior",
  "",
  "",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "",
  "",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "",
  "",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "",
  "Dotaccentsmall",
  "",
  "",
  "Macronsmall",
  "",
  "",
  "figuredash",
  "hypheninferior",
  "",
  "",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "",
  "",
  "",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "",
  "",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var $ef658f5c9a1488b2$export$c33b50336c234f16 = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron"
];
var $ef658f5c9a1488b2$export$3ed0f9e1fee8d489 = [
  ".notdef",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var $ef658f5c9a1488b2$export$dc28be11139d4120 = [
  ".notdef",
  "space",
  "dollaroldstyle",
  "dollarsuperior",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "hyphensuperior",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "centoldstyle",
  "figuredash",
  "hypheninferior",
  "onequarter",
  "onehalf",
  "threequarters",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior"
];
var $7cbbe4e24ef3cb75$var$LangSysTable = new Struct({
  reserved: new Reserved(uint16),
  reqFeatureIndex: uint16,
  featureCount: uint16,
  featureIndexes: new ArrayT(uint16, "featureCount")
});
var $7cbbe4e24ef3cb75$var$LangSysRecord = new Struct({
  tag: new StringT(4),
  langSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$var$Script = new Struct({
  defaultLangSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable),
  count: uint16,
  langSysRecords: new ArrayT($7cbbe4e24ef3cb75$var$LangSysRecord, "count")
});
var $7cbbe4e24ef3cb75$var$ScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $7cbbe4e24ef3cb75$var$Script, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$export$3e15fc05ce864229 = new ArrayT($7cbbe4e24ef3cb75$var$ScriptRecord, uint16);
var $7cbbe4e24ef3cb75$var$FeatureParams = new Struct({
  version: uint16,
  nameID: uint16
});
var $7cbbe4e24ef3cb75$export$6e91cf7616333d5 = new Struct({
  featureParams: new Pointer(uint16, $7cbbe4e24ef3cb75$var$FeatureParams),
  lookupCount: uint16,
  lookupListIndexes: new ArrayT(uint16, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$FeatureRecord = new Struct({
  tag: new StringT(4),
  feature: new Pointer(uint16, $7cbbe4e24ef3cb75$export$6e91cf7616333d5, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$export$aa18130def4b6cb4 = new ArrayT($7cbbe4e24ef3cb75$var$FeatureRecord, uint16);
var $7cbbe4e24ef3cb75$var$LookupFlags = new Struct({
  markAttachmentType: uint8,
  flags: new Bitfield(uint8, [
    "rightToLeft",
    "ignoreBaseGlyphs",
    "ignoreLigatures",
    "ignoreMarks",
    "useMarkFilteringSet"
  ])
});
function $7cbbe4e24ef3cb75$export$df0008c6ff2da22a(SubTable) {
  let Lookup = new Struct({
    lookupType: uint16,
    flags: $7cbbe4e24ef3cb75$var$LookupFlags,
    subTableCount: uint16,
    subTables: new ArrayT(new Pointer(uint16, SubTable), "subTableCount"),
    markFilteringSet: new Optional(uint16, (t2) => t2.flags.flags.useMarkFilteringSet)
  });
  return new LazyArray(new Pointer(uint16, Lookup), uint16);
}
var $7cbbe4e24ef3cb75$var$RangeRecord = new Struct({
  start: uint16,
  end: uint16,
  startCoverageIndex: uint16
});
var $7cbbe4e24ef3cb75$export$17608c3f81a6111 = new VersionedStruct(uint16, {
  1: {
    glyphCount: uint16,
    glyphs: new ArrayT(uint16, "glyphCount")
  },
  2: {
    rangeCount: uint16,
    rangeRecords: new ArrayT($7cbbe4e24ef3cb75$var$RangeRecord, "rangeCount")
  }
});
var $7cbbe4e24ef3cb75$var$ClassRangeRecord = new Struct({
  start: uint16,
  end: uint16,
  class: uint16
});
var $7cbbe4e24ef3cb75$export$843d551fbbafef71 = new VersionedStruct(uint16, {
  1: {
    startGlyph: uint16,
    glyphCount: uint16,
    classValueArray: new ArrayT(uint16, "glyphCount")
  },
  2: {
    classRangeCount: uint16,
    classRangeRecord: new ArrayT($7cbbe4e24ef3cb75$var$ClassRangeRecord, "classRangeCount")
  }
});
var $7cbbe4e24ef3cb75$export$8215d14a63d9fb10 = new Struct({
  a: uint16,
  b: uint16,
  deltaFormat: uint16
});
var $7cbbe4e24ef3cb75$var$LookupRecord = new Struct({
  sequenceIndex: uint16,
  lookupListIndex: uint16
});
var $7cbbe4e24ef3cb75$var$Rule = new Struct({
  glyphCount: uint16,
  lookupCount: uint16,
  input: new ArrayT(uint16, (t2) => t2.glyphCount - 1),
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$RuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$Rule), uint16);
var $7cbbe4e24ef3cb75$var$ClassRule = new Struct({
  glyphCount: uint16,
  lookupCount: uint16,
  classes: new ArrayT(uint16, (t2) => t2.glyphCount - 1),
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$ClassSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassRule), uint16);
var $7cbbe4e24ef3cb75$export$841858b892ce1f4c = new VersionedStruct(uint16, {
  1: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    ruleSetCount: uint16,
    ruleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$RuleSet), "ruleSetCount")
  },
  2: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    classDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    classSetCnt: uint16,
    classSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassSet), "classSetCnt")
  },
  3: {
    glyphCount: uint16,
    lookupCount: uint16,
    coverages: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "glyphCount"),
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  }
});
var $7cbbe4e24ef3cb75$var$ChainRule = new Struct({
  backtrackGlyphCount: uint16,
  backtrack: new ArrayT(uint16, "backtrackGlyphCount"),
  inputGlyphCount: uint16,
  input: new ArrayT(uint16, (t2) => t2.inputGlyphCount - 1),
  lookaheadGlyphCount: uint16,
  lookahead: new ArrayT(uint16, "lookaheadGlyphCount"),
  lookupCount: uint16,
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$ChainRuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRule), uint16);
var $7cbbe4e24ef3cb75$export$5e6d09e6861162f6 = new VersionedStruct(uint16, {
  1: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    chainCount: uint16,
    chainRuleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
  },
  2: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    backtrackClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    inputClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    lookaheadClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    chainCount: uint16,
    chainClassSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
  },
  3: {
    backtrackGlyphCount: uint16,
    backtrackCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "backtrackGlyphCount"),
    inputGlyphCount: uint16,
    inputCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "inputGlyphCount"),
    lookaheadGlyphCount: uint16,
    lookaheadCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "lookaheadGlyphCount"),
    lookupCount: uint16,
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  }
});
var $1a47b0c45c1c22fe$var$F2DOT14 = new Fixed(16, "BE", 14);
var $1a47b0c45c1c22fe$var$RegionAxisCoordinates = new Struct({
  startCoord: $1a47b0c45c1c22fe$var$F2DOT14,
  peakCoord: $1a47b0c45c1c22fe$var$F2DOT14,
  endCoord: $1a47b0c45c1c22fe$var$F2DOT14
});
var $1a47b0c45c1c22fe$var$VariationRegionList = new Struct({
  axisCount: uint16,
  regionCount: uint16,
  variationRegions: new ArrayT(new ArrayT($1a47b0c45c1c22fe$var$RegionAxisCoordinates, "axisCount"), "regionCount")
});
var $1a47b0c45c1c22fe$var$DeltaSet = new Struct({
  shortDeltas: new ArrayT(int16, (t2) => t2.parent.shortDeltaCount),
  regionDeltas: new ArrayT(int8, (t2) => t2.parent.regionIndexCount - t2.parent.shortDeltaCount),
  deltas: (t2) => t2.shortDeltas.concat(t2.regionDeltas)
});
var $1a47b0c45c1c22fe$var$ItemVariationData = new Struct({
  itemCount: uint16,
  shortDeltaCount: uint16,
  regionIndexCount: uint16,
  regionIndexes: new ArrayT(uint16, "regionIndexCount"),
  deltaSets: new ArrayT($1a47b0c45c1c22fe$var$DeltaSet, "itemCount")
});
var $1a47b0c45c1c22fe$export$fe1b122a2710f241 = new Struct({
  format: uint16,
  variationRegionList: new Pointer(uint32, $1a47b0c45c1c22fe$var$VariationRegionList),
  variationDataCount: uint16,
  itemVariationData: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ItemVariationData), "variationDataCount")
});
var $1a47b0c45c1c22fe$var$ConditionTable = new VersionedStruct(uint16, {
  1: {
    axisIndex: uint16,
    axisIndex: uint16,
    filterRangeMinValue: $1a47b0c45c1c22fe$var$F2DOT14,
    filterRangeMaxValue: $1a47b0c45c1c22fe$var$F2DOT14
  }
});
var $1a47b0c45c1c22fe$var$ConditionSet = new Struct({
  conditionCount: uint16,
  conditionTable: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionTable), "conditionCount")
});
var $1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord = new Struct({
  featureIndex: uint16,
  alternateFeatureTable: new Pointer(uint32, (0, $7cbbe4e24ef3cb75$export$6e91cf7616333d5), {
    type: "parent"
  })
});
var $1a47b0c45c1c22fe$var$FeatureTableSubstitution = new Struct({
  version: fixed32,
  substitutionCount: uint16,
  substitutions: new ArrayT($1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord, "substitutionCount")
});
var $1a47b0c45c1c22fe$var$FeatureVariationRecord = new Struct({
  conditionSet: new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionSet, {
    type: "parent"
  }),
  featureTableSubstitution: new Pointer(uint32, $1a47b0c45c1c22fe$var$FeatureTableSubstitution, {
    type: "parent"
  })
});
var $1a47b0c45c1c22fe$export$441b70b7971dd419 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  featureVariationRecordCount: uint32,
  featureVariationRecords: new ArrayT($1a47b0c45c1c22fe$var$FeatureVariationRecord, "featureVariationRecordCount")
});
var $b84fd3dd9d8eddb2$var$PredefinedOp = class {
  decode(stream2, parent, operands) {
    if (this.predefinedOps[operands[0]]) return this.predefinedOps[operands[0]];
    return this.type.decode(stream2, parent, operands);
  }
  size(value2, ctx) {
    return this.type.size(value2, ctx);
  }
  encode(stream2, value2, ctx) {
    let index2 = this.predefinedOps.indexOf(value2);
    if (index2 !== -1) return index2;
    return this.type.encode(stream2, value2, ctx);
  }
  constructor(predefinedOps, type2) {
    this.predefinedOps = predefinedOps;
    this.type = type2;
  }
};
var $b84fd3dd9d8eddb2$var$CFFEncodingVersion = class extends NumberT {
  decode(stream2) {
    return uint8.decode(stream2) & 127;
  }
  constructor() {
    super("UInt8");
  }
};
var $b84fd3dd9d8eddb2$var$Range1 = new Struct({
  first: uint16,
  nLeft: uint8
});
var $b84fd3dd9d8eddb2$var$Range2 = new Struct({
  first: uint16,
  nLeft: uint16
});
var $b84fd3dd9d8eddb2$var$CFFCustomEncoding = new VersionedStruct(new $b84fd3dd9d8eddb2$var$CFFEncodingVersion(), {
  0: {
    nCodes: uint8,
    codes: new ArrayT(uint8, "nCodes")
  },
  1: {
    nRanges: uint8,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$Range1, "nRanges")
  }
});
var $b84fd3dd9d8eddb2$var$CFFEncoding = new $b84fd3dd9d8eddb2$var$PredefinedOp([
  (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd),
  (0, $bc0433d9b7e41f5f$export$4f58f497e14a53c3)
], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomEncoding, {
  lazy: true
}));
var $b84fd3dd9d8eddb2$var$RangeArray = class extends ArrayT {
  decode(stream2, parent) {
    let length4 = (0, resolveLength)(this.length, stream2, parent);
    let count = 0;
    let res = [];
    while (count < length4) {
      let range3 = this.type.decode(stream2, parent);
      range3.offset = count;
      count += range3.nLeft + 1;
      res.push(range3);
    }
    return res;
  }
};
var $b84fd3dd9d8eddb2$var$CFFCustomCharset = new VersionedStruct(uint8, {
  0: {
    glyphs: new ArrayT(uint16, (t2) => t2.parent.CharStrings.length - 1)
  },
  1: {
    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range1, (t2) => t2.parent.CharStrings.length - 1)
  },
  2: {
    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range2, (t2) => t2.parent.CharStrings.length - 1)
  }
});
var $b84fd3dd9d8eddb2$var$CFFCharset = new $b84fd3dd9d8eddb2$var$PredefinedOp([
  (0, $ef658f5c9a1488b2$export$c33b50336c234f16),
  (0, $ef658f5c9a1488b2$export$3ed0f9e1fee8d489),
  (0, $ef658f5c9a1488b2$export$dc28be11139d4120)
], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomCharset, {
  lazy: true
}));
var $b84fd3dd9d8eddb2$var$FDRange3 = new Struct({
  first: uint16,
  fd: uint8
});
var $b84fd3dd9d8eddb2$var$FDRange4 = new Struct({
  first: uint32,
  fd: uint16
});
var $b84fd3dd9d8eddb2$var$FDSelect = new VersionedStruct(uint8, {
  0: {
    fds: new ArrayT(uint8, (t2) => t2.parent.CharStrings.length)
  },
  3: {
    nRanges: uint16,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange3, "nRanges"),
    sentinel: uint16
  },
  4: {
    nRanges: uint32,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange4, "nRanges"),
    sentinel: uint32
  }
});
var $b84fd3dd9d8eddb2$var$ptr = new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)((0, $6d59db2e29cc77b3$export$2e2bcd8739ae039));
var $b84fd3dd9d8eddb2$var$CFFPrivateOp = class {
  decode(stream2, parent, operands) {
    parent.length = operands[0];
    return $b84fd3dd9d8eddb2$var$ptr.decode(stream2, parent, [
      operands[1]
    ]);
  }
  size(dict, ctx) {
    return [
      (0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx, false),
      $b84fd3dd9d8eddb2$var$ptr.size(dict, ctx)[0]
    ];
  }
  encode(stream2, dict, ctx) {
    return [
      (0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx, false),
      $b84fd3dd9d8eddb2$var$ptr.encode(stream2, dict, ctx)[0]
    ];
  }
};
var $b84fd3dd9d8eddb2$var$FontDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                   type(s)                                 default
  [
    18,
    "Private",
    new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
    null
  ],
  [
    [
      12,
      38
    ],
    "FontName",
    "sid",
    null
  ],
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    [
      12,
      5
    ],
    "PaintType",
    "number",
    0
  ]
]);
var $b84fd3dd9d8eddb2$var$CFFTopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                   type(s)                                 default
  [
    [
      12,
      30
    ],
    "ROS",
    [
      "sid",
      "sid",
      "number"
    ],
    null
  ],
  [
    0,
    "version",
    "sid",
    null
  ],
  [
    1,
    "Notice",
    "sid",
    null
  ],
  [
    [
      12,
      0
    ],
    "Copyright",
    "sid",
    null
  ],
  [
    2,
    "FullName",
    "sid",
    null
  ],
  [
    3,
    "FamilyName",
    "sid",
    null
  ],
  [
    4,
    "Weight",
    "sid",
    null
  ],
  [
    [
      12,
      1
    ],
    "isFixedPitch",
    "boolean",
    false
  ],
  [
    [
      12,
      2
    ],
    "ItalicAngle",
    "number",
    0
  ],
  [
    [
      12,
      3
    ],
    "UnderlinePosition",
    "number",
    -100
  ],
  [
    [
      12,
      4
    ],
    "UnderlineThickness",
    "number",
    50
  ],
  [
    [
      12,
      5
    ],
    "PaintType",
    "number",
    0
  ],
  [
    [
      12,
      6
    ],
    "CharstringType",
    "number",
    2
  ],
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    13,
    "UniqueID",
    "number",
    null
  ],
  [
    5,
    "FontBBox",
    "array",
    [
      0,
      0,
      0,
      0
    ]
  ],
  [
    [
      12,
      8
    ],
    "StrokeWidth",
    "number",
    0
  ],
  [
    14,
    "XUID",
    "array",
    null
  ],
  [
    15,
    "charset",
    $b84fd3dd9d8eddb2$var$CFFCharset,
    (0, $ef658f5c9a1488b2$export$c33b50336c234f16)
  ],
  [
    16,
    "Encoding",
    $b84fd3dd9d8eddb2$var$CFFEncoding,
    (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd)
  ],
  [
    17,
    "CharStrings",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()),
    null
  ],
  [
    18,
    "Private",
    new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
    null
  ],
  [
    [
      12,
      20
    ],
    "SyntheticBase",
    "number",
    null
  ],
  [
    [
      12,
      21
    ],
    "PostScript",
    "sid",
    null
  ],
  [
    [
      12,
      22
    ],
    "BaseFontName",
    "sid",
    null
  ],
  [
    [
      12,
      23
    ],
    "BaseFontBlend",
    "delta",
    null
  ],
  // CID font specific
  [
    [
      12,
      31
    ],
    "CIDFontVersion",
    "number",
    0
  ],
  [
    [
      12,
      32
    ],
    "CIDFontRevision",
    "number",
    0
  ],
  [
    [
      12,
      33
    ],
    "CIDFontType",
    "number",
    0
  ],
  [
    [
      12,
      34
    ],
    "CIDCount",
    "number",
    8720
  ],
  [
    [
      12,
      35
    ],
    "UIDBase",
    "number",
    null
  ],
  [
    [
      12,
      37
    ],
    "FDSelect",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect),
    null
  ],
  [
    [
      12,
      36
    ],
    "FDArray",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)),
    null
  ],
  [
    [
      12,
      38
    ],
    "FontName",
    "sid",
    null
  ]
]);
var $b84fd3dd9d8eddb2$var$VariationStore = new Struct({
  length: uint16,
  itemVariationStore: (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)
});
var $b84fd3dd9d8eddb2$var$CFF2TopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    17,
    "CharStrings",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()),
    null
  ],
  [
    [
      12,
      37
    ],
    "FDSelect",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect),
    null
  ],
  [
    [
      12,
      36
    ],
    "FDArray",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)),
    null
  ],
  [
    24,
    "vstore",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$VariationStore),
    null
  ],
  [
    25,
    "maxstack",
    "number",
    193
  ]
]);
var $b84fd3dd9d8eddb2$var$CFFTop = new VersionedStruct(fixed16, {
  1: {
    hdrSize: uint8,
    offSize: uint8,
    nameIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new StringT("length")),
    topDictIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFTopDict),
    stringIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new StringT("length")),
    globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()
  },
  2: {
    hdrSize: uint8,
    length: uint16,
    topDict: $b84fd3dd9d8eddb2$var$CFF2TopDict,
    globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()
  }
});
var $b84fd3dd9d8eddb2$export$2e2bcd8739ae039 = $b84fd3dd9d8eddb2$var$CFFTop;
var $822ac0d589e4e237$var$CFFFont = class _$822ac0d589e4e237$var$CFFFont {
  static decode(stream2) {
    return new _$822ac0d589e4e237$var$CFFFont(stream2);
  }
  decode() {
    let start3 = this.stream.pos;
    let top = (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).decode(this.stream);
    for (let key in top) {
      let val = top[key];
      this[key] = val;
    }
    if (this.version < 2) {
      if (this.topDictIndex.length !== 1) throw new Error("Only a single font is allowed in CFF");
      this.topDict = this.topDictIndex[0];
    }
    this.isCIDFont = this.topDict.ROS != null;
    return this;
  }
  string(sid) {
    if (this.version >= 2) return null;
    if (sid < (0, $229224aec43783c5$export$2e2bcd8739ae039).length) return (0, $229224aec43783c5$export$2e2bcd8739ae039)[sid];
    return this.stringIndex[sid - (0, $229224aec43783c5$export$2e2bcd8739ae039).length];
  }
  get postscriptName() {
    if (this.version < 2) return this.nameIndex[0];
    return null;
  }
  get fullName() {
    return this.string(this.topDict.FullName);
  }
  get familyName() {
    return this.string(this.topDict.FamilyName);
  }
  getCharString(glyph) {
    this.stream.pos = this.topDict.CharStrings[glyph].offset;
    return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);
  }
  getGlyphName(gid) {
    if (this.version >= 2) return null;
    if (this.isCIDFont) return null;
    let { charset } = this.topDict;
    if (Array.isArray(charset)) return charset[gid];
    if (gid === 0) return ".notdef";
    gid -= 1;
    switch (charset.version) {
      case 0:
        return this.string(charset.glyphs[gid]);
      case 1:
      case 2:
        for (let i = 0; i < charset.ranges.length; i++) {
          let range3 = charset.ranges[i];
          if (range3.offset <= gid && gid <= range3.offset + range3.nLeft) return this.string(range3.first + (gid - range3.offset));
        }
        break;
    }
    return null;
  }
  fdForGlyph(gid) {
    if (!this.topDict.FDSelect) return null;
    switch (this.topDict.FDSelect.version) {
      case 0:
        return this.topDict.FDSelect.fds[gid];
      case 3:
      case 4:
        let { ranges } = this.topDict.FDSelect;
        let low = 0;
        let high = ranges.length - 1;
        while (low <= high) {
          let mid = low + high >> 1;
          if (gid < ranges[mid].first) high = mid - 1;
          else if (mid < high && gid >= ranges[mid + 1].first) low = mid + 1;
          else return ranges[mid].fd;
        }
      default:
        throw new Error(`Unknown FDSelect version: ${this.topDict.FDSelect.version}`);
    }
  }
  privateDictForGlyph(gid) {
    if (this.topDict.FDSelect) {
      let fd = this.fdForGlyph(gid);
      if (this.topDict.FDArray[fd]) return this.topDict.FDArray[fd].Private;
      return null;
    }
    if (this.version < 2) return this.topDict.Private;
    return this.topDict.FDArray[0].Private;
  }
  constructor(stream2) {
    this.stream = stream2;
    this.decode();
  }
};
var $822ac0d589e4e237$export$2e2bcd8739ae039 = $822ac0d589e4e237$var$CFFFont;
var $2bbf2bc1ce37cd8f$var$VerticalOrigin = new Struct({
  glyphIndex: uint16,
  vertOriginY: int16
});
var $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  defaultVertOriginY: int16,
  numVertOriginYMetrics: uint16,
  metrics: new ArrayT($2bbf2bc1ce37cd8f$var$VerticalOrigin, "numVertOriginYMetrics")
});
var $0941618dc22a946d$export$16b227cb15d716a0 = new Struct({
  height: uint8,
  width: uint8,
  horiBearingX: int8,
  horiBearingY: int8,
  horiAdvance: uint8,
  vertBearingX: int8,
  vertBearingY: int8,
  vertAdvance: uint8
});
var $0941618dc22a946d$export$62c53e75f69bfe12 = new Struct({
  height: uint8,
  width: uint8,
  bearingX: int8,
  bearingY: int8,
  advance: uint8
});
var $0941618dc22a946d$var$EBDTComponent = new Struct({
  glyph: uint16,
  xOffset: int8,
  yOffset: int8
});
var $0941618dc22a946d$var$ByteAligned = class {
};
var $0941618dc22a946d$var$BitAligned = class {
};
var $0941618dc22a946d$export$f1f5ddeb20d14f = new VersionedStruct("version", {
  1: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    data: $0941618dc22a946d$var$ByteAligned
  },
  2: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    data: $0941618dc22a946d$var$BitAligned
  },
  // format 3 is deprecated
  // format 4 is not supported by Microsoft
  5: {
    data: $0941618dc22a946d$var$BitAligned
  },
  6: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    data: $0941618dc22a946d$var$ByteAligned
  },
  7: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    data: $0941618dc22a946d$var$BitAligned
  },
  8: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    pad: new Reserved(uint8),
    numComponents: uint16,
    components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
  },
  9: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    pad: new Reserved(uint8),
    numComponents: uint16,
    components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
  },
  17: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    dataLen: uint32,
    data: new BufferT("dataLen")
  },
  18: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    dataLen: uint32,
    data: new BufferT("dataLen")
  },
  19: {
    dataLen: uint32,
    data: new BufferT("dataLen")
  }
});
var $9911c4c7201c13de$var$SBitLineMetrics = new Struct({
  ascender: int8,
  descender: int8,
  widthMax: uint8,
  caretSlopeNumerator: int8,
  caretSlopeDenominator: int8,
  caretOffset: int8,
  minOriginSB: int8,
  minAdvanceSB: int8,
  maxBeforeBL: int8,
  minAfterBL: int8,
  pad: new Reserved(int8, 2)
});
var $9911c4c7201c13de$var$CodeOffsetPair = new Struct({
  glyphCode: uint16,
  offset: uint16
});
var $9911c4c7201c13de$var$IndexSubtable = new VersionedStruct(uint16, {
  header: {
    imageFormat: uint16,
    imageDataOffset: uint32
  },
  1: {
    offsetArray: new ArrayT(uint32, (t2) => t2.parent.lastGlyphIndex - t2.parent.firstGlyphIndex + 1)
  },
  2: {
    imageSize: uint32,
    bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0)
  },
  3: {
    offsetArray: new ArrayT(uint16, (t2) => t2.parent.lastGlyphIndex - t2.parent.firstGlyphIndex + 1)
  },
  4: {
    numGlyphs: uint32,
    glyphArray: new ArrayT($9911c4c7201c13de$var$CodeOffsetPair, (t2) => t2.numGlyphs + 1)
  },
  5: {
    imageSize: uint32,
    bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0),
    numGlyphs: uint32,
    glyphCodeArray: new ArrayT(uint16, "numGlyphs")
  }
});
var $9911c4c7201c13de$var$IndexSubtableArray = new Struct({
  firstGlyphIndex: uint16,
  lastGlyphIndex: uint16,
  subtable: new Pointer(uint32, $9911c4c7201c13de$var$IndexSubtable)
});
var $9911c4c7201c13de$var$BitmapSizeTable = new Struct({
  indexSubTableArray: new Pointer(uint32, new ArrayT($9911c4c7201c13de$var$IndexSubtableArray, 1), {
    type: "parent"
  }),
  indexTablesSize: uint32,
  numberOfIndexSubTables: uint32,
  colorRef: uint32,
  hori: $9911c4c7201c13de$var$SBitLineMetrics,
  vert: $9911c4c7201c13de$var$SBitLineMetrics,
  startGlyphIndex: uint16,
  endGlyphIndex: uint16,
  ppemX: uint8,
  ppemY: uint8,
  bitDepth: uint8,
  flags: new Bitfield(uint8, [
    "horizontal",
    "vertical"
  ])
});
var $9911c4c7201c13de$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  numSizes: uint32,
  sizes: new ArrayT($9911c4c7201c13de$var$BitmapSizeTable, "numSizes")
});
var $abb847051efd51b1$var$ImageTable = new Struct({
  ppem: uint16,
  resolution: uint16,
  imageOffsets: new ArrayT(new Pointer(uint32, "void"), (t2) => t2.parent.parent.maxp.numGlyphs + 1)
});
var $abb847051efd51b1$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  flags: new Bitfield(uint16, [
    "renderOutlines"
  ]),
  numImgTables: uint32,
  imageTables: new ArrayT(new Pointer(uint32, $abb847051efd51b1$var$ImageTable), "numImgTables")
});
var $eb629188f3dfefdd$var$LayerRecord = new Struct({
  gid: uint16,
  paletteIndex: uint16
  // Index value to use in the appropriate palette. This value must
});
var $eb629188f3dfefdd$var$BaseGlyphRecord = new Struct({
  gid: uint16,
  // and is not rendered for color.
  firstLayerIndex: uint16,
  // There will be numLayers consecutive entries for this base glyph.
  numLayers: uint16
});
var $eb629188f3dfefdd$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numBaseGlyphRecords: uint16,
  baseGlyphRecord: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$BaseGlyphRecord, "numBaseGlyphRecords")),
  layerRecords: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$LayerRecord, "numLayerRecords"), {
    lazy: true
  }),
  numLayerRecords: uint16
});
var $08734b8e7dc64587$var$ColorRecord = new Struct({
  blue: uint8,
  green: uint8,
  red: uint8,
  alpha: uint8
});
var $08734b8e7dc64587$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
  header: {
    numPaletteEntries: uint16,
    numPalettes: uint16,
    numColorRecords: uint16,
    colorRecords: new Pointer(uint32, new ArrayT($08734b8e7dc64587$var$ColorRecord, "numColorRecords")),
    colorRecordIndices: new ArrayT(uint16, "numPalettes")
  },
  0: {},
  1: {
    offsetPaletteTypeArray: new Pointer(uint32, new ArrayT(uint32, "numPalettes")),
    offsetPaletteLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPalettes")),
    offsetPaletteEntryLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPaletteEntries"))
  }
});
var $497cef411d884e34$var$BaseCoord = new VersionedStruct(uint16, {
  1: {
    coordinate: int16
    // X or Y value, in design units
  },
  2: {
    coordinate: int16,
    referenceGlyph: uint16,
    baseCoordPoint: uint16
    // Index of contour point on the referenceGlyph
  },
  3: {
    coordinate: int16,
    deviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
    // Device table for X or Y value
  }
});
var $497cef411d884e34$var$BaseValues = new Struct({
  defaultIndex: uint16,
  baseCoordCount: uint16,
  baseCoords: new ArrayT(new Pointer(uint16, $497cef411d884e34$var$BaseCoord), "baseCoordCount")
});
var $497cef411d884e34$var$FeatMinMaxRecord = new Struct({
  tag: new StringT(4),
  minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
    type: "parent"
  }),
  maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
    type: "parent"
  })
  // May be NULL
});
var $497cef411d884e34$var$MinMax = new Struct({
  minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
  maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
  featMinMaxCount: uint16,
  featMinMaxRecords: new ArrayT($497cef411d884e34$var$FeatMinMaxRecord, "featMinMaxCount")
  // In alphabetical order
});
var $497cef411d884e34$var$BaseLangSysRecord = new Struct({
  tag: new StringT(4),
  minMax: new Pointer(uint16, $497cef411d884e34$var$MinMax, {
    type: "parent"
  })
});
var $497cef411d884e34$var$BaseScript = new Struct({
  baseValues: new Pointer(uint16, $497cef411d884e34$var$BaseValues),
  defaultMinMax: new Pointer(uint16, $497cef411d884e34$var$MinMax),
  baseLangSysCount: uint16,
  baseLangSysRecords: new ArrayT($497cef411d884e34$var$BaseLangSysRecord, "baseLangSysCount")
  // in alphabetical order by BaseLangSysTag
});
var $497cef411d884e34$var$BaseScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $497cef411d884e34$var$BaseScript, {
    type: "parent"
  })
});
var $497cef411d884e34$var$BaseScriptList = new ArrayT($497cef411d884e34$var$BaseScriptRecord, uint16);
var $497cef411d884e34$var$BaseTagList = new ArrayT(new StringT(4), uint16);
var $497cef411d884e34$var$Axis = new Struct({
  baseTagList: new Pointer(uint16, $497cef411d884e34$var$BaseTagList),
  baseScriptList: new Pointer(uint16, $497cef411d884e34$var$BaseScriptList)
});
var $497cef411d884e34$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    horizAxis: new Pointer(uint16, $497cef411d884e34$var$Axis),
    vertAxis: new Pointer(uint16, $497cef411d884e34$var$Axis)
    // May be NULL
  },
  65536: {},
  65537: {
    itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))
  }
});
var $cf5f33c63ef209e6$var$AttachPoint = new ArrayT(uint16, uint16);
var $cf5f33c63ef209e6$var$AttachList = new Struct({
  coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
  glyphCount: uint16,
  attachPoints: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$AttachPoint), "glyphCount")
});
var $cf5f33c63ef209e6$var$CaretValue = new VersionedStruct(uint16, {
  1: {
    coordinate: int16
  },
  2: {
    caretValuePoint: uint16
  },
  3: {
    coordinate: int16,
    deviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
  }
});
var $cf5f33c63ef209e6$var$LigGlyph = new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$CaretValue), uint16);
var $cf5f33c63ef209e6$var$LigCaretList = new Struct({
  coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
  ligGlyphCount: uint16,
  ligGlyphs: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$LigGlyph), "ligGlyphCount")
});
var $cf5f33c63ef209e6$var$MarkGlyphSetsDef = new Struct({
  markSetTableFormat: uint16,
  markSetCount: uint16,
  coverage: new ArrayT(new Pointer(uint32, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "markSetCount")
});
var $cf5f33c63ef209e6$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    glyphClassDef: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
    attachList: new Pointer(uint16, $cf5f33c63ef209e6$var$AttachList),
    ligCaretList: new Pointer(uint16, $cf5f33c63ef209e6$var$LigCaretList),
    markAttachClassDef: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71))
  },
  65536: {},
  65538: {
    markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef)
  },
  65539: {
    markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef),
    itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))
  }
});
var $47e0e8ef515d9903$var$ValueFormat = new Bitfield(uint16, [
  "xPlacement",
  "yPlacement",
  "xAdvance",
  "yAdvance",
  "xPlaDevice",
  "yPlaDevice",
  "xAdvDevice",
  "yAdvDevice"
]);
var $47e0e8ef515d9903$var$types = {
  xPlacement: int16,
  yPlacement: int16,
  xAdvance: int16,
  yAdvance: int16,
  xPlaDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  yPlaDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  xAdvDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  yAdvDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  })
};
var $47e0e8ef515d9903$var$ValueRecord = class {
  buildStruct(parent) {
    let struct2 = parent;
    while (!struct2[this.key] && struct2.parent) struct2 = struct2.parent;
    if (!struct2[this.key]) return;
    let fields = {};
    fields.rel = () => struct2._startOffset;
    let format3 = struct2[this.key];
    for (let key in format3) if (format3[key]) fields[key] = $47e0e8ef515d9903$var$types[key];
    return new Struct(fields);
  }
  size(val, ctx) {
    return this.buildStruct(ctx).size(val, ctx);
  }
  decode(stream2, parent) {
    let res = this.buildStruct(parent).decode(stream2, parent);
    delete res.rel;
    return res;
  }
  constructor(key = "valueFormat") {
    this.key = key;
  }
};
var $47e0e8ef515d9903$var$PairValueRecord = new Struct({
  secondGlyph: uint16,
  value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
  value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
});
var $47e0e8ef515d9903$var$PairSet = new ArrayT($47e0e8ef515d9903$var$PairValueRecord, uint16);
var $47e0e8ef515d9903$var$Class2Record = new Struct({
  value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
  value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
});
var $47e0e8ef515d9903$var$Anchor = new VersionedStruct(uint16, {
  1: {
    xCoordinate: int16,
    yCoordinate: int16
  },
  2: {
    xCoordinate: int16,
    yCoordinate: int16,
    anchorPoint: uint16
  },
  3: {
    xCoordinate: int16,
    yCoordinate: int16,
    xDeviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10)),
    yDeviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
  }
});
var $47e0e8ef515d9903$var$EntryExitRecord = new Struct({
  entryAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  }),
  exitAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  })
});
var $47e0e8ef515d9903$var$MarkRecord = new Struct({
  class: uint16,
  markAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  })
});
var $47e0e8ef515d9903$var$MarkArray = new ArrayT($47e0e8ef515d9903$var$MarkRecord, uint16);
var $47e0e8ef515d9903$var$BaseRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t2) => t2.parent.classCount);
var $47e0e8ef515d9903$var$BaseArray = new ArrayT($47e0e8ef515d9903$var$BaseRecord, uint16);
var $47e0e8ef515d9903$var$ComponentRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t2) => t2.parent.parent.classCount);
var $47e0e8ef515d9903$var$LigatureAttach = new ArrayT($47e0e8ef515d9903$var$ComponentRecord, uint16);
var $47e0e8ef515d9903$var$LigatureArray = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$LigatureAttach), uint16);
var $47e0e8ef515d9903$export$73a8cfb19cd43a0f = new VersionedStruct("lookupType", {
  1: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat: $47e0e8ef515d9903$var$ValueFormat,
      value: new $47e0e8ef515d9903$var$ValueRecord()
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat: $47e0e8ef515d9903$var$ValueFormat,
      valueCount: uint16,
      values: new LazyArray(new $47e0e8ef515d9903$var$ValueRecord(), "valueCount")
    }
  }),
  2: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
      pairSetCount: uint16,
      pairSets: new LazyArray(new Pointer(uint16, $47e0e8ef515d9903$var$PairSet), "pairSetCount")
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
      classDef1: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
      classDef2: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
      class1Count: uint16,
      class2Count: uint16,
      classRecords: new LazyArray(new LazyArray($47e0e8ef515d9903$var$Class2Record, "class2Count"), "class1Count")
    }
  }),
  3: {
    format: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    entryExitCount: uint16,
    entryExitRecords: new ArrayT($47e0e8ef515d9903$var$EntryExitRecord, "entryExitCount")
  },
  4: {
    format: uint16,
    markCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    baseCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    baseArray: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
  },
  5: {
    format: uint16,
    markCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    ligatureCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    ligatureArray: new Pointer(uint16, $47e0e8ef515d9903$var$LigatureArray)
  },
  6: {
    format: uint16,
    mark1Coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    mark2Coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    mark1Array: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    mark2Array: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
  },
  7: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),
  8: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),
  9: {
    posFormat: uint16,
    lookupType: uint16,
    extension: new Pointer(uint32, null)
  }
});
$47e0e8ef515d9903$export$73a8cfb19cd43a0f.versions[9].extension.type = $47e0e8ef515d9903$export$73a8cfb19cd43a0f;
var $47e0e8ef515d9903$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    scriptList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),
    featureList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),
    lookupList: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($47e0e8ef515d9903$export$73a8cfb19cd43a0f))
  },
  65536: {},
  65537: {
    featureVariations: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))
  }
});
var $d3f442064af66e06$var$Sequence = new ArrayT(uint16, uint16);
var $d3f442064af66e06$var$AlternateSet = $d3f442064af66e06$var$Sequence;
var $d3f442064af66e06$var$Ligature = new Struct({
  glyph: uint16,
  compCount: uint16,
  components: new ArrayT(uint16, (t2) => t2.compCount - 1)
});
var $d3f442064af66e06$var$LigatureSet = new ArrayT(new Pointer(uint16, $d3f442064af66e06$var$Ligature), uint16);
var $d3f442064af66e06$var$GSUBLookup = new VersionedStruct("lookupType", {
  1: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      deltaGlyphID: int16
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      glyphCount: uint16,
      substitute: new LazyArray(uint16, "glyphCount")
    }
  }),
  2: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    sequences: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$Sequence), "count")
  },
  3: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    alternateSet: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$AlternateSet), "count")
  },
  4: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    ligatureSets: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$LigatureSet), "count")
  },
  5: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),
  6: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),
  7: {
    substFormat: uint16,
    lookupType: uint16,
    extension: new Pointer(uint32, null)
  },
  8: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    backtrackCoverage: new ArrayT(new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "backtrackGlyphCount"),
    lookaheadGlyphCount: uint16,
    lookaheadCoverage: new ArrayT(new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "lookaheadGlyphCount"),
    glyphCount: uint16,
    substitutes: new ArrayT(uint16, "glyphCount")
  }
});
$d3f442064af66e06$var$GSUBLookup.versions[7].extension.type = $d3f442064af66e06$var$GSUBLookup;
var $d3f442064af66e06$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    scriptList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),
    featureList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),
    lookupList: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($d3f442064af66e06$var$GSUBLookup))
  },
  65536: {},
  65537: {
    featureVariations: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))
  }
});
var $71cfb3c4767fbd0c$var$JstfGSUBModList = new ArrayT(uint16, uint16);
var $71cfb3c4767fbd0c$var$JstfPriority = new Struct({
  shrinkageEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageJstfMax: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f))),
  extensionEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionJstfMax: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f)))
});
var $71cfb3c4767fbd0c$var$JstfLangSys = new ArrayT(new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfPriority), uint16);
var $71cfb3c4767fbd0c$var$JstfLangSysRecord = new Struct({
  tag: new StringT(4),
  jstfLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys)
});
var $71cfb3c4767fbd0c$var$JstfScript = new Struct({
  extenderGlyphs: new Pointer(uint16, new ArrayT(uint16, uint16)),
  defaultLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys),
  langSysCount: uint16,
  langSysRecords: new ArrayT($71cfb3c4767fbd0c$var$JstfLangSysRecord, "langSysCount")
});
var $71cfb3c4767fbd0c$var$JstfScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfScript, {
    type: "parent"
  })
});
var $71cfb3c4767fbd0c$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  scriptCount: uint16,
  scriptList: new ArrayT($71cfb3c4767fbd0c$var$JstfScriptRecord, "scriptCount")
});
var $d059a6bd2d3b5b63$var$VariableSizeNumber = class {
  decode(stream2, parent) {
    switch (this.size(0, parent)) {
      case 1:
        return stream2.readUInt8();
      case 2:
        return stream2.readUInt16BE();
      case 3:
        return stream2.readUInt24BE();
      case 4:
        return stream2.readUInt32BE();
    }
  }
  size(val, parent) {
    return (0, resolveLength)(this._size, null, parent);
  }
  constructor(size) {
    this._size = size;
  }
};
var $d059a6bd2d3b5b63$var$MapDataEntry = new Struct({
  entry: new $d059a6bd2d3b5b63$var$VariableSizeNumber((t2) => ((t2.parent.entryFormat & 48) >> 4) + 1),
  outerIndex: (t2) => t2.entry >> (t2.parent.entryFormat & 15) + 1,
  innerIndex: (t2) => t2.entry & (1 << (t2.parent.entryFormat & 15) + 1) - 1
});
var $d059a6bd2d3b5b63$var$DeltaSetIndexMap = new Struct({
  entryFormat: uint16,
  mapCount: uint16,
  mapData: new ArrayT($d059a6bd2d3b5b63$var$MapDataEntry, "mapCount")
});
var $d059a6bd2d3b5b63$export$2e2bcd8739ae039 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)),
  advanceWidthMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
  LSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
  RSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap)
});
var $dceeca3e1977ce30$var$Signature = new Struct({
  format: uint32,
  length: uint32,
  offset: uint32
});
var $dceeca3e1977ce30$var$SignatureBlock = new Struct({
  reserved: new Reserved(uint16, 2),
  cbSignature: uint32,
  signature: new BufferT("cbSignature")
});
var $dceeca3e1977ce30$export$2e2bcd8739ae039 = new Struct({
  ulVersion: uint32,
  usNumSigs: uint16,
  usFlag: uint16,
  signatures: new ArrayT($dceeca3e1977ce30$var$Signature, "usNumSigs"),
  signatureBlocks: new ArrayT($dceeca3e1977ce30$var$SignatureBlock, "usNumSigs")
});
var $8acd740a9435aad0$var$GaspRange = new Struct({
  rangeMaxPPEM: uint16,
  rangeGaspBehavior: new Bitfield(uint16, [
    "grayscale",
    "gridfit",
    "symmetricSmoothing",
    "symmetricGridfit"
    // only in version 1, for ClearType
  ])
});
var $8acd740a9435aad0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRanges: uint16,
  gaspRanges: new ArrayT($8acd740a9435aad0$var$GaspRange, "numRanges")
  // Sorted by ppem
});
var $b5f380243c34d6a0$var$DeviceRecord = new Struct({
  pixelSize: uint8,
  maximumWidth: uint8,
  widths: new ArrayT(uint8, (t2) => t2.parent.parent.maxp.numGlyphs)
});
var $b5f380243c34d6a0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRecords: int16,
  sizeDeviceRecord: int32,
  records: new ArrayT($b5f380243c34d6a0$var$DeviceRecord, "numRecords")
});
var $ca2df1256966e313$var$KernPair = new Struct({
  left: uint16,
  right: uint16,
  value: int16
});
var $ca2df1256966e313$var$ClassTable = new Struct({
  firstGlyph: uint16,
  nGlyphs: uint16,
  offsets: new ArrayT(uint16, "nGlyphs"),
  max: (t2) => t2.offsets.length && Math.max.apply(Math, t2.offsets)
});
var $ca2df1256966e313$var$Kern2Array = new Struct({
  off: (t2) => t2._startOffset - t2.parent.parent._startOffset,
  len: (t2) => ((t2.parent.leftTable.max - t2.off) / t2.parent.rowWidth + 1) * (t2.parent.rowWidth / 2),
  values: new LazyArray(int16, "len")
});
var $ca2df1256966e313$var$KernSubtable = new VersionedStruct("format", {
  0: {
    nPairs: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    pairs: new ArrayT($ca2df1256966e313$var$KernPair, "nPairs")
  },
  2: {
    rowWidth: uint16,
    leftTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
      type: "parent"
    }),
    rightTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
      type: "parent"
    }),
    array: new Pointer(uint16, $ca2df1256966e313$var$Kern2Array, {
      type: "parent"
    })
  },
  3: {
    glyphCount: uint16,
    kernValueCount: uint8,
    leftClassCount: uint8,
    rightClassCount: uint8,
    flags: uint8,
    kernValue: new ArrayT(int16, "kernValueCount"),
    leftClass: new ArrayT(uint8, "glyphCount"),
    rightClass: new ArrayT(uint8, "glyphCount"),
    kernIndex: new ArrayT(uint8, (t2) => t2.leftClassCount * t2.rightClassCount)
  }
});
var $ca2df1256966e313$var$KernTable = new VersionedStruct("version", {
  0: {
    subVersion: uint16,
    length: uint16,
    format: uint8,
    coverage: new Bitfield(uint8, [
      "horizontal",
      "minimum",
      "crossStream",
      "override"
      // If set to 1 the value in this table replaces the accumulated value
    ]),
    subtable: $ca2df1256966e313$var$KernSubtable,
    padding: new Reserved(uint8, (t2) => t2.length - t2._currentOffset)
  },
  1: {
    length: uint32,
    coverage: new Bitfield(uint8, [
      null,
      null,
      null,
      null,
      null,
      "variation",
      "crossStream",
      "vertical"
      // Set if table has vertical kerning values
    ]),
    format: uint8,
    tupleIndex: uint16,
    subtable: $ca2df1256966e313$var$KernSubtable,
    padding: new Reserved(uint8, (t2) => t2.length - t2._currentOffset)
  }
});
var $ca2df1256966e313$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
  0: {
    nTables: uint16,
    tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
  },
  1: {
    reserved: new Reserved(uint16),
    nTables: uint32,
    tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
  }
});
var $7a9f92b0c46ebe33$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numGlyphs: uint16,
  yPels: new ArrayT(uint8, "numGlyphs")
});
var $2b2ccc419d152631$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  fontNumber: uint32,
  pitch: uint16,
  xHeight: uint16,
  style: uint16,
  typeFamily: uint16,
  capHeight: uint16,
  symbolSet: uint16,
  typeface: new StringT(16),
  characterComplement: new StringT(8),
  fileName: new StringT(6),
  strokeWeight: new StringT(1),
  widthType: new StringT(1),
  serifStyle: uint8,
  reserved: new Reserved(uint8)
});
var $ca5b40b9bcda9c9b$var$Ratio = new Struct({
  bCharSet: uint8,
  xRatio: uint8,
  yStartRatio: uint8,
  yEndRatio: uint8
  // Ending y-Ratio value
});
var $ca5b40b9bcda9c9b$var$vTable = new Struct({
  yPelHeight: uint16,
  yMax: int16,
  yMin: int16
  // Minimum value (in pels) for this yPelHeight
});
var $ca5b40b9bcda9c9b$var$VdmxGroup = new Struct({
  recs: uint16,
  startsz: uint8,
  endsz: uint8,
  entries: new ArrayT($ca5b40b9bcda9c9b$var$vTable, "recs")
  // The VDMX records
});
var $ca5b40b9bcda9c9b$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRecs: uint16,
  numRatios: uint16,
  ratioRanges: new ArrayT($ca5b40b9bcda9c9b$var$Ratio, "numRatios"),
  offsets: new ArrayT(uint16, "numRatios"),
  groups: new ArrayT($ca5b40b9bcda9c9b$var$VdmxGroup, "numRecs")
  // The actual VDMX groupings
});
var $69530a3c40755af0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  ascent: int16,
  descent: int16,
  lineGap: int16,
  advanceHeightMax: int16,
  minTopSideBearing: int16,
  minBottomSideBearing: int16,
  yMaxExtent: int16,
  caretSlopeRise: int16,
  caretSlopeRun: int16,
  caretOffset: int16,
  reserved: new Reserved(int16, 4),
  metricDataFormat: int16,
  numberOfMetrics: uint16
  // Number of advance heights in the Vertical Metrics table
});
var $344073dd270f0e62$var$VmtxEntry = new Struct({
  advance: uint16,
  bearing: int16
  // The top sidebearing of the glyph
});
var $344073dd270f0e62$export$2e2bcd8739ae039 = new Struct({
  metrics: new LazyArray($344073dd270f0e62$var$VmtxEntry, (t2) => t2.parent.vhea.numberOfMetrics),
  bearings: new LazyArray(int16, (t2) => t2.parent.maxp.numGlyphs - t2.parent.vhea.numberOfMetrics)
});
var $3793b781918cfced$var$shortFrac = new Fixed(16, "BE", 14);
var $3793b781918cfced$var$Correspondence = new Struct({
  fromCoord: $3793b781918cfced$var$shortFrac,
  toCoord: $3793b781918cfced$var$shortFrac
});
var $3793b781918cfced$var$Segment = new Struct({
  pairCount: uint16,
  correspondence: new ArrayT($3793b781918cfced$var$Correspondence, "pairCount")
});
var $3793b781918cfced$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  axisCount: uint32,
  segment: new ArrayT($3793b781918cfced$var$Segment, "axisCount")
});
var $6cb7dd5f47d82580$var$UnboundedArrayAccessor = class {
  getItem(index2) {
    if (this._items[index2] == null) {
      let pos = this.stream.pos;
      this.stream.pos = this.base + this.type.size(null, this.parent) * index2;
      this._items[index2] = this.type.decode(this.stream, this.parent);
      this.stream.pos = pos;
    }
    return this._items[index2];
  }
  inspect() {
    return `[UnboundedArray ${this.type.constructor.name}]`;
  }
  constructor(type2, stream2, parent) {
    this.type = type2;
    this.stream = stream2;
    this.parent = parent;
    this.base = this.stream.pos;
    this._items = [];
  }
};
var $6cb7dd5f47d82580$export$c5af1eebc882e39a = class extends ArrayT {
  decode(stream2, parent) {
    return new $6cb7dd5f47d82580$var$UnboundedArrayAccessor(this.type, stream2, parent);
  }
  constructor(type2) {
    super(type2, 0);
  }
};
var $6cb7dd5f47d82580$export$8351f8c2ae2f103c = function(ValueType = uint16) {
  class Shadow {
    decode(stream2, ctx) {
      ctx = ctx.parent.parent;
      return this.type.decode(stream2, ctx);
    }
    size(val, ctx) {
      ctx = ctx.parent.parent;
      return this.type.size(val, ctx);
    }
    encode(stream2, val, ctx) {
      ctx = ctx.parent.parent;
      return this.type.encode(stream2, val, ctx);
    }
    constructor(type2) {
      this.type = type2;
    }
  }
  ValueType = new Shadow(ValueType);
  let BinarySearchHeader = new Struct({
    unitSize: uint16,
    nUnits: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16
  });
  let LookupSegmentSingle = new Struct({
    lastGlyph: uint16,
    firstGlyph: uint16,
    value: ValueType
  });
  let LookupSegmentArray = new Struct({
    lastGlyph: uint16,
    firstGlyph: uint16,
    values: new Pointer(uint16, new ArrayT(ValueType, (t2) => t2.lastGlyph - t2.firstGlyph + 1), {
      type: "parent"
    })
  });
  let LookupSingle = new Struct({
    glyph: uint16,
    value: ValueType
  });
  return new VersionedStruct(uint16, {
    0: {
      values: new $6cb7dd5f47d82580$export$c5af1eebc882e39a(ValueType)
      // length == number of glyphs maybe?
    },
    2: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSegmentSingle, (t2) => t2.binarySearchHeader.nUnits)
    },
    4: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSegmentArray, (t2) => t2.binarySearchHeader.nUnits)
    },
    6: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSingle, (t2) => t2.binarySearchHeader.nUnits)
    },
    8: {
      firstGlyph: uint16,
      count: uint16,
      values: new ArrayT(ValueType, "count")
    }
  });
};
function $6cb7dd5f47d82580$export$79f7d93d790934ba(entryData = {}, lookupType = uint16) {
  let entry = Object.assign({
    newState: uint16,
    flags: uint16
  }, entryData);
  let Entry = new Struct(entry);
  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint16, (t2) => t2.nClasses));
  let StateHeader = new Struct({
    nClasses: uint32,
    classTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$8351f8c2ae2f103c(lookupType)),
    stateArray: new Pointer(uint32, StateArray),
    entryTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
  });
  return StateHeader;
}
function $6cb7dd5f47d82580$export$105027425199cc51(entryData = {}, lookupType = uint16) {
  let ClassLookupTable = new Struct({
    version() {
      return 8;
    },
    firstGlyph: uint16,
    values: new ArrayT(uint8, uint16)
  });
  let entry = Object.assign({
    newStateOffset: uint16,
    // convert offset to stateArray index
    newState: (t2) => (t2.newStateOffset - (t2.parent.stateArray.base - t2.parent._startOffset)) / t2.parent.nClasses,
    flags: uint16
  }, entryData);
  let Entry = new Struct(entry);
  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint8, (t2) => t2.nClasses));
  let StateHeader1 = new Struct({
    nClasses: uint16,
    classTable: new Pointer(uint16, ClassLookupTable),
    stateArray: new Pointer(uint16, StateArray),
    entryTable: new Pointer(uint16, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
  });
  return StateHeader1;
}
var $6a3746e8c708f5a3$var$BslnSubtable = new VersionedStruct("format", {
  0: {
    deltas: new ArrayT(int16, 32)
  },
  1: {
    deltas: new ArrayT(int16, 32),
    mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(uint16)
  },
  2: {
    standardGlyph: uint16,
    controlPoints: new ArrayT(uint16, 32)
  },
  3: {
    standardGlyph: uint16,
    controlPoints: new ArrayT(uint16, 32),
    mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(uint16)
  }
});
var $6a3746e8c708f5a3$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  format: uint16,
  defaultBaseline: uint16,
  subtable: $6a3746e8c708f5a3$var$BslnSubtable
});
var $d0c76fac617b308a$var$Setting = new Struct({
  setting: uint16,
  nameIndex: int16,
  name: (t2) => t2.parent.parent.parent.name.records.fontFeatures[t2.nameIndex]
});
var $d0c76fac617b308a$var$FeatureName = new Struct({
  feature: uint16,
  nSettings: uint16,
  settingTable: new Pointer(uint32, new ArrayT($d0c76fac617b308a$var$Setting, "nSettings"), {
    type: "parent"
  }),
  featureFlags: new Bitfield(uint8, [
    null,
    null,
    null,
    null,
    null,
    null,
    "hasDefault",
    "exclusive"
  ]),
  defaultSetting: uint8,
  nameIndex: int16,
  name: (t2) => t2.parent.parent.name.records.fontFeatures[t2.nameIndex]
});
var $d0c76fac617b308a$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  featureNameCount: uint16,
  reserved1: new Reserved(uint16),
  reserved2: new Reserved(uint32),
  featureNames: new ArrayT($d0c76fac617b308a$var$FeatureName, "featureNameCount")
});
var $e83fd065f00fcd01$var$Axis = new Struct({
  axisTag: new StringT(4),
  minValue: fixed32,
  defaultValue: fixed32,
  maxValue: fixed32,
  flags: uint16,
  nameID: uint16,
  name: (t2) => t2.parent.parent.name.records.fontFeatures[t2.nameID]
});
var $e83fd065f00fcd01$var$Instance = new Struct({
  nameID: uint16,
  name: (t2) => t2.parent.parent.name.records.fontFeatures[t2.nameID],
  flags: uint16,
  coord: new ArrayT(fixed32, (t2) => t2.parent.axisCount),
  postscriptNameID: new Optional(uint16, (t2) => t2.parent.instanceSize - t2._currentOffset > 0)
});
var $e83fd065f00fcd01$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  offsetToData: uint16,
  countSizePairs: uint16,
  axisCount: uint16,
  axisSize: uint16,
  instanceCount: uint16,
  instanceSize: uint16,
  axis: new ArrayT($e83fd065f00fcd01$var$Axis, "axisCount"),
  instance: new ArrayT($e83fd065f00fcd01$var$Instance, "instanceCount")
});
var $dbe33c8d3a7f131c$var$shortFrac = new Fixed(16, "BE", 14);
var $dbe33c8d3a7f131c$var$Offset = class {
  static decode(stream2, parent) {
    return parent.flags ? stream2.readUInt32BE() : stream2.readUInt16BE() * 2;
  }
};
var $dbe33c8d3a7f131c$var$gvar = new Struct({
  version: uint16,
  reserved: new Reserved(uint16),
  axisCount: uint16,
  globalCoordCount: uint16,
  globalCoords: new Pointer(uint32, new ArrayT(new ArrayT($dbe33c8d3a7f131c$var$shortFrac, "axisCount"), "globalCoordCount")),
  glyphCount: uint16,
  flags: uint16,
  offsetToData: uint32,
  offsets: new ArrayT(new Pointer($dbe33c8d3a7f131c$var$Offset, "void", {
    relativeTo: (ctx) => ctx.offsetToData,
    allowNull: false
  }), (t2) => t2.glyphCount + 1)
});
var $dbe33c8d3a7f131c$export$2e2bcd8739ae039 = $dbe33c8d3a7f131c$var$gvar;
var $05b01887df96c4ee$var$ClassTable = new Struct({
  length: uint16,
  coverage: uint16,
  subFeatureFlags: uint32,
  stateTable: new (0, $6cb7dd5f47d82580$export$105027425199cc51)()
});
var $05b01887df96c4ee$var$WidthDeltaRecord = new Struct({
  justClass: uint32,
  beforeGrowLimit: fixed32,
  beforeShrinkLimit: fixed32,
  afterGrowLimit: fixed32,
  afterShrinkLimit: fixed32,
  growFlags: uint16,
  shrinkFlags: uint16
});
var $05b01887df96c4ee$var$WidthDeltaCluster = new ArrayT($05b01887df96c4ee$var$WidthDeltaRecord, uint32);
var $05b01887df96c4ee$var$ActionData = new VersionedStruct("actionType", {
  0: {
    lowerLimit: fixed32,
    upperLimit: fixed32,
    order: uint16,
    glyphs: new ArrayT(uint16, uint16)
  },
  1: {
    addGlyph: uint16
  },
  2: {
    substThreshold: fixed32,
    addGlyph: uint16,
    substGlyph: uint16
  },
  3: {},
  4: {
    variationAxis: uint32,
    minimumLimit: fixed32,
    noStretchValue: fixed32,
    maximumLimit: fixed32
  },
  5: {
    flags: uint16,
    glyph: uint16
  }
});
var $05b01887df96c4ee$var$Action = new Struct({
  actionClass: uint16,
  actionType: uint16,
  actionLength: uint32,
  actionData: $05b01887df96c4ee$var$ActionData,
  padding: new Reserved(uint8, (t2) => t2.actionLength - t2._currentOffset)
});
var $05b01887df96c4ee$var$PostcompensationAction = new ArrayT($05b01887df96c4ee$var$Action, uint32);
var $05b01887df96c4ee$var$PostCompensationTable = new Struct({
  lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new Pointer(uint16, $05b01887df96c4ee$var$PostcompensationAction))
});
var $05b01887df96c4ee$var$JustificationTable = new Struct({
  classTable: new Pointer(uint16, $05b01887df96c4ee$var$ClassTable, {
    type: "parent"
  }),
  wdcOffset: uint16,
  postCompensationTable: new Pointer(uint16, $05b01887df96c4ee$var$PostCompensationTable, {
    type: "parent"
  }),
  widthDeltaClusters: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new Pointer(uint16, $05b01887df96c4ee$var$WidthDeltaCluster, {
    type: "parent",
    relativeTo: (ctx) => ctx.wdcOffset
  }))
});
var $05b01887df96c4ee$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  format: uint16,
  horizontal: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable),
  vertical: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable)
});
var $03ee6ebd54db1053$var$LigatureData = {
  action: uint16
};
var $03ee6ebd54db1053$var$ContextualData = {
  markIndex: uint16,
  currentIndex: uint16
};
var $03ee6ebd54db1053$var$InsertionData = {
  currentInsertIndex: uint16,
  markedInsertIndex: uint16
};
var $03ee6ebd54db1053$var$SubstitutionTable = new Struct({
  items: new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()))
});
var $03ee6ebd54db1053$var$SubtableData = new VersionedStruct("type", {
  0: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)()
  },
  1: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$ContextualData),
    substitutionTable: new Pointer(uint32, $03ee6ebd54db1053$var$SubstitutionTable)
  },
  2: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$LigatureData),
    ligatureActions: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint32)),
    components: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16)),
    ligatureList: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16))
  },
  4: {
    lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()
  },
  5: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$InsertionData),
    insertionActions: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16))
  }
});
var $03ee6ebd54db1053$var$Subtable = new Struct({
  length: uint32,
  coverage: uint24,
  type: uint8,
  subFeatureFlags: uint32,
  table: $03ee6ebd54db1053$var$SubtableData,
  padding: new Reserved(uint8, (t2) => t2.length - t2._currentOffset)
});
var $03ee6ebd54db1053$var$FeatureEntry = new Struct({
  featureType: uint16,
  featureSetting: uint16,
  enableFlags: uint32,
  disableFlags: uint32
});
var $03ee6ebd54db1053$var$MorxChain = new Struct({
  defaultFlags: uint32,
  chainLength: uint32,
  nFeatureEntries: uint32,
  nSubtables: uint32,
  features: new ArrayT($03ee6ebd54db1053$var$FeatureEntry, "nFeatureEntries"),
  subtables: new ArrayT($03ee6ebd54db1053$var$Subtable, "nSubtables")
});
var $03ee6ebd54db1053$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  unused: new Reserved(uint16),
  nChains: uint32,
  chains: new ArrayT($03ee6ebd54db1053$var$MorxChain, "nChains")
});
var $b7492a80b0d1a056$var$OpticalBounds = new Struct({
  left: int16,
  top: int16,
  right: int16,
  bottom: int16
});
var $b7492a80b0d1a056$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  format: uint16,
  lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)($b7492a80b0d1a056$var$OpticalBounds)
});
var $c3395722bea751e2$var$tables = {};
var $c3395722bea751e2$export$2e2bcd8739ae039 = $c3395722bea751e2$var$tables;
$c3395722bea751e2$var$tables.cmap = (0, $26a62205ad06574e$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.head = (0, $f2612a29f92ac062$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hhea = (0, $2c179dd593583073$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hmtx = (0, $bdc9060542264b85$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.maxp = (0, $dbf51cb3d3fe409d$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.name = (0, $2bcf221753ec8e32$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["OS/2"] = (0, $84b272aa31b70606$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.post = (0, $32d9e2eb9565d93c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.fpgm = (0, $5c0f37ca5ffb1850$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.loca = (0, $2b2b260902b1c57e$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.prep = (0, $7afb878c7bea4f66$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["cvt "] = (0, $5202bd9d9ad8eaac$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.glyf = (0, $6c92b6371bce8bd9$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["CFF "] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["CFF2"] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.VORG = (0, $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.EBLC = (0, $9911c4c7201c13de$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.CBLC = $c3395722bea751e2$var$tables.EBLC;
$c3395722bea751e2$var$tables.sbix = (0, $abb847051efd51b1$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.COLR = (0, $eb629188f3dfefdd$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.CPAL = (0, $08734b8e7dc64587$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.BASE = (0, $497cef411d884e34$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GDEF = (0, $cf5f33c63ef209e6$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GPOS = (0, $47e0e8ef515d9903$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GSUB = (0, $d3f442064af66e06$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.JSTF = (0, $71cfb3c4767fbd0c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.HVAR = (0, $d059a6bd2d3b5b63$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.DSIG = (0, $dceeca3e1977ce30$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.gasp = (0, $8acd740a9435aad0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hdmx = (0, $b5f380243c34d6a0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.kern = (0, $ca2df1256966e313$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.LTSH = (0, $7a9f92b0c46ebe33$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.PCLT = (0, $2b2ccc419d152631$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.VDMX = (0, $ca5b40b9bcda9c9b$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.vhea = (0, $69530a3c40755af0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.vmtx = (0, $344073dd270f0e62$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.avar = (0, $3793b781918cfced$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.bsln = (0, $6a3746e8c708f5a3$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.feat = (0, $d0c76fac617b308a$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.fvar = (0, $e83fd065f00fcd01$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.gvar = (0, $dbe33c8d3a7f131c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.just = (0, $05b01887df96c4ee$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.morx = (0, $03ee6ebd54db1053$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.opbd = (0, $b7492a80b0d1a056$export$2e2bcd8739ae039);
var $816c07a04b6dba87$var$TableEntry = new Struct({
  tag: new StringT(4),
  checkSum: uint32,
  offset: new Pointer(uint32, "void", {
    type: "global"
  }),
  length: uint32
});
var $816c07a04b6dba87$var$Directory = new Struct({
  tag: new StringT(4),
  numTables: uint16,
  searchRange: uint16,
  entrySelector: uint16,
  rangeShift: uint16,
  tables: new ArrayT($816c07a04b6dba87$var$TableEntry, "numTables")
});
$816c07a04b6dba87$var$Directory.process = function() {
  let tables = {};
  for (let table of this.tables) tables[table.tag] = table;
  this.tables = tables;
};
$816c07a04b6dba87$var$Directory.preEncode = function() {
  if (!Array.isArray(this.tables)) {
    let tables = [];
    for (let tag in this.tables) {
      let table = this.tables[tag];
      if (table) tables.push({
        tag,
        checkSum: 0,
        offset: new VoidPointer((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag], table),
        length: (0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag].size(table)
      });
    }
    this.tables = tables;
  }
  this.tag = "true";
  this.numTables = this.tables.length;
  let maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);
  let maxPowerOf2 = Math.pow(2, maxExponentFor2);
  this.searchRange = maxPowerOf2 * 16;
  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;
  this.rangeShift = this.numTables * 16 - this.searchRange;
};
var $816c07a04b6dba87$export$2e2bcd8739ae039 = $816c07a04b6dba87$var$Directory;
function $12727730ddfc8bfe$export$2e0ae67339d5f1ac(arr, cmp) {
  let min3 = 0;
  let max3 = arr.length - 1;
  while (min3 <= max3) {
    let mid = min3 + max3 >> 1;
    let res = cmp(arr[mid]);
    if (res < 0) max3 = mid - 1;
    else if (res > 0) min3 = mid + 1;
    else return mid;
  }
  return -1;
}
function $12727730ddfc8bfe$export$d02631cccf789723(index2, end3) {
  let range1 = [];
  while (index2 < end3) range1.push(index2++);
  return range1;
}
var $12727730ddfc8bfe$export$3d28c1996ced1f14 = new TextDecoder("ascii");
var $12727730ddfc8bfe$var$CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var $12727730ddfc8bfe$var$LOOKUP = new Uint8Array(256);
for (let i = 0; i < $12727730ddfc8bfe$var$CHARS.length; i++) $12727730ddfc8bfe$var$LOOKUP[$12727730ddfc8bfe$var$CHARS.charCodeAt(i)] = i;
function $12727730ddfc8bfe$export$94fdf11bafc8de6b(base64) {
  let bufferLength = base64.length * 0.75;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") bufferLength--;
  }
  let bytes = new Uint8Array(bufferLength);
  let p = 0;
  for (let i1 = 0, len = base64.length; i1 < len; i1 += 4) {
    let encoded1 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1)];
    let encoded2 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1 + 1)];
    let encoded3 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1 + 2)];
    let encoded4 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1 + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes;
}
var $f08dd41ef10b694c$export$2e2bcd8739ae039 = class {
  findSubtable(cmapTable, pairs3) {
    for (let [platformID, encodingID] of pairs3) for (let cmap of cmapTable.tables) {
      if (cmap.platformID === platformID && cmap.encodingID === encodingID) return cmap.table;
    }
    return null;
  }
  lookup(codepoint, variationSelector) {
    if (this.encoding) codepoint = this.encoding.get(codepoint) || codepoint;
    else if (variationSelector) {
      let gid = this.getVariationSelector(codepoint, variationSelector);
      if (gid) return gid;
    }
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0:
        return cmap.codeMap.get(codepoint) || 0;
      case 4: {
        let min3 = 0;
        let max3 = cmap.segCount - 1;
        while (min3 <= max3) {
          let mid = min3 + max3 >> 1;
          if (codepoint < cmap.startCode.get(mid)) max3 = mid - 1;
          else if (codepoint > cmap.endCode.get(mid)) min3 = mid + 1;
          else {
            let rangeOffset = cmap.idRangeOffset.get(mid);
            let gid;
            if (rangeOffset === 0) gid = codepoint + cmap.idDelta.get(mid);
            else {
              let index2 = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);
              gid = cmap.glyphIndexArray.get(index2) || 0;
              if (gid !== 0) gid += cmap.idDelta.get(mid);
            }
            return gid & 65535;
          }
        }
        return 0;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;
      case 12:
      case 13: {
        let min3 = 0;
        let max3 = cmap.nGroups - 1;
        while (min3 <= max3) {
          let mid = min3 + max3 >> 1;
          let group = cmap.groups.get(mid);
          if (codepoint < group.startCharCode) max3 = mid - 1;
          else if (codepoint > group.endCharCode) min3 = mid + 1;
          else {
            if (cmap.version === 12) return group.glyphID + (codepoint - group.startCharCode);
            else return group.glyphID;
          }
        }
        return 0;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  getVariationSelector(codepoint, variationSelector) {
    if (!this.uvs) return 0;
    let selectors = this.uvs.varSelectors.toArray();
    let i = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(selectors, (x) => variationSelector - x.varSelector);
    let sel = selectors[i];
    if (i !== -1 && sel.defaultUVS) i = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.defaultUVS, (x) => codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? 1 : 0);
    if (i !== -1 && sel.nonDefaultUVS) {
      i = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.nonDefaultUVS, (x) => codepoint - x.unicodeValue);
      if (i !== -1) return sel.nonDefaultUVS[i].glyphID;
    }
    return 0;
  }
  getCharacterSet() {
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0:
        return (0, $12727730ddfc8bfe$export$d02631cccf789723)(0, cmap.codeMap.length);
      case 4: {
        let res = [];
        let endCodes = cmap.endCode.toArray();
        for (let i = 0; i < endCodes.length; i++) {
          let tail = endCodes[i] + 1;
          let start3 = cmap.startCode.get(i);
          res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(start3, tail));
        }
        return res;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return (0, $12727730ddfc8bfe$export$d02631cccf789723)(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);
      case 12:
      case 13: {
        let res = [];
        for (let group of cmap.groups.toArray()) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));
        return res;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  codePointsForGlyph(gid) {
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0: {
        let res = [];
        for (let i = 0; i < 256; i++) if (cmap.codeMap.get(i) === gid) res.push(i);
        return res;
      }
      case 4: {
        let res = [];
        for (let i = 0; i < cmap.segCount; i++) {
          let end3 = cmap.endCode.get(i);
          let start3 = cmap.startCode.get(i);
          let rangeOffset = cmap.idRangeOffset.get(i);
          let delta = cmap.idDelta.get(i);
          for (var c2 = start3; c2 <= end3; c2++) {
            let g = 0;
            if (rangeOffset === 0) g = c2 + delta;
            else {
              let index2 = rangeOffset / 2 + (c2 - start3) - (cmap.segCount - i);
              g = cmap.glyphIndexArray.get(index2) || 0;
              if (g !== 0) g += delta;
            }
            if (g === gid) res.push(c2);
          }
        }
        return res;
      }
      case 12: {
        let res = [];
        for (let group of cmap.groups.toArray()) if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) res.push(group.startCharCode + (gid - group.glyphID));
        return res;
      }
      case 13: {
        let res = [];
        for (let group of cmap.groups.toArray()) if (gid === group.glyphID) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));
        return res;
      }
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  constructor(cmapTable) {
    this.encoding = null;
    this.cmap = this.findSubtable(cmapTable, [
      // 32-bit subtables
      [
        3,
        10
      ],
      [
        0,
        6
      ],
      [
        0,
        4
      ],
      // 16-bit subtables
      [
        3,
        1
      ],
      [
        0,
        3
      ],
      [
        0,
        2
      ],
      [
        0,
        1
      ],
      [
        0,
        0
      ]
    ]);
    if (!this.cmap) for (let cmap of cmapTable.tables) {
      let encoding = (0, $e449ad78d50845fe$export$badc544e0651b6b1)(cmap.platformID, cmap.encodingID, cmap.table.language - 1);
      let mapping = (0, $e449ad78d50845fe$export$1dceb3c14ed68bee)(encoding);
      if (mapping) {
        this.cmap = cmap.table;
        this.encoding = mapping;
      }
    }
    if (!this.cmap) throw new Error("Could not find a supported cmap table");
    this.uvs = this.findSubtable(cmapTable, [
      [
        0,
        5
      ]
    ]);
    if (this.uvs && this.uvs.version !== 14) this.uvs = null;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "getCharacterSet", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "codePointsForGlyph", null);
var $0bba3a9db57637f3$export$2e2bcd8739ae039 = class {
  process(glyphs, positions) {
    for (let glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {
      let left = glyphs[glyphIndex].id;
      let right = glyphs[glyphIndex + 1].id;
      positions[glyphIndex].xAdvance += this.getKerning(left, right);
    }
  }
  getKerning(left, right) {
    let res = 0;
    for (let table of this.kern.tables) {
      if (table.coverage.crossStream) continue;
      switch (table.version) {
        case 0:
          if (!table.coverage.horizontal) continue;
          break;
        case 1:
          if (table.coverage.vertical || table.coverage.variation) continue;
          break;
        default:
          throw new Error(`Unsupported kerning table version ${table.version}`);
      }
      let val = 0;
      let s2 = table.subtable;
      switch (table.format) {
        case 0:
          let pairIdx = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(s2.pairs, function(pair) {
            return left - pair.left || right - pair.right;
          });
          if (pairIdx >= 0) val = s2.pairs[pairIdx].value;
          break;
        case 2:
          let leftOffset = 0, rightOffset = 0;
          if (left >= s2.leftTable.firstGlyph && left < s2.leftTable.firstGlyph + s2.leftTable.nGlyphs) leftOffset = s2.leftTable.offsets[left - s2.leftTable.firstGlyph];
          else leftOffset = s2.array.off;
          if (right >= s2.rightTable.firstGlyph && right < s2.rightTable.firstGlyph + s2.rightTable.nGlyphs) rightOffset = s2.rightTable.offsets[right - s2.rightTable.firstGlyph];
          let index2 = (leftOffset + rightOffset - s2.array.off) / 2;
          val = s2.array.values.get(index2);
          break;
        case 3:
          if (left >= s2.glyphCount || right >= s2.glyphCount) return 0;
          val = s2.kernValue[s2.kernIndex[s2.leftClass[left] * s2.rightClassCount + s2.rightClass[right]]];
          break;
        default:
          throw new Error(`Unsupported kerning sub-table format ${table.format}`);
      }
      if (table.coverage.override) res = val;
      else res += val;
    }
    return res;
  }
  constructor(font2) {
    this.kern = font2.kern;
  }
};
var $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039 = class {
  positionGlyphs(glyphs, positions) {
    let clusterStart = 0;
    let clusterEnd = 0;
    for (let index2 = 0; index2 < glyphs.length; index2++) {
      let glyph = glyphs[index2];
      if (glyph.isMark) clusterEnd = index2;
      else {
        if (clusterStart !== clusterEnd) this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
        clusterStart = clusterEnd = index2;
      }
    }
    if (clusterStart !== clusterEnd) this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
    return positions;
  }
  positionCluster(glyphs, positions, clusterStart, clusterEnd) {
    let base = glyphs[clusterStart];
    let baseBox = base.cbox.copy();
    if (base.codePoints.length > 1)
      baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
    let xOffset = -positions[clusterStart].xAdvance;
    let yOffset = 0;
    let yGap = this.font.unitsPerEm / 16;
    for (let index2 = clusterStart + 1; index2 <= clusterEnd; index2++) {
      let mark = glyphs[index2];
      let markBox = mark.cbox;
      let position = positions[index2];
      let combiningClass = this.getCombiningClass(mark.codePoints[0]);
      if (combiningClass !== "Not_Reordered") {
        position.xOffset = position.yOffset = 0;
        switch (combiningClass) {
          case "Double_Above":
          case "Double_Below":
            position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
            break;
          case "Attached_Below_Left":
          case "Below_Left":
          case "Above_Left":
            position.xOffset += baseBox.minX - markBox.minX;
            break;
          case "Attached_Above_Right":
          case "Below_Right":
          case "Above_Right":
            position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
            break;
          default:
            position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
        }
        switch (combiningClass) {
          case "Double_Below":
          case "Below_Left":
          case "Below":
          case "Below_Right":
          case "Attached_Below_Left":
          case "Attached_Below":
            if (combiningClass === "Attached_Below_Left" || combiningClass === "Attached_Below") baseBox.minY += yGap;
            position.yOffset = -baseBox.minY - markBox.maxY;
            baseBox.minY += markBox.height;
            break;
          case "Double_Above":
          case "Above_Left":
          case "Above":
          case "Above_Right":
          case "Attached_Above":
          case "Attached_Above_Right":
            if (combiningClass === "Attached_Above" || combiningClass === "Attached_Above_Right") baseBox.maxY += yGap;
            position.yOffset = baseBox.maxY - markBox.minY;
            baseBox.maxY += markBox.height;
            break;
        }
        position.xAdvance = position.yAdvance = 0;
        position.xOffset += xOffset;
        position.yOffset += yOffset;
      } else {
        xOffset -= position.xAdvance;
        yOffset -= position.yAdvance;
      }
    }
    return;
  }
  getCombiningClass(codePoint) {
    let combiningClass = (0, $747425b437e121da$export$c03b919c6651ed55)(codePoint);
    if ((codePoint & -256) === 3584) {
      if (combiningClass === "Not_Reordered") switch (codePoint) {
        case 3633:
        case 3636:
        case 3637:
        case 3638:
        case 3639:
        case 3655:
        case 3660:
        case 3645:
        case 3662:
          return "Above_Right";
        case 3761:
        case 3764:
        case 3765:
        case 3766:
        case 3767:
        case 3771:
        case 3788:
        case 3789:
          return "Above";
        case 3772:
          return "Below";
      }
      else if (codePoint === 3642) return "Below_Right";
    }
    switch (combiningClass) {
      case "CCC10":
      case "CCC11":
      case "CCC12":
      case "CCC13":
      case "CCC14":
      case "CCC15":
      case "CCC16":
      case "CCC17":
      case "CCC18":
      case "CCC20":
      case "CCC22":
        return "Below";
      case "CCC23":
        return "Attached_Above";
      case "CCC24":
        return "Above_Right";
      case "CCC25":
      case "CCC19":
        return "Above_Left";
      case "CCC26":
        return "Above";
      case "CCC21":
        break;
      case "CCC27":
      case "CCC28":
      case "CCC30":
      case "CCC31":
      case "CCC33":
      case "CCC34":
      case "CCC35":
      case "CCC36":
        return "Above";
      case "CCC29":
      case "CCC32":
        return "Below";
      case "CCC103":
        return "Below_Right";
      case "CCC107":
        return "Above_Right";
      case "CCC118":
        return "Below";
      case "CCC122":
        return "Above";
      case "CCC129":
      case "CCC132":
        return "Below";
      case "CCC130":
        return "Above";
    }
    return combiningClass;
  }
  constructor(font2) {
    this.font = font2;
  }
};
var $f34600ab9d7f70d8$export$2e2bcd8739ae039 = class _$f34600ab9d7f70d8$export$2e2bcd8739ae039 {
  /**
  * The width of the bounding box
  * @type {number}
  */
  get width() {
    return this.maxX - this.minX;
  }
  /**
  * The height of the bounding box
  * @type {number}
  */
  get height() {
    return this.maxY - this.minY;
  }
  addPoint(x, y) {
    if (Math.abs(x) !== Infinity) {
      if (x < this.minX) this.minX = x;
      if (x > this.maxX) this.maxX = x;
    }
    if (Math.abs(y) !== Infinity) {
      if (y < this.minY) this.minY = y;
      if (y > this.maxY) this.maxY = y;
    }
  }
  copy() {
    return new _$f34600ab9d7f70d8$export$2e2bcd8739ae039(this.minX, this.minY, this.maxX, this.maxY);
  }
  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
};
var $130d1a642ebcd2b7$var$UNICODE_SCRIPTS = {
  Caucasian_Albanian: "aghb",
  Arabic: "arab",
  Imperial_Aramaic: "armi",
  Armenian: "armn",
  Avestan: "avst",
  Balinese: "bali",
  Bamum: "bamu",
  Bassa_Vah: "bass",
  Batak: "batk",
  Bengali: [
    "bng2",
    "beng"
  ],
  Bopomofo: "bopo",
  Brahmi: "brah",
  Braille: "brai",
  Buginese: "bugi",
  Buhid: "buhd",
  Chakma: "cakm",
  Canadian_Aboriginal: "cans",
  Carian: "cari",
  Cham: "cham",
  Cherokee: "cher",
  Coptic: "copt",
  Cypriot: "cprt",
  Cyrillic: "cyrl",
  Devanagari: [
    "dev2",
    "deva"
  ],
  Deseret: "dsrt",
  Duployan: "dupl",
  Egyptian_Hieroglyphs: "egyp",
  Elbasan: "elba",
  Ethiopic: "ethi",
  Georgian: "geor",
  Glagolitic: "glag",
  Gothic: "goth",
  Grantha: "gran",
  Greek: "grek",
  Gujarati: [
    "gjr2",
    "gujr"
  ],
  Gurmukhi: [
    "gur2",
    "guru"
  ],
  Hangul: "hang",
  Han: "hani",
  Hanunoo: "hano",
  Hebrew: "hebr",
  Hiragana: "hira",
  Pahawh_Hmong: "hmng",
  Katakana_Or_Hiragana: "hrkt",
  Old_Italic: "ital",
  Javanese: "java",
  Kayah_Li: "kali",
  Katakana: "kana",
  Kharoshthi: "khar",
  Khmer: "khmr",
  Khojki: "khoj",
  Kannada: [
    "knd2",
    "knda"
  ],
  Kaithi: "kthi",
  Tai_Tham: "lana",
  Lao: "lao ",
  Latin: "latn",
  Lepcha: "lepc",
  Limbu: "limb",
  Linear_A: "lina",
  Linear_B: "linb",
  Lisu: "lisu",
  Lycian: "lyci",
  Lydian: "lydi",
  Mahajani: "mahj",
  Mandaic: "mand",
  Manichaean: "mani",
  Mende_Kikakui: "mend",
  Meroitic_Cursive: "merc",
  Meroitic_Hieroglyphs: "mero",
  Malayalam: [
    "mlm2",
    "mlym"
  ],
  Modi: "modi",
  Mongolian: "mong",
  Mro: "mroo",
  Meetei_Mayek: "mtei",
  Myanmar: [
    "mym2",
    "mymr"
  ],
  Old_North_Arabian: "narb",
  Nabataean: "nbat",
  Nko: "nko ",
  Ogham: "ogam",
  Ol_Chiki: "olck",
  Old_Turkic: "orkh",
  Oriya: [
    "ory2",
    "orya"
  ],
  Osmanya: "osma",
  Palmyrene: "palm",
  Pau_Cin_Hau: "pauc",
  Old_Permic: "perm",
  Phags_Pa: "phag",
  Inscriptional_Pahlavi: "phli",
  Psalter_Pahlavi: "phlp",
  Phoenician: "phnx",
  Miao: "plrd",
  Inscriptional_Parthian: "prti",
  Rejang: "rjng",
  Runic: "runr",
  Samaritan: "samr",
  Old_South_Arabian: "sarb",
  Saurashtra: "saur",
  Shavian: "shaw",
  Sharada: "shrd",
  Siddham: "sidd",
  Khudawadi: "sind",
  Sinhala: "sinh",
  Sora_Sompeng: "sora",
  Sundanese: "sund",
  Syloti_Nagri: "sylo",
  Syriac: "syrc",
  Tagbanwa: "tagb",
  Takri: "takr",
  Tai_Le: "tale",
  New_Tai_Lue: "talu",
  Tamil: [
    "tml2",
    "taml"
  ],
  Tai_Viet: "tavt",
  Telugu: [
    "tel2",
    "telu"
  ],
  Tifinagh: "tfng",
  Tagalog: "tglg",
  Thaana: "thaa",
  Thai: "thai",
  Tibetan: "tibt",
  Tirhuta: "tirh",
  Ugaritic: "ugar",
  Vai: "vai ",
  Warang_Citi: "wara",
  Old_Persian: "xpeo",
  Cuneiform: "xsux",
  Yi: "yi  ",
  Inherited: "zinh",
  Common: "zyyy",
  Unknown: "zzzz"
};
var $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS = {};
for (let script in $130d1a642ebcd2b7$var$UNICODE_SCRIPTS) {
  let tag = $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  if (Array.isArray(tag)) for (let t2 of tag) $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[t2] = script;
  else $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag] = script;
}
function $130d1a642ebcd2b7$export$ce50e82f12a827a4(tag) {
  return $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag];
}
function $130d1a642ebcd2b7$export$e5cb25e204fb8450(string) {
  let len = string.length;
  let idx = 0;
  while (idx < len) {
    let code = string.charCodeAt(idx++);
    if (55296 <= code && code <= 56319 && idx < len) {
      let next = string.charCodeAt(idx);
      if (56320 <= next && next <= 57343) {
        idx++;
        code = ((code & 1023) << 10) + (next & 1023) + 65536;
      }
    }
    let script2 = (0, $747425b437e121da$export$941569448d136665)(code);
    if (script2 !== "Common" && script2 !== "Inherited" && script2 !== "Unknown") return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script2];
  }
  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
}
function $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints) {
  for (let i = 0; i < codePoints.length; i++) {
    let codePoint = codePoints[i];
    let script3 = (0, $747425b437e121da$export$941569448d136665)(codePoint);
    if (script3 !== "Common" && script3 !== "Inherited" && script3 !== "Unknown") return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script3];
  }
  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
}
var $130d1a642ebcd2b7$var$RTL = {
  arab: true,
  hebr: true,
  syrc: true,
  thaa: true,
  cprt: true,
  khar: true,
  phnx: true,
  "nko ": true,
  lydi: true,
  avst: true,
  armi: true,
  phli: true,
  prti: true,
  sarb: true,
  orkh: true,
  samr: true,
  mand: true,
  merc: true,
  mero: true,
  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)
  mani: true,
  mend: true,
  nbat: true,
  narb: true,
  palm: true,
  phlp: true
  // Psalter Pahlavi
};
function $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script4) {
  if ($130d1a642ebcd2b7$var$RTL[script4]) return "rtl";
  return "ltr";
}
var $be07b3e97a42687a$export$2e2bcd8739ae039 = class {
  /**
  * The total advance width of the run.
  * @type {number}
  */
  get advanceWidth() {
    let width = 0;
    for (let position of this.positions) width += position.xAdvance;
    return width;
  }
  /**
  * The total advance height of the run.
  * @type {number}
  */
  get advanceHeight() {
    let height5 = 0;
    for (let position of this.positions) height5 += position.yAdvance;
    return height5;
  }
  /**
  * The bounding box containing all glyphs in the run.
  * @type {BBox}
  */
  get bbox() {
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    let x = 0;
    let y = 0;
    for (let index2 = 0; index2 < this.glyphs.length; index2++) {
      let glyph = this.glyphs[index2];
      let p = this.positions[index2];
      let b = glyph.bbox;
      bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);
      bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);
      x += p.xAdvance;
      y += p.yAdvance;
    }
    return bbox;
  }
  constructor(glyphs, features, script, language, direction) {
    this.glyphs = glyphs;
    this.positions = null;
    this.script = script;
    this.language = language || null;
    this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
    this.features = {};
    if (Array.isArray(features)) for (let tag of features) this.features[tag] = true;
    else if (typeof features === "object") this.features = features;
  }
};
var $1ac75d9a55b67f01$export$2e2bcd8739ae039 = class {
  constructor(xAdvance = 0, yAdvance = 0, xOffset = 0, yOffset = 0) {
    this.xAdvance = xAdvance;
    this.yAdvance = yAdvance;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
  }
};
var $3b6302b64eccc32c$var$features = {
  allTypographicFeatures: {
    code: 0,
    exclusive: false,
    allTypeFeatures: 0
  },
  ligatures: {
    code: 1,
    exclusive: false,
    requiredLigatures: 0,
    commonLigatures: 2,
    rareLigatures: 4,
    // logos: 6
    rebusPictures: 8,
    diphthongLigatures: 10,
    squaredLigatures: 12,
    abbrevSquaredLigatures: 14,
    symbolLigatures: 16,
    contextualLigatures: 18,
    historicalLigatures: 20
  },
  cursiveConnection: {
    code: 2,
    exclusive: true,
    unconnected: 0,
    partiallyConnected: 1,
    cursive: 2
  },
  letterCase: {
    code: 3,
    exclusive: true
  },
  // upperAndLowerCase: 0          # deprecated
  // allCaps: 1                    # deprecated
  // allLowerCase: 2               # deprecated
  // smallCaps: 3                  # deprecated
  // initialCaps: 4                # deprecated
  // initialCapsAndSmallCaps: 5    # deprecated
  verticalSubstitution: {
    code: 4,
    exclusive: false,
    substituteVerticalForms: 0
  },
  linguisticRearrangement: {
    code: 5,
    exclusive: false,
    linguisticRearrangement: 0
  },
  numberSpacing: {
    code: 6,
    exclusive: true,
    monospacedNumbers: 0,
    proportionalNumbers: 1,
    thirdWidthNumbers: 2,
    quarterWidthNumbers: 3
  },
  smartSwash: {
    code: 8,
    exclusive: false,
    wordInitialSwashes: 0,
    wordFinalSwashes: 2,
    // lineInitialSwashes: 4
    // lineFinalSwashes: 6
    nonFinalSwashes: 8
  },
  diacritics: {
    code: 9,
    exclusive: true,
    showDiacritics: 0,
    hideDiacritics: 1,
    decomposeDiacritics: 2
  },
  verticalPosition: {
    code: 10,
    exclusive: true,
    normalPosition: 0,
    superiors: 1,
    inferiors: 2,
    ordinals: 3,
    scientificInferiors: 4
  },
  fractions: {
    code: 11,
    exclusive: true,
    noFractions: 0,
    verticalFractions: 1,
    diagonalFractions: 2
  },
  overlappingCharacters: {
    code: 13,
    exclusive: false,
    preventOverlap: 0
  },
  typographicExtras: {
    code: 14,
    exclusive: false,
    // hyphensToEmDash: 0
    // hyphenToEnDash: 2
    slashedZero: 4
  },
  // formInterrobang: 6
  // smartQuotes: 8
  // periodsToEllipsis: 10
  mathematicalExtras: {
    code: 15,
    exclusive: false,
    // hyphenToMinus: 0
    // asteristoMultiply: 2
    // slashToDivide: 4
    // inequalityLigatures: 6
    // exponents: 8
    mathematicalGreek: 10
  },
  ornamentSets: {
    code: 16,
    exclusive: true,
    noOrnaments: 0,
    dingbats: 1,
    piCharacters: 2,
    fleurons: 3,
    decorativeBorders: 4,
    internationalSymbols: 5,
    mathSymbols: 6
  },
  characterAlternatives: {
    code: 17,
    exclusive: true,
    noAlternates: 0
  },
  // user defined options
  designComplexity: {
    code: 18,
    exclusive: true,
    designLevel1: 0,
    designLevel2: 1,
    designLevel3: 2,
    designLevel4: 3,
    designLevel5: 4
  },
  styleOptions: {
    code: 19,
    exclusive: true,
    noStyleOptions: 0,
    displayText: 1,
    engravedText: 2,
    illuminatedCaps: 3,
    titlingCaps: 4,
    tallCaps: 5
  },
  characterShape: {
    code: 20,
    exclusive: true,
    traditionalCharacters: 0,
    simplifiedCharacters: 1,
    JIS1978Characters: 2,
    JIS1983Characters: 3,
    JIS1990Characters: 4,
    traditionalAltOne: 5,
    traditionalAltTwo: 6,
    traditionalAltThree: 7,
    traditionalAltFour: 8,
    traditionalAltFive: 9,
    expertCharacters: 10,
    JIS2004Characters: 11,
    hojoCharacters: 12,
    NLCCharacters: 13,
    traditionalNamesCharacters: 14
  },
  numberCase: {
    code: 21,
    exclusive: true,
    lowerCaseNumbers: 0,
    upperCaseNumbers: 1
  },
  textSpacing: {
    code: 22,
    exclusive: true,
    proportionalText: 0,
    monospacedText: 1,
    halfWidthText: 2,
    thirdWidthText: 3,
    quarterWidthText: 4,
    altProportionalText: 5,
    altHalfWidthText: 6
  },
  transliteration: {
    code: 23,
    exclusive: true,
    noTransliteration: 0
  },
  // hanjaToHangul: 1
  // hiraganaToKatakana: 2
  // katakanaToHiragana: 3
  // kanaToRomanization: 4
  // romanizationToHiragana: 5
  // romanizationToKatakana: 6
  // hanjaToHangulAltOne: 7
  // hanjaToHangulAltTwo: 8
  // hanjaToHangulAltThree: 9
  annotation: {
    code: 24,
    exclusive: true,
    noAnnotation: 0,
    boxAnnotation: 1,
    roundedBoxAnnotation: 2,
    circleAnnotation: 3,
    invertedCircleAnnotation: 4,
    parenthesisAnnotation: 5,
    periodAnnotation: 6,
    romanNumeralAnnotation: 7,
    diamondAnnotation: 8,
    invertedBoxAnnotation: 9,
    invertedRoundedBoxAnnotation: 10
  },
  kanaSpacing: {
    code: 25,
    exclusive: true,
    fullWidthKana: 0,
    proportionalKana: 1
  },
  ideographicSpacing: {
    code: 26,
    exclusive: true,
    fullWidthIdeographs: 0,
    proportionalIdeographs: 1,
    halfWidthIdeographs: 2
  },
  unicodeDecomposition: {
    code: 27,
    exclusive: false,
    canonicalComposition: 0,
    compatibilityComposition: 2,
    transcodingComposition: 4
  },
  rubyKana: {
    code: 28,
    exclusive: false,
    // noRubyKana: 0     # deprecated - use rubyKanaOff instead
    // rubyKana: 1     # deprecated - use rubyKanaOn instead
    rubyKana: 2
  },
  CJKSymbolAlternatives: {
    code: 29,
    exclusive: true,
    noCJKSymbolAlternatives: 0,
    CJKSymbolAltOne: 1,
    CJKSymbolAltTwo: 2,
    CJKSymbolAltThree: 3,
    CJKSymbolAltFour: 4,
    CJKSymbolAltFive: 5
  },
  ideographicAlternatives: {
    code: 30,
    exclusive: true,
    noIdeographicAlternatives: 0,
    ideographicAltOne: 1,
    ideographicAltTwo: 2,
    ideographicAltThree: 3,
    ideographicAltFour: 4,
    ideographicAltFive: 5
  },
  CJKVerticalRomanPlacement: {
    code: 31,
    exclusive: true,
    CJKVerticalRomanCentered: 0,
    CJKVerticalRomanHBaseline: 1
  },
  italicCJKRoman: {
    code: 32,
    exclusive: false,
    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead
    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead
    CJKItalicRoman: 2
  },
  caseSensitiveLayout: {
    code: 33,
    exclusive: false,
    caseSensitiveLayout: 0,
    caseSensitiveSpacing: 2
  },
  alternateKana: {
    code: 34,
    exclusive: false,
    alternateHorizKana: 0,
    alternateVertKana: 2
  },
  stylisticAlternatives: {
    code: 35,
    exclusive: false,
    noStylisticAlternates: 0,
    stylisticAltOne: 2,
    stylisticAltTwo: 4,
    stylisticAltThree: 6,
    stylisticAltFour: 8,
    stylisticAltFive: 10,
    stylisticAltSix: 12,
    stylisticAltSeven: 14,
    stylisticAltEight: 16,
    stylisticAltNine: 18,
    stylisticAltTen: 20,
    stylisticAltEleven: 22,
    stylisticAltTwelve: 24,
    stylisticAltThirteen: 26,
    stylisticAltFourteen: 28,
    stylisticAltFifteen: 30,
    stylisticAltSixteen: 32,
    stylisticAltSeventeen: 34,
    stylisticAltEighteen: 36,
    stylisticAltNineteen: 38,
    stylisticAltTwenty: 40
  },
  contextualAlternates: {
    code: 36,
    exclusive: false,
    contextualAlternates: 0,
    swashAlternates: 2,
    contextualSwashAlternates: 4
  },
  lowerCase: {
    code: 37,
    exclusive: true,
    defaultLowerCase: 0,
    lowerCaseSmallCaps: 1,
    lowerCasePetiteCaps: 2
  },
  upperCase: {
    code: 38,
    exclusive: true,
    defaultUpperCase: 0,
    upperCaseSmallCaps: 1,
    upperCasePetiteCaps: 2
  },
  languageTag: {
    code: 39,
    exclusive: true
  },
  CJKRomanSpacing: {
    code: 103,
    exclusive: true,
    halfWidthCJKRoman: 0,
    proportionalCJKRoman: 1,
    defaultCJKRoman: 2,
    fullWidthCJKRoman: 3
  }
};
var $3b6302b64eccc32c$var$feature = (name2, selector) => [
  $3b6302b64eccc32c$var$features[name2].code,
  $3b6302b64eccc32c$var$features[name2][selector]
];
var $3b6302b64eccc32c$var$OTMapping = {
  rlig: $3b6302b64eccc32c$var$feature("ligatures", "requiredLigatures"),
  clig: $3b6302b64eccc32c$var$feature("ligatures", "contextualLigatures"),
  dlig: $3b6302b64eccc32c$var$feature("ligatures", "rareLigatures"),
  hlig: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
  liga: $3b6302b64eccc32c$var$feature("ligatures", "commonLigatures"),
  hist: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
  smcp: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCaseSmallCaps"),
  pcap: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCasePetiteCaps"),
  frac: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  dnom: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  numr: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  afrc: $3b6302b64eccc32c$var$feature("fractions", "verticalFractions"),
  // aalt
  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?
  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?
  // unic, vatu, vhal, vjmo, vpal, vrt2
  // dist -> trak table?
  // kern, vkrn -> kern table
  // lfbd + opbd + rtbd -> opbd table?
  // mark, mkmk -> acnt table?
  // locl -> languageTag + ltag table
  case: $3b6302b64eccc32c$var$feature("caseSensitiveLayout", "caseSensitiveLayout"),
  ccmp: $3b6302b64eccc32c$var$feature("unicodeDecomposition", "canonicalComposition"),
  cpct: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  valt: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  swsh: $3b6302b64eccc32c$var$feature("contextualAlternates", "swashAlternates"),
  cswh: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualSwashAlternates"),
  curs: $3b6302b64eccc32c$var$feature("cursiveConnection", "cursive"),
  c2pc: $3b6302b64eccc32c$var$feature("upperCase", "upperCasePetiteCaps"),
  c2sc: $3b6302b64eccc32c$var$feature("upperCase", "upperCaseSmallCaps"),
  init: $3b6302b64eccc32c$var$feature("smartSwash", "wordInitialSwashes"),
  fin2: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  medi: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
  med2: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
  fin3: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  fina: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  pkna: $3b6302b64eccc32c$var$feature("kanaSpacing", "proportionalKana"),
  half: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
  halt: $3b6302b64eccc32c$var$feature("textSpacing", "altHalfWidthText"),
  hkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateHorizKana"),
  vkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateVertKana"),
  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated
  ital: $3b6302b64eccc32c$var$feature("italicCJKRoman", "CJKItalicRoman"),
  lnum: $3b6302b64eccc32c$var$feature("numberCase", "upperCaseNumbers"),
  onum: $3b6302b64eccc32c$var$feature("numberCase", "lowerCaseNumbers"),
  mgrk: $3b6302b64eccc32c$var$feature("mathematicalExtras", "mathematicalGreek"),
  // nalt: not enough info. what type of annotation?
  // ornm: ditto, which ornament style?
  calt: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualAlternates"),
  vrt2: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
  vert: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
  tnum: $3b6302b64eccc32c$var$feature("numberSpacing", "monospacedNumbers"),
  pnum: $3b6302b64eccc32c$var$feature("numberSpacing", "proportionalNumbers"),
  sups: $3b6302b64eccc32c$var$feature("verticalPosition", "superiors"),
  subs: $3b6302b64eccc32c$var$feature("verticalPosition", "inferiors"),
  ordn: $3b6302b64eccc32c$var$feature("verticalPosition", "ordinals"),
  pwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
  hwid: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
  qwid: $3b6302b64eccc32c$var$feature("textSpacing", "quarterWidthText"),
  twid: $3b6302b64eccc32c$var$feature("textSpacing", "thirdWidthText"),
  fwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
  palt: $3b6302b64eccc32c$var$feature("textSpacing", "altProportionalText"),
  trad: $3b6302b64eccc32c$var$feature("characterShape", "traditionalCharacters"),
  smpl: $3b6302b64eccc32c$var$feature("characterShape", "simplifiedCharacters"),
  jp78: $3b6302b64eccc32c$var$feature("characterShape", "JIS1978Characters"),
  jp83: $3b6302b64eccc32c$var$feature("characterShape", "JIS1983Characters"),
  jp90: $3b6302b64eccc32c$var$feature("characterShape", "JIS1990Characters"),
  jp04: $3b6302b64eccc32c$var$feature("characterShape", "JIS2004Characters"),
  expt: $3b6302b64eccc32c$var$feature("characterShape", "expertCharacters"),
  hojo: $3b6302b64eccc32c$var$feature("characterShape", "hojoCharacters"),
  nlck: $3b6302b64eccc32c$var$feature("characterShape", "NLCCharacters"),
  tnam: $3b6302b64eccc32c$var$feature("characterShape", "traditionalNamesCharacters"),
  ruby: $3b6302b64eccc32c$var$feature("rubyKana", "rubyKana"),
  titl: $3b6302b64eccc32c$var$feature("styleOptions", "titlingCaps"),
  zero: $3b6302b64eccc32c$var$feature("typographicExtras", "slashedZero"),
  ss01: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltOne"),
  ss02: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwo"),
  ss03: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThree"),
  ss04: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFour"),
  ss05: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFive"),
  ss06: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSix"),
  ss07: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeven"),
  ss08: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEight"),
  ss09: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNine"),
  ss10: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTen"),
  ss11: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEleven"),
  ss12: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwelve"),
  ss13: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThirteen"),
  ss14: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFourteen"),
  ss15: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFifteen"),
  ss16: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSixteen"),
  ss17: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeventeen"),
  ss18: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEighteen"),
  ss19: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNineteen"),
  ss20: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwenty")
};
for (let i = 1; i <= 99; i++) $3b6302b64eccc32c$var$OTMapping[`cv${`00${i}`.slice(-2)}`] = [
  $3b6302b64eccc32c$var$features.characterAlternatives.code,
  i
];
var $3b6302b64eccc32c$var$AATMapping = {};
for (let ot in $3b6302b64eccc32c$var$OTMapping) {
  let aat = $3b6302b64eccc32c$var$OTMapping[ot];
  if ($3b6302b64eccc32c$var$AATMapping[aat[0]] == null) $3b6302b64eccc32c$var$AATMapping[aat[0]] = {};
  $3b6302b64eccc32c$var$AATMapping[aat[0]][aat[1]] = ot;
}
function $3b6302b64eccc32c$export$b813f7d2a1677c16(features1) {
  let res = {};
  for (let k in features1) {
    let r;
    if (r = $3b6302b64eccc32c$var$OTMapping[k]) {
      if (res[r[0]] == null) res[r[0]] = {};
      res[r[0]][r[1]] = features1[k];
    }
  }
  return res;
}
function $3b6302b64eccc32c$var$mapFeatureStrings(f) {
  let [type2, setting] = f;
  if (isNaN(type2)) var typeCode = $3b6302b64eccc32c$var$features[type2] && $3b6302b64eccc32c$var$features[type2].code;
  else var typeCode = type2;
  if (isNaN(setting)) var settingCode = $3b6302b64eccc32c$var$features[type2] && $3b6302b64eccc32c$var$features[type2][setting];
  else var settingCode = setting;
  return [
    typeCode,
    settingCode
  ];
}
function $3b6302b64eccc32c$export$bd6df347a4f391c4(features2) {
  let res = {};
  if (Array.isArray(features2)) for (let k = 0; k < features2.length; k++) {
    let r;
    let f = $3b6302b64eccc32c$var$mapFeatureStrings(features2[k]);
    if (r = $3b6302b64eccc32c$var$AATMapping[f[0]] && $3b6302b64eccc32c$var$AATMapping[f[0]][f[1]]) res[r] = true;
  }
  else if (typeof features2 === "object") for (let type2 in features2) {
    let feature1 = features2[type2];
    for (let setting in feature1) {
      let r;
      let f = $3b6302b64eccc32c$var$mapFeatureStrings([
        type2,
        setting
      ]);
      if (feature1[setting] && (r = $3b6302b64eccc32c$var$AATMapping[f[0]] && $3b6302b64eccc32c$var$AATMapping[f[0]][f[1]])) res[r] = true;
    }
  }
  return Object.keys(res);
}
var $ff5ce077dae0f144$export$2e2bcd8739ae039 = class {
  lookup(glyph) {
    switch (this.table.version) {
      case 0:
        return this.table.values.getItem(glyph);
      case 2:
      case 4: {
        let min3 = 0;
        let max3 = this.table.binarySearchHeader.nUnits - 1;
        while (min3 <= max3) {
          var mid = min3 + max3 >> 1;
          var seg = this.table.segments[mid];
          if (seg.firstGlyph === 65535) return null;
          if (glyph < seg.firstGlyph) max3 = mid - 1;
          else if (glyph > seg.lastGlyph) min3 = mid + 1;
          else {
            if (this.table.version === 2) return seg.value;
            else return seg.values[glyph - seg.firstGlyph];
          }
        }
        return null;
      }
      case 6: {
        let min3 = 0;
        let max3 = this.table.binarySearchHeader.nUnits - 1;
        while (min3 <= max3) {
          var mid = min3 + max3 >> 1;
          var seg = this.table.segments[mid];
          if (seg.glyph === 65535) return null;
          if (glyph < seg.glyph) max3 = mid - 1;
          else if (glyph > seg.glyph) min3 = mid + 1;
          else return seg.value;
        }
        return null;
      }
      case 8:
        return this.table.values[glyph - this.table.firstGlyph];
      default:
        throw new Error(`Unknown lookup table format: ${this.table.version}`);
    }
  }
  glyphsForValue(classValue) {
    let res = [];
    switch (this.table.version) {
      case 2:
      case 4:
        for (let segment of this.table.segments) if (this.table.version === 2 && segment.value === classValue) res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(segment.firstGlyph, segment.lastGlyph + 1));
        else {
          for (let index2 = 0; index2 < segment.values.length; index2++) if (segment.values[index2] === classValue) res.push(segment.firstGlyph + index2);
        }
        break;
      case 6:
        for (let segment1 of this.table.segments) if (segment1.value === classValue) res.push(segment1.glyph);
        break;
      case 8:
        for (let i = 0; i < this.table.values.length; i++) if (this.table.values[i] === classValue) res.push(this.table.firstGlyph + i);
        break;
      default:
        throw new Error(`Unknown lookup table format: ${this.table.version}`);
    }
    return res;
  }
  constructor(table) {
    this.table = table;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $ff5ce077dae0f144$export$2e2bcd8739ae039.prototype, "glyphsForValue", null);
var $50c7aac9316f2948$var$START_OF_TEXT_STATE = 0;
var $50c7aac9316f2948$var$END_OF_TEXT_CLASS = 0;
var $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS = 1;
var $50c7aac9316f2948$var$DELETED_GLYPH_CLASS = 2;
var $50c7aac9316f2948$var$DONT_ADVANCE = 16384;
var $50c7aac9316f2948$export$2e2bcd8739ae039 = class {
  process(glyphs, reverse5, processEntry) {
    let currentState = $50c7aac9316f2948$var$START_OF_TEXT_STATE;
    let index2 = reverse5 ? glyphs.length - 1 : 0;
    let dir = reverse5 ? -1 : 1;
    while (dir === 1 && index2 <= glyphs.length || dir === -1 && index2 >= -1) {
      let glyph = null;
      let classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
      let shouldAdvance = true;
      if (index2 === glyphs.length || index2 === -1) classCode = $50c7aac9316f2948$var$END_OF_TEXT_CLASS;
      else {
        glyph = glyphs[index2];
        if (glyph.id === 65535) classCode = $50c7aac9316f2948$var$DELETED_GLYPH_CLASS;
        else {
          classCode = this.lookupTable.lookup(glyph.id);
          if (classCode == null) classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
        }
      }
      let row = this.stateTable.stateArray.getItem(currentState);
      let entryIndex = row[classCode];
      let entry = this.stateTable.entryTable.getItem(entryIndex);
      if (classCode !== $50c7aac9316f2948$var$END_OF_TEXT_CLASS && classCode !== $50c7aac9316f2948$var$DELETED_GLYPH_CLASS) {
        processEntry(glyph, entry, index2);
        shouldAdvance = !(entry.flags & $50c7aac9316f2948$var$DONT_ADVANCE);
      }
      currentState = entry.newState;
      if (shouldAdvance) index2 += dir;
    }
    return glyphs;
  }
  /**
  * Performs a depth-first traversal of the glyph strings
  * represented by the state machine.
  */
  traverse(opts2, state2 = 0, visited = /* @__PURE__ */ new Set()) {
    if (visited.has(state2)) return;
    visited.add(state2);
    let { nClasses, stateArray, entryTable } = this.stateTable;
    let row = stateArray.getItem(state2);
    for (let classCode = 4; classCode < nClasses; classCode++) {
      let entryIndex = row[classCode];
      let entry = entryTable.getItem(entryIndex);
      for (let glyph of this.lookupTable.glyphsForValue(classCode)) {
        if (opts2.enter) opts2.enter(glyph, entry);
        if (entry.newState !== 0) this.traverse(opts2, entry.newState, visited);
        if (opts2.exit) opts2.exit(glyph, entry);
      }
    }
  }
  constructor(stateTable) {
    this.stateTable = stateTable;
    this.lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(stateTable.classTable);
  }
};
var $55f71433a605c87d$var$MARK_FIRST = 32768;
var $55f71433a605c87d$var$MARK_LAST = 8192;
var $55f71433a605c87d$var$VERB = 15;
var $55f71433a605c87d$var$SET_MARK = 32768;
var $55f71433a605c87d$var$SET_COMPONENT = 32768;
var $55f71433a605c87d$var$PERFORM_ACTION = 8192;
var $55f71433a605c87d$var$LAST_MASK = 2147483648;
var $55f71433a605c87d$var$STORE_MASK = 1073741824;
var $55f71433a605c87d$var$OFFSET_MASK = 1073741823;
var $55f71433a605c87d$var$REVERSE_DIRECTION = 4194304;
var $55f71433a605c87d$var$CURRENT_INSERT_BEFORE = 2048;
var $55f71433a605c87d$var$MARKED_INSERT_BEFORE = 1024;
var $55f71433a605c87d$var$CURRENT_INSERT_COUNT = 992;
var $55f71433a605c87d$var$MARKED_INSERT_COUNT = 31;
var $55f71433a605c87d$export$2e2bcd8739ae039 = class {
  // Processes an array of glyphs and applies the specified features
  // Features should be in the form of {featureType:{featureSetting:boolean}}
  process(glyphs, features = {}) {
    for (let chain of this.morx.chains) {
      let flags = chain.defaultFlags;
      for (let feature of chain.features) {
        let f;
        if (f = features[feature.featureType]) {
          if (f[feature.featureSetting]) {
            flags &= feature.disableFlags;
            flags |= feature.enableFlags;
          } else if (f[feature.featureSetting] === false) {
            flags |= ~feature.disableFlags;
            flags &= ~feature.enableFlags;
          }
        }
      }
      for (let subtable of chain.subtables) if (subtable.subFeatureFlags & flags) this.processSubtable(subtable, glyphs);
    }
    let index2 = glyphs.length - 1;
    while (index2 >= 0) {
      if (glyphs[index2].id === 65535) glyphs.splice(index2, 1);
      index2--;
    }
    return glyphs;
  }
  processSubtable(subtable, glyphs) {
    this.subtable = subtable;
    this.glyphs = glyphs;
    if (this.subtable.type === 4) {
      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
      return;
    }
    this.ligatureStack = [];
    this.markedGlyph = null;
    this.firstGlyph = null;
    this.lastGlyph = null;
    this.markedIndex = null;
    let stateMachine = this.getStateMachine(subtable);
    let process2 = this.getProcessor();
    let reverse5 = !!(this.subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
    return stateMachine.process(this.glyphs, reverse5, process2);
  }
  getStateMachine(subtable) {
    return new (0, $50c7aac9316f2948$export$2e2bcd8739ae039)(subtable.table.stateTable);
  }
  getProcessor() {
    switch (this.subtable.type) {
      case 0:
        return this.processIndicRearragement;
      case 1:
        return this.processContextualSubstitution;
      case 2:
        return this.processLigature;
      case 4:
        return this.processNoncontextualSubstitutions;
      case 5:
        return this.processGlyphInsertion;
      default:
        throw new Error(`Invalid morx subtable type: ${this.subtable.type}`);
    }
  }
  processIndicRearragement(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$MARK_FIRST) this.firstGlyph = index2;
    if (entry.flags & $55f71433a605c87d$var$MARK_LAST) this.lastGlyph = index2;
    $55f71433a605c87d$var$reorderGlyphs(this.glyphs, entry.flags & $55f71433a605c87d$var$VERB, this.firstGlyph, this.lastGlyph);
  }
  processContextualSubstitution(glyph, entry, index2) {
    let subsitutions = this.subtable.table.substitutionTable.items;
    if (entry.markIndex !== 65535) {
      let lookup4 = subsitutions.getItem(entry.markIndex);
      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup4);
      glyph = this.glyphs[this.markedGlyph];
      var gid = lookupTable.lookup(glyph.id);
      if (gid) this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);
    }
    if (entry.currentIndex !== 65535) {
      let lookup4 = subsitutions.getItem(entry.currentIndex);
      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup4);
      glyph = this.glyphs[index2];
      var gid = lookupTable.lookup(glyph.id);
      if (gid) this.glyphs[index2] = this.font.getGlyph(gid, glyph.codePoints);
    }
    if (entry.flags & $55f71433a605c87d$var$SET_MARK) this.markedGlyph = index2;
  }
  processLigature(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$SET_COMPONENT) this.ligatureStack.push(index2);
    if (entry.flags & $55f71433a605c87d$var$PERFORM_ACTION) {
      let actions = this.subtable.table.ligatureActions;
      let components = this.subtable.table.components;
      let ligatureList = this.subtable.table.ligatureList;
      let actionIndex = entry.action;
      let last3 = false;
      let ligatureIndex = 0;
      let codePoints = [];
      let ligatureGlyphs = [];
      while (!last3) {
        let componentGlyph = this.ligatureStack.pop();
        codePoints.unshift(...this.glyphs[componentGlyph].codePoints);
        let action = actions.getItem(actionIndex++);
        last3 = !!(action & $55f71433a605c87d$var$LAST_MASK);
        let store = !!(action & $55f71433a605c87d$var$STORE_MASK);
        let offset3 = (action & $55f71433a605c87d$var$OFFSET_MASK) << 2 >> 2;
        offset3 += this.glyphs[componentGlyph].id;
        let component = components.getItem(offset3);
        ligatureIndex += component;
        if (last3 || store) {
          let ligatureEntry = ligatureList.getItem(ligatureIndex);
          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
          ligatureGlyphs.push(componentGlyph);
          ligatureIndex = 0;
          codePoints = [];
        } else this.glyphs[componentGlyph] = this.font.getGlyph(65535);
      }
      this.ligatureStack.push(...ligatureGlyphs);
    }
  }
  processNoncontextualSubstitutions(subtable, glyphs, index2) {
    let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(subtable.table.lookupTable);
    for (index2 = 0; index2 < glyphs.length; index2++) {
      let glyph = glyphs[index2];
      if (glyph.id !== 65535) {
        let gid = lookupTable.lookup(glyph.id);
        if (gid) glyphs[index2] = this.font.getGlyph(gid, glyph.codePoints);
      }
    }
  }
  _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {
    let insertions = [];
    while (count--) {
      let gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
      insertions.push(this.font.getGlyph(gid));
    }
    if (!isBefore) glyphIndex++;
    this.glyphs.splice(glyphIndex, 0, ...insertions);
  }
  processGlyphInsertion(glyph, entry, index2) {
    if (entry.flags & $55f71433a605c87d$var$SET_MARK) this.markedIndex = index2;
    if (entry.markedInsertIndex !== 65535) {
      let count = (entry.flags & $55f71433a605c87d$var$MARKED_INSERT_COUNT) >>> 5;
      let isBefore = !!(entry.flags & $55f71433a605c87d$var$MARKED_INSERT_BEFORE);
      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);
    }
    if (entry.currentInsertIndex !== 65535) {
      let count = (entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_COUNT) >>> 5;
      let isBefore = !!(entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_BEFORE);
      this._insertGlyphs(index2, entry.currentInsertIndex, count, isBefore);
    }
  }
  getSupportedFeatures() {
    let features = [];
    for (let chain of this.morx.chains) for (let feature of chain.features) features.push([
      feature.featureType,
      feature.featureSetting
    ]);
    return features;
  }
  generateInputs(gid) {
    if (!this.inputCache) this.generateInputCache();
    return this.inputCache[gid] || [];
  }
  generateInputCache() {
    this.inputCache = {};
    for (let chain of this.morx.chains) {
      let flags = chain.defaultFlags;
      for (let subtable of chain.subtables) if (subtable.subFeatureFlags & flags) this.generateInputsForSubtable(subtable);
    }
  }
  generateInputsForSubtable(subtable) {
    if (subtable.type !== 2) return;
    let reverse5 = !!(subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
    if (reverse5) throw new Error("Reverse subtable, not supported.");
    this.subtable = subtable;
    this.ligatureStack = [];
    let stateMachine = this.getStateMachine(subtable);
    let process2 = this.getProcessor();
    let input = [];
    let stack = [];
    this.glyphs = [];
    stateMachine.traverse({
      enter: (glyph, entry) => {
        let glyphs = this.glyphs;
        stack.push({
          glyphs: glyphs.slice(),
          ligatureStack: this.ligatureStack.slice()
        });
        let g1 = this.font.getGlyph(glyph);
        input.push(g1);
        glyphs.push(input[input.length - 1]);
        process2(glyphs[glyphs.length - 1], entry, glyphs.length - 1);
        let count = 0;
        let found = 0;
        for (let i = 0; i < glyphs.length && count <= 1; i++) if (glyphs[i].id !== 65535) {
          count++;
          found = glyphs[i].id;
        }
        if (count === 1) {
          let result = input.map((g) => g.id);
          let cache1 = this.inputCache[found];
          if (cache1) cache1.push(result);
          else this.inputCache[found] = [
            result
          ];
        }
      },
      exit: () => {
        ({ glyphs: this.glyphs, ligatureStack: this.ligatureStack } = stack.pop());
        input.pop();
      }
    });
  }
  constructor(font2) {
    this.processIndicRearragement = this.processIndicRearragement.bind(this);
    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);
    this.processLigature = this.processLigature.bind(this);
    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);
    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);
    this.font = font2;
    this.morx = font2.morx;
    this.inputCache = null;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $55f71433a605c87d$export$2e2bcd8739ae039.prototype, "getStateMachine", null);
function $55f71433a605c87d$var$swap(glyphs, rangeA, rangeB, reverseA = false, reverseB = false) {
  let end3 = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
  if (reverseB) end3.reverse();
  let start3 = glyphs.splice(rangeA[0], rangeA[1], ...end3);
  if (reverseA) start3.reverse();
  glyphs.splice(rangeB[0] - (rangeA[1] - 1), 0, ...start3);
  return glyphs;
}
function $55f71433a605c87d$var$reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {
  let length4 = lastGlyph - firstGlyph + 1;
  switch (verb) {
    case 0:
      return glyphs;
    case 1:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        0
      ]);
    case 2:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        1
      ]);
    case 3:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        1
      ]);
    case 4:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        0
      ]);
    case 5:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        0
      ], true, false);
    case 6:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        2
      ]);
    case 7:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        2
      ], false, true);
    case 8:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        2
      ]);
    case 9:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        2
      ], false, true);
    case 10:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        1
      ]);
    case 11:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        1
      ], true, false);
    case 12:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ]);
    case 13:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], true, false);
    case 14:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], false, true);
    case 15:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], true, true);
    default:
      throw new Error(`Unknown verb: ${verb}`);
  }
}
var $ba6dd74203be8728$export$2e2bcd8739ae039 = class {
  substitute(glyphRun) {
    if (glyphRun.direction === "rtl") glyphRun.glyphs.reverse();
    this.morxProcessor.process(glyphRun.glyphs, $3b6302b64eccc32c$export$b813f7d2a1677c16(glyphRun.features));
  }
  getAvailableFeatures(script, language) {
    return $3b6302b64eccc32c$export$bd6df347a4f391c4(this.morxProcessor.getSupportedFeatures());
  }
  stringsForGlyph(gid) {
    let glyphStrings = this.morxProcessor.generateInputs(gid);
    let result = /* @__PURE__ */ new Set();
    for (let glyphs of glyphStrings) this._addStrings(glyphs, 0, result, "");
    return result;
  }
  _addStrings(glyphs, index2, strings, string) {
    let codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index2]);
    for (let codePoint of codePoints) {
      let s2 = string + String.fromCodePoint(codePoint);
      if (index2 < glyphs.length - 1) this._addStrings(glyphs, index2 + 1, strings, s2);
      else strings.add(s2);
    }
  }
  constructor(font2) {
    this.font = font2;
    this.morxProcessor = new (0, $55f71433a605c87d$export$2e2bcd8739ae039)(font2);
    this.fallbackPosition = false;
  }
};
var $94d7a73bd2edfc9a$export$2e2bcd8739ae039 = class {
  /**
  * Adds the given features to the last stage.
  * Ignores features that have already been applied.
  */
  _addFeatures(features, global2) {
    let stageIndex = this.stages.length - 1;
    let stage = this.stages[stageIndex];
    for (let feature of features) if (this.allFeatures[feature] == null) {
      stage.push(feature);
      this.allFeatures[feature] = stageIndex;
      if (global2) this.globalFeatures[feature] = true;
    }
  }
  /**
  * Add features to the last stage
  */
  add(arg, global2 = true) {
    if (this.stages.length === 0) this.stages.push([]);
    if (typeof arg === "string") arg = [
      arg
    ];
    if (Array.isArray(arg)) this._addFeatures(arg, global2);
    else if (typeof arg === "object") {
      this._addFeatures(arg.global || [], true);
      this._addFeatures(arg.local || [], false);
    } else throw new Error("Unsupported argument to ShapingPlan#add");
  }
  /**
  * Add a new stage
  */
  addStage(arg, global2) {
    if (typeof arg === "function") this.stages.push(arg, []);
    else {
      this.stages.push([]);
      this.add(arg, global2);
    }
  }
  setFeatureOverrides(features) {
    if (Array.isArray(features)) this.add(features);
    else if (typeof features === "object") for (let tag in features) {
      if (features[tag]) this.add(tag);
      else if (this.allFeatures[tag] != null) {
        let stage = this.stages[this.allFeatures[tag]];
        stage.splice(stage.indexOf(tag), 1);
        delete this.allFeatures[tag];
        delete this.globalFeatures[tag];
      }
    }
  }
  /**
  * Assigns the global features to the given glyphs
  */
  assignGlobalFeatures(glyphs) {
    for (let glyph of glyphs) for (let feature in this.globalFeatures) glyph.features[feature] = true;
  }
  /**
  * Executes the planned stages using the given OTProcessor
  */
  process(processor, glyphs, positions) {
    for (let stage of this.stages) {
      if (typeof stage === "function") {
        if (!positions) stage(this.font, glyphs, this);
      } else if (stage.length > 0) processor.applyFeatures(stage, glyphs, positions);
    }
  }
  constructor(font2, script, direction) {
    this.font = font2;
    this.script = script;
    this.direction = direction;
    this.stages = [];
    this.globalFeatures = {};
    this.allFeatures = {};
  }
};
var $649970d87335b30f$var$VARIATION_FEATURES = [
  "rvrn"
];
var $649970d87335b30f$var$COMMON_FEATURES = [
  "ccmp",
  "locl",
  "rlig",
  "mark",
  "mkmk"
];
var $649970d87335b30f$var$FRACTIONAL_FEATURES = [
  "frac",
  "numr",
  "dnom"
];
var $649970d87335b30f$var$HORIZONTAL_FEATURES = [
  "calt",
  "clig",
  "liga",
  "rclt",
  "curs",
  "kern"
];
var $649970d87335b30f$var$DIRECTIONAL_FEATURES = {
  ltr: [
    "ltra",
    "ltrm"
  ],
  rtl: [
    "rtla",
    "rtlm"
  ]
};
var $649970d87335b30f$export$2e2bcd8739ae039 = class {
  static plan(plan, glyphs, features) {
    this.planPreprocessing(plan);
    this.planFeatures(plan);
    this.planPostprocessing(plan, features);
    plan.assignGlobalFeatures(glyphs);
    this.assignFeatures(plan, glyphs);
  }
  static planPreprocessing(plan) {
    plan.add({
      global: [
        ...$649970d87335b30f$var$VARIATION_FEATURES,
        ...$649970d87335b30f$var$DIRECTIONAL_FEATURES[plan.direction]
      ],
      local: $649970d87335b30f$var$FRACTIONAL_FEATURES
    });
  }
  static planFeatures(plan) {
  }
  static planPostprocessing(plan, userFeatures) {
    plan.add([
      ...$649970d87335b30f$var$COMMON_FEATURES,
      ...$649970d87335b30f$var$HORIZONTAL_FEATURES
    ]);
    plan.setFeatureOverrides(userFeatures);
  }
  static assignFeatures(plan, glyphs) {
    for (let i = 0; i < glyphs.length; i++) {
      let glyph = glyphs[i];
      if (glyph.codePoints[0] === 8260) {
        let start3 = i;
        let end3 = i + 1;
        while (start3 > 0 && (0, $747425b437e121da$export$727d9dbc4fbb948f)(glyphs[start3 - 1].codePoints[0])) {
          glyphs[start3 - 1].features.numr = true;
          glyphs[start3 - 1].features.frac = true;
          start3--;
        }
        while (end3 < glyphs.length && (0, $747425b437e121da$export$727d9dbc4fbb948f)(glyphs[end3].codePoints[0])) {
          glyphs[end3].features.dnom = true;
          glyphs[end3].features.frac = true;
          end3++;
        }
        glyph.features.frac = true;
        i = end3 - 1;
      }
    }
  }
};
(0, _define_property)($649970d87335b30f$export$2e2bcd8739ae039, "zeroMarkWidths", "AFTER_GPOS");
var $764eb544bbe1ccf0$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("ABABAAAAAACgMQAAAZUBav7t2CtPA0EUBeDZB00pin9AJZIEgyUEj0QhweDAgQOJxCBRBElQSBwSicLgkOAwnNKZ5GaY2c7uzj4o5yZfZrrbefbuIx2nSq3CGmzAWH/+K+UO7MIe7MMhHMMpnMMFXMIVXIt2t3CnP088iPqjqNN8e4Ij7Rle4LUH82rLm6i/92A+RERERERERERNmfz/89GDeRARERERzbN8ceps2Iwt9H0C9/AJ6yOlDkbTczcot5VSm8Pm1vcFWfb7+BKOLTuOd2UlTX4wGP85Eg953lWPFbnuN7PkjtLmalOWbNenkHOSa7T3KmR9MVTZ2zZkVj1kHa68MueVKH0R4zqQ44WEXLM8VjcWHP0PtKLfPzQnMtGn3W4QYf6qxFxceVI394r2xnV+1rih0fV1Vzf3fO1n3evL5J78ruvZ5ptX2Rwy92Tfb1wlEqut3U+sZ3HXOeJ7/zDrbyuP6+Zz0fqa6Nv3vhY7Yu1xWnGevmsvsUpTT/RYIe8waUH/rvHMWKFzLfN8L+rTfp645mfX7ftlnfDtYxN59w0="));
var $764eb544bbe1ccf0$var$FEATURES = [
  "isol",
  "fina",
  "fin2",
  "fin3",
  "medi",
  "med2",
  "init"
];
var $764eb544bbe1ccf0$var$ShapingClasses = {
  Non_Joining: 0,
  Left_Joining: 1,
  Right_Joining: 2,
  Dual_Joining: 3,
  Join_Causing: 3,
  ALAPH: 4,
  "DALATH RISH": 5,
  Transparent: 6
};
var $764eb544bbe1ccf0$var$ISOL = "isol";
var $764eb544bbe1ccf0$var$FINA = "fina";
var $764eb544bbe1ccf0$var$FIN2 = "fin2";
var $764eb544bbe1ccf0$var$FIN3 = "fin3";
var $764eb544bbe1ccf0$var$MEDI = "medi";
var $764eb544bbe1ccf0$var$MED2 = "med2";
var $764eb544bbe1ccf0$var$INIT = "init";
var $764eb544bbe1ccf0$var$NONE = null;
var $764eb544bbe1ccf0$var$STATE_TABLE = [
  //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH
  // State 0: prev was U,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 1: prev was R or ISOL/ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 2: prev was D/L in ISOL form,  willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      1
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      3
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      4
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      6
    ]
  ],
  // State 3: prev was D in FINA form,  willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      1
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      3
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      4
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      6
    ]
  ],
  // State 4: prev was FINA ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 6: prev was DALATH/RISH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$FIN3,
      5
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ]
];
var $764eb544bbe1ccf0$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.add([
      "ccmp",
      "locl"
    ]);
    for (let i = 0; i < $764eb544bbe1ccf0$var$FEATURES.length; i++) {
      let feature = $764eb544bbe1ccf0$var$FEATURES[i];
      plan.addStage(feature, false);
    }
    plan.addStage("mset");
  }
  static assignFeatures(plan, glyphs) {
    super.assignFeatures(plan, glyphs);
    let prev = -1;
    let state2 = 0;
    let actions = [];
    for (let i = 0; i < glyphs.length; i++) {
      let curAction, prevAction;
      var glyph = glyphs[i];
      let type2 = $764eb544bbe1ccf0$var$getShapingClass(glyph.codePoints[0]);
      if (type2 === $764eb544bbe1ccf0$var$ShapingClasses.Transparent) {
        actions[i] = $764eb544bbe1ccf0$var$NONE;
        continue;
      }
      [prevAction, curAction, state2] = $764eb544bbe1ccf0$var$STATE_TABLE[state2][type2];
      if (prevAction !== $764eb544bbe1ccf0$var$NONE && prev !== -1) actions[prev] = prevAction;
      actions[i] = curAction;
      prev = i;
    }
    for (let index2 = 0; index2 < glyphs.length; index2++) {
      let feature;
      var glyph = glyphs[index2];
      if (feature = actions[index2]) glyph.features[feature] = true;
    }
  }
};
function $764eb544bbe1ccf0$var$getShapingClass(codePoint) {
  let res = $764eb544bbe1ccf0$var$trie.get(codePoint);
  if (res) return res - 1;
  let category = (0, $747425b437e121da$export$410364bbb673ddbc)(codePoint);
  if (category === "Mn" || category === "Me" || category === "Cf") return $764eb544bbe1ccf0$var$ShapingClasses.Transparent;
  return $764eb544bbe1ccf0$var$ShapingClasses.Non_Joining;
}
var $85d408632270248b$export$2e2bcd8739ae039 = class {
  reset(options = {}, index2 = 0) {
    this.options = options;
    this.flags = options.flags || {};
    this.markAttachmentType = options.markAttachmentType || 0;
    this.index = index2;
  }
  get cur() {
    return this.glyphs[this.index] || null;
  }
  shouldIgnore(glyph) {
    return this.flags.ignoreMarks && glyph.isMark || this.flags.ignoreBaseGlyphs && glyph.isBase || this.flags.ignoreLigatures && glyph.isLigature || this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType;
  }
  move(dir) {
    this.index += dir;
    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) this.index += dir;
    if (0 > this.index || this.index >= this.glyphs.length) return null;
    return this.glyphs[this.index];
  }
  next() {
    return this.move(1);
  }
  prev() {
    return this.move(-1);
  }
  peek(count = 1) {
    let idx = this.index;
    let res = this.increment(count);
    this.index = idx;
    return res;
  }
  peekIndex(count = 1) {
    let idx = this.index;
    this.increment(count);
    let res = this.index;
    this.index = idx;
    return res;
  }
  increment(count = 1) {
    let dir = count < 0 ? -1 : 1;
    count = Math.abs(count);
    while (count--) this.move(dir);
    return this.glyphs[this.index];
  }
  constructor(glyphs, options) {
    this.glyphs = glyphs;
    this.reset(options);
  }
};
var $a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS = [
  "DFLT",
  "dflt",
  "latn"
];
var $a83b9c36aaa94fd3$export$2e2bcd8739ae039 = class {
  findScript(script) {
    if (this.table.scriptList == null) return null;
    if (!Array.isArray(script)) script = [
      script
    ];
    for (let s2 of script) for (let entry of this.table.scriptList) {
      if (entry.tag === s2) return entry;
    }
    return null;
  }
  selectScript(script, language, direction) {
    let changed = false;
    let entry;
    if (!this.script || script !== this.scriptTag) {
      entry = this.findScript(script);
      if (!entry) entry = this.findScript($a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS);
      if (!entry) return this.scriptTag;
      this.scriptTag = entry.tag;
      this.script = entry.script;
      this.language = null;
      this.languageTag = null;
      changed = true;
    }
    if (!direction || direction !== this.direction) this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
    if (language && language.length < 4) language += " ".repeat(4 - language.length);
    if (!language || language !== this.languageTag) {
      this.language = null;
      for (let lang of this.script.langSysRecords) if (lang.tag === language) {
        this.language = lang.langSys;
        this.languageTag = lang.tag;
        break;
      }
      if (!this.language) {
        this.language = this.script.defaultLangSys;
        this.languageTag = null;
      }
      changed = true;
    }
    if (changed) {
      this.features = {};
      if (this.language) for (let featureIndex of this.language.featureIndexes) {
        let record = this.table.featureList[featureIndex];
        let substituteFeature = this.substituteFeatureForVariations(featureIndex);
        this.features[record.tag] = substituteFeature || record.feature;
      }
    }
    return this.scriptTag;
  }
  lookupsForFeatures(userFeatures = [], exclude) {
    let lookups = [];
    for (let tag of userFeatures) {
      let feature = this.features[tag];
      if (!feature) continue;
      for (let lookupIndex of feature.lookupListIndexes) {
        if (exclude && exclude.indexOf(lookupIndex) !== -1) continue;
        lookups.push({
          feature: tag,
          index: lookupIndex,
          lookup: this.table.lookupList.get(lookupIndex)
        });
      }
    }
    lookups.sort((a2, b) => a2.index - b.index);
    return lookups;
  }
  substituteFeatureForVariations(featureIndex) {
    if (this.variationsIndex === -1) return null;
    let record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];
    let substitutions = record.featureTableSubstitution.substitutions;
    for (let substitution of substitutions) {
      if (substitution.featureIndex === featureIndex) return substitution.alternateFeatureTable;
    }
    return null;
  }
  findVariationsIndex(coords) {
    let variations = this.table.featureVariations;
    if (!variations) return -1;
    let records = variations.featureVariationRecords;
    for (let i = 0; i < records.length; i++) {
      let conditions = records[i].conditionSet.conditionTable;
      if (this.variationConditionsMatch(conditions, coords)) return i;
    }
    return -1;
  }
  variationConditionsMatch(conditions, coords) {
    return conditions.every((condition) => {
      let coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;
      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;
    });
  }
  applyFeatures(userFeatures, glyphs, advances) {
    let lookups = this.lookupsForFeatures(userFeatures);
    this.applyLookups(lookups, glyphs, advances);
  }
  applyLookups(lookups, glyphs, positions) {
    this.glyphs = glyphs;
    this.positions = positions;
    this.glyphIterator = new (0, $85d408632270248b$export$2e2bcd8739ae039)(glyphs);
    for (let { feature, lookup: lookup4 } of lookups) {
      this.currentFeature = feature;
      this.glyphIterator.reset(lookup4.flags);
      while (this.glyphIterator.index < glyphs.length) {
        if (!(feature in this.glyphIterator.cur.features)) {
          this.glyphIterator.next();
          continue;
        }
        for (let table of lookup4.subTables) {
          let res = this.applyLookup(lookup4.lookupType, table);
          if (res) break;
        }
        this.glyphIterator.next();
      }
    }
  }
  applyLookup(lookup4, table) {
    throw new Error("applyLookup must be implemented by subclasses");
  }
  applyLookupList(lookupRecords) {
    let options = this.glyphIterator.options;
    let glyphIndex = this.glyphIterator.index;
    for (let lookupRecord of lookupRecords) {
      this.glyphIterator.reset(options, glyphIndex);
      this.glyphIterator.increment(lookupRecord.sequenceIndex);
      let lookup4 = this.table.lookupList.get(lookupRecord.lookupListIndex);
      this.glyphIterator.reset(lookup4.flags, this.glyphIterator.index);
      for (let table of lookup4.subTables) {
        if (this.applyLookup(lookup4.lookupType, table)) break;
      }
    }
    this.glyphIterator.reset(options, glyphIndex);
    return true;
  }
  coverageIndex(coverage, glyph) {
    if (glyph == null) glyph = this.glyphIterator.cur.id;
    switch (coverage.version) {
      case 1:
        return coverage.glyphs.indexOf(glyph);
      case 2:
        for (let range3 of coverage.rangeRecords) {
          if (range3.start <= glyph && glyph <= range3.end) return range3.startCoverageIndex + glyph - range3.start;
        }
        break;
    }
    return -1;
  }
  match(sequenceIndex, sequence, fn, matched) {
    let pos = this.glyphIterator.index;
    let glyph = this.glyphIterator.increment(sequenceIndex);
    let idx = 0;
    while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {
      if (matched) matched.push(this.glyphIterator.index);
      idx++;
      glyph = this.glyphIterator.next();
    }
    this.glyphIterator.index = pos;
    if (idx < sequence.length) return false;
    return matched || true;
  }
  sequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (component, glyph) => component === glyph.id);
  }
  sequenceMatchIndices(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (component, glyph) => {
      if (!(this.currentFeature in glyph.features)) return false;
      return component === glyph.id;
    }, []);
  }
  coverageSequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (coverage, glyph) => this.coverageIndex(coverage, glyph.id) >= 0);
  }
  getClassID(glyph, classDef) {
    switch (classDef.version) {
      case 1:
        let i = glyph - classDef.startGlyph;
        if (i >= 0 && i < classDef.classValueArray.length) return classDef.classValueArray[i];
        break;
      case 2:
        for (let range3 of classDef.classRangeRecord) {
          if (range3.start <= glyph && glyph <= range3.end) return range3.class;
        }
        break;
    }
    return 0;
  }
  classSequenceMatches(sequenceIndex, sequence, classDef) {
    return this.match(sequenceIndex, sequence, (classID, glyph) => classID === this.getClassID(glyph.id, classDef));
  }
  applyContext(table) {
    let index2, set5;
    switch (table.version) {
      case 1:
        index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        set5 = table.ruleSets[index2];
        for (let rule of set5) {
          if (this.sequenceMatches(1, rule.input)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 2:
        if (this.coverageIndex(table.coverage) === -1) return false;
        index2 = this.getClassID(this.glyphIterator.cur.id, table.classDef);
        if (index2 === -1) return false;
        set5 = table.classSet[index2];
        for (let rule1 of set5) {
          if (this.classSequenceMatches(1, rule1.classes, table.classDef)) return this.applyLookupList(rule1.lookupRecords);
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(0, table.coverages)) return this.applyLookupList(table.lookupRecords);
        break;
    }
    return false;
  }
  applyChainingContext(table) {
    let index2;
    switch (table.version) {
      case 1:
        index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        let set5 = table.chainRuleSets[index2];
        for (let rule of set5) {
          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 2:
        if (this.coverageIndex(table.coverage) === -1) return false;
        index2 = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);
        let rules = table.chainClassSet[index2];
        if (!rules) return false;
        for (let rule2 of rules) {
          if (this.classSequenceMatches(-rule2.backtrack.length, rule2.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, rule2.input, table.inputClassDef) && this.classSequenceMatches(1 + rule2.input.length, rule2.lookahead, table.lookaheadClassDef)) return this.applyLookupList(rule2.lookupRecords);
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) return this.applyLookupList(table.lookupRecords);
        break;
    }
    return false;
  }
  constructor(font2, table) {
    this.font = font2;
    this.table = table;
    this.script = null;
    this.scriptTag = null;
    this.language = null;
    this.languageTag = null;
    this.features = {};
    this.lookups = {};
    this.variationsIndex = font2._variationProcessor ? this.findVariationsIndex(font2._variationProcessor.normalizedCoords) : -1;
    this.selectScript();
    this.glyphs = [];
    this.positions = [];
    this.ligatureID = 1;
    this.currentFeature = null;
  }
};
var $10e7b257e1a9a756$export$2e2bcd8739ae039 = class _$10e7b257e1a9a756$export$2e2bcd8739ae039 {
  get id() {
    return this._id;
  }
  set id(id) {
    this._id = id;
    this.substituted = true;
    let GDEF = this._font.GDEF;
    if (GDEF && GDEF.glyphClassDef) {
      let classID = (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.glyphClassDef);
      this.isBase = classID === 1;
      this.isLigature = classID === 2;
      this.isMark = classID === 3;
      this.markAttachmentType = GDEF.markAttachClassDef ? (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.markAttachClassDef) : 0;
    } else {
      this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $747425b437e121da$export$e33ad6871e762338));
      this.isBase = !this.isMark;
      this.isLigature = this.codePoints.length > 1;
      this.markAttachmentType = 0;
    }
  }
  copy() {
    return new _$10e7b257e1a9a756$export$2e2bcd8739ae039(this._font, this.id, this.codePoints, this.features);
  }
  constructor(font2, id, codePoints = [], features) {
    this._font = font2;
    this.codePoints = codePoints;
    this.id = id;
    this.features = {};
    if (Array.isArray(features)) for (let i = 0; i < features.length; i++) {
      let feature = features[i];
      this.features[feature] = true;
    }
    else if (typeof features === "object") Object.assign(this.features, features);
    this.ligatureID = null;
    this.ligatureComponent = null;
    this.isLigated = false;
    this.cursiveAttachment = null;
    this.markAttachment = null;
    this.shaperInfo = null;
    this.substituted = false;
    this.isMultiplied = false;
  }
};
var $e1c6bbc8cb416f8c$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.add([
      "ljmo",
      "vjmo",
      "tjmo"
    ], false);
  }
  static assignFeatures(plan, glyphs) {
    let state2 = 0;
    let i = 0;
    while (i < glyphs.length) {
      let action;
      let glyph = glyphs[i];
      let code = glyph.codePoints[0];
      let type2 = $e1c6bbc8cb416f8c$var$getType(code);
      [action, state2] = $e1c6bbc8cb416f8c$var$STATE_TABLE[state2][type2];
      switch (action) {
        case $e1c6bbc8cb416f8c$var$DECOMPOSE:
          if (!plan.font.hasGlyphForCodePoint(code)) i = $e1c6bbc8cb416f8c$var$decompose(glyphs, i, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$COMPOSE:
          i = $e1c6bbc8cb416f8c$var$compose(glyphs, i, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$TONE_MARK:
          $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$INVALID:
          i = $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i, plan.font);
          break;
      }
      i++;
    }
  }
};
(0, _define_property)($e1c6bbc8cb416f8c$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
var $e1c6bbc8cb416f8c$var$HANGUL_BASE = 44032;
var $e1c6bbc8cb416f8c$var$HANGUL_END = 55204;
var $e1c6bbc8cb416f8c$var$HANGUL_COUNT = $e1c6bbc8cb416f8c$var$HANGUL_END - $e1c6bbc8cb416f8c$var$HANGUL_BASE + 1;
var $e1c6bbc8cb416f8c$var$L_BASE = 4352;
var $e1c6bbc8cb416f8c$var$V_BASE = 4449;
var $e1c6bbc8cb416f8c$var$T_BASE = 4519;
var $e1c6bbc8cb416f8c$var$L_COUNT = 19;
var $e1c6bbc8cb416f8c$var$V_COUNT = 21;
var $e1c6bbc8cb416f8c$var$T_COUNT = 28;
var $e1c6bbc8cb416f8c$var$L_END = $e1c6bbc8cb416f8c$var$L_BASE + $e1c6bbc8cb416f8c$var$L_COUNT - 1;
var $e1c6bbc8cb416f8c$var$V_END = $e1c6bbc8cb416f8c$var$V_BASE + $e1c6bbc8cb416f8c$var$V_COUNT - 1;
var $e1c6bbc8cb416f8c$var$T_END = $e1c6bbc8cb416f8c$var$T_BASE + $e1c6bbc8cb416f8c$var$T_COUNT - 1;
var $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE = 9676;
var $e1c6bbc8cb416f8c$var$isL = (code) => 4352 <= code && code <= 4447 || 43360 <= code && code <= 43388;
var $e1c6bbc8cb416f8c$var$isV = (code) => 4448 <= code && code <= 4519 || 55216 <= code && code <= 55238;
var $e1c6bbc8cb416f8c$var$isT = (code) => 4520 <= code && code <= 4607 || 55243 <= code && code <= 55291;
var $e1c6bbc8cb416f8c$var$isTone = (code) => 12334 <= code && code <= 12335;
var $e1c6bbc8cb416f8c$var$isLVT = (code) => $e1c6bbc8cb416f8c$var$HANGUL_BASE <= code && code <= $e1c6bbc8cb416f8c$var$HANGUL_END;
var $e1c6bbc8cb416f8c$var$isLV = (code) => code - $e1c6bbc8cb416f8c$var$HANGUL_BASE < $e1c6bbc8cb416f8c$var$HANGUL_COUNT && (code - $e1c6bbc8cb416f8c$var$HANGUL_BASE) % $e1c6bbc8cb416f8c$var$T_COUNT === 0;
var $e1c6bbc8cb416f8c$var$isCombiningL = (code) => $e1c6bbc8cb416f8c$var$L_BASE <= code && code <= $e1c6bbc8cb416f8c$var$L_END;
var $e1c6bbc8cb416f8c$var$isCombiningV = (code) => $e1c6bbc8cb416f8c$var$V_BASE <= code && code <= $e1c6bbc8cb416f8c$var$V_END;
var $e1c6bbc8cb416f8c$var$isCombiningT = (code) => $e1c6bbc8cb416f8c$var$T_BASE + 1 && 1 <= code && code <= $e1c6bbc8cb416f8c$var$T_END;
var $e1c6bbc8cb416f8c$var$X = 0;
var $e1c6bbc8cb416f8c$var$L = 1;
var $e1c6bbc8cb416f8c$var$V = 2;
var $e1c6bbc8cb416f8c$var$T = 3;
var $e1c6bbc8cb416f8c$var$LV = 4;
var $e1c6bbc8cb416f8c$var$LVT = 5;
var $e1c6bbc8cb416f8c$var$M = 6;
function $e1c6bbc8cb416f8c$var$getType(code) {
  if ($e1c6bbc8cb416f8c$var$isL(code)) return $e1c6bbc8cb416f8c$var$L;
  if ($e1c6bbc8cb416f8c$var$isV(code)) return $e1c6bbc8cb416f8c$var$V;
  if ($e1c6bbc8cb416f8c$var$isT(code)) return $e1c6bbc8cb416f8c$var$T;
  if ($e1c6bbc8cb416f8c$var$isLV(code)) return $e1c6bbc8cb416f8c$var$LV;
  if ($e1c6bbc8cb416f8c$var$isLVT(code)) return $e1c6bbc8cb416f8c$var$LVT;
  if ($e1c6bbc8cb416f8c$var$isTone(code)) return $e1c6bbc8cb416f8c$var$M;
  return $e1c6bbc8cb416f8c$var$X;
}
var $e1c6bbc8cb416f8c$var$NO_ACTION = 0;
var $e1c6bbc8cb416f8c$var$DECOMPOSE = 1;
var $e1c6bbc8cb416f8c$var$COMPOSE = 2;
var $e1c6bbc8cb416f8c$var$TONE_MARK = 4;
var $e1c6bbc8cb416f8c$var$INVALID = 5;
var $e1c6bbc8cb416f8c$var$STATE_TABLE = [
  //       X                 L                 V                T                  LV                LVT               M
  // State 0: start state
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$INVALID,
      0
    ]
  ],
  // State 1: <L>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$COMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$INVALID,
      0
    ]
  ],
  // State 2: <L,V> or <LV>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$COMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$TONE_MARK,
      0
    ]
  ],
  // State 3: <L,V,T> or <LVT>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$TONE_MARK,
      0
    ]
  ]
];
function $e1c6bbc8cb416f8c$var$getGlyph(font2, code, features) {
  return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font2, font2.glyphForCodePoint(code).id, [
    code
  ], features);
}
function $e1c6bbc8cb416f8c$var$decompose(glyphs, i, font2) {
  let glyph = glyphs[i];
  let code = glyph.codePoints[0];
  let s2 = code - $e1c6bbc8cb416f8c$var$HANGUL_BASE;
  let t2 = $e1c6bbc8cb416f8c$var$T_BASE + s2 % $e1c6bbc8cb416f8c$var$T_COUNT;
  s2 = s2 / $e1c6bbc8cb416f8c$var$T_COUNT | 0;
  let l2 = $e1c6bbc8cb416f8c$var$L_BASE + s2 / $e1c6bbc8cb416f8c$var$V_COUNT | 0;
  let v2 = $e1c6bbc8cb416f8c$var$V_BASE + s2 % $e1c6bbc8cb416f8c$var$V_COUNT;
  if (!font2.hasGlyphForCodePoint(l2) || !font2.hasGlyphForCodePoint(v2) || t2 !== $e1c6bbc8cb416f8c$var$T_BASE && !font2.hasGlyphForCodePoint(t2)) return i;
  let ljmo = $e1c6bbc8cb416f8c$var$getGlyph(font2, l2, glyph.features);
  ljmo.features.ljmo = true;
  let vjmo = $e1c6bbc8cb416f8c$var$getGlyph(font2, v2, glyph.features);
  vjmo.features.vjmo = true;
  let insert3 = [
    ljmo,
    vjmo
  ];
  if (t2 > $e1c6bbc8cb416f8c$var$T_BASE) {
    let tjmo = $e1c6bbc8cb416f8c$var$getGlyph(font2, t2, glyph.features);
    tjmo.features.tjmo = true;
    insert3.push(tjmo);
  }
  glyphs.splice(i, 1, ...insert3);
  return i + insert3.length - 1;
}
function $e1c6bbc8cb416f8c$var$compose(glyphs, i, font2) {
  let glyph = glyphs[i];
  let code = glyphs[i].codePoints[0];
  let type2 = $e1c6bbc8cb416f8c$var$getType(code);
  let prev = glyphs[i - 1].codePoints[0];
  let prevType = $e1c6bbc8cb416f8c$var$getType(prev);
  let lv, ljmo, vjmo, tjmo;
  if (prevType === $e1c6bbc8cb416f8c$var$LV && type2 === $e1c6bbc8cb416f8c$var$T) {
    lv = prev;
    tjmo = glyph;
  } else {
    if (type2 === $e1c6bbc8cb416f8c$var$V) {
      ljmo = glyphs[i - 1];
      vjmo = glyph;
    } else {
      ljmo = glyphs[i - 2];
      vjmo = glyphs[i - 1];
      tjmo = glyph;
    }
    let l2 = ljmo.codePoints[0];
    let v2 = vjmo.codePoints[0];
    if ($e1c6bbc8cb416f8c$var$isCombiningL(l2) && $e1c6bbc8cb416f8c$var$isCombiningV(v2)) lv = $e1c6bbc8cb416f8c$var$HANGUL_BASE + ((l2 - $e1c6bbc8cb416f8c$var$L_BASE) * $e1c6bbc8cb416f8c$var$V_COUNT + (v2 - $e1c6bbc8cb416f8c$var$V_BASE)) * $e1c6bbc8cb416f8c$var$T_COUNT;
  }
  let t2 = tjmo && tjmo.codePoints[0] || $e1c6bbc8cb416f8c$var$T_BASE;
  if (lv != null && (t2 === $e1c6bbc8cb416f8c$var$T_BASE || $e1c6bbc8cb416f8c$var$isCombiningT(t2))) {
    let s2 = lv + (t2 - $e1c6bbc8cb416f8c$var$T_BASE);
    if (font2.hasGlyphForCodePoint(s2)) {
      let del = prevType === $e1c6bbc8cb416f8c$var$V ? 3 : 2;
      glyphs.splice(i - del + 1, del, $e1c6bbc8cb416f8c$var$getGlyph(font2, s2, glyph.features));
      return i - del + 1;
    }
  }
  if (ljmo) ljmo.features.ljmo = true;
  if (vjmo) vjmo.features.vjmo = true;
  if (tjmo) tjmo.features.tjmo = true;
  if (prevType === $e1c6bbc8cb416f8c$var$LV) {
    $e1c6bbc8cb416f8c$var$decompose(glyphs, i - 1, font2);
    return i + 1;
  }
  return i;
}
function $e1c6bbc8cb416f8c$var$getLength(code) {
  switch ($e1c6bbc8cb416f8c$var$getType(code)) {
    case $e1c6bbc8cb416f8c$var$LV:
    case $e1c6bbc8cb416f8c$var$LVT:
      return 1;
    case $e1c6bbc8cb416f8c$var$V:
      return 2;
    case $e1c6bbc8cb416f8c$var$T:
      return 3;
  }
}
function $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i, font2) {
  let glyph = glyphs[i];
  let code = glyphs[i].codePoints[0];
  if (font2.glyphForCodePoint(code).advanceWidth === 0) return;
  let prev = glyphs[i - 1].codePoints[0];
  let len = $e1c6bbc8cb416f8c$var$getLength(prev);
  glyphs.splice(i, 1);
  return glyphs.splice(i - len, 0, glyph);
}
function $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i, font2) {
  let glyph = glyphs[i];
  let code = glyphs[i].codePoints[0];
  if (font2.hasGlyphForCodePoint($e1c6bbc8cb416f8c$var$DOTTED_CIRCLE)) {
    let dottedCircle = $e1c6bbc8cb416f8c$var$getGlyph(font2, $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE, glyph.features);
    let idx = font2.glyphForCodePoint(code).advanceWidth === 0 ? i : i + 1;
    glyphs.splice(idx, 0, dottedCircle);
    i++;
  }
  return i;
}
var $4b0735ca6c692ea5$exports = {};
$4b0735ca6c692ea5$exports = JSON.parse('{"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,14,15,16,17],[0,0,0,18,19,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,28,29,30,31,32,33,0,34,0,0,35,36,0,0,37,0],[0,0,0,38,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,39,0,0,0,40,41,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,12,43,0,0,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,0,43,0,0,0,0],[0,0,0,45,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,50,0,0,51,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,0],[0,0,0,53,54,55,56,57,58,0,59,0,0,60,61,0,0,62,0],[0,0,0,4,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,63,64,0,0,40,41,0,9,0,10,0,0,0,42,0,63,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,0,2,16,0],[0,0,0,18,65,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,0,0],[0,0,0,69,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,73,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,75,0,0,0,76,77,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,25,79,0,0,0,0],[0,0,0,18,19,20,74,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,81,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,86,0,0,87,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,0],[0,0,0,18,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,89,90,0,0,76,77,0,23,0,24,0,0,0,78,0,89,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,0,0],[0,0,0,94,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,96,0,0,0,97,98,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,35,100,0,0,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,102,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,107,0,0,108,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,109,0,0,0,0,0,0,0,0],[0,0,0,28,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,110,111,0,0,97,98,0,33,0,34,0,0,0,99,0,110,0,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,0,0],[0,0,0,0,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,0,0,115,116,117,118,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,39,0,122,0,123,123,8,9,0,10,0,0,0,42,0,39,0,0],[0,124,64,0,0,0,0,0,0,0,0,0,0,0,0,0,124,0,0],[0,39,0,0,0,121,125,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,126,126,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,47,47,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,128,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,129,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,50,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,134,0,0,0,0,0,0,0,0],[0,0,0,135,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,136,0,0,0,137,138,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,60,140,0,0,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,0,140,0,0,0,0],[0,0,0,142,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,147,0,0,148,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,149,0,0,0,0,0,0,0,0],[0,0,0,53,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,150,151,0,0,137,138,0,58,0,59,0,0,0,139,0,150,0,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,0,0],[0,0,0,155,116,156,157,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,75,3,4,5,159,160,8,161,0,162,0,11,12,163,0,75,16,0],[0,0,0,0,0,40,164,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,0,165,0,0,0,0],[0,124,64,0,0,40,164,0,9,0,10,0,0,0,42,0,124,0,0],[0,0,0,0,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,167,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,168,0,0,0,0,0,0,0,0],[0,0,0,0,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,0,79,0,0,0,0],[0,0,0,169,170,171,172,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,75,0,176,0,177,177,22,23,0,24,0,0,0,78,0,75,0,0],[0,178,90,0,0,0,0,0,0,0,0,0,0,0,0,0,178,0,0],[0,75,0,0,0,175,179,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,180,180,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,83,83,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,182,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,183,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,86,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,188,0,0,0,0,0,0,0,0],[0,0,0,189,170,190,191,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,76,193,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,0,194,0,0,0,0],[0,178,90,0,0,76,193,0,23,0,24,0,0,0,78,0,178,0,0],[0,0,0,0,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,195,196,197,198,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,96,0,202,0,203,203,32,33,0,34,0,0,0,99,0,96,0,0],[0,204,111,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0],[0,96,0,0,0,201,205,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,206,206,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,104,104,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,208,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,209,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,107,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,0,0,0],[0,0,0,215,196,216,217,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,97,219,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,0,220,0,0,0,0],[0,204,111,0,0,97,219,0,33,0,34,0,0,0,99,0,204,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,223,0,0,0,40,224,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,119,225,0,0,0,0],[0,0,0,115,116,117,222,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,115,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,226,64,0,0,40,224,0,9,0,10,0,0,0,42,0,226,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,39,0,0,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,44,44,8,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,227,0,228,229,0,9,0,10,0,0,230,0,0,0,0,0],[0,39,0,122,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,231,231,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,131,131,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,234,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,235,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,0,0,240,241,242,243,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,136,0,247,0,248,248,57,58,0,59,0,0,0,139,0,136,0,0],[0,249,151,0,0,0,0,0,0,0,0,0,0,0,0,0,249,0,0],[0,136,0,0,0,246,250,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,251,251,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,144,144,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,253,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,254,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,147,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,259,0,0,0,0,0,0,0,0],[0,0,0,260,241,261,262,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,137,264,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,0,265,0,0,0,0],[0,249,151,0,0,137,264,0,58,0,59,0,0,0,139,0,249,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,158,225,0,0,0,0],[0,0,0,155,116,156,222,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,155,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,43,266,266,8,161,0,24,0,0,12,267,0,0,0,0],[0,75,0,176,43,268,268,269,161,0,24,0,0,0,267,0,75,0,0],[0,0,0,0,0,270,0,0,271,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,272,0,0,0,0,0,0,0,0],[0,273,274,0,0,40,41,0,9,0,10,0,0,0,42,0,273,0,0],[0,0,0,40,0,123,123,8,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,121,275,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,276,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,279,0,0,0,76,280,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,173,281,0,0,0,0],[0,0,0,169,170,171,278,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,169,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,282,90,0,0,76,280,0,23,0,24,0,0,0,78,0,282,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,75,0,0,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,80,80,22,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,283,0,284,285,0,23,0,24,0,0,286,0,0,0,0,0],[0,75,0,176,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,287,287,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,288,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,185,185,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,290,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,291,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,192,281,0,0,0,0],[0,0,0,189,170,190,278,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,189,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,76,0,177,177,22,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,175,296,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,299,0,0,0,97,300,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,199,301,0,0,0,0],[0,0,0,195,196,197,298,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,195,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,302,111,0,0,97,300,0,33,0,34,0,0,0,99,0,302,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,96,0,0,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,101,101,32,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,303,0,304,305,0,33,0,34,0,0,306,0,0,0,0,0],[0,96,0,202,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,307,307,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,308,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,211,211,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,310,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,311,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,218,301,0,0,0,0],[0,0,0,215,196,216,298,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,215,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,97,0,203,203,32,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,201,316,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,0,225,0,0,0,0],[0,0,0,317,318,319,320,8,9,0,10,0,0,321,322,0,0,16,0],[0,223,0,323,0,123,123,8,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,0,0,121,324,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,325,318,326,327,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,64,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,230,0,0,0,0,0],[0,0,0,227,0,228,121,0,9,0,10,0,0,230,0,0,0,0,0],[0,0,0,227,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,0,0],[0,0,0,0,0,329,329,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,330,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,237,237,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,332,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,333,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,337,0,0,0,137,338,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,244,339,0,0,0,0],[0,0,0,240,241,242,336,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,240,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,340,151,0,0,137,338,0,58,0,59,0,0,0,139,0,340,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,136,0,0,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,141,141,57,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,341,0,342,343,0,58,0,59,0,0,344,0,0,0,0,0],[0,136,0,247,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,345,345,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,346,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,256,256,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,348,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,349,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,263,339,0,0,0,0],[0,0,0,260,241,261,336,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,260,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,137,0,248,248,57,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,246,354,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,126,126,8,23,0,0,0,0,0,0,0,0,0,0],[0,355,90,0,0,121,125,0,9,0,10,0,0,0,42,0,355,0,0],[0,0,0,0,0,356,356,269,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,357,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,270,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,363,0,0,0,0,0,0,0,0],[0,0,0,364,116,365,366,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,40,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,0,281,0,0,0,0],[0,0,0,369,370,371,372,22,23,0,24,0,0,373,374,0,0,27,0],[0,279,0,375,0,177,177,22,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,0,0,175,376,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,377,370,378,379,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,90,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,286,0,0,0,0,0],[0,0,0,283,0,284,175,0,23,0,24,0,0,286,0,0,0,0,0],[0,0,0,283,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,82,0,0],[0,0,0,0,0,381,381,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,382,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,293,293,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,384,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,385,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,76,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,0,301,0,0,0,0],[0,0,0,387,388,389,390,32,33,0,34,0,0,391,392,0,0,37,0],[0,299,0,393,0,203,203,32,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,0,0,201,394,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,395,388,396,397,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,111,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,306,0,0,0,0,0],[0,0,0,303,0,304,201,0,33,0,34,0,0,306,0,0,0,0,0],[0,0,0,303,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,0,0],[0,0,0,0,0,399,399,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,400,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,313,313,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,402,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,403,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,97,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,407,0,0,0,40,408,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,321,409,0,0,0,0],[0,0,0,317,318,319,406,8,9,0,10,0,0,321,322,0,0,16,0],[0,0,0,317,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,410,64,0,0,40,408,0,9,0,10,0,0,0,42,0,410,0,0],[0,223,0,0,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,323,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,328,409,0,0,0,0],[0,0,0,325,318,326,406,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,325,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,0,0,0,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0],[0,0,0,0,0,411,411,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,412,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,413,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,0,339,0,0,0,0],[0,0,0,414,415,416,417,57,58,0,59,0,0,418,419,0,0,62,0],[0,337,0,420,0,248,248,57,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,0,0,246,421,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,422,415,423,424,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,151,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,344,0,0,0,0,0],[0,0,0,341,0,342,246,0,58,0,59,0,0,344,0,0,0,0,0],[0,0,0,341,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,143,0,0],[0,0,0,0,0,426,426,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,427,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,351,351,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,429,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,430,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,137,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,432,116,433,434,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,0,0,180,180,269,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,359,359,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,437,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,438,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,443,274,0,0,0,0,0,0,0,0,0,0,0,0,0,443,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,367,225,0,0,0,0],[0,0,0,364,116,365,445,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,364,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,448,0,0,0,76,449,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,373,450,0,0,0,0],[0,0,0,369,370,371,447,22,23,0,24,0,0,373,374,0,0,27,0],[0,0,0,369,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,451,90,0,0,76,449,0,23,0,24,0,0,0,78,0,451,0,0],[0,279,0,0,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,375,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,380,450,0,0,0,0],[0,0,0,377,370,378,447,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,377,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,0,0,0,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,184,0,0],[0,0,0,0,0,452,452,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,453,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,454,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,457,0,0,0,97,458,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,391,459,0,0,0,0],[0,0,0,387,388,389,456,32,33,0,34,0,0,391,392,0,0,37,0],[0,0,0,387,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,460,111,0,0,97,458,0,33,0,34,0,0,0,99,0,460,0,0],[0,299,0,0,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,393,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,398,459,0,0,0,0],[0,0,0,395,388,396,456,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,395,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,0,0,0,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,210,0,0],[0,0,0,0,0,461,461,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,462,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,463,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,0,409,0,0,0,0],[0,0,0,464,465,466,467,8,9,0,10,0,0,468,469,0,0,16,0],[0,407,0,470,0,123,123,8,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,0,0,121,471,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,472,465,473,474,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,0,0,0,0,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,236,0,0],[0,0,0,0,0,0,476,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,479,0,0,0,137,480,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,418,481,0,0,0,0],[0,0,0,414,415,416,478,57,58,0,59,0,0,418,419,0,0,62,0],[0,0,0,414,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,482,151,0,0,137,480,0,58,0,59,0,0,0,139,0,482,0,0],[0,337,0,0,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,420,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,425,481,0,0,0,0],[0,0,0,422,415,423,478,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,422,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,0,0,0,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0],[0,0,0,0,0,483,483,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,484,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,485,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,435,225,0,0,0,0],[0,0,0,432,116,433,445,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,432,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,486,486,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,487,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,440,440,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,489,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,490,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,495,0,496,497,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,0,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,0,225,0,0,0,0],[0,0,0,0,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,0,450,0,0,0,0],[0,0,0,499,500,501,502,22,23,0,24,0,0,503,504,0,0,27,0],[0,448,0,505,0,177,177,22,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,0,0,175,506,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,507,500,508,509,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,0,0,0,0,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,292,0,0],[0,0,0,0,0,0,511,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,0,459,0,0,0,0],[0,0,0,512,513,514,515,32,33,0,34,0,0,516,517,0,0,37,0],[0,457,0,518,0,203,203,32,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,0,0,201,519,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,520,513,521,522,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,0,0,0,0,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,312,0,0],[0,0,0,0,0,0,524,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,527,0,0,0,40,528,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,468,529,0,0,0,0],[0,0,0,464,465,466,526,8,9,0,10,0,0,468,469,0,0,16,0],[0,0,0,464,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,530,64,0,0,40,528,0,9,0,10,0,0,0,42,0,530,0,0],[0,407,0,0,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,470,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,475,529,0,0,0,0],[0,0,0,472,465,473,526,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,472,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0],[0,0,0,0,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,0,481,0,0,0,0],[0,0,0,531,532,533,534,57,58,0,59,0,0,535,536,0,0,62,0],[0,479,0,537,0,248,248,57,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,0,0,246,538,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,539,532,540,541,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,0,0,0,0,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,350,0,0],[0,0,0,0,0,0,543,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,358,0,0],[0,0,0,0,0,544,544,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,545,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,492,492,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,547,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,548,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,274,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,498,0,0,0,0,0],[0,0,0,495,0,496,368,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,495,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,553,0,0,0,76,554,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,503,555,0,0,0,0],[0,0,0,499,500,501,552,22,23,0,24,0,0,503,504,0,0,27,0],[0,0,0,499,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,556,90,0,0,76,554,0,23,0,24,0,0,0,78,0,556,0,0],[0,448,0,0,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,505,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,510,555,0,0,0,0],[0,0,0,507,500,508,552,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,507,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,76,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,559,0,0,0,97,560,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,516,561,0,0,0,0],[0,0,0,512,513,514,558,32,33,0,34,0,0,516,517,0,0,37,0],[0,0,0,512,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,562,111,0,0,97,560,0,33,0,34,0,0,0,99,0,562,0,0],[0,457,0,0,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,518,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,523,561,0,0,0,0],[0,0,0,520,513,521,558,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,520,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,0,0],[0,0,0,0,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,0,529,0,0,0,0],[0,0,0,563,66,564,565,8,9,0,10,0,0,566,68,0,0,16,0],[0,527,0,567,0,123,123,8,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,0,0,121,568,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,569,66,570,571,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,575,0,0,0,137,576,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,535,577,0,0,0,0],[0,0,0,531,532,533,574,57,58,0,59,0,0,535,536,0,0,62,0],[0,0,0,531,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,578,151,0,0,137,576,0,58,0,59,0,0,0,139,0,578,0,0],[0,479,0,0,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,537,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,542,577,0,0,0,0],[0,0,0,539,532,540,574,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,539,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,137,0,0],[0,0,0,0,0,0,0,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,439,0,0],[0,0,0,0,0,579,579,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,580,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,581,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,0,555,0,0,0,0],[0,0,0,582,91,583,584,22,23,0,24,0,0,585,93,0,0,27,0],[0,553,0,586,0,177,177,22,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,0,0,175,587,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,588,91,589,590,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,0,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,0,561,0,0,0,0],[0,0,0,592,112,593,594,32,33,0,34,0,0,595,114,0,0,37,0],[0,559,0,596,0,203,203,32,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,0,0,201,597,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,598,112,599,600,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,566,165,0,0,0,0],[0,0,0,563,66,564,67,8,9,0,10,0,0,566,68,0,0,16,0],[0,0,0,563,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,527,0,0,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,567,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,572,165,0,0,0,0],[0,0,0,569,66,570,67,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,569,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,0,577,0,0,0,0],[0,0,0,603,152,604,605,57,58,0,59,0,0,606,154,0,0,62,0],[0,575,0,607,0,248,248,57,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,0,0,246,608,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,609,152,610,611,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,0,0,0,0,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,491,0,0],[0,0,0,0,0,0,613,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,585,194,0,0,0,0],[0,0,0,582,91,583,92,22,23,0,24,0,0,585,93,0,0,27,0],[0,0,0,582,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,553,0,0,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,586,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,591,194,0,0,0,0],[0,0,0,588,91,589,92,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,588,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,595,220,0,0,0,0],[0,0,0,592,112,593,113,32,33,0,34,0,0,595,114,0,0,37,0],[0,0,0,592,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,559,0,0,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,596,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,601,220,0,0,0,0],[0,0,0,598,112,599,113,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,598,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,606,265,0,0,0,0],[0,0,0,603,152,604,153,57,58,0,59,0,0,606,154,0,0,62,0],[0,0,0,603,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,575,0,0,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,607,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,612,265,0,0,0,0],[0,0,0,609,152,610,153,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,609,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,549,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0]],"accepting":[false,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,false,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,false,false,true,false,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,false,false,true,true,false,false,true,true,true,false,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,false,false,false,false,false,false,false,true,true,false,false,true,true,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,false,true,true,false,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,false,true,true,true,true,true,false,true,true,false,true,true,true],"tags":[[],["broken_cluster"],["consonant_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],[],["broken_cluster"],["symbol_cluster"],[],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["symbol_cluster"],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],[],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],[],[],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],["consonant_syllable"],["vowel_syllable"],["standalone_cluster"]]}');
var $aa333a9607471296$exports = {};
$aa333a9607471296$exports = JSON.parse('{"categories":["O","IND","S","GB","B","FM","CGJ","VMAbv","VMPst","VAbv","VPst","CMBlw","VPre","VBlw","H","VMBlw","CMAbv","MBlw","CS","R","SUB","MPst","MPre","FAbv","FPst","FBlw","SMAbv","SMBlw","VMPre","ZWNJ","ZWJ","WJ","VS","N","HN","MAbv"],"decompositions":{"2507":[2503,2494],"2508":[2503,2519],"2888":[2887,2902],"2891":[2887,2878],"2892":[2887,2903],"3018":[3014,3006],"3019":[3015,3006],"3020":[3014,3031],"3144":[3142,3158],"3264":[3263,3285],"3271":[3270,3285],"3272":[3270,3286],"3274":[3270,3266],"3275":[3270,3266,3285],"3402":[3398,3390],"3403":[3399,3390],"3404":[3398,3415],"3546":[3545,3530],"3548":[3545,3535],"3549":[3545,3535,3530],"3550":[3545,3551],"3635":[3661,3634],"3763":[3789,3762],"3955":[3953,3954],"3957":[3953,3956],"3958":[4018,3968],"3959":[4018,3953,3968],"3960":[4019,3968],"3961":[4019,3953,3968],"3969":[3953,3968],"6971":[6970,6965],"6973":[6972,6965],"6976":[6974,6965],"6977":[6975,6965],"6979":[6978,6965],"69934":[69937,69927],"69935":[69938,69927],"70475":[70471,70462],"70476":[70471,70487],"70843":[70841,70842],"70844":[70841,70832],"70846":[70841,70845],"71098":[71096,71087],"71099":[71097,71087]},"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,3,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,17,18,11,19,20,21,22,0,0,23,0,0,2,0,24,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,27,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,39,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,11,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,49,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,35,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,53,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,54,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0]],"accepting":[false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true],"tags":[[],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["symbol_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["virama_terminated_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["number_joiner_terminated_cluster"],["standard_cluster"],["standard_cluster"],["numeral_cluster"]]}');
var $90a9d3398ee54fe5$export$a513ea61a7bee91c = {
  X: 1,
  C: 2,
  V: 4,
  N: 8,
  H: 16,
  ZWNJ: 32,
  ZWJ: 64,
  M: 128,
  SM: 256,
  VD: 512,
  A: 1024,
  Placeholder: 2048,
  Dotted_Circle: 4096,
  RS: 8192,
  Coeng: 16384,
  Repha: 32768,
  Ra: 65536,
  CM: 131072,
  Symbol: 262144
  // Avagraha, etc that take marks (SM,A,VD).
};
var $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0 = {
  Start: 1,
  Ra_To_Become_Reph: 2,
  Pre_M: 4,
  Pre_C: 8,
  Base_C: 16,
  After_Main: 32,
  Above_C: 64,
  Before_Sub: 128,
  Below_C: 256,
  After_Sub: 512,
  Before_Post: 1024,
  Post_C: 2048,
  After_Post: 4096,
  Final_C: 8192,
  SMVD: 16384,
  End: 32768
};
var $90a9d3398ee54fe5$export$8519deaa7de2b07 = $90a9d3398ee54fe5$export$a513ea61a7bee91c.C | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Ra | $90a9d3398ee54fe5$export$a513ea61a7bee91c.CM | $90a9d3398ee54fe5$export$a513ea61a7bee91c.V | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Placeholder | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Dotted_Circle;
var $90a9d3398ee54fe5$export$bbcd928767338e0d = $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWJ | $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWNJ;
var $90a9d3398ee54fe5$export$ca9599b2a300afc = $90a9d3398ee54fe5$export$a513ea61a7bee91c.H | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Coeng;
var $90a9d3398ee54fe5$export$e99d119da76a0fc5 = {
  Default: {
    hasOldSpec: false,
    virama: 0,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Devanagari: {
    hasOldSpec: true,
    virama: 2381,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Bengali: {
    hasOldSpec: true,
    virama: 2509,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gurmukhi: {
    hasOldSpec: true,
    virama: 2637,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gujarati: {
    hasOldSpec: true,
    virama: 2765,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Oriya: {
    hasOldSpec: true,
    virama: 2893,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Tamil: {
    hasOldSpec: true,
    virama: 3021,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Telugu: {
    hasOldSpec: true,
    virama: 3149,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Explicit",
    blwfMode: "Post_Only"
  },
  Kannada: {
    hasOldSpec: true,
    virama: 3277,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Implicit",
    blwfMode: "Post_Only"
  },
  Malayalam: {
    hasOldSpec: true,
    virama: 3405,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
    rephMode: "Log_Repha",
    blwfMode: "Pre_And_Post"
  },
  // Handled by UniversalShaper
  // Sinhala: {
  //   hasOldSpec: false,
  //   virama: 0x0DCA,
  //   basePos: 'Last_Sinhala',
  //   rephPos: POSITIONS.After_Main,
  //   rephMode: 'Explicit',
  //   blwfMode: 'Pre_And_Post'
  // },
  Khmer: {
    hasOldSpec: false,
    virama: 6098,
    basePos: "First",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Ra_To_Become_Reph,
    rephMode: "Vis_Repha",
    blwfMode: "Pre_And_Post"
  }
};
var $90a9d3398ee54fe5$export$f647c9cfdd77d95a = {
  // Khmer
  6078: [
    6081,
    6078
  ],
  6079: [
    6081,
    6079
  ],
  6080: [
    6081,
    6080
  ],
  6084: [
    6081,
    6084
  ],
  6085: [
    6081,
    6085
  ]
};
var { decompositions: $7826f90f6f0cecc9$var$decompositions } = (0, $parcel$interopDefault2($aa333a9607471296$exports));
var $7826f90f6f0cecc9$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("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"));
var $7826f90f6f0cecc9$var$stateMachine = new (0, import_dfa.default)((0, $parcel$interopDefault2($4b0735ca6c692ea5$exports)));
var $7826f90f6f0cecc9$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.addStage($7826f90f6f0cecc9$var$setupSyllables);
    plan.addStage([
      "locl",
      "ccmp"
    ]);
    plan.addStage($7826f90f6f0cecc9$var$initialReordering);
    plan.addStage("nukt");
    plan.addStage("akhn");
    plan.addStage("rphf", false);
    plan.addStage("rkrf");
    plan.addStage("pref", false);
    plan.addStage("blwf", false);
    plan.addStage("abvf", false);
    plan.addStage("half", false);
    plan.addStage("pstf", false);
    plan.addStage("vatu");
    plan.addStage("cjct");
    plan.addStage("cfar", false);
    plan.addStage($7826f90f6f0cecc9$var$finalReordering);
    plan.addStage({
      local: [
        "init"
      ],
      global: [
        "pres",
        "abvs",
        "blws",
        "psts",
        "haln",
        "dist",
        "abvm",
        "blwm",
        "calt",
        "clig"
      ]
    });
    plan.unicodeScript = $130d1a642ebcd2b7$export$ce50e82f12a827a4(plan.script);
    plan.indicConfig = (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5)[plan.unicodeScript] || (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5).Default;
    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== "2";
  }
  static assignFeatures(plan, glyphs) {
    for (let i = glyphs.length - 1; i >= 0; i--) {
      let codepoint = glyphs[i].codePoints[0];
      let d = (0, $90a9d3398ee54fe5$export$f647c9cfdd77d95a)[codepoint] || $7826f90f6f0cecc9$var$decompositions[codepoint];
      if (d) {
        let decomposed = d.map((c2) => {
          let g = plan.font.glyphForCodePoint(c2);
          return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g.id, [
            c2
          ], glyphs[i].features);
        });
        glyphs.splice(i, 1, ...decomposed);
      }
    }
  }
};
(0, _define_property)($7826f90f6f0cecc9$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
function $7826f90f6f0cecc9$var$indicCategory(glyph) {
  return $7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) >> 8;
}
function $7826f90f6f0cecc9$var$indicPosition(glyph) {
  return 1 << ($7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) & 255);
}
var $7826f90f6f0cecc9$var$IndicInfo = class {
  constructor(category, position, syllableType, syllable) {
    this.category = category;
    this.position = position;
    this.syllableType = syllableType;
    this.syllable = syllable;
  }
};
function $7826f90f6f0cecc9$var$setupSyllables(font2, glyphs) {
  let syllable = 0;
  let last3 = 0;
  for (let [start3, end3, tags2] of $7826f90f6f0cecc9$var$stateMachine.match(glyphs.map($7826f90f6f0cecc9$var$indicCategory))) {
    if (start3 > last3) {
      ++syllable;
      for (let i = last3; i < start3; i++) glyphs[i].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
    }
    ++syllable;
    for (let i = start3; i <= end3; i++) glyphs[i].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(glyphs[i]), $7826f90f6f0cecc9$var$indicPosition(glyphs[i]), tags2[0], syllable);
    last3 = end3 + 1;
  }
  if (last3 < glyphs.length) {
    ++syllable;
    for (let i = last3; i < glyphs.length; i++) glyphs[i].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
  }
}
function $7826f90f6f0cecc9$var$isConsonant(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$8519deaa7de2b07);
}
function $7826f90f6f0cecc9$var$isJoiner(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$bbcd928767338e0d);
}
function $7826f90f6f0cecc9$var$isHalantOrCoeng(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$ca9599b2a300afc);
}
function $7826f90f6f0cecc9$var$wouldSubstitute(glyphs, feature) {
  for (let glyph of glyphs) glyph.features = {
    [feature]: true
  };
  let GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;
  GSUB.applyFeatures([
    feature
  ], glyphs);
  return glyphs.length === 1;
}
function $7826f90f6f0cecc9$var$consonantPosition(font2, consonant, virama) {
  let glyphs = [
    virama,
    consonant,
    virama
  ];
  if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "blwf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "blwf")) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;
  else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pstf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pstf")) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;
  else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pref") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pref")) return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;
  return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
}
function $7826f90f6f0cecc9$var$initialReordering(font2, glyphs, plan) {
  let indicConfig = plan.indicConfig;
  let features = font2._layoutEngine.engine.GSUBProcessor.features;
  let dottedCircle = font2.glyphForCodePoint(9676).id;
  let virama = font2.glyphForCodePoint(indicConfig.virama).id;
  if (virama) {
    let info = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font2, virama, [
      indicConfig.virama
    ]);
    for (let i = 0; i < glyphs.length; i++) if (glyphs[i].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) glyphs[i].shaperInfo.position = $7826f90f6f0cecc9$var$consonantPosition(font2, glyphs[i].copy(), info);
  }
  for (let start3 = 0, end3 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start3 < glyphs.length; start3 = end3, end3 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start3)) {
    let { category, syllableType } = glyphs[start3].shaperInfo;
    if (syllableType === "symbol_cluster" || syllableType === "non_indic_cluster") continue;
    if (syllableType === "broken_cluster" && dottedCircle) {
      let g = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font2, dottedCircle, [
        9676
      ]);
      g.shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(g), $7826f90f6f0cecc9$var$indicPosition(g), glyphs[start3].shaperInfo.syllableType, glyphs[start3].shaperInfo.syllable);
      let i = start3;
      while (i < end3 && glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha) i++;
      glyphs.splice(i++, 0, g);
      end3++;
    }
    let base = end3;
    let limit = start3;
    let hasReph = false;
    if (indicConfig.rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && features.rphf && start3 + 3 <= end3 && (indicConfig.rephMode === "Implicit" && !$7826f90f6f0cecc9$var$isJoiner(glyphs[start3 + 2]) || indicConfig.rephMode === "Explicit" && glyphs[start3 + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {
      let g = [
        glyphs[start3].copy(),
        glyphs[start3 + 1].copy(),
        glyphs[start3 + 2].copy()
      ];
      if ($7826f90f6f0cecc9$var$wouldSubstitute(g.slice(0, 2), "rphf") || indicConfig.rephMode === "Explicit" && $7826f90f6f0cecc9$var$wouldSubstitute(g, "rphf")) {
        limit += 2;
        while (limit < end3 && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit])) limit++;
        base = start3;
        hasReph = true;
      }
    } else if (indicConfig.rephMode === "Log_Repha" && glyphs[start3].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha) {
      limit++;
      while (limit < end3 && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit])) limit++;
      base = start3;
      hasReph = true;
    }
    switch (indicConfig.basePos) {
      case "Last": {
        let i = end3;
        let seenBelow = false;
        do {
          let info = glyphs[--i].shaperInfo;
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i])) {
            if (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C && (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C || seenBelow)) {
              base = i;
              break;
            }
            if (info.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C) seenBelow = true;
            base = i;
          } else if (start3 < i && info.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ && glyphs[i - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) break;
        } while (i > limit);
        break;
      }
      case "First":
        base = start3;
        for (let i = base + 1; i < end3; i++) if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i])) glyphs[i].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;
    }
    if (hasReph && base === start3 && limit - base <= 2) hasReph = false;
    for (let i1 = start3; i1 < base; i1++) {
      let info = glyphs[i1].shaperInfo;
      info.position = Math.min((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_C, info.position);
    }
    if (base < end3) glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
    for (let i2 = base + 1; i2 < end3; i2++) if (glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
      for (let j = i2 + 1; j < end3; j++) if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j])) {
        glyphs[j].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Final_C;
        break;
      }
      break;
    }
    if (hasReph) glyphs[start3].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph;
    if (plan.isOldSpec) {
      let disallowDoubleHalants = plan.unicodeScript !== "Malayalam";
      for (let i = base + 1; i < end3; i++) if (glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) {
        let j;
        for (j = end3 - 1; j > i; j--) {
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j]) || disallowDoubleHalants && glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) break;
        }
        if (glyphs[j].shaperInfo.category !== (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && j > i) {
          let t2 = glyphs[i];
          glyphs.splice(i, 0, ...glyphs.splice(i + 1, j - i));
          glyphs[j] = t2;
        }
        break;
      }
    }
    let lastPos = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Start;
    for (let i3 = start3; i3 < end3; i3++) {
      let info = glyphs[i3].shaperInfo;
      if (info.category & ((0, $90a9d3398ee54fe5$export$bbcd928767338e0d) | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).RS | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).CM | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc) & info.category)) {
        info.position = lastPos;
        if (info.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && info.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          for (let j = i3; j > start3; j--) if (glyphs[j - 1].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
            info.position = glyphs[j - 1].shaperInfo.position;
            break;
          }
        }
      } else if (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) lastPos = info.position;
    }
    let last3 = base;
    for (let i4 = base + 1; i4 < end3; i4++) {
      if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i4])) {
        for (let j = last3 + 1; j < i4; j++) if (glyphs[j].shaperInfo.position < (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) glyphs[j].shaperInfo.position = glyphs[i4].shaperInfo.position;
        last3 = i4;
      } else if (glyphs[i4].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) last3 = i4;
    }
    let arr = glyphs.slice(start3, end3);
    arr.sort((a2, b) => a2.shaperInfo.position - b.shaperInfo.position);
    glyphs.splice(start3, arr.length, ...arr);
    for (let i5 = start3; i5 < end3; i5++) if (glyphs[i5].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {
      base = i5;
      break;
    }
    for (let i6 = start3; i6 < end3 && glyphs[i6].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph; i6++) glyphs[i6].features.rphf = true;
    let blwf = !plan.isOldSpec && indicConfig.blwfMode === "Pre_And_Post";
    for (let i7 = start3; i7 < base; i7++) {
      glyphs[i7].features.half = true;
      if (blwf) glyphs[i7].features.blwf = true;
    }
    for (let i8 = base + 1; i8 < end3; i8++) {
      glyphs[i8].features.abvf = true;
      glyphs[i8].features.pstf = true;
      glyphs[i8].features.blwf = true;
    }
    if (plan.isOldSpec && plan.unicodeScript === "Devanagari") {
      for (let i = start3; i + 1 < base; i++) if (glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Ra && glyphs[i + 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && (i + 1 === base || glyphs[i + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {
        glyphs[i].features.blwf = true;
        glyphs[i + 1].features.blwf = true;
      }
    }
    let prefLen = 2;
    if (features.pref && base + prefLen < end3)
      for (let i9 = base + 1; i9 + prefLen - 1 < end3; i9++) {
        let g = [
          glyphs[i9].copy(),
          glyphs[i9 + 1].copy()
        ];
        if ($7826f90f6f0cecc9$var$wouldSubstitute(g, "pref")) {
          for (let j = 0; j < prefLen; j++) glyphs[i9++].features.pref = true;
          if (features.cfar) for (; i9 < end3; i9++) glyphs[i9].features.cfar = true;
          break;
        }
      }
    for (let i10 = start3 + 1; i10 < end3; i10++) if ($7826f90f6f0cecc9$var$isJoiner(glyphs[i10])) {
      let nonJoiner = glyphs[i10].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWNJ;
      let j = i10;
      do {
        j--;
        if (nonJoiner) delete glyphs[j].features.half;
      } while (j > start3 && !$7826f90f6f0cecc9$var$isConsonant(glyphs[j]));
    }
  }
}
function $7826f90f6f0cecc9$var$finalReordering(font2, glyphs, plan) {
  let indicConfig = plan.indicConfig;
  let features = font2._layoutEngine.engine.GSUBProcessor.features;
  for (let start3 = 0, end3 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start3 < glyphs.length; start3 = end3, end3 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start3)) {
    let tryPref = !!features.pref;
    let base = start3;
    for (; base < end3; base++) if (glyphs[base].shaperInfo.position >= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {
      if (tryPref && base + 1 < end3) {
        for (let i = base + 1; i < end3; i++) if (glyphs[i].features.pref) {
          if (!(glyphs[i].substituted && glyphs[i].isLigated && !glyphs[i].isMultiplied)) {
            base = i;
            while (base < end3 && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[base])) base++;
            glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).BASE_C;
            tryPref = false;
          }
          break;
        }
      }
      if (plan.unicodeScript === "Malayalam") for (let i = base + 1; i < end3; i++) {
        while (i < end3 && $7826f90f6f0cecc9$var$isJoiner(glyphs[i])) i++;
        if (i === end3 || !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[i])) break;
        i++;
        while (i < end3 && $7826f90f6f0cecc9$var$isJoiner(glyphs[i])) i++;
        if (i < end3 && $7826f90f6f0cecc9$var$isConsonant(glyphs[i]) && glyphs[i].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C) {
          base = i;
          glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
        }
      }
      if (start3 < base && glyphs[base].shaperInfo.position > (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) base--;
      break;
    }
    if (base === end3 && start3 < base && glyphs[base - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ) base--;
    if (base < end3) while (start3 < base && glyphs[base].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc))) base--;
    if (start3 + 1 < end3 && start3 < base) {
      let newPos = base === end3 ? base - 2 : base - 1;
      if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
        while (newPos > start3 && !(glyphs[newPos].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc)))) newPos--;
        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          if (newPos + 1 < end3 && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos + 1])) newPos++;
        } else newPos = start3;
      }
      if (start3 < newPos && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
        for (let i = newPos; i > start3; i--) if (glyphs[i - 1].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          let oldPos = i - 1;
          if (oldPos < base && base <= newPos) base--;
          let tmp = glyphs[oldPos];
          glyphs.splice(oldPos, 0, ...glyphs.splice(oldPos + 1, newPos - oldPos));
          glyphs[newPos] = tmp;
          newPos--;
        }
      }
    }
    if (start3 + 1 < end3 && glyphs[start3].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && glyphs[start3].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha !== (glyphs[start3].isLigated && !glyphs[start3].isMultiplied)) {
      let newRephPos;
      let rephPos = indicConfig.rephPos;
      let found = false;
      if (rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post) {
        newRephPos = start3 + 1;
        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) newRephPos++;
        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1])) newRephPos++;
          found = true;
        }
        if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main) {
          newRephPos = base;
          while (newRephPos + 1 < end3 && glyphs[newRephPos + 1].shaperInfo.position <= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main) newRephPos++;
          found = newRephPos < end3;
        }
        if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Sub) {
          newRephPos = base;
          while (newRephPos + 1 < end3 && !(glyphs[newRephPos + 1].shaperInfo.position & ((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD))) newRephPos++;
          found = newRephPos < end3;
        }
      }
      if (!found) {
        newRephPos = start3 + 1;
        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) newRephPos++;
        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1])) newRephPos++;
          found = true;
        }
      }
      if (!found) {
        newRephPos = end3 - 1;
        while (newRephPos > start3 && glyphs[newRephPos].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD) newRephPos--;
        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          for (let i = base + 1; i < newRephPos; i++) if (glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) newRephPos--;
        }
      }
      let reph = glyphs[start3];
      glyphs.splice(start3, 0, ...glyphs.splice(start3 + 1, newRephPos - start3));
      glyphs[newRephPos] = reph;
      if (start3 < base && base <= newRephPos) base--;
    }
    if (tryPref && base + 1 < end3) {
      for (let i = base + 1; i < end3; i++) if (glyphs[i].features.pref) {
        if (glyphs[i].isLigated && !glyphs[i].isMultiplied) {
          let newPos = base;
          if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
            while (newPos > start3 && !(glyphs[newPos - 1].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc)))) newPos--;
            if (newPos > start3 && glyphs[newPos - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
              let oldPos2 = i;
              for (let j = base + 1; j < oldPos2; j++) if (glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
                newPos--;
                break;
              }
            }
          }
          if (newPos > start3 && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos - 1])) {
            if (newPos < end3 && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos])) newPos++;
          }
          let oldPos = i;
          let tmp = glyphs[oldPos];
          glyphs.splice(newPos + 1, 0, ...glyphs.splice(newPos, oldPos - newPos));
          glyphs[newPos] = tmp;
          if (newPos <= base && base < oldPos) base++;
        }
        break;
      }
    }
    if (glyphs[start3].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M && (!start3 || !/Cf|Mn/.test((0, $747425b437e121da$export$410364bbb673ddbc)(glyphs[start3 - 1].codePoints[0])))) glyphs[start3].features.init = true;
  }
}
function $7826f90f6f0cecc9$var$nextSyllable(glyphs, start3) {
  if (start3 >= glyphs.length) return start3;
  let syllable = glyphs[start3].shaperInfo.syllable;
  while (++start3 < glyphs.length && glyphs[start3].shaperInfo.syllable === syllable) ;
  return start3;
}
var { categories: $7ab494fe977143c6$var$categories, decompositions: $7ab494fe977143c6$var$decompositions } = (0, $parcel$interopDefault2($aa333a9607471296$exports));
var $7ab494fe977143c6$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("AAACAAAAAADQqQAAAVEMrvPtnH+oHUcVx+fd99799W5e8mx+9NkYm7YUI2KtimkVDG3FWgVTFY1Fqa2VJirYB0IaUFLBaKGJViXir6oxKCSBoi0UTKtg2yA26h+milYNtMH+0WK1VQyvtBS/487hnncyMzuzu7N7n7kHPszu7OzMmTNzdmdmfzzfUmpiUqkemAMbwSZwKbjcxM1XEL4VvB28G3zAk+56cLMlfgdYADvBbvBF8GWwH9xl+CFLfwj8BPwU/MKS38/AMfA86v9ro9ucQcdR+CjCP4CT4EnwDPg3eAFMTik1A+bAPNgINoFLwGawZSpLfzXCrWAb+AjYDm4BO8FusAfsA/vBXeAgOALuNfv3g4fAcXACPAaeAE+B58Bp8NJUpnN7WqlZsHY629+A8GLwWvAG8BZwJXinOf5ehB8EN4AdYGE6q7dmF9uugs8hvz0V58nZK/L+Kva/BX4ADoN7prP6HgUPgkfA73L0eQzHnwBPgX+Y80+DF8FUW6lBO4tbjXA9uAi8pj3sS2/E9mawBVwNtoJt5pzrTXgzwk+B7awP7sT+7nY6WxFfQBlfAl8H3wU/Anezcu/D9s/BMRN3HOEJ8EdwMkC/J5HmmXZmq2fBIjgEVEepbieLX4Fw0MnSrzRxmrVsm7MB8ReDV4vjr3ekJy7rZGVPMb196Xm6oug83oRyt4CrwDVgK9gGPtzxn3uTOD6YPDPNJ5Hm0+AznazffJ7Z4KSnXncg3VfAN8EBhx42/z/UGdbrx52sr9yH8AFTrt5+2GzfnWPbKuw7ZszZyNh/xowZM2bMmDFjxsQyZ5lPNs3h9nBNYHuAfr9ic9ffiHnsJzznU91/j3P+2snWYf6G8O/gn+A0eMnEt7vQp5ulX4NwHmwEm7rZ8UsRXg6uMPvXIHwPuK7rLl+nu9FzfMyYMWPGpGVuslmarv+YMWPSkNq/d2D8uNDNngvdivA2y3jy9m72bF9v3ymOf2MExp8fG2TsAcfA2wJYBJetWBq3i+0fwPafwLmzSl0LFmZNPMLHZ4fpnsX2AdjgcXB+T6kPge+AG7D/vXYW/tLsc9r9M+MkVyLNR1m6g9g+ZfYvmMExcHCm+ftP0+T5y/e17Uw/PYLwHnC0m80TH+zG30/3mjSDnPS2/B4pUJ4rX3n+b5H3o92l6UjfvZ7y/oJzToGnu8O66XTPYf8/Jr8XWL6TPXf9bPnHtmVs+89AnxVgDVgPLgKvAg+Y/F6H7c1gC7jKHH8XeJ/x15vAjt4wvwVs7wKfBXvAPvA18G1wsJevj36f5gjS3etIq+ft9+PYQ73h/nFsn2D7f+5l75bo/VPYftpTblFb2/Jo2pdjfL0uXOX/qxfnp8vZVk2Xv9hbmu+LxvYt3A/7/WZsPoptPkr9bdCv1ya+d4TuMO8Tre5n4XkILwSbzP4l/WHazX1//r2O/z7cFHnvSYW8R/Vm02ZXIHxHze1Xdf9bbn7p0z2kDroNr2X9WL+7937sX9fP+v9h9n6jTrfI3jG9EfsfN3G35PR/G4uRfY3eMTwdkFa/C3hrf2kcfy/xYTOmprrfZsLbEe7rDPW/U9Rrv9k/ahmTL0cWWxP/YxRkgtES+zwNhZPs+FQgMj/liEsto2HxsZBQX2pZoLZqWc5riXDaQBLSt1L3hcnE+Vct7aYVKCEhbXk2+b7NZ84mmXAwCiL14Ne85S62MYPcXi5StM/YxlJF2lfabznZsC6/C807xvZV+yFve9d1KY//d3HNO8pKUXuTDh0Gpp7B852q6QFMgdWM2dfbAxOuEPQEfcEsO5fquJLZrMfyCtWP0heZF6oSdiH9u4aQvJRIJ/eL6BBynItLp5D2JRkY5L5u3xAf6lviXHWSZcfaKO/+5zvO/c9Xtq8uRXSObd+8bS0zJrS1rxTyX7k/a0nrk5D+mHeOC90uq1Q216X57lykfqHt62uTGJ2rat+i/kttyq/RSi29PlclZf2Xxq55ZeSV34T96d5X5PqZJ9I3ZX2lnkXt3xL1Kyrav/LutbZ6uGxuS6ss6V3pXOXY4kP7EBfyJT7+4TJQS9uf74f6n+3+6ZIi9bCtieatFfCxUMx4KMYfy/pzrB30vm88q9SZ11K+n9eeNN612UFKWX8uI9TmRca7TbWvKy2JvF6naF+b/0uRupZp35cZikhZvyniY2R/CbdB3vXynIC6hbRBHf4l1xps6w4x/lVEtxRtGZMuRA8uNh/jfYV8kdpsBUszcODrD7E2JT2KrB3V6XMhbdNjcXItxzaOJWkpf976/I5glQn1sbLP86U9FQvz4l0S28/lcWUJbbrE2l+Z/TlHvi4/kvZXLMyrmy1PW7x8hl6UFgvlmNM1Jq3aJ3Se0yJcpdwS6mOp/ZgLX5N1rdFKaIzH9ztquMbqq+/qCFRk+hRoyZvrTHuO8fNd/djmEzZJ3TdisN1bNQNl7y96DV/3mVkTtwasVdk1ai6ybGlDek8nT1fXc4M5tVSPvhqOsWQeXQs8L1n3IradU8OxCeVjK7dr7Dpl0cMHnUvt18TzfVsfb/pZY56fV2GnVPVIYaOi9xcZJ8cmKcu3wcuPsVHV5cdKFfZXNZefp5sWft+wzR1cczKCxh99NRx76HvwOpWNv6YZtAajt6WPyPswtVVs/VOJ7xpYx3VR31er7gMxNuV9Q443CDlW43KuYSXblsybfKYt58trfez7A1X7Tdm+V7TcoudL+LpVGf2khN63U5OyD5Af0NoUv06l7Jc0Rte+so4xL9Ayy3Rz+SufY5Jf267xcm7J4dd3kumIOrmk7Pl549bUY1puI91Gdb8Tpu+9tjmhXFdwtfVsTv5SQvXKW0cK4eXgPBO6iJ07NNVOHH7/tF1jyJdnWbrU/Uau3VNI156QZ2ZaZFu76i6vQXy9YJ2H9QZ97aF3p1xlx1yfuYRcd0Kl7NyaX190+pUOKI0tvus5j7/nSWKLo3FER8R3LHEx8gqwge1POgi1l1yfirV3zHpISHxs3vLeFXOellcG1DFGbGP00PPkeKEOaXIsqhzbruOh9Qk5L08nW2grJ0avsvWocv0zRh/fGCG0TV35hB4v0rds5Vddjm/sFCKx+aXSt2yalPZsolxXW46CDnXp0YQ0rdso9OUYPSYT6+yzuxxzlrVfFfavQ/LKqsP+dbVzE/0qRb8pKin6V9U6Fnn24pqHufLMWy90nV+0DkXmcrb0Uq+6pU7/qcs/67SHTeTaaBk9ipyXQvLqW1U7uPKpux/ESlP9umydR8H3UjzHoXxj0/J1Yr5ubHsPrWOJqxK+hk5r+EVtH3pe1XWIXa+1vQ9YJ/oZre1bGReh3xKWeX7BxfYstwh5errGJi59be8482cSsfUPQT4Xlc9K+XMmatcY0fo2+SxYQs/4XO8M03Ng/TxujYH+FRELSdH+6mtveu8itb1Cy7C9X8GfsVOcfN86RHg56wJ0ob5qOz/E/rIdq7YhF34/0cfoeWKVftJjIbWDbDfXeXR/prBOKWJ/3dd43+sr+32TvgEIEZ6/7Zt5/l7ghMm77u+ey4gcz5xfktA5vE9C5vy2Y3lpXeX40tHcLMX42qZHS/ltZluXiSlDxillt3VdIvufbc0j75wy5aWaOxWRUZmfl5nDSh3LzoWbXJOg8uumKkndp1PnH2IPfe+U33z7vjWhdPQuWMh4raqxWMh9X89RZtSZ7/JpyXs3NWQcETN3CZHU/lmVnstZB1+ZfM5A/1VJ2V9t8wTXN1S+f27mzaulbCxJHePwC1Tz/0K1/VdPvtOsba+vL7ZxM1/jakJ/V9/yfdtNx+i7bhVRRll/rrK+sk3qLt/3T0afH+tzz1HDfxzZ/HlGDduK1y/GL21zvKptQGWFSpVlFm0z+ZxD/vdAt9EqQ971NkRHW7qytog53+cfVfeFGLStfddfYka5x6dl+yi//4z6/559aUn4/+/k2pv8BqfM/0qVCnu+If2OJPRZUcyzJF/5RQm5xtM9ln+LRN+8U9+iMQS1Veg9q2z/TlV3Ett3/rLOIXOookidy/5X3GYD+S8a1z2e0vH695T9vhEqdbY//0dU3jWZ2rYq/cvCRT8r08/NLlT5/zySdSurv1ybLiup5tAp5+NNzfPJ5r61warapajItfTQNeK610/rWEMPyb+uOo/ierRNbGU01Z+rqneIPWNsT9t1rD+OYr8rm0eKvp/Ch1P4Yepyy+hWVD/f+VWXX5X+TZdfZZ+KLb9J+S8="));
var $7ab494fe977143c6$var$stateMachine = new (0, import_dfa.default)((0, $parcel$interopDefault2($aa333a9607471296$exports)));
var $7ab494fe977143c6$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.addStage($7ab494fe977143c6$var$setupSyllables);
    plan.addStage([
      "locl",
      "ccmp",
      "nukt",
      "akhn"
    ]);
    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
    plan.addStage([
      "rphf"
    ], false);
    plan.addStage($7ab494fe977143c6$var$recordRphf);
    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
    plan.addStage([
      "pref"
    ]);
    plan.addStage($7ab494fe977143c6$var$recordPref);
    plan.addStage([
      "rkrf",
      "abvf",
      "blwf",
      "half",
      "pstf",
      "vatu",
      "cjct"
    ]);
    plan.addStage($7ab494fe977143c6$var$reorder);
    plan.addStage([
      "abvs",
      "blws",
      "pres",
      "psts",
      "dist",
      "abvm",
      "blwm"
    ]);
  }
  static assignFeatures(plan, glyphs) {
    for (let i = glyphs.length - 1; i >= 0; i--) {
      let codepoint = glyphs[i].codePoints[0];
      if ($7ab494fe977143c6$var$decompositions[codepoint]) {
        let decomposed = $7ab494fe977143c6$var$decompositions[codepoint].map((c2) => {
          let g = plan.font.glyphForCodePoint(c2);
          return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g.id, [
            c2
          ], glyphs[i].features);
        });
        glyphs.splice(i, 1, ...decomposed);
      }
    }
  }
};
(0, _define_property)($7ab494fe977143c6$export$2e2bcd8739ae039, "zeroMarkWidths", "BEFORE_GPOS");
function $7ab494fe977143c6$var$useCategory(glyph) {
  return $7ab494fe977143c6$var$trie.get(glyph.codePoints[0]);
}
var $7ab494fe977143c6$var$USEInfo = class {
  constructor(category, syllableType, syllable) {
    this.category = category;
    this.syllableType = syllableType;
    this.syllable = syllable;
  }
};
function $7ab494fe977143c6$var$setupSyllables(font2, glyphs) {
  let syllable = 0;
  for (let [start3, end3, tags2] of $7ab494fe977143c6$var$stateMachine.match(glyphs.map($7ab494fe977143c6$var$useCategory))) {
    ++syllable;
    for (let i = start3; i <= end3; i++) glyphs[i].shaperInfo = new $7ab494fe977143c6$var$USEInfo($7ab494fe977143c6$var$categories[$7ab494fe977143c6$var$useCategory(glyphs[i])], tags2[0], syllable);
    let limit = glyphs[start3].shaperInfo.category === "R" ? 1 : Math.min(3, end3 - start3);
    for (let i1 = start3; i1 < start3 + limit; i1++) glyphs[i1].features.rphf = true;
  }
}
function $7ab494fe977143c6$var$clearSubstitutionFlags(font2, glyphs) {
  for (let glyph of glyphs) glyph.substituted = false;
}
function $7ab494fe977143c6$var$recordRphf(font2, glyphs) {
  for (let glyph of glyphs) if (glyph.substituted && glyph.features.rphf)
    glyph.shaperInfo.category = "R";
}
function $7ab494fe977143c6$var$recordPref(font2, glyphs) {
  for (let glyph of glyphs) if (glyph.substituted)
    glyph.shaperInfo.category = "VPre";
}
function $7ab494fe977143c6$var$reorder(font2, glyphs) {
  let dottedCircle = font2.glyphForCodePoint(9676).id;
  for (let start3 = 0, end3 = $7ab494fe977143c6$var$nextSyllable(glyphs, 0); start3 < glyphs.length; start3 = end3, end3 = $7ab494fe977143c6$var$nextSyllable(glyphs, start3)) {
    let i, j;
    let info = glyphs[start3].shaperInfo;
    let type2 = info.syllableType;
    if (type2 !== "virama_terminated_cluster" && type2 !== "standard_cluster" && type2 !== "broken_cluster") continue;
    if (type2 === "broken_cluster" && dottedCircle) {
      let g = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font2, dottedCircle, [
        9676
      ]);
      g.shaperInfo = info;
      for (i = start3; i < end3 && glyphs[i].shaperInfo.category === "R"; i++) ;
      glyphs.splice(++i, 0, g);
      end3++;
    }
    if (info.category === "R" && end3 - start3 > 1)
      for (i = start3 + 1; i < end3; i++) {
        info = glyphs[i].shaperInfo;
        if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i])) {
          if ($7ab494fe977143c6$var$isHalant(glyphs[i])) i--;
          glyphs.splice(start3, 0, ...glyphs.splice(start3 + 1, i - start3), glyphs[i]);
          break;
        }
      }
    for (i = start3, j = end3; i < end3; i++) {
      info = glyphs[i].shaperInfo;
      if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i]))
        j = $7ab494fe977143c6$var$isHalant(glyphs[i]) ? i + 1 : i;
      else if ((info.category === "VPre" || info.category === "VMPre") && j < i) glyphs.splice(j, 1, glyphs[i], ...glyphs.splice(j, i - j));
    }
  }
}
function $7ab494fe977143c6$var$nextSyllable(glyphs, start3) {
  if (start3 >= glyphs.length) return start3;
  let syllable = glyphs[start3].shaperInfo.syllable;
  while (++start3 < glyphs.length && glyphs[start3].shaperInfo.syllable === syllable) ;
  return start3;
}
function $7ab494fe977143c6$var$isHalant(glyph) {
  return glyph.shaperInfo.category === "H" && !glyph.isLigated;
}
function $7ab494fe977143c6$var$isBase(info) {
  return info.category === "B" || info.category === "GB";
}
var $102b6fe50f1d50b4$var$SHAPERS = {
  arab: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mong: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  syrc: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  "nko ": (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  phag: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mand: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mani: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  phlp: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  hang: (0, $e1c6bbc8cb416f8c$export$2e2bcd8739ae039),
  bng2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  beng: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  dev2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  deva: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gjr2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gujr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  guru: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gur2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  knda: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  knd2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  mlm2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  mlym: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  ory2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  orya: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  taml: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  tml2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  telu: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  tel2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  khmr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  bali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  batk: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  brah: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  bugi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  buhd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  cakm: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  cham: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  dupl: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  egyp: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  gran: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  hano: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  java: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  kthi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  kali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  khar: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  khoj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sind: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  lepc: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  limb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  mahj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // mand: UniversalShaper, // Mandaic
  // mani: UniversalShaper, // Manichaean
  mtei: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  modi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // mong: UniversalShaper, // Mongolian
  // 'nko ': UniversalShaper, // NKo
  hmng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // phag: UniversalShaper, // Phags-pa
  // phlp: UniversalShaper, // Psalter Pahlavi
  rjng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  saur: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  shrd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sidd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sinh: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  sund: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sylo: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tglg: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tagb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tale: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  lana: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tavt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  takr: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tibt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tfng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tirh: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  latn: (0, $649970d87335b30f$export$2e2bcd8739ae039),
  DFLT: (0, $649970d87335b30f$export$2e2bcd8739ae039)
};
function $102b6fe50f1d50b4$export$7877a478dd30fd3d(script) {
  if (!Array.isArray(script)) script = [
    script
  ];
  for (let s2 of script) {
    let shaper = $102b6fe50f1d50b4$var$SHAPERS[s2];
    if (shaper) return shaper;
  }
  return 0, $649970d87335b30f$export$2e2bcd8739ae039;
}
var $0a876c45f1f7c41c$export$2e2bcd8739ae039 = class extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {
  applyLookup(lookupType, table) {
    switch (lookupType) {
      case 1: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        let glyph = this.glyphIterator.cur;
        switch (table.version) {
          case 1:
            glyph.id = glyph.id + table.deltaGlyphID & 65535;
            break;
          case 2:
            glyph.id = table.substitute.get(index2);
            break;
        }
        return true;
      }
      case 2: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 !== -1) {
          let sequence = table.sequences.get(index2);
          if (sequence.length === 0) {
            this.glyphs.splice(this.glyphIterator.index, 1);
            return true;
          }
          this.glyphIterator.cur.id = sequence[0];
          this.glyphIterator.cur.ligatureComponent = 0;
          let features = this.glyphIterator.cur.features;
          let curGlyph = this.glyphIterator.cur;
          let replacement = sequence.slice(1).map((gid, i) => {
            let glyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, gid, void 0, features);
            glyph.shaperInfo = curGlyph.shaperInfo;
            glyph.isLigated = curGlyph.isLigated;
            glyph.ligatureComponent = i + 1;
            glyph.substituted = true;
            glyph.isMultiplied = true;
            return glyph;
          });
          this.glyphs.splice(this.glyphIterator.index + 1, 0, ...replacement);
          return true;
        }
        return false;
      }
      case 3: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 !== -1) {
          let USER_INDEX = 0;
          this.glyphIterator.cur.id = table.alternateSet.get(index2)[USER_INDEX];
          return true;
        }
        return false;
      }
      case 4: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        for (let ligature of table.ligatureSets.get(index2)) {
          let matched = this.sequenceMatchIndices(1, ligature.components);
          if (!matched) continue;
          let curGlyph = this.glyphIterator.cur;
          let characters2 = curGlyph.codePoints.slice();
          for (let index3 of matched) characters2.push(...this.glyphs[index3].codePoints);
          let ligatureGlyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, ligature.glyph, characters2, curGlyph.features);
          ligatureGlyph.shaperInfo = curGlyph.shaperInfo;
          ligatureGlyph.isLigated = true;
          ligatureGlyph.substituted = true;
          let isMarkLigature = curGlyph.isMark;
          for (let i = 0; i < matched.length && isMarkLigature; i++) isMarkLigature = this.glyphs[matched[i]].isMark;
          ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;
          let lastLigID = curGlyph.ligatureID;
          let lastNumComps = curGlyph.codePoints.length;
          let curComps = lastNumComps;
          let idx = this.glyphIterator.index + 1;
          for (let matchIndex of matched) {
            if (isMarkLigature) idx = matchIndex;
            else while (idx < matchIndex) {
              var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);
              this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;
              this.glyphs[idx].ligatureComponent = ligatureComponent;
              idx++;
            }
            lastLigID = this.glyphs[idx].ligatureID;
            lastNumComps = this.glyphs[idx].codePoints.length;
            curComps += lastNumComps;
            idx++;
          }
          if (lastLigID && !isMarkLigature) for (let i1 = idx; i1 < this.glyphs.length; i1++) {
            if (this.glyphs[i1].ligatureID === lastLigID) {
              var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i1].ligatureComponent || 1, lastNumComps);
              this.glyphs[i1].ligatureComponent = ligatureComponent;
            } else break;
          }
          for (let i2 = matched.length - 1; i2 >= 0; i2--) this.glyphs.splice(matched[i2], 1);
          this.glyphs[this.glyphIterator.index] = ligatureGlyph;
          return true;
        }
        return false;
      }
      case 5:
        return this.applyContext(table);
      case 6:
        return this.applyChainingContext(table);
      case 7:
        return this.applyLookup(table.lookupType, table.extension);
      default:
        throw new Error(`GSUB lookupType ${lookupType} is not supported`);
    }
  }
};
var $c96c93587d49c14d$export$2e2bcd8739ae039 = class extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {
  applyPositionValue(sequenceIndex, value2) {
    let position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];
    if (value2.xAdvance != null) position.xAdvance += value2.xAdvance;
    if (value2.yAdvance != null) position.yAdvance += value2.yAdvance;
    if (value2.xPlacement != null) position.xOffset += value2.xPlacement;
    if (value2.yPlacement != null) position.yOffset += value2.yPlacement;
    let variationProcessor = this.font._variationProcessor;
    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (value2.xPlaDevice) position.xOffset += variationProcessor.getDelta(variationStore, value2.xPlaDevice.a, value2.xPlaDevice.b);
      if (value2.yPlaDevice) position.yOffset += variationProcessor.getDelta(variationStore, value2.yPlaDevice.a, value2.yPlaDevice.b);
      if (value2.xAdvDevice) position.xAdvance += variationProcessor.getDelta(variationStore, value2.xAdvDevice.a, value2.xAdvDevice.b);
      if (value2.yAdvDevice) position.yAdvance += variationProcessor.getDelta(variationStore, value2.yAdvDevice.a, value2.yAdvDevice.b);
    }
  }
  applyLookup(lookupType, table) {
    switch (lookupType) {
      case 1: {
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        switch (table.version) {
          case 1:
            this.applyPositionValue(0, table.value);
            break;
          case 2:
            this.applyPositionValue(0, table.values.get(index2));
            break;
        }
        return true;
      }
      case 2: {
        let nextGlyph = this.glyphIterator.peek();
        if (!nextGlyph) return false;
        let index2 = this.coverageIndex(table.coverage);
        if (index2 === -1) return false;
        switch (table.version) {
          case 1:
            let set5 = table.pairSets.get(index2);
            for (let pair of set5) if (pair.secondGlyph === nextGlyph.id) {
              this.applyPositionValue(0, pair.value1);
              this.applyPositionValue(1, pair.value2);
              return true;
            }
            return false;
          case 2:
            let class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);
            let class2 = this.getClassID(nextGlyph.id, table.classDef2);
            if (class1 === -1 || class2 === -1) return false;
            var pair1 = table.classRecords.get(class1).get(class2);
            this.applyPositionValue(0, pair1.value1);
            this.applyPositionValue(1, pair1.value2);
            return true;
        }
      }
      case 3: {
        let nextIndex = this.glyphIterator.peekIndex();
        let nextGlyph = this.glyphs[nextIndex];
        if (!nextGlyph) return false;
        let curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];
        if (!curRecord || !curRecord.exitAnchor) return false;
        let nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, nextGlyph.id)];
        if (!nextRecord || !nextRecord.entryAnchor) return false;
        let entry = this.getAnchor(nextRecord.entryAnchor);
        let exit = this.getAnchor(curRecord.exitAnchor);
        let cur = this.positions[this.glyphIterator.index];
        let next = this.positions[nextIndex];
        let d;
        switch (this.direction) {
          case "ltr":
            cur.xAdvance = exit.x + cur.xOffset;
            d = entry.x + next.xOffset;
            next.xAdvance -= d;
            next.xOffset -= d;
            break;
          case "rtl":
            d = exit.x + cur.xOffset;
            cur.xAdvance -= d;
            cur.xOffset -= d;
            next.xAdvance = entry.x + next.xOffset;
            break;
        }
        if (this.glyphIterator.flags.rightToLeft) {
          this.glyphIterator.cur.cursiveAttachment = nextIndex;
          cur.yOffset = entry.y - exit.y;
        } else {
          nextGlyph.cursiveAttachment = this.glyphIterator.index;
          cur.yOffset = exit.y - entry.y;
        }
        return true;
      }
      case 4: {
        let markIndex = this.coverageIndex(table.markCoverage);
        if (markIndex === -1) return false;
        let baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0)) ;
        if (baseGlyphIndex < 0) return false;
        let baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);
        if (baseIndex === -1) return false;
        let markRecord = table.markArray[markIndex];
        let baseAnchor = table.baseArray[baseIndex][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 5: {
        let markIndex = this.coverageIndex(table.markCoverage);
        if (markIndex === -1) return false;
        let baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && this.glyphs[baseGlyphIndex].isMark) ;
        if (baseGlyphIndex < 0) return false;
        let ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[baseGlyphIndex].id);
        if (ligIndex === -1) return false;
        let ligAttach = table.ligatureArray[ligIndex];
        let markGlyph = this.glyphIterator.cur;
        let ligGlyph = this.glyphs[baseGlyphIndex];
        let compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;
        let markRecord = table.markArray[markIndex];
        let baseAnchor = ligAttach[compIndex][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 6: {
        let mark1Index = this.coverageIndex(table.mark1Coverage);
        if (mark1Index === -1) return false;
        let prevIndex = this.glyphIterator.peekIndex(-1);
        let prev = this.glyphs[prevIndex];
        if (!prev || !prev.isMark) return false;
        let cur = this.glyphIterator.cur;
        let good = false;
        if (cur.ligatureID === prev.ligatureID) {
          if (!cur.ligatureID) good = true;
          else if (cur.ligatureComponent === prev.ligatureComponent) good = true;
        } else if (cur.ligatureID && !cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent) good = true;
        if (!good) return false;
        let mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);
        if (mark2Index === -1) return false;
        let markRecord = table.mark1Array[mark1Index];
        let baseAnchor = table.mark2Array[mark2Index][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, prevIndex);
        return true;
      }
      case 7:
        return this.applyContext(table);
      case 8:
        return this.applyChainingContext(table);
      case 9:
        return this.applyLookup(table.lookupType, table.extension);
      default:
        throw new Error(`Unsupported GPOS table: ${lookupType}`);
    }
  }
  applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {
    let baseCoords = this.getAnchor(baseAnchor);
    let markCoords = this.getAnchor(markRecord.markAnchor);
    let basePos = this.positions[baseGlyphIndex];
    let markPos = this.positions[this.glyphIterator.index];
    markPos.xOffset = baseCoords.x - markCoords.x;
    markPos.yOffset = baseCoords.y - markCoords.y;
    this.glyphIterator.cur.markAttachment = baseGlyphIndex;
  }
  getAnchor(anchor) {
    let x = anchor.xCoordinate;
    let y = anchor.yCoordinate;
    let variationProcessor = this.font._variationProcessor;
    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (anchor.xDeviceTable) x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);
      if (anchor.yDeviceTable) y += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);
    }
    return {
      x,
      y
    };
  }
  applyFeatures(userFeatures, glyphs, advances) {
    super.applyFeatures(userFeatures, glyphs, advances);
    for (var i = 0; i < this.glyphs.length; i++) this.fixCursiveAttachment(i);
    this.fixMarkAttachment();
  }
  fixCursiveAttachment(i) {
    let glyph = this.glyphs[i];
    if (glyph.cursiveAttachment != null) {
      let j = glyph.cursiveAttachment;
      glyph.cursiveAttachment = null;
      this.fixCursiveAttachment(j);
      this.positions[i].yOffset += this.positions[j].yOffset;
    }
  }
  fixMarkAttachment() {
    for (let i = 0; i < this.glyphs.length; i++) {
      let glyph = this.glyphs[i];
      if (glyph.markAttachment != null) {
        let j = glyph.markAttachment;
        this.positions[i].xOffset += this.positions[j].xOffset;
        this.positions[i].yOffset += this.positions[j].yOffset;
        if (this.direction === "ltr") for (let k = j; k < i; k++) {
          this.positions[i].xOffset -= this.positions[k].xAdvance;
          this.positions[i].yOffset -= this.positions[k].yAdvance;
        }
        else for (let k1 = j + 1; k1 < i + 1; k1++) {
          this.positions[i].xOffset += this.positions[k1].xAdvance;
          this.positions[i].yOffset += this.positions[k1].yAdvance;
        }
      }
    }
  }
};
var $a62492810de27e3d$export$2e2bcd8739ae039 = class {
  setup(glyphRun) {
    this.glyphInfos = glyphRun.glyphs.map((glyph) => new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, glyph.id, [
      ...glyph.codePoints
    ]));
    let script = null;
    if (this.GPOSProcessor) script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    if (this.GSUBProcessor) script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    this.shaper = $102b6fe50f1d50b4$export$7877a478dd30fd3d(script);
    this.plan = new (0, $94d7a73bd2edfc9a$export$2e2bcd8739ae039)(this.font, script, glyphRun.direction);
    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);
    for (let key in this.plan.allFeatures) glyphRun.features[key] = true;
  }
  substitute(glyphRun) {
    if (this.GSUBProcessor) {
      this.plan.process(this.GSUBProcessor, this.glyphInfos);
      glyphRun.glyphs = this.glyphInfos.map((glyphInfo) => this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints));
    }
  }
  position(glyphRun) {
    if (this.shaper.zeroMarkWidths === "BEFORE_GPOS") this.zeroMarkAdvances(glyphRun.positions);
    if (this.GPOSProcessor) this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);
    if (this.shaper.zeroMarkWidths === "AFTER_GPOS") this.zeroMarkAdvances(glyphRun.positions);
    if (glyphRun.direction === "rtl") {
      glyphRun.glyphs.reverse();
      glyphRun.positions.reverse();
    }
    return this.GPOSProcessor && this.GPOSProcessor.features;
  }
  zeroMarkAdvances(positions) {
    for (let i = 0; i < this.glyphInfos.length; i++) if (this.glyphInfos[i].isMark) {
      positions[i].xAdvance = 0;
      positions[i].yAdvance = 0;
    }
  }
  cleanup() {
    this.glyphInfos = null;
    this.plan = null;
    this.shaper = null;
  }
  getAvailableFeatures(script, language) {
    let features = [];
    if (this.GSUBProcessor) {
      this.GSUBProcessor.selectScript(script, language);
      features.push(...Object.keys(this.GSUBProcessor.features));
    }
    if (this.GPOSProcessor) {
      this.GPOSProcessor.selectScript(script, language);
      features.push(...Object.keys(this.GPOSProcessor.features));
    }
    return features;
  }
  constructor(font2) {
    this.font = font2;
    this.glyphInfos = null;
    this.plan = null;
    this.GSUBProcessor = null;
    this.GPOSProcessor = null;
    this.fallbackPosition = true;
    if (font2.GSUB) this.GSUBProcessor = new (0, $0a876c45f1f7c41c$export$2e2bcd8739ae039)(font2, font2.GSUB);
    if (font2.GPOS) this.GPOSProcessor = new (0, $c96c93587d49c14d$export$2e2bcd8739ae039)(font2, font2.GPOS);
  }
};
var $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039 = class {
  layout(string, features, script, language, direction) {
    if (typeof features === "string") {
      direction = language;
      language = script;
      script = features;
      features = [];
    }
    if (typeof string === "string") {
      if (script == null) script = $130d1a642ebcd2b7$export$e5cb25e204fb8450(string);
      var glyphs = this.font.glyphsForString(string);
    } else {
      if (script == null) {
        let codePoints = [];
        for (let glyph of string) codePoints.push(...glyph.codePoints);
        script = $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints);
      }
      var glyphs = string;
    }
    let glyphRun = new (0, $be07b3e97a42687a$export$2e2bcd8739ae039)(glyphs, features, script, language, direction);
    if (glyphs.length === 0) {
      glyphRun.positions = [];
      return glyphRun;
    }
    if (this.engine && this.engine.setup) this.engine.setup(glyphRun);
    this.substitute(glyphRun);
    this.position(glyphRun);
    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);
    if (this.engine && this.engine.cleanup) this.engine.cleanup();
    return glyphRun;
  }
  substitute(glyphRun) {
    if (this.engine && this.engine.substitute) this.engine.substitute(glyphRun);
  }
  position(glyphRun) {
    glyphRun.positions = glyphRun.glyphs.map((glyph) => new (0, $1ac75d9a55b67f01$export$2e2bcd8739ae039)(glyph.advanceWidth));
    let positioned = null;
    if (this.engine && this.engine.position) positioned = this.engine.position(glyphRun);
    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {
      if (!this.unicodeLayoutEngine) this.unicodeLayoutEngine = new (0, $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039)(this.font);
      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);
    }
    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {
      if (!this.kernProcessor) this.kernProcessor = new (0, $0bba3a9db57637f3$export$2e2bcd8739ae039)(this.font);
      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);
      glyphRun.features.kern = true;
    }
  }
  hideDefaultIgnorables(glyphs, positions) {
    let space = this.font.glyphForCodePoint(32);
    for (let i = 0; i < glyphs.length; i++) if (this.isDefaultIgnorable(glyphs[i].codePoints[0])) {
      glyphs[i] = space;
      positions[i].xAdvance = 0;
      positions[i].yAdvance = 0;
    }
  }
  isDefaultIgnorable(ch) {
    let plane = ch >> 16;
    if (plane === 0)
      switch (ch >> 8) {
        case 0:
          return ch === 173;
        case 3:
          return ch === 847;
        case 6:
          return ch === 1564;
        case 23:
          return 6068 <= ch && ch <= 6069;
        case 24:
          return 6155 <= ch && ch <= 6158;
        case 32:
          return 8203 <= ch && ch <= 8207 || 8234 <= ch && ch <= 8238 || 8288 <= ch && ch <= 8303;
        case 254:
          return 65024 <= ch && ch <= 65039 || ch === 65279;
        case 255:
          return 65520 <= ch && ch <= 65528;
        default:
          return false;
      }
    else
      switch (plane) {
        case 1:
          return 113824 <= ch && ch <= 113827 || 119155 <= ch && ch <= 119162;
        case 14:
          return 917504 <= ch && ch <= 921599;
        default:
          return false;
      }
  }
  getAvailableFeatures(script, language) {
    let features = [];
    if (this.engine) features.push(...this.engine.getAvailableFeatures(script, language));
    if (this.font.kern && features.indexOf("kern") === -1) features.push("kern");
    return features;
  }
  stringsForGlyph(gid) {
    let result = /* @__PURE__ */ new Set();
    let codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);
    for (let codePoint of codePoints) result.add(String.fromCodePoint(codePoint));
    if (this.engine && this.engine.stringsForGlyph) for (let string of this.engine.stringsForGlyph(gid)) result.add(string);
    return Array.from(result);
  }
  constructor(font2) {
    this.font = font2;
    this.unicodeLayoutEngine = null;
    this.kernProcessor = null;
    if (this.font.morx) this.engine = new (0, $ba6dd74203be8728$export$2e2bcd8739ae039)(this.font);
    else if (this.font.GSUB || this.font.GPOS) this.engine = new (0, $a62492810de27e3d$export$2e2bcd8739ae039)(this.font);
  }
};
var $f43aec954cdfdf21$var$SVG_COMMANDS = {
  moveTo: "M",
  lineTo: "L",
  quadraticCurveTo: "Q",
  bezierCurveTo: "C",
  closePath: "Z"
};
var $f43aec954cdfdf21$export$2e2bcd8739ae039 = class _$f43aec954cdfdf21$export$2e2bcd8739ae039 {
  /**
  * Compiles the path to a JavaScript function that can be applied with
  * a graphics context in order to render the path.
  * @return {string}
  */
  toFunction() {
    return (ctx) => {
      this.commands.forEach((c2) => {
        return ctx[c2.command].apply(ctx, c2.args);
      });
    };
  }
  /**
  * Converts the path to an SVG path data string
  * @return {string}
  */
  toSVG() {
    let cmds = this.commands.map((c2) => {
      let args = c2.args.map((arg) => Math.round(arg * 100) / 100);
      return `${$f43aec954cdfdf21$var$SVG_COMMANDS[c2.command]}${args.join(" ")}`;
    });
    return cmds.join("");
  }
  /**
  * Gets the "control box" of a path.
  * This is like the bounding box, but it includes all points including
  * control points of bezier segments and is much faster to compute than
  * the real bounding box.
  * @type {BBox}
  */
  get cbox() {
    if (!this._cbox) {
      let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
      for (let command1 of this.commands) for (let i = 0; i < command1.args.length; i += 2) cbox.addPoint(command1.args[i], command1.args[i + 1]);
      this._cbox = Object.freeze(cbox);
    }
    return this._cbox;
  }
  /**
  * Gets the exact bounding box of the path by evaluating curve segments.
  * Slower to compute than the control box, but more accurate.
  * @type {BBox}
  */
  get bbox() {
    if (this._bbox) return this._bbox;
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    let cx2 = 0, cy2 = 0;
    let f = (t2) => Math.pow(1 - t2, 3) * p0[i] + 3 * Math.pow(1 - t2, 2) * t2 * p1[i] + 3 * (1 - t2) * Math.pow(t2, 2) * p2[i] + Math.pow(t2, 3) * p3[i];
    for (let c2 of this.commands) switch (c2.command) {
      case "moveTo":
      case "lineTo":
        let [x, y] = c2.args;
        bbox.addPoint(x, y);
        cx2 = x;
        cy2 = y;
        break;
      case "quadraticCurveTo":
      case "bezierCurveTo":
        if (c2.command === "quadraticCurveTo") {
          var [qp1x, qp1y, p3x, p3y] = c2.args;
          var cp1x = cx2 + 2 / 3 * (qp1x - cx2);
          var cp1y = cy2 + 2 / 3 * (qp1y - cy2);
          var cp2x = p3x + 2 / 3 * (qp1x - p3x);
          var cp2y = p3y + 2 / 3 * (qp1y - p3y);
        } else var [cp1x, cp1y, cp2x, cp2y, p3x, p3y] = c2.args;
        bbox.addPoint(p3x, p3y);
        var p0 = [
          cx2,
          cy2
        ];
        var p1 = [
          cp1x,
          cp1y
        ];
        var p2 = [
          cp2x,
          cp2y
        ];
        var p3 = [
          p3x,
          p3y
        ];
        for (var i = 0; i <= 1; i++) {
          let b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
          let a2 = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
          c2 = 3 * p1[i] - 3 * p0[i];
          if (a2 === 0) {
            if (b === 0) continue;
            let t3 = -c2 / b;
            if (0 < t3 && t3 < 1) {
              if (i === 0) bbox.addPoint(f(t3), bbox.maxY);
              else if (i === 1) bbox.addPoint(bbox.maxX, f(t3));
            }
            continue;
          }
          let b2ac = Math.pow(b, 2) - 4 * c2 * a2;
          if (b2ac < 0) continue;
          let t1 = (-b + Math.sqrt(b2ac)) / (2 * a2);
          if (0 < t1 && t1 < 1) {
            if (i === 0) bbox.addPoint(f(t1), bbox.maxY);
            else if (i === 1) bbox.addPoint(bbox.maxX, f(t1));
          }
          let t2 = (-b - Math.sqrt(b2ac)) / (2 * a2);
          if (0 < t2 && t2 < 1) {
            if (i === 0) bbox.addPoint(f(t2), bbox.maxY);
            else if (i === 1) bbox.addPoint(bbox.maxX, f(t2));
          }
        }
        cx2 = p3x;
        cy2 = p3y;
        break;
    }
    return this._bbox = Object.freeze(bbox);
  }
  /**
  * Applies a mapping function to each point in the path.
  * @param {function} fn
  * @return {Path}
  */
  mapPoints(fn) {
    let path2 = new _$f43aec954cdfdf21$export$2e2bcd8739ae039();
    for (let c2 of this.commands) {
      let args = [];
      for (let i = 0; i < c2.args.length; i += 2) {
        let [x, y] = fn(c2.args[i], c2.args[i + 1]);
        args.push(x, y);
      }
      path2[c2.command](...args);
    }
    return path2;
  }
  /**
  * Transforms the path by the given matrix.
  */
  transform(m0, m1, m2, m3, m4, m5) {
    return this.mapPoints((x, y) => {
      const tx = m0 * x + m2 * y + m4;
      const ty = m1 * x + m3 * y + m5;
      return [
        tx,
        ty
      ];
    });
  }
  /**
  * Translates the path by the given offset.
  */
  translate(x, y) {
    return this.transform(1, 0, 0, 1, x, y);
  }
  /**
  * Rotates the path by the given angle (in radians).
  */
  rotate(angle) {
    let cos = Math.cos(angle);
    let sin = Math.sin(angle);
    return this.transform(cos, sin, -sin, cos, 0, 0);
  }
  /**
  * Scales the path.
  */
  scale(scaleX, scaleY = scaleX) {
    return this.transform(scaleX, 0, 0, scaleY, 0, 0);
  }
  constructor() {
    this.commands = [];
    this._bbox = null;
    this._cbox = null;
  }
};
for (let command of [
  "moveTo",
  "lineTo",
  "quadraticCurveTo",
  "bezierCurveTo",
  "closePath"
]) $f43aec954cdfdf21$export$2e2bcd8739ae039.prototype[command] = function(...args) {
  this._bbox = this._cbox = null;
  this.commands.push({
    command,
    args
  });
  return this;
};
var $7713b9b7b438dff8$export$2e2bcd8739ae039 = [
  ".notdef",
  ".null",
  "nonmarkingreturn",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quotesingle",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "grave",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "Adieresis",
  "Aring",
  "Ccedilla",
  "Eacute",
  "Ntilde",
  "Odieresis",
  "Udieresis",
  "aacute",
  "agrave",
  "acircumflex",
  "adieresis",
  "atilde",
  "aring",
  "ccedilla",
  "eacute",
  "egrave",
  "ecircumflex",
  "edieresis",
  "iacute",
  "igrave",
  "icircumflex",
  "idieresis",
  "ntilde",
  "oacute",
  "ograve",
  "ocircumflex",
  "odieresis",
  "otilde",
  "uacute",
  "ugrave",
  "ucircumflex",
  "udieresis",
  "dagger",
  "degree",
  "cent",
  "sterling",
  "section",
  "bullet",
  "paragraph",
  "germandbls",
  "registered",
  "copyright",
  "trademark",
  "acute",
  "dieresis",
  "notequal",
  "AE",
  "Oslash",
  "infinity",
  "plusminus",
  "lessequal",
  "greaterequal",
  "yen",
  "mu",
  "partialdiff",
  "summation",
  "product",
  "pi",
  "integral",
  "ordfeminine",
  "ordmasculine",
  "Omega",
  "ae",
  "oslash",
  "questiondown",
  "exclamdown",
  "logicalnot",
  "radical",
  "florin",
  "approxequal",
  "Delta",
  "guillemotleft",
  "guillemotright",
  "ellipsis",
  "nonbreakingspace",
  "Agrave",
  "Atilde",
  "Otilde",
  "OE",
  "oe",
  "endash",
  "emdash",
  "quotedblleft",
  "quotedblright",
  "quoteleft",
  "quoteright",
  "divide",
  "lozenge",
  "ydieresis",
  "Ydieresis",
  "fraction",
  "currency",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "daggerdbl",
  "periodcentered",
  "quotesinglbase",
  "quotedblbase",
  "perthousand",
  "Acircumflex",
  "Ecircumflex",
  "Aacute",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Oacute",
  "Ocircumflex",
  "apple",
  "Ograve",
  "Uacute",
  "Ucircumflex",
  "Ugrave",
  "dotlessi",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "Lslash",
  "lslash",
  "Scaron",
  "scaron",
  "Zcaron",
  "zcaron",
  "brokenbar",
  "Eth",
  "eth",
  "Yacute",
  "yacute",
  "Thorn",
  "thorn",
  "minus",
  "multiply",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "onehalf",
  "onequarter",
  "threequarters",
  "franc",
  "Gbreve",
  "gbreve",
  "Idotaccent",
  "Scedilla",
  "scedilla",
  "Cacute",
  "cacute",
  "Ccaron",
  "ccaron",
  "dcroat"
];
var $f92906be28e61769$export$2e2bcd8739ae039 = class {
  _getPath() {
    return new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
  }
  _getCBox() {
    return this.path.cbox;
  }
  _getBBox() {
    return this.path.bbox;
  }
  _getTableMetrics(table) {
    if (this.id < table.metrics.length) return table.metrics.get(this.id);
    let metric = table.metrics.get(table.metrics.length - 1);
    let res = {
      advance: metric ? metric.advance : 0,
      bearing: table.bearings.get(this.id - table.metrics.length) || 0
    };
    return res;
  }
  _getMetrics(cbox) {
    if (this._metrics) return this._metrics;
    let { advance: advanceWidth5, bearing: leftBearing } = this._getTableMetrics(this._font.hmtx);
    if (this._font.vmtx) var { advance: advanceHeight, bearing: topBearing } = this._getTableMetrics(this._font.vmtx);
    else {
      let os2;
      if (typeof cbox === "undefined" || cbox === null) ({ cbox } = this);
      if ((os2 = this._font["OS/2"]) && os2.version > 0) {
        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
        var topBearing = os2.typoAscender - cbox.maxY;
      } else {
        let { hhea } = this._font;
        var advanceHeight = Math.abs(hhea.ascent - hhea.descent);
        var topBearing = hhea.ascent - cbox.maxY;
      }
    }
    if (this._font._variationProcessor && this._font.HVAR) advanceWidth5 += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);
    return this._metrics = {
      advanceWidth: advanceWidth5,
      advanceHeight,
      leftBearing,
      topBearing
    };
  }
  /**
  * The glyphs control box.
  * This is often the same as the bounding box, but is faster to compute.
  * Because of the way bezier curves are defined, some of the control points
  * can be outside of the bounding box. Where `bbox` takes this into account,
  * `cbox` does not. Thus, cbox is less accurate, but faster to compute.
  * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)
  * for a more detailed description.
  *
  * @type {BBox}
  */
  get cbox() {
    return this._getCBox();
  }
  /**
  * The glyphs bounding box, i.e. the rectangle that encloses the
  * glyph outline as tightly as possible.
  * @type {BBox}
  */
  get bbox() {
    return this._getBBox();
  }
  /**
  * A vector Path object representing the glyph outline.
  * @type {Path}
  */
  get path() {
    return this._getPath();
  }
  /**
  * Returns a path scaled to the given font size.
  * @param {number} size
  * @return {Path}
  */
  getScaledPath(size) {
    let scale4 = 1 / this._font.unitsPerEm * size;
    return this.path.scale(scale4);
  }
  /**
  * The glyph's advance width.
  * @type {number}
  */
  get advanceWidth() {
    return this._getMetrics().advanceWidth;
  }
  /**
  * The glyph's advance height.
  * @type {number}
  */
  get advanceHeight() {
    return this._getMetrics().advanceHeight;
  }
  get ligatureCaretPositions() {
  }
  _getName() {
    let { post } = this._font;
    if (!post) return null;
    switch (post.version) {
      case 1:
        return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id];
      case 2:
        let id = post.glyphNameIndex[this.id];
        if (id < (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length) return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[id];
        return post.names[id - (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length];
      case 2.5:
        return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id + post.offsets[this.id]];
      case 4:
        return String.fromCharCode(post.map[this.id]);
    }
  }
  /**
  * The glyph's name
  * @type {string}
  */
  get name() {
    return this._getName();
  }
  /**
  * Renders the glyph to the given graphics context, at the specified font size.
  * @param {CanvasRenderingContext2d} ctx
  * @param {number} size
  */
  render(ctx, size) {
    ctx.save();
    let scale4 = 1 / this._font.head.unitsPerEm * size;
    ctx.scale(scale4, scale4);
    let fn = this.path.toFunction();
    fn(ctx);
    ctx.fill();
    ctx.restore();
  }
  constructor(id, codePoints, font2) {
    this.id = id;
    this.codePoints = codePoints;
    this._font = font2;
    this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $747425b437e121da$export$e33ad6871e762338));
    this.isLigature = this.codePoints.length > 1;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "cbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "bbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "path", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceWidth", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceHeight", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "name", null);
var $69aac16029968692$var$GlyfHeader = new Struct({
  numberOfContours: int16,
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16
});
var $69aac16029968692$var$ON_CURVE = 1;
var $69aac16029968692$var$X_SHORT_VECTOR = 2;
var $69aac16029968692$var$Y_SHORT_VECTOR = 4;
var $69aac16029968692$var$REPEAT = 8;
var $69aac16029968692$var$SAME_X = 16;
var $69aac16029968692$var$SAME_Y = 32;
var $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS = 1;
var $69aac16029968692$var$WE_HAVE_A_SCALE = 8;
var $69aac16029968692$var$MORE_COMPONENTS = 32;
var $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE = 64;
var $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO = 128;
var $69aac16029968692$var$WE_HAVE_INSTRUCTIONS = 256;
var $69aac16029968692$export$baf26146a414f24a = class _$69aac16029968692$export$baf26146a414f24a {
  copy() {
    return new _$69aac16029968692$export$baf26146a414f24a(this.onCurve, this.endContour, this.x, this.y);
  }
  constructor(onCurve, endContour, x = 0, y = 0) {
    this.onCurve = onCurve;
    this.endContour = endContour;
    this.x = x;
    this.y = y;
  }
};
var $69aac16029968692$var$Component = class {
  constructor(glyphID, dx, dy) {
    this.glyphID = glyphID;
    this.dx = dx;
    this.dy = dy;
    this.pos = 0;
    this.scaleX = this.scaleY = 1;
    this.scale01 = this.scale10 = 0;
  }
};
var $69aac16029968692$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  // Parses just the glyph header and returns the bounding box
  _getCBox(internal) {
    if (this._font._variationProcessor && !internal) return this.path.cbox;
    let stream2 = this._font._getTableStream("glyf");
    stream2.pos += this._font.loca.offsets[this.id];
    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream2);
    let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
    return Object.freeze(cbox);
  }
  // Parses a single glyph coordinate
  _parseGlyphCoord(stream2, prev, short, same) {
    if (short) {
      var val = stream2.readUInt8();
      if (!same) val = -val;
      val += prev;
    } else if (same) var val = prev;
    else var val = prev + stream2.readInt16BE();
    return val;
  }
  // Decodes the glyph data into points for simple glyphs,
  // or components for composite glyphs
  _decode() {
    let glyfPos = this._font.loca.offsets[this.id];
    let nextPos = this._font.loca.offsets[this.id + 1];
    if (glyfPos === nextPos) return null;
    let stream2 = this._font._getTableStream("glyf");
    stream2.pos += glyfPos;
    let startPos = stream2.pos;
    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream2);
    if (glyph.numberOfContours > 0) this._decodeSimple(glyph, stream2);
    else if (glyph.numberOfContours < 0) this._decodeComposite(glyph, stream2, startPos);
    return glyph;
  }
  _decodeSimple(glyph, stream2) {
    glyph.points = [];
    let endPtsOfContours = new ArrayT(uint16, glyph.numberOfContours).decode(stream2);
    glyph.instructions = new ArrayT(uint8, uint16).decode(stream2);
    let flags = [];
    let numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
    while (flags.length < numCoords) {
      var flag = stream2.readUInt8();
      flags.push(flag);
      if (flag & $69aac16029968692$var$REPEAT) {
        let count = stream2.readUInt8();
        for (let j = 0; j < count; j++) flags.push(flag);
      }
    }
    for (var i = 0; i < flags.length; i++) {
      var flag = flags[i];
      let point = new $69aac16029968692$export$baf26146a414f24a(!!(flag & $69aac16029968692$var$ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);
      glyph.points.push(point);
    }
    let px2 = 0;
    for (var i = 0; i < flags.length; i++) {
      var flag = flags[i];
      glyph.points[i].x = px2 = this._parseGlyphCoord(stream2, px2, flag & $69aac16029968692$var$X_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_X);
    }
    let py2 = 0;
    for (var i = 0; i < flags.length; i++) {
      var flag = flags[i];
      glyph.points[i].y = py2 = this._parseGlyphCoord(stream2, py2, flag & $69aac16029968692$var$Y_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_Y);
    }
    if (this._font._variationProcessor) {
      let points = glyph.points.slice();
      points.push(...this._getPhantomPoints(glyph));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph.phantomPoints = points.slice(-4);
    }
    return;
  }
  _decodeComposite(glyph, stream2, offset3 = 0) {
    glyph.components = [];
    let haveInstructions = false;
    let flags = $69aac16029968692$var$MORE_COMPONENTS;
    while (flags & $69aac16029968692$var$MORE_COMPONENTS) {
      flags = stream2.readUInt16BE();
      let gPos = stream2.pos - offset3;
      let glyphID = stream2.readUInt16BE();
      if (!haveInstructions) haveInstructions = (flags & $69aac16029968692$var$WE_HAVE_INSTRUCTIONS) !== 0;
      if (flags & $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS) {
        var dx = stream2.readInt16BE();
        var dy = stream2.readInt16BE();
      } else {
        var dx = stream2.readInt8();
        var dy = stream2.readInt8();
      }
      var component = new $69aac16029968692$var$Component(glyphID, dx, dy);
      component.pos = gPos;
      if (flags & $69aac16029968692$var$WE_HAVE_A_SCALE)
        component.scaleX = component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      else if (flags & $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE) {
        component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      } else if (flags & $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO) {
        component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scale01 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scale10 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      }
      glyph.components.push(component);
    }
    if (this._font._variationProcessor) {
      let points = [];
      for (let j = 0; j < glyph.components.length; j++) {
        var component = glyph.components[j];
        points.push(new $69aac16029968692$export$baf26146a414f24a(true, true, component.dx, component.dy));
      }
      points.push(...this._getPhantomPoints(glyph));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph.phantomPoints = points.splice(-4, 4);
      for (let i = 0; i < points.length; i++) {
        let point = points[i];
        glyph.components[i].dx = point.x;
        glyph.components[i].dy = point.y;
      }
    }
    return haveInstructions;
  }
  _getPhantomPoints(glyph) {
    let cbox = this._getCBox(true);
    if (this._metrics == null) this._metrics = (0, $f92906be28e61769$export$2e2bcd8739ae039).prototype._getMetrics.call(this, cbox);
    let { advanceWidth: advanceWidth5, advanceHeight, leftBearing, topBearing } = this._metrics;
    return [
      new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing, 0),
      new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing + advanceWidth5, 0),
      new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing),
      new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing + advanceHeight)
    ];
  }
  // Decodes font data, resolves composite glyphs, and returns an array of contours
  _getContours() {
    let glyph = this._decode();
    if (!glyph) return [];
    let points = [];
    if (glyph.numberOfContours < 0)
      for (let component of glyph.components) {
        let contours2 = this._font.getGlyph(component.glyphID)._getContours();
        for (let i = 0; i < contours2.length; i++) {
          let contour = contours2[i];
          for (let j = 0; j < contour.length; j++) {
            let point2 = contour[j];
            let x = point2.x * component.scaleX + point2.y * component.scale01 + component.dx;
            let y = point2.y * component.scaleY + point2.x * component.scale10 + component.dy;
            points.push(new $69aac16029968692$export$baf26146a414f24a(point2.onCurve, point2.endContour, x, y));
          }
        }
      }
    else points = glyph.points || [];
    if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {
      this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;
      this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;
      this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;
      this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;
    }
    let contours = [];
    let cur = [];
    for (let k = 0; k < points.length; k++) {
      var point = points[k];
      cur.push(point);
      if (point.endContour) {
        contours.push(cur);
        cur = [];
      }
    }
    return contours;
  }
  _getMetrics() {
    if (this._metrics) return this._metrics;
    let cbox = this._getCBox(true);
    super._getMetrics(cbox);
    if (this._font._variationProcessor && !this._font.HVAR)
      this.path;
    return this._metrics;
  }
  // Converts contours to a Path object that can be rendered
  _getPath() {
    let contours = this._getContours();
    let path2 = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
    for (let i = 0; i < contours.length; i++) {
      let contour = contours[i];
      let firstPt = contour[0];
      let lastPt = contour[contour.length - 1];
      let start3 = 0;
      if (firstPt.onCurve) {
        var curvePt = null;
        start3 = 1;
      } else {
        if (lastPt.onCurve)
          firstPt = lastPt;
        else
          firstPt = new $69aac16029968692$export$baf26146a414f24a(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
        var curvePt = firstPt;
      }
      path2.moveTo(firstPt.x, firstPt.y);
      for (let j = start3; j < contour.length; j++) {
        let pt = contour[j];
        let prevPt = j === 0 ? firstPt : contour[j - 1];
        if (prevPt.onCurve && pt.onCurve) path2.lineTo(pt.x, pt.y);
        else if (prevPt.onCurve && !pt.onCurve) var curvePt = pt;
        else if (!prevPt.onCurve && !pt.onCurve) {
          let midX = (prevPt.x + pt.x) / 2;
          let midY = (prevPt.y + pt.y) / 2;
          path2.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
          var curvePt = pt;
        } else if (!prevPt.onCurve && pt.onCurve) {
          path2.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
          var curvePt = null;
        } else throw new Error("Unknown TTF path state");
      }
      if (curvePt) path2.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
      path2.closePath();
    }
    return path2;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "TTF");
  }
};
var $62cc5109c6101893$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  _getName() {
    if (this._font.CFF2) return super._getName();
    return this._font["CFF "].getGlyphName(this.id);
  }
  bias(s2) {
    if (s2.length < 1240) return 107;
    else if (s2.length < 33900) return 1131;
    else return 32768;
  }
  _getPath() {
    let cff = this._font.CFF2 || this._font["CFF "];
    let { stream: stream2 } = cff;
    let str = cff.topDict.CharStrings[this.id];
    let end3 = str.offset + str.length;
    stream2.pos = str.offset;
    let path2 = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
    let stack = [];
    let trans = [];
    let width = null;
    let nStems = 0;
    let x1 = 0, y1 = 0;
    let usedGsubrs;
    let usedSubrs;
    let open = false;
    this._usedGsubrs = usedGsubrs = {};
    this._usedSubrs = usedSubrs = {};
    let gsubrs = cff.globalSubrIndex || [];
    let gsubrsBias = this.bias(gsubrs);
    let privateDict = cff.privateDictForGlyph(this.id) || {};
    let subrs = privateDict.Subrs || [];
    let subrsBias = this.bias(subrs);
    let vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;
    let vsindex = privateDict.vsindex;
    let variationProcessor = this._font._variationProcessor;
    function checkWidth() {
      if (width == null) width = stack.shift() + privateDict.nominalWidthX;
    }
    function parseStems() {
      if (stack.length % 2 !== 0) checkWidth();
      nStems += stack.length >> 1;
      return stack.length = 0;
    }
    function moveTo2(x, y) {
      if (open) path2.closePath();
      path2.moveTo(x, y);
      open = true;
    }
    let parse3 = function() {
      while (stream2.pos < end3) {
        let op = stream2.readUInt8();
        if (op < 32) {
          let index2, subr, phase;
          switch (op) {
            case 1:
            case 3:
            case 18:
            case 23:
              parseStems();
              break;
            case 4:
              if (stack.length > 1) checkWidth();
              y1 += stack.shift();
              moveTo2(x1, y1);
              break;
            case 5:
              while (stack.length >= 2) {
                x1 += stack.shift();
                y1 += stack.shift();
                path2.lineTo(x1, y1);
              }
              break;
            case 6:
            case 7:
              phase = op === 6;
              while (stack.length >= 1) {
                if (phase) x1 += stack.shift();
                else y1 += stack.shift();
                path2.lineTo(x1, y1);
                phase = !phase;
              }
              break;
            case 8:
              while (stack.length > 0) {
                var c1x = x1 + stack.shift();
                var c1y = y1 + stack.shift();
                var c2x = c1x + stack.shift();
                var c2y = c1y + stack.shift();
                x1 = c2x + stack.shift();
                y1 = c2y + stack.shift();
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              }
              break;
            case 10:
              index2 = stack.pop() + subrsBias;
              subr = subrs[index2];
              if (subr) {
                usedSubrs[index2] = true;
                var p = stream2.pos;
                var e = end3;
                stream2.pos = subr.offset;
                end3 = subr.offset + subr.length;
                parse3();
                stream2.pos = p;
                end3 = e;
              }
              break;
            case 11:
              if (cff.version >= 2) break;
              return;
            case 14:
              if (cff.version >= 2) break;
              if (stack.length > 0) checkWidth();
              if (open) {
                path2.closePath();
                open = false;
              }
              break;
            case 15:
              if (cff.version < 2) throw new Error("vsindex operator not supported in CFF v1");
              vsindex = stack.pop();
              break;
            case 16: {
              if (cff.version < 2) throw new Error("blend operator not supported in CFF v1");
              if (!variationProcessor) throw new Error("blend operator in non-variation font");
              let blendVector = variationProcessor.getBlendVector(vstore, vsindex);
              let numBlends = stack.pop();
              let numOperands = numBlends * blendVector.length;
              let delta = stack.length - numOperands;
              let base = delta - numBlends;
              for (let i = 0; i < numBlends; i++) {
                let sum = stack[base + i];
                for (let j = 0; j < blendVector.length; j++) sum += blendVector[j] * stack[delta++];
                stack[base + i] = sum;
              }
              while (numOperands--) stack.pop();
              break;
            }
            case 19:
            case 20:
              parseStems();
              stream2.pos += nStems + 7 >> 3;
              break;
            case 21:
              if (stack.length > 2) checkWidth();
              x1 += stack.shift();
              y1 += stack.shift();
              moveTo2(x1, y1);
              break;
            case 22:
              if (stack.length > 1) checkWidth();
              x1 += stack.shift();
              moveTo2(x1, y1);
              break;
            case 24:
              while (stack.length >= 8) {
                var c1x = x1 + stack.shift();
                var c1y = y1 + stack.shift();
                var c2x = c1x + stack.shift();
                var c2y = c1y + stack.shift();
                x1 = c2x + stack.shift();
                y1 = c2y + stack.shift();
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              }
              x1 += stack.shift();
              y1 += stack.shift();
              path2.lineTo(x1, y1);
              break;
            case 25:
              while (stack.length >= 8) {
                x1 += stack.shift();
                y1 += stack.shift();
                path2.lineTo(x1, y1);
              }
              var c1x = x1 + stack.shift();
              var c1y = y1 + stack.shift();
              var c2x = c1x + stack.shift();
              var c2y = c1y + stack.shift();
              x1 = c2x + stack.shift();
              y1 = c2y + stack.shift();
              path2.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              break;
            case 26:
              if (stack.length % 2) x1 += stack.shift();
              while (stack.length >= 4) {
                c1x = x1;
                c1y = y1 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x1 = c2x;
                y1 = c2y + stack.shift();
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              }
              break;
            case 27:
              if (stack.length % 2) y1 += stack.shift();
              while (stack.length >= 4) {
                c1x = x1 + stack.shift();
                c1y = y1;
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x1 = c2x + stack.shift();
                y1 = c2y;
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              }
              break;
            case 28:
              stack.push(stream2.readInt16BE());
              break;
            case 29:
              index2 = stack.pop() + gsubrsBias;
              subr = gsubrs[index2];
              if (subr) {
                usedGsubrs[index2] = true;
                var p = stream2.pos;
                var e = end3;
                stream2.pos = subr.offset;
                end3 = subr.offset + subr.length;
                parse3();
                stream2.pos = p;
                end3 = e;
              }
              break;
            case 30:
            case 31:
              phase = op === 31;
              while (stack.length >= 4) {
                if (phase) {
                  c1x = x1 + stack.shift();
                  c1y = y1;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  y1 = c2y + stack.shift();
                  x1 = c2x + (stack.length === 1 ? stack.shift() : 0);
                } else {
                  c1x = x1;
                  c1y = y1 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x1 = c2x + stack.shift();
                  y1 = c2y + (stack.length === 1 ? stack.shift() : 0);
                }
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
                phase = !phase;
              }
              break;
            case 12:
              op = stream2.readUInt8();
              switch (op) {
                case 3:
                  let a2 = stack.pop();
                  let b = stack.pop();
                  stack.push(a2 && b ? 1 : 0);
                  break;
                case 4:
                  a2 = stack.pop();
                  b = stack.pop();
                  stack.push(a2 || b ? 1 : 0);
                  break;
                case 5:
                  a2 = stack.pop();
                  stack.push(a2 ? 0 : 1);
                  break;
                case 9:
                  a2 = stack.pop();
                  stack.push(Math.abs(a2));
                  break;
                case 10:
                  a2 = stack.pop();
                  b = stack.pop();
                  stack.push(a2 + b);
                  break;
                case 11:
                  a2 = stack.pop();
                  b = stack.pop();
                  stack.push(a2 - b);
                  break;
                case 12:
                  a2 = stack.pop();
                  b = stack.pop();
                  stack.push(a2 / b);
                  break;
                case 14:
                  a2 = stack.pop();
                  stack.push(-a2);
                  break;
                case 15:
                  a2 = stack.pop();
                  b = stack.pop();
                  stack.push(a2 === b ? 1 : 0);
                  break;
                case 18:
                  stack.pop();
                  break;
                case 20:
                  let val = stack.pop();
                  let idx = stack.pop();
                  trans[idx] = val;
                  break;
                case 21:
                  idx = stack.pop();
                  stack.push(trans[idx] || 0);
                  break;
                case 22:
                  let s1 = stack.pop();
                  let s2 = stack.pop();
                  let v1 = stack.pop();
                  let v2 = stack.pop();
                  stack.push(v1 <= v2 ? s1 : s2);
                  break;
                case 23:
                  stack.push(Math.random());
                  break;
                case 24:
                  a2 = stack.pop();
                  b = stack.pop();
                  stack.push(a2 * b);
                  break;
                case 26:
                  a2 = stack.pop();
                  stack.push(Math.sqrt(a2));
                  break;
                case 27:
                  a2 = stack.pop();
                  stack.push(a2, a2);
                  break;
                case 28:
                  a2 = stack.pop();
                  b = stack.pop();
                  stack.push(b, a2);
                  break;
                case 29:
                  idx = stack.pop();
                  if (idx < 0) idx = 0;
                  else if (idx > stack.length - 1) idx = stack.length - 1;
                  stack.push(stack[idx]);
                  break;
                case 30:
                  let n = stack.pop();
                  let j = stack.pop();
                  if (j >= 0) while (j > 0) {
                    var t2 = stack[n - 1];
                    for (let i = n - 2; i >= 0; i--) stack[i + 1] = stack[i];
                    stack[0] = t2;
                    j--;
                  }
                  else while (j < 0) {
                    var t2 = stack[0];
                    for (let i = 0; i <= n; i++) stack[i] = stack[i + 1];
                    stack[n - 1] = t2;
                    j++;
                  }
                  break;
                case 34:
                  c1x = x1 + stack.shift();
                  c1y = y1;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  let c3x = c2x + stack.shift();
                  let c3y = c2y;
                  let c4x = c3x + stack.shift();
                  let c4y = c3y;
                  let c5x = c4x + stack.shift();
                  let c5y = c4y;
                  let c6x = c5x + stack.shift();
                  let c6y = c5y;
                  x1 = c6x;
                  y1 = c6y;
                  path2.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path2.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 35:
                  let pts = [];
                  for (let i = 0; i <= 5; i++) {
                    x1 += stack.shift();
                    y1 += stack.shift();
                    pts.push(x1, y1);
                  }
                  path2.bezierCurveTo(...pts.slice(0, 6));
                  path2.bezierCurveTo(...pts.slice(6));
                  stack.shift();
                  break;
                case 36:
                  c1x = x1 + stack.shift();
                  c1y = y1 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  c3x = c2x + stack.shift();
                  c3y = c2y;
                  c4x = c3x + stack.shift();
                  c4y = c3y;
                  c5x = c4x + stack.shift();
                  c5y = c4y + stack.shift();
                  c6x = c5x + stack.shift();
                  c6y = c5y;
                  x1 = c6x;
                  y1 = c6y;
                  path2.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path2.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 37:
                  let startx = x1;
                  let starty = y1;
                  pts = [];
                  for (let i1 = 0; i1 <= 4; i1++) {
                    x1 += stack.shift();
                    y1 += stack.shift();
                    pts.push(x1, y1);
                  }
                  if (Math.abs(x1 - startx) > Math.abs(y1 - starty)) {
                    x1 += stack.shift();
                    y1 = starty;
                  } else {
                    x1 = startx;
                    y1 += stack.shift();
                  }
                  pts.push(x1, y1);
                  path2.bezierCurveTo(...pts.slice(0, 6));
                  path2.bezierCurveTo(...pts.slice(6));
                  break;
                default:
                  throw new Error(`Unknown op: 12 ${op}`);
              }
              break;
            default:
              throw new Error(`Unknown op: ${op}`);
          }
        } else if (op < 247) stack.push(op - 139);
        else if (op < 251) {
          var b1 = stream2.readUInt8();
          stack.push((op - 247) * 256 + b1 + 108);
        } else if (op < 255) {
          var b1 = stream2.readUInt8();
          stack.push(-(op - 251) * 256 - b1 - 108);
        } else stack.push(stream2.readInt32BE() / 65536);
      }
    };
    parse3();
    if (open) path2.closePath();
    return path2;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "CFF");
  }
};
var $25d8f049c222084c$var$SBIXImage = new Struct({
  originX: uint16,
  originY: uint16,
  type: new StringT(4),
  data: new BufferT((t2) => t2.parent.buflen - t2._currentOffset)
});
var $25d8f049c222084c$export$2e2bcd8739ae039 = class extends (0, $69aac16029968692$export$2e2bcd8739ae039) {
  /**
  * Returns an object representing a glyph image at the given point size.
  * The object has a data property with a Buffer containing the actual image data,
  * along with the image type, and origin.
  *
  * @param {number} size
  * @return {object}
  */
  getImageForSize(size) {
    for (let i = 0; i < this._font.sbix.imageTables.length; i++) {
      var table = this._font.sbix.imageTables[i];
      if (table.ppem >= size) break;
    }
    let offsets = table.imageOffsets;
    let start3 = offsets[this.id];
    let end3 = offsets[this.id + 1];
    if (start3 === end3) return null;
    this._font.stream.pos = start3;
    return $25d8f049c222084c$var$SBIXImage.decode(this._font.stream, {
      buflen: end3 - start3
    });
  }
  render(ctx, size) {
    let img = this.getImageForSize(size);
    if (img != null) {
      let scale4 = size / this._font.unitsPerEm;
      ctx.image(img.data, {
        height: size,
        x: img.originX,
        y: (this.bbox.minY - img.originY) * scale4
      });
    }
    if (this._font.sbix.flags.renderOutlines) super.render(ctx, size);
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "SBIX");
  }
};
var $0d411f0165859681$var$COLRLayer = class {
  constructor(glyph, color) {
    this.glyph = glyph;
    this.color = color;
  }
};
var $0d411f0165859681$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  _getBBox() {
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    for (let i = 0; i < this.layers.length; i++) {
      let layer = this.layers[i];
      let b = layer.glyph.bbox;
      bbox.addPoint(b.minX, b.minY);
      bbox.addPoint(b.maxX, b.maxY);
    }
    return bbox;
  }
  /**
  * Returns an array of objects containing the glyph and color for
  * each layer in the composite color glyph.
  * @type {object[]}
  */
  get layers() {
    let cpal = this._font.CPAL;
    let colr = this._font.COLR;
    let low = 0;
    let high = colr.baseGlyphRecord.length - 1;
    while (low <= high) {
      let mid = low + high >> 1;
      var rec = colr.baseGlyphRecord[mid];
      if (this.id < rec.gid) high = mid - 1;
      else if (this.id > rec.gid) low = mid + 1;
      else {
        var baseLayer = rec;
        break;
      }
    }
    if (baseLayer == null) {
      var g = this._font._getBaseGlyph(this.id);
      var color = {
        red: 0,
        green: 0,
        blue: 0,
        alpha: 255
      };
      return [
        new $0d411f0165859681$var$COLRLayer(g, color)
      ];
    }
    let layers = [];
    for (let i = baseLayer.firstLayerIndex; i < baseLayer.firstLayerIndex + baseLayer.numLayers; i++) {
      var rec = colr.layerRecords[i];
      var color = cpal.colorRecords[rec.paletteIndex];
      var g = this._font._getBaseGlyph(rec.gid);
      layers.push(new $0d411f0165859681$var$COLRLayer(g, color));
    }
    return layers;
  }
  render(ctx, size) {
    for (let { glyph, color } of this.layers) {
      ctx.fillColor([
        color.red,
        color.green,
        color.blue
      ], color.alpha / 255 * 100);
      glyph.render(ctx, size);
    }
    return;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "COLR");
  }
};
var $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS = 32768;
var $0bb840cac04e911b$var$TUPLE_COUNT_MASK = 4095;
var $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD = 32768;
var $0bb840cac04e911b$var$INTERMEDIATE_TUPLE = 16384;
var $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS = 8192;
var $0bb840cac04e911b$var$TUPLE_INDEX_MASK = 4095;
var $0bb840cac04e911b$var$POINTS_ARE_WORDS = 128;
var $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK = 127;
var $0bb840cac04e911b$var$DELTAS_ARE_ZERO = 128;
var $0bb840cac04e911b$var$DELTAS_ARE_WORDS = 64;
var $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK = 63;
var $0bb840cac04e911b$export$2e2bcd8739ae039 = class {
  normalizeCoords(coords) {
    let normalized = [];
    for (var i = 0; i < this.font.fvar.axis.length; i++) {
      let axis = this.font.fvar.axis[i];
      if (coords[i] < axis.defaultValue) normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));
      else normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));
    }
    if (this.font.avar) for (var i = 0; i < this.font.avar.segment.length; i++) {
      let segment = this.font.avar.segment[i];
      for (let j = 0; j < segment.correspondence.length; j++) {
        let pair = segment.correspondence[j];
        if (j >= 1 && normalized[i] < pair.fromCoord) {
          let prev = segment.correspondence[j - 1];
          normalized[i] = ((normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) / (pair.fromCoord - prev.fromCoord + Number.EPSILON) + prev.toCoord;
          break;
        }
      }
    }
    return normalized;
  }
  transformPoints(gid, glyphPoints) {
    if (!this.font.fvar || !this.font.gvar) return;
    let { gvar } = this.font;
    if (gid >= gvar.glyphCount) return;
    let offset3 = gvar.offsets[gid];
    if (offset3 === gvar.offsets[gid + 1]) return;
    let { stream: stream2 } = this.font;
    stream2.pos = offset3;
    if (stream2.pos >= stream2.length) return;
    let tupleCount = stream2.readUInt16BE();
    let offsetToData = offset3 + stream2.readUInt16BE();
    if (tupleCount & $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS) {
      var here = stream2.pos;
      stream2.pos = offsetToData;
      var sharedPoints = this.decodePoints();
      offsetToData = stream2.pos;
      stream2.pos = here;
    }
    let origPoints = glyphPoints.map((pt) => pt.copy());
    tupleCount &= $0bb840cac04e911b$var$TUPLE_COUNT_MASK;
    for (let i = 0; i < tupleCount; i++) {
      let tupleDataSize = stream2.readUInt16BE();
      let tupleIndex = stream2.readUInt16BE();
      if (tupleIndex & $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD) {
        var tupleCoords = [];
        for (let a2 = 0; a2 < gvar.axisCount; a2++) tupleCoords.push(stream2.readInt16BE() / 16384);
      } else {
        if ((tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK) >= gvar.globalCoordCount) throw new Error("Invalid gvar table");
        var tupleCoords = gvar.globalCoords[tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK];
      }
      if (tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) {
        var startCoords = [];
        for (let a2 = 0; a2 < gvar.axisCount; a2++) startCoords.push(stream2.readInt16BE() / 16384);
        var endCoords = [];
        for (let a1 = 0; a1 < gvar.axisCount; a1++) endCoords.push(stream2.readInt16BE() / 16384);
      }
      let factor3 = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
      if (factor3 === 0) {
        offsetToData += tupleDataSize;
        continue;
      }
      var here = stream2.pos;
      stream2.pos = offsetToData;
      if (tupleIndex & $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS) var points = this.decodePoints();
      else var points = sharedPoints;
      let nPoints = points.length === 0 ? glyphPoints.length : points.length;
      let xDeltas = this.decodeDeltas(nPoints);
      let yDeltas = this.decodeDeltas(nPoints);
      if (points.length === 0) for (let i2 = 0; i2 < glyphPoints.length; i2++) {
        var point = glyphPoints[i2];
        point.x += Math.round(xDeltas[i2] * factor3);
        point.y += Math.round(yDeltas[i2] * factor3);
      }
      else {
        let outPoints = origPoints.map((pt) => pt.copy());
        let hasDelta = glyphPoints.map(() => false);
        for (let i2 = 0; i2 < points.length; i2++) {
          let idx = points[i2];
          if (idx < glyphPoints.length) {
            let point2 = outPoints[idx];
            hasDelta[idx] = true;
            point2.x += Math.round(xDeltas[i2] * factor3);
            point2.y += Math.round(yDeltas[i2] * factor3);
          }
        }
        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);
        for (let i1 = 0; i1 < glyphPoints.length; i1++) {
          let deltaX = outPoints[i1].x - origPoints[i1].x;
          let deltaY = outPoints[i1].y - origPoints[i1].y;
          glyphPoints[i1].x += deltaX;
          glyphPoints[i1].y += deltaY;
        }
      }
      offsetToData += tupleDataSize;
      stream2.pos = here;
    }
  }
  decodePoints() {
    let stream2 = this.font.stream;
    let count = stream2.readUInt8();
    if (count & $0bb840cac04e911b$var$POINTS_ARE_WORDS) count = (count & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) << 8 | stream2.readUInt8();
    let points = new Uint16Array(count);
    let i = 0;
    let point = 0;
    while (i < count) {
      let run = stream2.readUInt8();
      let runCount = (run & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) + 1;
      let fn = run & $0bb840cac04e911b$var$POINTS_ARE_WORDS ? stream2.readUInt16 : stream2.readUInt8;
      for (let j = 0; j < runCount && i < count; j++) {
        point += fn.call(stream2);
        points[i++] = point;
      }
    }
    return points;
  }
  decodeDeltas(count) {
    let stream2 = this.font.stream;
    let i = 0;
    let deltas = new Int16Array(count);
    while (i < count) {
      let run = stream2.readUInt8();
      let runCount = (run & $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK) + 1;
      if (run & $0bb840cac04e911b$var$DELTAS_ARE_ZERO) i += runCount;
      else {
        let fn = run & $0bb840cac04e911b$var$DELTAS_ARE_WORDS ? stream2.readInt16BE : stream2.readInt8;
        for (let j = 0; j < runCount && i < count; j++) deltas[i++] = fn.call(stream2);
      }
    }
    return deltas;
  }
  tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {
    let normalized = this.normalizedCoords;
    let { gvar } = this.font;
    let factor3 = 1;
    for (let i = 0; i < gvar.axisCount; i++) {
      if (tupleCoords[i] === 0) continue;
      if (normalized[i] === 0) return 0;
      if ((tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) === 0) {
        if (normalized[i] < Math.min(0, tupleCoords[i]) || normalized[i] > Math.max(0, tupleCoords[i])) return 0;
        factor3 = (factor3 * normalized[i] + Number.EPSILON) / (tupleCoords[i] + Number.EPSILON);
      } else {
        if (normalized[i] < startCoords[i] || normalized[i] > endCoords[i]) return 0;
        else if (normalized[i] < tupleCoords[i]) factor3 = factor3 * (normalized[i] - startCoords[i] + Number.EPSILON) / (tupleCoords[i] - startCoords[i] + Number.EPSILON);
        else factor3 = factor3 * (endCoords[i] - normalized[i] + Number.EPSILON) / (endCoords[i] - tupleCoords[i] + Number.EPSILON);
      }
    }
    return factor3;
  }
  // Interpolates points without delta values.
  // Needed for the  and Q glyphs in Skia.
  // Algorithm from Freetype.
  interpolateMissingDeltas(points, inPoints, hasDelta) {
    if (points.length === 0) return;
    let point = 0;
    while (point < points.length) {
      let firstPoint = point;
      let endPoint = point;
      let pt = points[endPoint];
      while (!pt.endContour) pt = points[++endPoint];
      while (point <= endPoint && !hasDelta[point]) point++;
      if (point > endPoint) continue;
      let firstDelta = point;
      let curDelta = point;
      point++;
      while (point <= endPoint) {
        if (hasDelta[point]) {
          this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);
          curDelta = point;
        }
        point++;
      }
      if (curDelta === firstDelta) this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);
      else {
        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
        if (firstDelta > 0) this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);
      }
      point = endPoint + 1;
    }
  }
  deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {
    if (p1 > p2) return;
    let iterable = [
      "x",
      "y"
    ];
    for (let i = 0; i < iterable.length; i++) {
      let k = iterable[i];
      if (inPoints[ref1][k] > inPoints[ref2][k]) {
        var p = ref1;
        ref1 = ref2;
        ref2 = p;
      }
      let in1 = inPoints[ref1][k];
      let in2 = inPoints[ref2][k];
      let out1 = outPoints[ref1][k];
      let out2 = outPoints[ref2][k];
      if (in1 !== in2 || out1 === out2) {
        let scale4 = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
        for (let p3 = p1; p3 <= p2; p3++) {
          let out = inPoints[p3][k];
          if (out <= in1) out += out1 - in1;
          else if (out >= in2) out += out2 - in2;
          else out = out1 + (out - in1) * scale4;
          outPoints[p3][k] = out;
        }
      }
    }
  }
  deltaShift(p1, p2, ref, inPoints, outPoints) {
    let deltaX = outPoints[ref].x - inPoints[ref].x;
    let deltaY = outPoints[ref].y - inPoints[ref].y;
    if (deltaX === 0 && deltaY === 0) return;
    for (let p = p1; p <= p2; p++) if (p !== ref) {
      outPoints[p].x += deltaX;
      outPoints[p].y += deltaY;
    }
  }
  getAdvanceAdjustment(gid, table) {
    let outerIndex, innerIndex;
    if (table.advanceWidthMapping) {
      let idx = gid;
      if (idx >= table.advanceWidthMapping.mapCount) idx = table.advanceWidthMapping.mapCount - 1;
      let entryFormat = table.advanceWidthMapping.entryFormat;
      ({ outerIndex, innerIndex } = table.advanceWidthMapping.mapData[idx]);
    } else {
      outerIndex = 0;
      innerIndex = gid;
    }
    return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);
  }
  // See pseudo code from `Font Variations Overview'
  // in the OpenType specification.
  getDelta(itemStore, outerIndex, innerIndex) {
    if (outerIndex >= itemStore.itemVariationData.length) return 0;
    let varData = itemStore.itemVariationData[outerIndex];
    if (innerIndex >= varData.deltaSets.length) return 0;
    let deltaSet = varData.deltaSets[innerIndex];
    let blendVector = this.getBlendVector(itemStore, outerIndex);
    let netAdjustment = 0;
    for (let master = 0; master < varData.regionIndexCount; master++) netAdjustment += deltaSet.deltas[master] * blendVector[master];
    return netAdjustment;
  }
  getBlendVector(itemStore, outerIndex) {
    let varData = itemStore.itemVariationData[outerIndex];
    if (this.blendVectors.has(varData)) return this.blendVectors.get(varData);
    let normalizedCoords = this.normalizedCoords;
    let blendVector = [];
    for (let master = 0; master < varData.regionIndexCount; master++) {
      let scalar = 1;
      let regionIndex = varData.regionIndexes[master];
      let axes = itemStore.variationRegionList.variationRegions[regionIndex];
      for (let j = 0; j < axes.length; j++) {
        let axis = axes[j];
        let axisScalar;
        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) axisScalar = 1;
        else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) axisScalar = 1;
        else if (axis.peakCoord === 0) axisScalar = 1;
        else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) axisScalar = 0;
        else {
          if (normalizedCoords[j] === axis.peakCoord) axisScalar = 1;
          else if (normalizedCoords[j] < axis.peakCoord) axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) / (axis.peakCoord - axis.startCoord + Number.EPSILON);
          else axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) / (axis.endCoord - axis.peakCoord + Number.EPSILON);
        }
        scalar *= axisScalar;
      }
      blendVector[master] = scalar;
    }
    this.blendVectors.set(varData, blendVector);
    return blendVector;
  }
  constructor(font2, coords) {
    this.font = font2;
    this.normalizedCoords = this.normalizeCoords(coords);
    this.blendVectors = /* @__PURE__ */ new Map();
  }
};
var $5cc7476da92df375$var$resolved = Promise.resolve();
var $5cc7476da92df375$export$2e2bcd8739ae039 = class {
  includeGlyph(glyph) {
    if (typeof glyph === "object") glyph = glyph.id;
    if (this.mapping[glyph] == null) {
      this.glyphs.push(glyph);
      this.mapping[glyph] = this.glyphs.length - 1;
    }
    return this.mapping[glyph];
  }
  constructor(font2) {
    this.font = font2;
    this.glyphs = [];
    this.mapping = {};
    this.includeGlyph(0);
  }
};
var $807e58506be70005$var$ON_CURVE = 1;
var $807e58506be70005$var$X_SHORT_VECTOR = 2;
var $807e58506be70005$var$Y_SHORT_VECTOR = 4;
var $807e58506be70005$var$REPEAT = 8;
var $807e58506be70005$var$SAME_X = 16;
var $807e58506be70005$var$SAME_Y = 32;
var $807e58506be70005$var$Point = class {
  static size(val) {
    return val >= 0 && val <= 255 ? 1 : 2;
  }
  static encode(stream2, value2) {
    if (value2 >= 0 && value2 <= 255) stream2.writeUInt8(value2);
    else stream2.writeInt16BE(value2);
  }
};
var $807e58506be70005$var$Glyf = new Struct({
  numberOfContours: int16,
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16,
  endPtsOfContours: new ArrayT(uint16, "numberOfContours"),
  instructions: new ArrayT(uint8, uint16),
  flags: new ArrayT(uint8, 0),
  xPoints: new ArrayT($807e58506be70005$var$Point, 0),
  yPoints: new ArrayT($807e58506be70005$var$Point, 0)
});
var $807e58506be70005$export$2e2bcd8739ae039 = class {
  encodeSimple(path2, instructions = []) {
    let endPtsOfContours = [];
    let xPoints = [];
    let yPoints = [];
    let flags = [];
    let same = 0;
    let lastX = 0, lastY = 0, lastFlag = 0;
    let pointCount = 0;
    for (let i = 0; i < path2.commands.length; i++) {
      let c2 = path2.commands[i];
      for (let j = 0; j < c2.args.length; j += 2) {
        let x = c2.args[j];
        let y = c2.args[j + 1];
        let flag = 0;
        if (c2.command === "quadraticCurveTo" && j === 2) {
          let next = path2.commands[i + 1];
          if (next && next.command === "quadraticCurveTo") {
            let midX = (lastX + next.args[0]) / 2;
            let midY = (lastY + next.args[1]) / 2;
            if (x === midX && y === midY) continue;
          }
        }
        if (!(c2.command === "quadraticCurveTo" && j === 0)) flag |= $807e58506be70005$var$ON_CURVE;
        flag = this._encodePoint(x, lastX, xPoints, flag, $807e58506be70005$var$X_SHORT_VECTOR, $807e58506be70005$var$SAME_X);
        flag = this._encodePoint(y, lastY, yPoints, flag, $807e58506be70005$var$Y_SHORT_VECTOR, $807e58506be70005$var$SAME_Y);
        if (flag === lastFlag && same < 255) {
          flags[flags.length - 1] |= $807e58506be70005$var$REPEAT;
          same++;
        } else {
          if (same > 0) {
            flags.push(same);
            same = 0;
          }
          flags.push(flag);
          lastFlag = flag;
        }
        lastX = x;
        lastY = y;
        pointCount++;
      }
      if (c2.command === "closePath") endPtsOfContours.push(pointCount - 1);
    }
    if (path2.commands.length > 1 && path2.commands[path2.commands.length - 1].command !== "closePath") endPtsOfContours.push(pointCount - 1);
    let bbox = path2.bbox;
    let glyf = {
      numberOfContours: endPtsOfContours.length,
      xMin: bbox.minX,
      yMin: bbox.minY,
      xMax: bbox.maxX,
      yMax: bbox.maxY,
      endPtsOfContours,
      instructions,
      flags,
      xPoints,
      yPoints
    };
    let size = $807e58506be70005$var$Glyf.size(glyf);
    let tail = 4 - size % 4;
    let stream2 = new EncodeStream(size + tail);
    $807e58506be70005$var$Glyf.encode(stream2, glyf);
    if (tail !== 0) stream2.fill(0, tail);
    return stream2.buffer;
  }
  _encodePoint(value2, last3, points, flag, shortFlag, sameFlag) {
    let diff = value2 - last3;
    if (value2 === last3) flag |= sameFlag;
    else {
      if (-255 <= diff && diff <= 255) {
        flag |= shortFlag;
        if (diff < 0) diff = -diff;
        else flag |= sameFlag;
      }
      points.push(diff);
    }
    return flag;
  }
};
var $4abbb6a5dbdc441a$export$2e2bcd8739ae039 = class extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {
  _addGlyph(gid) {
    let glyph = this.font.getGlyph(gid);
    let glyf = glyph._decode();
    let curOffset = this.font.loca.offsets[gid];
    let nextOffset = this.font.loca.offsets[gid + 1];
    let stream2 = this.font._getTableStream("glyf");
    stream2.pos += curOffset;
    let buffer = stream2.readBuffer(nextOffset - curOffset);
    if (glyf && glyf.numberOfContours < 0) {
      buffer = new Uint8Array(buffer);
      let view = new DataView(buffer.buffer);
      for (let component of glyf.components) {
        gid = this.includeGlyph(component.glyphID);
        view.setUint16(component.pos, gid);
      }
    } else if (glyf && this.font._variationProcessor)
      buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);
    this.glyf.push(buffer);
    this.loca.offsets.push(this.offset);
    this.hmtx.metrics.push({
      advance: glyph.advanceWidth,
      bearing: glyph._getMetrics().leftBearing
    });
    this.offset += buffer.length;
    return this.glyf.length - 1;
  }
  encode() {
    this.glyf = [];
    this.offset = 0;
    this.loca = {
      offsets: [],
      version: this.font.loca.version
    };
    this.hmtx = {
      metrics: [],
      bearings: []
    };
    let i = 0;
    while (i < this.glyphs.length) this._addGlyph(this.glyphs[i++]);
    let maxp = (0, import_clone.default)(this.font.maxp);
    maxp.numGlyphs = this.glyf.length;
    this.loca.offsets.push(this.offset);
    let head = (0, import_clone.default)(this.font.head);
    head.indexToLocFormat = this.loca.version;
    let hhea = (0, import_clone.default)(this.font.hhea);
    hhea.numberOfMetrics = this.hmtx.metrics.length;
    return (0, $816c07a04b6dba87$export$2e2bcd8739ae039).toBuffer({
      tables: {
        head,
        hhea,
        loca: this.loca,
        maxp,
        "cvt ": this.font["cvt "],
        prep: this.font.prep,
        glyf: this.glyf,
        hmtx: this.hmtx,
        fpgm: this.font.fpgm
      }
    });
  }
  constructor(font2) {
    super(font2);
    this.glyphEncoder = new (0, $807e58506be70005$export$2e2bcd8739ae039)();
  }
};
var $001d739428a71d5a$export$2e2bcd8739ae039 = class extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {
  subsetCharstrings() {
    this.charstrings = [];
    let gsubrs = {};
    for (let gid of this.glyphs) {
      this.charstrings.push(this.cff.getCharString(gid));
      let glyph = this.font.getGlyph(gid);
      let path2 = glyph.path;
      for (let subr in glyph._usedGsubrs) gsubrs[subr] = true;
    }
    this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
  }
  subsetSubrs(subrs, used) {
    let res = [];
    for (let i = 0; i < subrs.length; i++) {
      let subr = subrs[i];
      if (used[i]) {
        this.cff.stream.pos = subr.offset;
        res.push(this.cff.stream.readBuffer(subr.length));
      } else res.push(new Uint8Array([
        11
      ]));
    }
    return res;
  }
  subsetFontdict(topDict) {
    topDict.FDArray = [];
    topDict.FDSelect = {
      version: 0,
      fds: []
    };
    let used_fds = {};
    let used_subrs = [];
    let fd_select = {};
    for (let gid of this.glyphs) {
      let fd = this.cff.fdForGlyph(gid);
      if (fd == null) continue;
      if (!used_fds[fd]) {
        topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));
        used_subrs.push({});
        fd_select[fd] = topDict.FDArray.length - 1;
      }
      used_fds[fd] = true;
      topDict.FDSelect.fds.push(fd_select[fd]);
      let glyph = this.font.getGlyph(gid);
      let path2 = glyph.path;
      for (let subr in glyph._usedSubrs) used_subrs[fd_select[fd]][subr] = true;
    }
    for (let i = 0; i < topDict.FDArray.length; i++) {
      let dict = topDict.FDArray[i];
      delete dict.FontName;
      if (dict.Private && dict.Private.Subrs) {
        dict.Private = Object.assign({}, dict.Private);
        dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i]);
      }
    }
    return;
  }
  createCIDFontdict(topDict) {
    let used_subrs = {};
    for (let gid of this.glyphs) {
      let glyph = this.font.getGlyph(gid);
      let path2 = glyph.path;
      for (let subr in glyph._usedSubrs) used_subrs[subr] = true;
    }
    let privateDict = Object.assign({}, this.cff.topDict.Private);
    if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
    topDict.FDArray = [
      {
        Private: privateDict
      }
    ];
    return topDict.FDSelect = {
      version: 3,
      nRanges: 1,
      ranges: [
        {
          first: 0,
          fd: 0
        }
      ],
      sentinel: this.charstrings.length
    };
  }
  addString(string) {
    if (!string) return null;
    if (!this.strings) this.strings = [];
    this.strings.push(string);
    return (0, $229224aec43783c5$export$2e2bcd8739ae039).length + this.strings.length - 1;
  }
  encode() {
    this.subsetCharstrings();
    let charset = {
      version: this.charstrings.length > 255 ? 2 : 1,
      ranges: [
        {
          first: 1,
          nLeft: this.charstrings.length - 2
        }
      ]
    };
    let topDict = Object.assign({}, this.cff.topDict);
    topDict.Private = null;
    topDict.charset = charset;
    topDict.Encoding = null;
    topDict.CharStrings = this.charstrings;
    for (let key of [
      "version",
      "Notice",
      "Copyright",
      "FullName",
      "FamilyName",
      "Weight",
      "PostScript",
      "BaseFontName",
      "FontName"
    ]) topDict[key] = this.addString(this.cff.string(topDict[key]));
    topDict.ROS = [
      this.addString("Adobe"),
      this.addString("Identity"),
      0
    ];
    topDict.CIDCount = this.charstrings.length;
    if (this.cff.isCIDFont) this.subsetFontdict(topDict);
    else this.createCIDFontdict(topDict);
    let top = {
      version: 1,
      hdrSize: this.cff.hdrSize,
      offSize: 4,
      header: this.cff.header,
      nameIndex: [
        this.cff.postscriptName
      ],
      topDictIndex: [
        topDict
      ],
      stringIndex: this.strings,
      globalSubrIndex: this.gsubrs
    };
    return (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).toBuffer(top);
  }
  constructor(font2) {
    super(font2);
    this.cff = this.font["CFF "];
    if (!this.cff) throw new Error("Not a CFF Font");
  }
};
var $4c1709dee528ea76$export$2e2bcd8739ae039 = class _$4c1709dee528ea76$export$2e2bcd8739ae039 {
  static probe(buffer) {
    let format3 = (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4));
    return format3 === "true" || format3 === "OTTO" || format3 === String.fromCharCode(0, 1, 0, 0);
  }
  setDefaultLanguage(lang = null) {
    this.defaultLanguage = lang;
  }
  _getTable(table) {
    if (!(table.tag in this._tables)) try {
      this._tables[table.tag] = this._decodeTable(table);
    } catch (e) {
      if ($d636bc798e7178db$export$bd5c5d8b8dcafd78) {
        console.error(`Error decoding table ${table.tag}`);
        console.error(e.stack);
      }
    }
    return this._tables[table.tag];
  }
  _getTableStream(tag) {
    let table = this.directory.tables[tag];
    if (table) {
      this.stream.pos = table.offset;
      return this.stream;
    }
    return null;
  }
  _decodeDirectory() {
    return this.directory = (0, $816c07a04b6dba87$export$2e2bcd8739ae039).decode(this.stream, {
      _startOffset: 0
    });
  }
  _decodeTable(table) {
    let pos = this.stream.pos;
    let stream2 = this._getTableStream(table.tag);
    let result = (0, $c3395722bea751e2$export$2e2bcd8739ae039)[table.tag].decode(stream2, this, table.length);
    this.stream.pos = pos;
    return result;
  }
  /**
  * Gets a string from the font's `name` table
  * `lang` is a BCP-47 language code.
  * @return {string}
  */
  getName(key, lang = this.defaultLanguage || $d636bc798e7178db$export$42940898df819940) {
    let record = this.name && this.name.records[key];
    if (record)
      return record[lang] || record[this.defaultLanguage] || record[$d636bc798e7178db$export$42940898df819940] || record["en"] || record[Object.keys(record)[0]] || null;
    return null;
  }
  /**
  * The unique PostScript name for this font, e.g. "Helvetica-Bold"
  * @type {string}
  */
  get postscriptName() {
    return this.getName("postscriptName");
  }
  /**
  * The font's full name, e.g. "Helvetica Bold"
  * @type {string}
  */
  get fullName() {
    return this.getName("fullName");
  }
  /**
  * The font's family name, e.g. "Helvetica"
  * @type {string}
  */
  get familyName() {
    return this.getName("fontFamily");
  }
  /**
  * The font's sub-family, e.g. "Bold".
  * @type {string}
  */
  get subfamilyName() {
    return this.getName("fontSubfamily");
  }
  /**
  * The font's copyright information
  * @type {string}
  */
  get copyright() {
    return this.getName("copyright");
  }
  /**
  * The font's version number
  * @type {string}
  */
  get version() {
    return this.getName("version");
  }
  /**
  * The fonts [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))
  * @type {number}
  */
  get ascent() {
    return this.hhea.ascent;
  }
  /**
  * The fonts [descender](https://en.wikipedia.org/wiki/Descender)
  * @type {number}
  */
  get descent() {
    return this.hhea.descent;
  }
  /**
  * The amount of space that should be included between lines
  * @type {number}
  */
  get lineGap() {
    return this.hhea.lineGap;
  }
  /**
  * The offset from the normal underline position that should be used
  * @type {number}
  */
  get underlinePosition() {
    return this.post.underlinePosition;
  }
  /**
  * The weight of the underline that should be used
  * @type {number}
  */
  get underlineThickness() {
    return this.post.underlineThickness;
  }
  /**
  * If this is an italic font, the angle the cursor should be drawn at to match the font design
  * @type {number}
  */
  get italicAngle() {
    return this.post.italicAngle;
  }
  /**
  * The height of capital letters above the baseline.
  * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.
  * @type {number}
  */
  get capHeight() {
    let os2 = this["OS/2"];
    return os2 ? os2.capHeight : this.ascent;
  }
  /**
  * The height of lower case letters in the font.
  * See [here](https://en.wikipedia.org/wiki/X-height) for more details.
  * @type {number}
  */
  get xHeight() {
    let os2 = this["OS/2"];
    return os2 ? os2.xHeight : 0;
  }
  /**
  * The number of glyphs in the font.
  * @type {number}
  */
  get numGlyphs() {
    return this.maxp.numGlyphs;
  }
  /**
  * The size of the fonts internal coordinate grid
  * @type {number}
  */
  get unitsPerEm() {
    return this.head.unitsPerEm;
  }
  /**
  * The fonts bounding box, i.e. the box that encloses all glyphs in the font.
  * @type {BBox}
  */
  get bbox() {
    return Object.freeze(new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
  }
  get _cmapProcessor() {
    return new (0, $f08dd41ef10b694c$export$2e2bcd8739ae039)(this.cmap);
  }
  /**
  * An array of all of the unicode code points supported by the font.
  * @type {number[]}
  */
  get characterSet() {
    return this._cmapProcessor.getCharacterSet();
  }
  /**
  * Returns whether there is glyph in the font for the given unicode code point.
  *
  * @param {number} codePoint
  * @return {boolean}
  */
  hasGlyphForCodePoint(codePoint) {
    return !!this._cmapProcessor.lookup(codePoint);
  }
  /**
  * Maps a single unicode code point to a Glyph object.
  * Does not perform any advanced substitutions (there is no context to do so).
  *
  * @param {number} codePoint
  * @return {Glyph}
  */
  glyphForCodePoint(codePoint) {
    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [
      codePoint
    ]);
  }
  /**
  * Returns an array of Glyph objects for the given string.
  * This is only a one-to-one mapping from characters to glyphs.
  * For most uses, you should use font.layout (described below), which
  * provides a much more advanced mapping supporting AAT and OpenType shaping.
  *
  * @param {string} string
  * @return {Glyph[]}
  */
  glyphsForString(string) {
    let glyphs = [];
    let len = string.length;
    let idx = 0;
    let last3 = -1;
    let state2 = -1;
    while (idx <= len) {
      let code = 0;
      let nextState = 0;
      if (idx < len) {
        code = string.charCodeAt(idx++);
        if (55296 <= code && code <= 56319 && idx < len) {
          let next = string.charCodeAt(idx);
          if (56320 <= next && next <= 57343) {
            idx++;
            code = ((code & 1023) << 10) + (next & 1023) + 65536;
          }
        }
        nextState = 65024 <= code && code <= 65039 || 917760 <= code && code <= 917999 ? 1 : 0;
      } else idx++;
      if (state2 === 0 && nextState === 1)
        glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last3, code), [
          last3,
          code
        ]));
      else if (state2 === 0 && nextState === 0)
        glyphs.push(this.glyphForCodePoint(last3));
      last3 = code;
      state2 = nextState;
    }
    return glyphs;
  }
  get _layoutEngine() {
    return new (0, $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039)(this);
  }
  /**
  * Returns a GlyphRun object, which includes an array of Glyphs and GlyphPositions for the given string.
  *
  * @param {string} string
  * @param {string[]} [userFeatures]
  * @param {string} [script]
  * @param {string} [language]
  * @param {string} [direction]
  * @return {GlyphRun}
  */
  layout(string, userFeatures, script, language, direction) {
    return this._layoutEngine.layout(string, userFeatures, script, language, direction);
  }
  /**
  * Returns an array of strings that map to the given glyph id.
  * @param {number} gid - glyph id
  */
  stringsForGlyph(gid) {
    return this._layoutEngine.stringsForGlyph(gid);
  }
  /**
  * An array of all [OpenType feature tags](https://www.microsoft.com/typography/otspec/featuretags.htm)
  * (or mapped AAT tags) supported by the font.
  * The features parameter is an array of OpenType feature tags to be applied in addition to the default set.
  * If this is an AAT font, the OpenType feature tags are mapped to AAT features.
  *
  * @type {string[]}
  */
  get availableFeatures() {
    return this._layoutEngine.getAvailableFeatures();
  }
  getAvailableFeatures(script, language) {
    return this._layoutEngine.getAvailableFeatures(script, language);
  }
  _getBaseGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.glyf) this._glyphs[glyph] = new (0, $69aac16029968692$export$2e2bcd8739ae039)(glyph, characters2, this);
      else if (this.directory.tables["CFF "] || this.directory.tables.CFF2) this._glyphs[glyph] = new (0, $62cc5109c6101893$export$2e2bcd8739ae039)(glyph, characters2, this);
    }
    return this._glyphs[glyph] || null;
  }
  /**
  * Returns a glyph object for the given glyph id.
  * You can pass the array of code points this glyph represents for
  * your use later, and it will be stored in the glyph object.
  *
  * @param {number} glyph
  * @param {number[]} characters
  * @return {Glyph}
  */
  getGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.sbix) this._glyphs[glyph] = new (0, $25d8f049c222084c$export$2e2bcd8739ae039)(glyph, characters2, this);
      else if (this.directory.tables.COLR && this.directory.tables.CPAL) this._glyphs[glyph] = new (0, $0d411f0165859681$export$2e2bcd8739ae039)(glyph, characters2, this);
      else this._getBaseGlyph(glyph, characters2);
    }
    return this._glyphs[glyph] || null;
  }
  /**
  * Returns a Subset for this font.
  * @return {Subset}
  */
  createSubset() {
    if (this.directory.tables["CFF "]) return new (0, $001d739428a71d5a$export$2e2bcd8739ae039)(this);
    return new (0, $4abbb6a5dbdc441a$export$2e2bcd8739ae039)(this);
  }
  /**
  * Returns an object describing the available variation axes
  * that this font supports. Keys are setting tags, and values
  * contain the axis name, range, and default value.
  *
  * @type {object}
  */
  get variationAxes() {
    let res = {};
    if (!this.fvar) return res;
    for (let axis of this.fvar.axis) res[axis.axisTag.trim()] = {
      name: axis.name.en,
      min: axis.minValue,
      default: axis.defaultValue,
      max: axis.maxValue
    };
    return res;
  }
  /**
  * Returns an object describing the named variation instances
  * that the font designer has specified. Keys are variation names
  * and values are the variation settings for this instance.
  *
  * @type {object}
  */
  get namedVariations() {
    let res = {};
    if (!this.fvar) return res;
    for (let instance of this.fvar.instance) {
      let settings = {};
      for (let i = 0; i < this.fvar.axis.length; i++) {
        let axis = this.fvar.axis[i];
        settings[axis.axisTag.trim()] = instance.coord[i];
      }
      res[instance.name.en] = settings;
    }
    return res;
  }
  /**
  * Returns a new font with the given variation settings applied.
  * Settings can either be an instance name, or an object containing
  * variation tags as specified by the `variationAxes` property.
  *
  * @param {object} settings
  * @return {TTFFont}
  */
  getVariation(settings) {
    if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2))) throw new Error("Variations require a font with the fvar, gvar and glyf, or CFF2 tables.");
    if (typeof settings === "string") settings = this.namedVariations[settings];
    if (typeof settings !== "object") throw new Error("Variation settings must be either a variation name or settings object.");
    let coords = this.fvar.axis.map((axis, i) => {
      let axisTag = axis.axisTag.trim();
      if (axisTag in settings) return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));
      else return axis.defaultValue;
    });
    let stream2 = new DecodeStream(this.stream.buffer);
    stream2.pos = this._directoryPos;
    let font2 = new _$4c1709dee528ea76$export$2e2bcd8739ae039(stream2, coords);
    font2._tables = this._tables;
    return font2;
  }
  get _variationProcessor() {
    if (!this.fvar) return null;
    let variationCoords = this.variationCoords;
    if (!variationCoords && !this.CFF2) return null;
    if (!variationCoords) variationCoords = this.fvar.axis.map((axis) => axis.defaultValue);
    return new (0, $0bb840cac04e911b$export$2e2bcd8739ae039)(this, variationCoords);
  }
  // Standardized format plugin API
  getFont(name2) {
    return this.getVariation(name2);
  }
  constructor(stream2, variationCoords = null) {
    (0, _define_property)(this, "type", "TTF");
    this.defaultLanguage = null;
    this.stream = stream2;
    this.variationCoords = variationCoords;
    this._directoryPos = this.stream.pos;
    this._tables = {};
    this._glyphs = {};
    this._decodeDirectory();
    for (let tag in this.directory.tables) {
      let table = this.directory.tables[tag];
      if ((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag] && table.length > 0) Object.defineProperty(this, tag, {
        get: this._getTable.bind(this, table)
      });
    }
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "bbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_cmapProcessor", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "characterSet", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_layoutEngine", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "variationAxes", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "namedVariations", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_variationProcessor", null);
var $c1726355ecc5b889$var$WOFFDirectoryEntry = new Struct({
  tag: new StringT(4),
  offset: new Pointer(uint32, "void", {
    type: "global"
  }),
  compLength: uint32,
  length: uint32,
  origChecksum: uint32
});
var $c1726355ecc5b889$var$WOFFDirectory = new Struct({
  tag: new StringT(4),
  flavor: uint32,
  length: uint32,
  numTables: uint16,
  reserved: new Reserved(uint16),
  totalSfntSize: uint32,
  majorVersion: uint16,
  minorVersion: uint16,
  metaOffset: uint32,
  metaLength: uint32,
  metaOrigLength: uint32,
  privOffset: uint32,
  privLength: uint32,
  tables: new ArrayT($c1726355ecc5b889$var$WOFFDirectoryEntry, "numTables")
});
$c1726355ecc5b889$var$WOFFDirectory.process = function() {
  let tables1 = {};
  for (let table of this.tables) tables1[table.tag] = table;
  this.tables = tables1;
};
var $c1726355ecc5b889$export$2e2bcd8739ae039 = $c1726355ecc5b889$var$WOFFDirectory;
var $760785214b9fc52c$export$2e2bcd8739ae039 = class extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "wOFF";
  }
  _decodeDirectory() {
    this.directory = (0, $c1726355ecc5b889$export$2e2bcd8739ae039).decode(this.stream, {
      _startOffset: 0
    });
  }
  _getTableStream(tag) {
    let table = this.directory.tables[tag];
    if (table) {
      this.stream.pos = table.offset;
      if (table.compLength < table.length) {
        this.stream.pos += 2;
        let outBuffer = new Uint8Array(table.length);
        let buf = (0, import_tiny_inflate.default)(this.stream.readBuffer(table.compLength - 2), outBuffer);
        return new DecodeStream(buf);
      } else return this.stream;
    }
    return null;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF");
  }
};
var $8046190c9f1ad19e$export$2e2bcd8739ae039 = class extends (0, $69aac16029968692$export$2e2bcd8739ae039) {
  _decode() {
    return this._font._transformedGlyphs[this.id];
  }
  _getCBox() {
    return this.path.bbox;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF2");
  }
};
var $c28ec7bbb3b8de3a$var$Base128 = {
  decode(stream2) {
    let result = 0;
    let iterable = [
      0,
      1,
      2,
      3,
      4
    ];
    for (let j = 0; j < iterable.length; j++) {
      let i = iterable[j];
      let code = stream2.readUInt8();
      if (result & 3758096384) throw new Error("Overflow");
      result = result << 7 | code & 127;
      if ((code & 128) === 0) return result;
    }
    throw new Error("Bad base 128 number");
  }
};
var $c28ec7bbb3b8de3a$var$knownTags = [
  "cmap",
  "head",
  "hhea",
  "hmtx",
  "maxp",
  "name",
  "OS/2",
  "post",
  "cvt ",
  "fpgm",
  "glyf",
  "loca",
  "prep",
  "CFF ",
  "VORG",
  "EBDT",
  "EBLC",
  "gasp",
  "hdmx",
  "kern",
  "LTSH",
  "PCLT",
  "VDMX",
  "vhea",
  "vmtx",
  "BASE",
  "GDEF",
  "GPOS",
  "GSUB",
  "EBSC",
  "JSTF",
  "MATH",
  "CBDT",
  "CBLC",
  "COLR",
  "CPAL",
  "SVG ",
  "sbix",
  "acnt",
  "avar",
  "bdat",
  "bloc",
  "bsln",
  "cvar",
  "fdsc",
  "feat",
  "fmtx",
  "fvar",
  "gvar",
  "hsty",
  "just",
  "lcar",
  "mort",
  "morx",
  "opbd",
  "prop",
  "trak",
  "Zapf",
  "Silf",
  "Glat",
  "Gloc",
  "Feat",
  "Sill"
];
var $c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry = new Struct({
  flags: uint8,
  customTag: new Optional(new StringT(4), (t2) => (t2.flags & 63) === 63),
  tag: (t2) => t2.customTag || $c28ec7bbb3b8de3a$var$knownTags[t2.flags & 63],
  length: $c28ec7bbb3b8de3a$var$Base128,
  transformVersion: (t2) => t2.flags >>> 6 & 3,
  transformed: (t2) => t2.tag === "glyf" || t2.tag === "loca" ? t2.transformVersion === 0 : t2.transformVersion !== 0,
  transformLength: new Optional($c28ec7bbb3b8de3a$var$Base128, (t2) => t2.transformed)
});
var $c28ec7bbb3b8de3a$var$WOFF2Directory = new Struct({
  tag: new StringT(4),
  flavor: uint32,
  length: uint32,
  numTables: uint16,
  reserved: new Reserved(uint16),
  totalSfntSize: uint32,
  totalCompressedSize: uint32,
  majorVersion: uint16,
  minorVersion: uint16,
  metaOffset: uint32,
  metaLength: uint32,
  metaOrigLength: uint32,
  privOffset: uint32,
  privLength: uint32,
  tables: new ArrayT($c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry, "numTables")
});
$c28ec7bbb3b8de3a$var$WOFF2Directory.process = function() {
  let tables = {};
  for (let i = 0; i < this.tables.length; i++) {
    let table = this.tables[i];
    tables[table.tag] = table;
  }
  return this.tables = tables;
};
var $c28ec7bbb3b8de3a$export$2e2bcd8739ae039 = $c28ec7bbb3b8de3a$var$WOFF2Directory;
var $21ee218f84ac7f32$export$2e2bcd8739ae039 = class extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "wOF2";
  }
  _decodeDirectory() {
    this.directory = (0, $c28ec7bbb3b8de3a$export$2e2bcd8739ae039).decode(this.stream);
    this._dataPos = this.stream.pos;
  }
  _decompress() {
    if (!this._decompressed) {
      this.stream.pos = this._dataPos;
      let buffer = this.stream.readBuffer(this.directory.totalCompressedSize);
      let decompressedSize = 0;
      for (let tag in this.directory.tables) {
        let entry = this.directory.tables[tag];
        entry.offset = decompressedSize;
        decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;
      }
      let decompressed = (0, import_decompress.default)(buffer, decompressedSize);
      if (!decompressed) throw new Error("Error decoding compressed data in WOFF2");
      this.stream = new DecodeStream(decompressed);
      this._decompressed = true;
    }
  }
  _decodeTable(table) {
    this._decompress();
    return super._decodeTable(table);
  }
  // Override this method to get a glyph and return our
  // custom subclass if there is a glyf table.
  _getBaseGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {
        if (!this._transformedGlyphs) this._transformGlyfTable();
        return this._glyphs[glyph] = new (0, $8046190c9f1ad19e$export$2e2bcd8739ae039)(glyph, characters2, this);
      } else return super._getBaseGlyph(glyph, characters2);
    }
  }
  _transformGlyfTable() {
    this._decompress();
    this.stream.pos = this.directory.tables.glyf.offset;
    let table = $21ee218f84ac7f32$var$GlyfTable.decode(this.stream);
    let glyphs = [];
    for (let index2 = 0; index2 < table.numGlyphs; index2++) {
      let glyph = {};
      let nContours = table.nContours.readInt16BE();
      glyph.numberOfContours = nContours;
      if (nContours > 0) {
        let nPoints = [];
        let totalPoints = 0;
        for (let i = 0; i < nContours; i++) {
          let r1 = $21ee218f84ac7f32$var$read255UInt16(table.nPoints);
          totalPoints += r1;
          nPoints.push(totalPoints);
        }
        glyph.points = $21ee218f84ac7f32$var$decodeTriplet(table.flags, table.glyphs, totalPoints);
        for (let i1 = 0; i1 < nContours; i1++) glyph.points[nPoints[i1] - 1].endContour = true;
        var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);
      } else if (nContours < 0) {
        let haveInstructions = (0, $69aac16029968692$export$2e2bcd8739ae039).prototype._decodeComposite.call({
          _font: this
        }, glyph, table.composites);
        if (haveInstructions) var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);
      }
      glyphs.push(glyph);
    }
    this._transformedGlyphs = glyphs;
  }
  constructor(...args) {
    super(...args);
    (0, _define_property)(this, "type", "WOFF2");
  }
};
var $21ee218f84ac7f32$var$Substream = class {
  decode(stream2, parent) {
    return new DecodeStream(this._buf.decode(stream2, parent));
  }
  constructor(length4) {
    this.length = length4;
    this._buf = new BufferT(length4);
  }
};
var $21ee218f84ac7f32$var$GlyfTable = new Struct({
  version: uint32,
  numGlyphs: uint16,
  indexFormat: uint16,
  nContourStreamSize: uint32,
  nPointsStreamSize: uint32,
  flagStreamSize: uint32,
  glyphStreamSize: uint32,
  compositeStreamSize: uint32,
  bboxStreamSize: uint32,
  instructionStreamSize: uint32,
  nContours: new $21ee218f84ac7f32$var$Substream("nContourStreamSize"),
  nPoints: new $21ee218f84ac7f32$var$Substream("nPointsStreamSize"),
  flags: new $21ee218f84ac7f32$var$Substream("flagStreamSize"),
  glyphs: new $21ee218f84ac7f32$var$Substream("glyphStreamSize"),
  composites: new $21ee218f84ac7f32$var$Substream("compositeStreamSize"),
  bboxes: new $21ee218f84ac7f32$var$Substream("bboxStreamSize"),
  instructions: new $21ee218f84ac7f32$var$Substream("instructionStreamSize")
});
var $21ee218f84ac7f32$var$WORD_CODE = 253;
var $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2 = 254;
var $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1 = 255;
var $21ee218f84ac7f32$var$LOWEST_U_CODE = 253;
function $21ee218f84ac7f32$var$read255UInt16(stream2) {
  let code = stream2.readUInt8();
  if (code === $21ee218f84ac7f32$var$WORD_CODE) return stream2.readUInt16BE();
  if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1) return stream2.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE;
  if (code === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2) return stream2.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE * 2;
  return code;
}
function $21ee218f84ac7f32$var$withSign(flag, baseval) {
  return flag & 1 ? baseval : -baseval;
}
function $21ee218f84ac7f32$var$decodeTriplet(flags, glyphs, nPoints) {
  let y;
  let x = y = 0;
  let res = [];
  for (let i = 0; i < nPoints; i++) {
    let dx = 0, dy = 0;
    let flag = flags.readUInt8();
    let onCurve = !(flag >> 7);
    flag &= 127;
    if (flag < 10) {
      dx = 0;
      dy = $21ee218f84ac7f32$var$withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());
    } else if (flag < 20) {
      dx = $21ee218f84ac7f32$var$withSign(flag, ((flag - 10 & 14) << 7) + glyphs.readUInt8());
      dy = 0;
    } else if (flag < 84) {
      var b0 = flag - 20;
      var b1 = glyphs.readUInt8();
      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b0 & 48) + (b1 >> 4));
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + ((b0 & 12) << 2) + (b1 & 15));
    } else if (flag < 120) {
      var b0 = flag - 84;
      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b0 / 12 << 8) + glyphs.readUInt8());
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphs.readUInt8());
    } else if (flag < 124) {
      var b1 = glyphs.readUInt8();
      let b2 = glyphs.readUInt8();
      dx = $21ee218f84ac7f32$var$withSign(flag, (b1 << 4) + (b2 >> 4));
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, ((b2 & 15) << 8) + glyphs.readUInt8());
    } else {
      dx = $21ee218f84ac7f32$var$withSign(flag, glyphs.readUInt16BE());
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, glyphs.readUInt16BE());
    }
    x += dx;
    y += dy;
    res.push(new (0, $69aac16029968692$export$baf26146a414f24a)(onCurve, false, x, y));
  }
  return res;
}
var $cd5853a56c68fec7$var$TTCHeader = new VersionedStruct(uint32, {
  65536: {
    numFonts: uint32,
    offsets: new ArrayT(uint32, "numFonts")
  },
  131072: {
    numFonts: uint32,
    offsets: new ArrayT(uint32, "numFonts"),
    dsigTag: uint32,
    dsigLength: uint32,
    dsigOffset: uint32
  }
});
var $cd5853a56c68fec7$export$2e2bcd8739ae039 = class {
  static probe(buffer) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer.slice(0, 4)) === "ttcf";
  }
  getFont(name2) {
    for (let offset3 of this.header.offsets) {
      let stream2 = new DecodeStream(this.stream.buffer);
      stream2.pos = offset3;
      let font2 = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2);
      if (font2.postscriptName === name2 || font2.postscriptName instanceof Uint8Array && name2 instanceof Uint8Array && font2.postscriptName.every((v2, i) => name2[i] === v2)) return font2;
    }
    return null;
  }
  get fonts() {
    let fonts = [];
    for (let offset3 of this.header.offsets) {
      let stream2 = new DecodeStream(this.stream.buffer);
      stream2.pos = offset3;
      fonts.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2));
    }
    return fonts;
  }
  constructor(stream2) {
    (0, _define_property)(this, "type", "TTC");
    this.stream = stream2;
    if (stream2.readString(4) !== "ttcf") throw new Error("Not a TrueType collection");
    this.header = $cd5853a56c68fec7$var$TTCHeader.decode(stream2);
  }
};
var $05f49f930186144e$var$DFontName = new StringT(uint8);
var $05f49f930186144e$var$DFontData = new Struct({
  len: uint32,
  buf: new BufferT("len")
});
var $05f49f930186144e$var$Ref = new Struct({
  id: uint16,
  nameOffset: int16,
  attr: uint8,
  dataOffset: uint24,
  handle: uint32
});
var $05f49f930186144e$var$Type = new Struct({
  name: new StringT(4),
  maxTypeIndex: uint16,
  refList: new Pointer(uint16, new ArrayT($05f49f930186144e$var$Ref, (t2) => t2.maxTypeIndex + 1), {
    type: "parent"
  })
});
var $05f49f930186144e$var$TypeList = new Struct({
  length: uint16,
  types: new ArrayT($05f49f930186144e$var$Type, (t2) => t2.length + 1)
});
var $05f49f930186144e$var$DFontMap = new Struct({
  reserved: new Reserved(uint8, 24),
  typeList: new Pointer(uint16, $05f49f930186144e$var$TypeList),
  nameListOffset: new Pointer(uint16, "void")
});
var $05f49f930186144e$var$DFontHeader = new Struct({
  dataOffset: uint32,
  map: new Pointer(uint32, $05f49f930186144e$var$DFontMap),
  dataLength: uint32,
  mapLength: uint32
});
var $05f49f930186144e$export$2e2bcd8739ae039 = class {
  static probe(buffer) {
    let stream2 = new DecodeStream(buffer);
    try {
      var header = $05f49f930186144e$var$DFontHeader.decode(stream2);
    } catch (e) {
      return false;
    }
    for (let type2 of header.map.typeList.types) {
      if (type2.name === "sfnt") return true;
    }
    return false;
  }
  getFont(name2) {
    if (!this.sfnt) return null;
    for (let ref of this.sfnt.refList) {
      let pos = this.header.dataOffset + ref.dataOffset + 4;
      let stream2 = new DecodeStream(this.stream.buffer.slice(pos));
      let font2 = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2);
      if (font2.postscriptName === name2 || font2.postscriptName instanceof Uint8Array && name2 instanceof Uint8Array && font2.postscriptName.every((v2, i) => name2[i] === v2)) return font2;
    }
    return null;
  }
  get fonts() {
    let fonts = [];
    for (let ref of this.sfnt.refList) {
      let pos = this.header.dataOffset + ref.dataOffset + 4;
      let stream2 = new DecodeStream(this.stream.buffer.slice(pos));
      fonts.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2));
    }
    return fonts;
  }
  constructor(stream2) {
    (0, _define_property)(this, "type", "DFont");
    this.stream = stream2;
    this.header = $05f49f930186144e$var$DFontHeader.decode(this.stream);
    for (let type2 of this.header.map.typeList.types) {
      for (let ref of type2.refList) if (ref.nameOffset >= 0) {
        this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
        ref.name = $05f49f930186144e$var$DFontName.decode(this.stream);
      } else ref.name = null;
      if (type2.name === "sfnt") this.sfnt = type2;
    }
  }
};
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $4c1709dee528ea76$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $760785214b9fc52c$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $21ee218f84ac7f32$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $cd5853a56c68fec7$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $05f49f930186144e$export$2e2bcd8739ae039));

// ../../.yarn/cache/@react-pdf-font-npm-2.5.1-14fbe6682c-140c4b9bbb.zip/node_modules/@react-pdf/font/lib/index.browser.js
var _excluded = ["src", "fontWeight", "fontStyle"];
var FONT_WEIGHTS = {
  thin: 100,
  hairline: 100,
  ultralight: 200,
  extralight: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  demibold: 600,
  bold: 700,
  ultrabold: 800,
  extrabold: 800,
  heavy: 900,
  black: 900
};
var fetchFont = function() {
  var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(src, options) {
    var response, data2;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return (0, import_cross_fetch.default)(src, options);
        case 2:
          response = _context.sent;
          _context.next = 5;
          return response.arrayBuffer();
        case 5:
          data2 = _context.sent;
          return _context.abrupt("return", new Uint8Array(data2));
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function fetchFont2(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var isDataUrl = function isDataUrl2(dataUrl) {
  var header = dataUrl.split(",")[0];
  var hasDataPrefix = header.substring(0, 5) === "data:";
  var hasBase64Prefix = header.split(";")[1] === "base64";
  return hasDataPrefix && hasBase64Prefix;
};
var resolveFontWeight = function resolveFontWeight2(value2) {
  return typeof value2 === "string" ? FONT_WEIGHTS[value2] : value2;
};
var sortByFontWeight = function sortByFontWeight2(a2, b) {
  return a2.fontWeight - b.fontWeight;
};
var FontSource = function() {
  function FontSource2(src, fontFamily, fontStyle, fontWeight, options) {
    this.src = src;
    this.fontFamily = fontFamily;
    this.fontStyle = fontStyle || "normal";
    this.fontWeight = fontWeight || 400;
    this.data = null;
    this.options = options;
    this.loadResultPromise = null;
  }
  var _proto = FontSource2.prototype;
  _proto._load = function() {
    var _load2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2() {
      var postscriptName, raw, uint8Array, _this$options, headers, body, _this$options$method, method, data2;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            postscriptName = this.options.postscriptName;
            if (!isDataUrl(this.src)) {
              _context2.next = 7;
              break;
            }
            raw = this.src.split(",")[1];
            uint8Array = new Uint8Array(atob(raw).split("").map(function(c2) {
              return c2.charCodeAt(0);
            }));
            this.data = $d636bc798e7178db$export$185802fd694ee1f5(uint8Array, postscriptName);
            _context2.next = 19;
            break;
          case 7:
            _this$options = this.options, headers = _this$options.headers, body = _this$options.body, _this$options$method = _this$options.method, method = _this$options$method === void 0 ? "GET" : _this$options$method;
            _context2.next = 11;
            return fetchFont(this.src, {
              method,
              body,
              headers
            });
          case 11:
            data2 = _context2.sent;
            this.data = $d636bc798e7178db$export$185802fd694ee1f5(data2, postscriptName);
            _context2.next = 19;
            break;
          case 15: {
            _context2.next = 19;
            break;
          }
          case 18:
            this.data = _context2.sent;
          case 19:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function _load() {
      return _load2.apply(this, arguments);
    }
    return _load;
  }();
  _proto.load = function() {
    var _load3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3() {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if (this.loadResultPromise === null) {
              this.loadResultPromise = this._load();
            }
            return _context3.abrupt("return", this.loadResultPromise);
          case 2:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function load() {
      return _load3.apply(this, arguments);
    }
    return load;
  }();
  return FontSource2;
}();
var Font = function() {
  Font3.create = function create2(family) {
    return new Font3(family);
  };
  function Font3(family) {
    this.family = family;
    this.sources = [];
  }
  var _proto2 = Font3.prototype;
  _proto2.register = function register(_ref2) {
    var src = _ref2.src, fontWeight = _ref2.fontWeight, fontStyle = _ref2.fontStyle, options = _objectWithoutPropertiesLoose(_ref2, _excluded);
    var numericFontWeight = resolveFontWeight(fontWeight);
    this.sources.push(new FontSource(src, this.family, fontStyle, numericFontWeight, options));
  };
  _proto2.resolve = function resolve3(descriptor) {
    var _descriptor$fontWeigh = descriptor.fontWeight, fontWeight = _descriptor$fontWeigh === void 0 ? 400 : _descriptor$fontWeigh, _descriptor$fontStyle = descriptor.fontStyle, fontStyle = _descriptor$fontStyle === void 0 ? "normal" : _descriptor$fontStyle;
    var styleSources = this.sources.filter(function(s2) {
      return s2.fontStyle === fontStyle;
    });
    var exactFit = styleSources.find(function(s2) {
      return s2.fontWeight === fontWeight;
    });
    if (exactFit) return exactFit;
    var res;
    if (fontWeight >= 400 && fontWeight <= 500) {
      var leftOffset = styleSources.filter(function(s2) {
        return s2.fontWeight <= fontWeight;
      });
      var rightOffset = styleSources.filter(function(s2) {
        return s2.fontWeight > 500;
      });
      var fit = styleSources.filter(function(s2) {
        return s2.fontWeight >= fontWeight && s2.fontWeight < 500;
      });
      res = fit[0] || leftOffset[leftOffset.length - 1] || rightOffset[0];
    }
    var lt = styleSources.filter(function(s2) {
      return s2.fontWeight < fontWeight;
    }).sort(sortByFontWeight);
    var gt = styleSources.filter(function(s2) {
      return s2.fontWeight > fontWeight;
    }).sort(sortByFontWeight);
    if (fontWeight < 400) {
      res = lt[lt.length - 1] || gt[0];
    }
    if (fontWeight > 500) {
      res = gt[0] || lt[lt.length - 1];
    }
    if (!res) {
      throw new Error("Could not resolve font for " + this.family + ", fontWeight " + fontWeight);
    }
    return res;
  };
  return Font3;
}();
var standard = ["Courier", "Courier-Bold", "Courier-Oblique", "Courier-BoldOblique", "Helvetica", "Helvetica-Bold", "Helvetica-Oblique", "Helvetica-BoldOblique", "Times-Roman", "Times-Bold", "Times-Italic", "Times-BoldItalic"];
function FontStore() {
  var _this = this;
  var fonts = {};
  var emojiSource = null;
  var hyphenationCallback = null;
  this.register = function(data2) {
    var family = data2.family;
    if (!fonts[family]) {
      fonts[family] = Font.create(family);
    }
    if (data2.fonts) {
      for (var i = 0; i < data2.fonts.length; i += 1) {
        fonts[family].register(_extends({
          family
        }, data2.fonts[i]));
      }
    } else {
      fonts[family].register(data2);
    }
  };
  this.registerEmojiSource = function(_ref) {
    var url = _ref.url, _ref$format = _ref.format, format3 = _ref$format === void 0 ? "png" : _ref$format, builder = _ref.builder, _ref$withVariationSel = _ref.withVariationSelectors, withVariationSelectors = _ref$withVariationSel === void 0 ? false : _ref$withVariationSel;
    emojiSource = {
      url,
      format: format3,
      builder,
      withVariationSelectors
    };
  };
  this.registerHyphenationCallback = function(callback) {
    hyphenationCallback = callback;
  };
  this.getFont = function(descriptor) {
    var fontFamily = descriptor.fontFamily;
    var isStandard = standard.includes(fontFamily);
    if (isStandard) return null;
    if (!fonts[fontFamily]) {
      throw new Error("Font family not registered: " + fontFamily + ". Please register it calling Font.register() method.");
    }
    return fonts[fontFamily].resolve(descriptor);
  };
  this.load = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(descriptor) {
      var fontFamily, fontFamilies, promises, len, i, family, isStandard, f;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            fontFamily = descriptor.fontFamily;
            fontFamilies = typeof fontFamily === "string" ? [fontFamily] : [].concat(fontFamily || []);
            promises = [];
            len = fontFamilies.length, i = 0;
          case 4:
            if (!(i < len)) {
              _context.next = 14;
              break;
            }
            family = fontFamilies[i];
            isStandard = standard.includes(family);
            if (!isStandard) {
              _context.next = 9;
              break;
            }
            return _context.abrupt("return");
          case 9:
            f = _this.getFont(_extends({}, descriptor, {
              fontFamily: family
            }));
            promises.push(f.load());
          case 11:
            i += 1;
            _context.next = 4;
            break;
          case 14:
            _context.next = 16;
            return Promise.all(promises);
          case 16:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  this.reset = function() {
    var keys2 = Object.keys(fonts);
    for (var i = 0; i < keys2.length; i += 1) {
      var key = keys2[i];
      fonts[key].data = null;
    }
  };
  this.clear = function() {
    fonts = {};
  };
  this.getRegisteredFonts = function() {
    return fonts;
  };
  this.getEmojiSource = function() {
    return emojiSource;
  };
  this.getHyphenationCallback = function() {
    return hyphenationCallback;
  };
  this.getRegisteredFontFamilies = function() {
    return Object.keys(fonts);
  };
}

// ../../.yarn/cache/@react-pdf-fns-npm-2.2.1-77536ed89f-457bdff57e.zip/node_modules/@react-pdf/fns/lib/index.js
var adjust = function adjust2(index2, fn, collection) {
  var _Object$assign;
  if (index2 >= 0 && index2 >= collection.length) return collection;
  if (index2 < 0 && Math.abs(index2) > collection.length) return collection;
  var i = index2 < 0 ? collection.length + index2 : index2;
  return Object.assign([], collection, (_Object$assign = {}, _Object$assign[i] = fn(collection[i]), _Object$assign));
};
var reverse = function reverse2(list) {
  return Array.prototype.slice.call(list, 0).reverse();
};
var asyncCompose = function asyncCompose2() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(value2) {
      var result, reversedFns, _len2, args, _key2, i, fn, _args = arguments;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            result = value2;
            reversedFns = reverse(fns);
            for (_len2 = _args.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = _args[_key2];
            }
            i = 0;
          case 4:
            if (!(i < reversedFns.length)) {
              _context.next = 12;
              break;
            }
            fn = reversedFns[i];
            _context.next = 8;
            return fn.apply(void 0, [result].concat(args));
          case 8:
            result = _context.sent;
          case 9:
            i += 1;
            _context.next = 4;
            break;
          case 12:
            return _context.abrupt("return", result);
          case 13:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function(_x) {
      return _ref.apply(this, arguments);
    };
  }();
};
var capitalize = function capitalize2(value2) {
  if (!value2) return value2;
  return value2.replace(/(^|\s)\S/g, function(l2) {
    return l2.toUpperCase();
  });
};
var castArray = function castArray2(value2) {
  return Array.isArray(value2) ? value2 : [value2];
};
var compose = function compose2() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function(value2) {
    var result = value2;
    var reversedFns = reverse(fns);
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    for (var i = 0; i < reversedFns.length; i += 1) {
      var fn = reversedFns[i];
      result = fn.apply(void 0, [result].concat(args));
    }
    return result;
  };
};
var dropLast = function dropLast2(array) {
  return array.slice(0, array.length - 1);
};
var evolve = function evolve2(transformations, object) {
  var result = object instanceof Array ? [] : {};
  var keys2 = Object.keys(object);
  for (var i = 0; i < keys2.length; i += 1) {
    var key = keys2[i];
    var transformation = transformations[key];
    var type2 = typeof transformation;
    if (type2 === "function") {
      result[key] = transformation(object[key]);
    } else if (transformation && type2 === "object") {
      result[key] = evolve2(transformation, object[key]);
    } else result[key] = object[key];
  }
  return result;
};
var isNil = function isNil2(value2) {
  return value2 === null || value2 === void 0;
};
var get = function get2(target, path2, defaultValue) {
  if (isNil(target)) return defaultValue;
  var _path = castArray(path2);
  var result = target;
  for (var i = 0; i < _path.length; i += 1) {
    if (isNil(result)) return void 0;
    result = result[_path[i]];
  }
  return isNil(result) ? defaultValue : result;
};
var last = function last2(value2) {
  return value2 === "" ? "" : value2[value2.length - 1];
};
var mapValues = function mapValues2(object, fn) {
  var entries = Object.entries(object);
  return entries.reduce(function(acc, _ref, index2) {
    var key = _ref[0], value2 = _ref[1];
    acc[key] = fn(value2, key, index2);
    return acc;
  }, {});
};
var isPercent = function isPercent2(value2) {
  return /((-)?\d+\.?\d*)%/g.exec("" + value2);
};
var matchPercent = function matchPercent2(value2) {
  var match = isPercent(value2);
  if (match) {
    var f = parseFloat(match[1]);
    var percent = f / 100;
    return {
      percent,
      value: f
    };
  }
  return null;
};
var omit = function omit2(keys2, object) {
  var _keys = castArray(keys2);
  var copy6 = Object.assign({}, object);
  _keys.forEach(function(key) {
    delete copy6[key];
  });
  return copy6;
};
var pick = function pick2(keys2, obj) {
  var result = {};
  for (var i = 0; i < keys2.length; i += 1) {
    var key = keys2[i];
    if (key in obj) result[key] = obj[key];
  }
  return result;
};
var repeat = function repeat2(list, length4) {
  if (length4 === void 0) {
    length4 = 0;
  }
  var result = new Array(length4);
  for (var i = 0; i < length4; i += 1) {
    result[i] = list;
  }
  return result;
};
var upperFirst = function upperFirst2(value2) {
  if (!value2) return value2;
  return value2.charAt(0).toUpperCase() + value2.slice(1);
};

// ../../.yarn/cache/@react-pdf-render-npm-3.4.4-783d87a611-4ff29289a0.zip/node_modules/@react-pdf/render/lib/index.js
var import_abs_svg_path = __toESM(require_abs_svg_path());
var import_parse_svg_path = __toESM(require_parse_svg_path());

// ../../.yarn/cache/svg-arc-to-cubic-bezier-npm-3.2.0-06dd5e62ac-6dddbaff9d.zip/node_modules/svg-arc-to-cubic-bezier/modules/index.js
var _slicedToArray = /* @__PURE__ */ function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err2) {
      _d = true;
      _e = err2;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var TAU = Math.PI * 2;
var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x = _ref.x, y = _ref.y;
  x *= rx;
  y *= ry;
  var xp = cosphi * x - sinphi * y;
  var yp = sinphi * x + cosphi * y;
  return {
    x: xp + centerx,
    y: yp + centery
  };
};
var approxUnitArc = function approxUnitArc2(ang1, ang2) {
  var a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);
  return [{
    x: x1 - y1 * a2,
    y: y1 + x1 * a2
  }, {
    x: x2 + y2 * a2,
    y: y2 - x2 * a2
  }, {
    x: x2,
    y: y2
  }];
};
var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var dot = ux * vx + uy * vy;
  if (dot > 1) {
    dot = 1;
  }
  if (dot < -1) {
    dot = -1;
  }
  return sign * Math.acos(dot);
};
var getArcCenter = function getArcCenter2(px2, py2, cx2, cy2, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);
  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;
  var centerx = cosphi * centerxp - sinphi * centeryp + (px2 + cx2) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py2 + cy2) / 2;
  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;
  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  return [centerx, centery, ang1, ang2];
};
var arcToBezier = function arcToBezier2(_ref2) {
  var px2 = _ref2.px, py2 = _ref2.py, cx2 = _ref2.cx, cy2 = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
  var curves = [];
  if (rx === 0 || ry === 0) {
    return [];
  }
  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);
  var pxp = cosphi * (px2 - cx2) / 2 + sinphi * (py2 - cy2) / 2;
  var pyp = -sinphi * (px2 - cx2) / 2 + cosphi * (py2 - cy2) / 2;
  if (pxp === 0 && pyp === 0) {
    return [];
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var _getArcCenter = getArcCenter(px2, py2, cx2, cy2, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  var segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  for (var i = 0; i < segments; i++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }
  return curves.map(function(curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y2 = _mapToEllipse2.y;
    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _mapToEllipse3.x, y = _mapToEllipse3.y;
    return { x1, y1, x2, y2, x, y };
  });
};
var modules_default = arcToBezier;

// ../../.yarn/cache/normalize-svg-path-npm-1.1.0-6094833661-2e24e1d0a9.zip/node_modules/normalize-svg-path/index.mjs
function normalize(path2) {
  var prev;
  var result = [];
  var bezierX = 0;
  var bezierY = 0;
  var startX = 0;
  var startY = 0;
  var quadX = null;
  var quadY = null;
  var x = 0;
  var y = 0;
  for (var i = 0, len = path2.length; i < len; i++) {
    var seg = path2[i];
    var command = seg[0];
    switch (command) {
      case "M":
        startX = seg[1];
        startY = seg[2];
        break;
      case "A":
        var curves = modules_default({
          px: x,
          py: y,
          cx: seg[6],
          cy: seg[7],
          rx: seg[1],
          ry: seg[2],
          xAxisRotation: seg[3],
          largeArcFlag: seg[4],
          sweepFlag: seg[5]
        });
        if (!curves.length) continue;
        for (var j = 0, c2; j < curves.length; j++) {
          c2 = curves[j];
          seg = ["C", c2.x1, c2.y1, c2.x2, c2.y2, c2.x, c2.y];
          if (j < curves.length - 1) result.push(seg);
        }
        break;
      case "S":
        var cx2 = x;
        var cy2 = y;
        if (prev == "C" || prev == "S") {
          cx2 += cx2 - bezierX;
          cy2 += cy2 - bezierY;
        }
        seg = ["C", cx2, cy2, seg[1], seg[2], seg[3], seg[4]];
        break;
      case "T":
        if (prev == "Q" || prev == "T") {
          quadX = x * 2 - quadX;
          quadY = y * 2 - quadY;
        } else {
          quadX = x;
          quadY = y;
        }
        seg = quadratic(x, y, quadX, quadY, seg[1], seg[2]);
        break;
      case "Q":
        quadX = seg[1];
        quadY = seg[2];
        seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4]);
        break;
      case "L":
        seg = line(x, y, seg[1], seg[2]);
        break;
      case "H":
        seg = line(x, y, seg[1], y);
        break;
      case "V":
        seg = line(x, y, x, seg[1]);
        break;
      case "Z":
        seg = line(x, y, startX, startY);
        break;
    }
    prev = command;
    x = seg[seg.length - 2];
    y = seg[seg.length - 1];
    if (seg.length > 4) {
      bezierX = seg[seg.length - 4];
      bezierY = seg[seg.length - 3];
    } else {
      bezierX = x;
      bezierY = y;
    }
    result.push(seg);
  }
  return result;
}
function line(x1, y1, x2, y2) {
  return ["C", x1, y1, x2, y2, x2, y2];
}
function quadratic(x1, y1, cx2, cy2, x2, y2) {
  return [
    "C",
    x1 / 3 + 2 / 3 * cx2,
    y1 / 3 + 2 / 3 * cy2,
    x2 / 3 + 2 / 3 * cx2,
    y2 / 3 + 2 / 3 * cy2,
    x2,
    y2
  ];
}

// ../../.yarn/cache/@react-pdf-render-npm-3.4.4-783d87a611-4ff29289a0.zip/node_modules/@react-pdf/render/lib/index.js
var import_color_string = __toESM(require_color_string());
var renderPath = function renderPath2(ctx, node) {
  var _node$props;
  var d = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d;
  if (d) ctx.path(node.props.d);
};
var KAPPA$3 = 4 * ((Math.sqrt(2) - 1) / 3);
var renderRect = function renderRect2(ctx, node) {
  var _node$props, _node$props2, _node$props3, _node$props4, _node$props5, _node$props6;
  var x = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.x) || 0;
  var y = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.y) || 0;
  var rx = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.rx) || 0;
  var ry = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.ry) || 0;
  var width = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.width) || 0;
  var height5 = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.height) || 0;
  if (!width || !height5) return;
  if (rx && ry) {
    var krx = rx * KAPPA$3;
    var kry = ry * KAPPA$3;
    ctx.moveTo(x + rx, y);
    ctx.lineTo(x - rx + width, y);
    ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);
    ctx.lineTo(x + width, y + height5 - ry);
    ctx.bezierCurveTo(x + width, y + height5 - ry + kry, x - rx + width + krx, y + height5, x - rx + width, y + height5);
    ctx.lineTo(x + rx, y + height5);
    ctx.bezierCurveTo(x + rx - krx, y + height5, x, y + height5 - ry + kry, x, y + height5 - ry);
    ctx.lineTo(x, y + ry);
    ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);
  } else {
    ctx.moveTo(x, y);
    ctx.lineTo(x + width, y);
    ctx.lineTo(x + width, y + height5);
    ctx.lineTo(x, y + height5);
  }
  ctx.closePath();
};
var renderLine$1 = function renderLine(ctx, node) {
  var _ref = node.props || {}, x1 = _ref.x1, x2 = _ref.x2, y1 = _ref.y1, y2 = _ref.y2;
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
};
var renderGroup = function renderGroup2() {
};
var KAPPA$2 = 4 * ((Math.sqrt(2) - 1) / 3);
var drawEllipse = function drawEllipse2(ctx, cx2, cy2, rx, ry) {
  if (cx2 === void 0) {
    cx2 = 0;
  }
  if (cy2 === void 0) {
    cy2 = 0;
  }
  var x = cx2 - rx;
  var y = cy2 - ry;
  var ox = rx * KAPPA$2;
  var oy = ry * KAPPA$2;
  var xe = x + rx * 2;
  var ye = y + ry * 2;
  var xm = x + rx;
  var ym = y + ry;
  ctx.moveTo(x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  ctx.closePath();
};
var renderEllipse = function renderEllipse2(ctx, node) {
  var _ref = node.props || {}, cx2 = _ref.cx, cy2 = _ref.cy, rx = _ref.rx, ry = _ref.ry;
  drawEllipse(ctx, cx2, cy2, rx, ry);
};
var renderCircle = function renderCircle2(ctx, node) {
  var _node$props, _node$props2, _node$props3;
  var cx2 = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.cx;
  var cy2 = (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.cy;
  var r = (_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.r;
  drawEllipse(ctx, cx2, cy2, r, r);
};
var renderGlyphs = function renderGlyphs2(ctx, glyphs, positions, x, y, options) {
  if (options === void 0) {
    options = {};
  }
  var scale4 = 1e3 / ctx._fontSize;
  var unitsPerEm = ctx._font.font.unitsPerEm || 1e3;
  var advanceWidthScale = 1e3 / unitsPerEm;
  var encodedGlyphs = ctx._font.encodeGlyphs(glyphs);
  var encodedPositions = positions.map(function(pos, i) {
    return {
      xAdvance: pos.xAdvance * scale4,
      yAdvance: pos.yAdvance * scale4,
      xOffset: pos.xOffset,
      yOffset: pos.yOffset,
      advanceWidth: glyphs[i].advanceWidth * advanceWidthScale
    };
  });
  return ctx._glyphs(encodedGlyphs, encodedPositions, x, y, options);
};
var renderRun$1 = function renderRun(ctx, run) {
  var runAdvanceWidth = run.xAdvance;
  var _run$attributes = run.attributes, font2 = _run$attributes.font, fontSize2 = _run$attributes.fontSize, color = _run$attributes.color, opacity2 = _run$attributes.opacity;
  ctx.fillColor(color);
  ctx.fillOpacity(opacity2);
  if (font2.sbix || font2.COLR && font2.CPAL) {
    ctx.save();
    ctx.translate(0, -run.ascent);
    for (var i = 0; i < run.glyphs.length; i += 1) {
      var position = run.positions[i];
      var glyph = run.glyphs[i];
      ctx.save();
      ctx.translate(position.xOffset, position.yOffset);
      glyph.render(ctx, fontSize2);
      ctx.restore();
      ctx.translate(position.xAdvance, position.yAdvance);
    }
    ctx.restore();
  } else {
    ctx.font(typeof font2.name === "string" ? font2.name : font2, fontSize2);
    try {
      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);
    } catch (error) {
      console.log(error);
    }
  }
  ctx.translate(runAdvanceWidth, 0);
};
var renderSpan = function renderSpan2(ctx, line2, textAnchor, dominantBaseline) {
  var _line$box, _line$box2, _line$runs$, _line$runs$2, _line$runs$2$attribut;
  ctx.save();
  var x = ((_line$box = line2.box) === null || _line$box === void 0 ? void 0 : _line$box.x) || 0;
  var y = ((_line$box2 = line2.box) === null || _line$box2 === void 0 ? void 0 : _line$box2.y) || 0;
  var font2 = (_line$runs$ = line2.runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes.font;
  var scale4 = ((_line$runs$2 = line2.runs[0]) === null || _line$runs$2 === void 0 ? void 0 : (_line$runs$2$attribut = _line$runs$2.attributes) === null || _line$runs$2$attribut === void 0 ? void 0 : _line$runs$2$attribut.scale) || 1;
  var width = line2.xAdvance;
  var ascent4 = font2.ascent * scale4;
  var xHeight = font2.xHeight * scale4;
  var descent3 = font2.descent * scale4;
  var capHeight = font2.capHeight * scale4;
  var xTranslate = x;
  var yTranslate = y;
  switch (textAnchor) {
    case "middle":
      xTranslate = x - width / 2;
      break;
    case "end":
      xTranslate = x - width;
      break;
    default:
      xTranslate = x;
      break;
  }
  switch (dominantBaseline) {
    case "middle":
    case "central":
      yTranslate = y + capHeight / 2;
      break;
    case "hanging":
      yTranslate = y + capHeight;
      break;
    case "mathematical":
      yTranslate = y + xHeight;
      break;
    case "text-after-edge":
      yTranslate = y + descent3;
      break;
    case "text-before-edge":
      yTranslate = y + ascent4;
      break;
    default:
      yTranslate = y;
      break;
  }
  ctx.translate(xTranslate, yTranslate);
  line2.runs.forEach(function(run) {
    return renderRun$1(ctx, run);
  });
  ctx.restore();
};
var renderSvgText = function renderSvgText2(ctx, node) {
  node.children.forEach(function(span) {
    return renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline);
  });
};
var pairs = function pairs2(values) {
  var result = [];
  for (var i = 0; i < values.length; i += 2) {
    result.push([values[i], values[i + 1]]);
  }
  return result;
};
var parsePoints = function parsePoints2(points) {
  var values = (points || "").trim().replace(/,/g, " ").replace(/(\d)-(\d)/g, "$1 -$2").split(/\s+/);
  if (values.length % 2 !== 0) {
    values = values.slice(0, -1);
  }
  var mappedValues = values.map(parseFloat);
  return pairs(mappedValues);
};
var drawPolyline = function drawPolyline2(ctx, points) {
  if (points.length > 0) {
    ctx.moveTo(points[0][0], points[0][1]);
    points.slice(1).forEach(function(p) {
      return ctx.lineTo(p[0], p[1]);
    });
  }
};
var renderPolyline = function renderPolyline2(ctx, node) {
  var points = parsePoints(node.props.points || "");
  drawPolyline(ctx, points);
};
var renderPolygon = function renderPolygon2(ctx, node) {
  renderPolyline(ctx, node);
  ctx.closePath();
};
var renderImage$1 = function renderImage(ctx, node) {
  if (!node.image.data) return;
  var _node$props = node.props, x = _node$props.x, y = _node$props.y;
  var _node$style = node.style, width = _node$style.width, height5 = _node$style.height, opacity2 = _node$style.opacity;
  var paddingTop = node.box.paddingLeft || 0;
  var paddingLeft = node.box.paddingLeft || 0;
  if (width === 0 || height5 === 0) {
    console.warn("Image with src '" + node.props.href + "' skipped due to invalid dimensions");
    return;
  }
  ctx.save();
  ctx.fillOpacity(opacity2 || 1).image(node.image.data, x + paddingLeft, y + paddingTop, {
    width,
    height: height5
  });
  ctx.restore();
};
var KAPPA$1 = 4 * ((Math.sqrt(2) - 1) / 3);
var clipNode = function clipNode2(ctx, node) {
  if (!node.style) return;
  var _node$box = node.box, top = _node$box.top, left = _node$box.left, width = _node$box.width, height5 = _node$box.height;
  var _node$style = node.style, _node$style$borderTop = _node$style.borderTopLeftRadius, borderTopLeftRadius = _node$style$borderTop === void 0 ? 0 : _node$style$borderTop, _node$style$borderTop2 = _node$style.borderTopRightRadius, borderTopRightRadius = _node$style$borderTop2 === void 0 ? 0 : _node$style$borderTop2, _node$style$borderBot = _node$style.borderBottomRightRadius, borderBottomRightRadius = _node$style$borderBot === void 0 ? 0 : _node$style$borderBot, _node$style$borderBot2 = _node$style.borderBottomLeftRadius, borderBottomLeftRadius = _node$style$borderBot2 === void 0 ? 0 : _node$style$borderBot2;
  var rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height5);
  var ctr = rtr * (1 - KAPPA$1);
  ctx.moveTo(left + rtr, top);
  ctx.lineTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);
  var rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height5);
  var cbr = rbr * (1 - KAPPA$1);
  ctx.lineTo(left + width, top + height5 - rbr);
  ctx.bezierCurveTo(left + width, top + height5 - cbr, left + width - cbr, top + height5, left + width - rbr, top + height5);
  var rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height5);
  var cbl = rbl * (1 - KAPPA$1);
  ctx.lineTo(left + rbl, top + height5);
  ctx.bezierCurveTo(left + cbl, top + height5, left, top + height5 - cbl, left, top + height5 - rbl);
  var rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height5);
  var ctl = rtl * (1 - KAPPA$1);
  ctx.lineTo(left, top + rtl);
  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);
  ctx.closePath();
  ctx.clip();
};
var applySingleTransformation = function applySingleTransformation2(ctx, transform4, origin) {
  var operation = transform4.operation, value2 = transform4.value;
  switch (operation) {
    case "scale": {
      var scaleX = value2[0], scaleY = value2[1];
      ctx.scale(scaleX, scaleY, {
        origin
      });
      break;
    }
    case "rotate": {
      var angle = value2[0];
      ctx.rotate(angle, {
        origin
      });
      break;
    }
    case "translate": {
      var x = value2[0], _value$ = value2[1], y = _value$ === void 0 ? 0 : _value$;
      ctx.translate(x, y, {
        origin
      });
      break;
    }
    case "skew": {
      var xAngle = value2[0], yAngle = value2[1];
      ctx.skew(xAngle, yAngle, {
        origin
      });
      break;
    }
    case "matrix": {
      ctx.transform.apply(ctx, value2);
      break;
    }
    default: {
      console.error("Transform operation: '" + operation + "' doesn't supported");
    }
  }
};
var applyTransformations = function applyTransformations2(ctx, node) {
  var _node$style, _node$props;
  if (!node.origin) return;
  var origin = [node.origin.left, node.origin.top];
  var operations = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.transform) || ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.transform) || [];
  operations.forEach(function(operation) {
    applySingleTransformation(ctx, operation, origin);
  });
};
var _boundingBoxFns;
var getPathBoundingBox = function getPathBoundingBox2(node) {
  var _node$props;
  var path2 = normalize((0, import_abs_svg_path.default)((0, import_parse_svg_path.default)(((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d) || "")));
  if (!path2.length) return [0, 0, 0, 0];
  var bounds = [Infinity, Infinity, -Infinity, -Infinity];
  for (var i = 0, l2 = path2.length; i < l2; i += 1) {
    var points = path2[i].slice(1);
    for (var j = 0; j < points.length; j += 2) {
      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];
      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];
      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];
      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];
    }
  }
  return bounds;
};
var getCircleBoundingBox = function getCircleBoundingBox2(node) {
  var _node$props2, _node$props3, _node$props4;
  var r = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.r) || 0;
  var cx2 = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.cx) || 0;
  var cy2 = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.cy) || 0;
  return [cx2 - r, cy2 - r, cx2 + r, cy2 + r];
};
var getEllipseBoundingBox = function getEllipseBoundingBox2(node) {
  var _node$props5, _node$props6, _node$props7, _node$props8;
  var cx2 = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.cx) || 0;
  var cy2 = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.cy) || 0;
  var rx = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.rx) || 0;
  var ry = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.ry) || 0;
  return [cx2 - rx, cy2 - ry, cx2 + rx, cy2 + ry];
};
var getLineBoundingBox = function getLineBoundingBox2(node) {
  var _node$props9, _node$props10, _node$props11, _node$props12;
  var x1 = ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : _node$props9.x1) || 0;
  var y1 = ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : _node$props10.y1) || 0;
  var x2 = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.x2) || 0;
  var y2 = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.y2) || 0;
  return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];
};
var getRectBoundingBox = function getRectBoundingBox2(node) {
  var _node$props13, _node$props14, _node$props15, _node$props16;
  var x = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.x) || 0;
  var y = ((_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.y) || 0;
  var width = ((_node$props15 = node.props) === null || _node$props15 === void 0 ? void 0 : _node$props15.width) || 0;
  var height5 = ((_node$props16 = node.props) === null || _node$props16 === void 0 ? void 0 : _node$props16.height) || 0;
  return [x, y, x + width, y + height5];
};
var max = function max2(values) {
  return Math.max.apply(Math, [-Infinity].concat(values));
};
var min = function min2(values) {
  return Math.min.apply(Math, [Infinity].concat(values));
};
var getPolylineBoundingBox = function getPolylineBoundingBox2(node) {
  var _node$props17;
  var points = parsePoints(((_node$props17 = node.props) === null || _node$props17 === void 0 ? void 0 : _node$props17.points) || []);
  var xValues = points.map(function(p) {
    return p[0];
  });
  var yValues = points.map(function(p) {
    return p[1];
  });
  return [min(xValues), min(yValues), max(xValues), max(yValues)];
};
var boundingBoxFns = (_boundingBoxFns = {}, _boundingBoxFns[Rect] = getRectBoundingBox, _boundingBoxFns[Line] = getLineBoundingBox, _boundingBoxFns[Path] = getPathBoundingBox, _boundingBoxFns[Circle] = getCircleBoundingBox, _boundingBoxFns[Ellipse] = getEllipseBoundingBox, _boundingBoxFns[Polygon] = getPolylineBoundingBox, _boundingBoxFns[Polyline] = getPolylineBoundingBox, _boundingBoxFns);
var getBoundingBox = function getBoundingBox2(node) {
  var boundingBoxFn = boundingBoxFns[node.type];
  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];
};
var _renderFns$1;
var setStrokeWidth = function setStrokeWidth2(ctx, node) {
  var _node$props;
  var lineWidth2 = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.strokeWidth) || 0;
  if (lineWidth2) ctx.lineWidth(lineWidth2);
};
var setStrokeColor = function setStrokeColor2(ctx, node) {
  var _node$props2;
  var strokeColor2 = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.stroke) || null;
  if (strokeColor2) ctx.strokeColor(strokeColor2);
};
var setOpacity = function setOpacity2(ctx, node) {
  var _node$props3;
  var opacity2 = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.opacity) || null;
  if (!isNil(opacity2)) ctx.opacity(opacity2);
};
var setFillOpacity = function setFillOpacity2(ctx, node) {
  var _node$props4;
  var fillOpacity2 = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.fillOpacity) || null;
  if (!isNil(fillOpacity2)) ctx.fillOpacity(fillOpacity2);
};
var setStrokeOpacity = function setStrokeOpacity2(ctx, node) {
  var _node$props5;
  var strokeOpacity2 = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.strokeOpacity) || null;
  if (!isNil(strokeOpacity2)) ctx.strokeOpacity(strokeOpacity2);
};
var setLineJoin = function setLineJoin2(ctx, node) {
  var _node$props6;
  var lineJoin2 = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.strokeLinejoin) || null;
  if (lineJoin2) ctx.lineJoin(lineJoin2);
};
var setLineCap = function setLineCap2(ctx, node) {
  var _node$props7;
  var lineCap2 = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.strokeLinecap) || null;
  if (lineCap2) ctx.lineCap(lineCap2);
};
var setLineDash = function setLineDash2(ctx, node) {
  var _node$props8;
  var value2 = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.strokeDasharray) || null;
  if (value2) ctx.dash(value2.split(",").map(Number));
};
var hasLinearGradientFill = function hasLinearGradientFill2(node) {
  var _node$props9, _node$props9$fill;
  return ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : (_node$props9$fill = _node$props9.fill) === null || _node$props9$fill === void 0 ? void 0 : _node$props9$fill.type) === LinearGradient;
};
var hasRadialGradientFill = function hasRadialGradientFill2(node) {
  var _node$props10, _node$props10$fill;
  return ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : (_node$props10$fill = _node$props10.fill) === null || _node$props10$fill === void 0 ? void 0 : _node$props10$fill.type) === RadialGradient;
};
var setLinearGradientFill = function setLinearGradientFill2(ctx, node) {
  var _node$props11;
  var bbox = getBoundingBox(node);
  var gradient = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.fill) || null;
  var x1 = gradient.props.x1 || 0;
  var y1 = gradient.props.y1 || 0;
  var x2 = gradient.props.x2 || 1;
  var y2 = gradient.props.y2 || 0;
  var m0 = bbox[2] - bbox[0];
  var m3 = bbox[3] - bbox[1];
  var m4 = bbox[0];
  var m5 = bbox[1];
  var gx1 = m0 * x1 + m4;
  var gy1 = m3 * y1 + m5;
  var gx2 = m0 * x2 + m4;
  var gy2 = m3 * y2 + m5;
  var grad = ctx.linearGradient(gx1, gy1, gx2, gy2);
  gradient.children.forEach(function(stop) {
    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);
  });
  ctx.fill(grad);
};
var setRadialGradientFill = function setRadialGradientFill2(ctx, node) {
  var _node$props12;
  var bbox = getBoundingBox(node);
  var gradient = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.fill) || null;
  var cx2 = gradient.props.cx || 0.5;
  var cy2 = gradient.props.cy || 0.5;
  var fx = gradient.props.fx || cx2;
  var fy = gradient.props.fy || cy2;
  var r = gradient.props.r || 0.5;
  var m0 = bbox[2] - bbox[0];
  var m3 = bbox[3] - bbox[1];
  var m4 = bbox[0];
  var m5 = bbox[1];
  var gr = r * m0;
  var gcx = m0 * cx2 + m4;
  var gcy = m3 * cy2 + m5;
  var gfx = m0 * fx + m4;
  var gfy = m3 * fy + m5;
  var grad = ctx.radialGradient(gfx, gfy, 0, gcx, gcy, gr);
  gradient.children.forEach(function(stop) {
    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);
  });
  ctx.fill(grad);
};
var setFillColor = function setFillColor2(ctx, node) {
  var _node$props13;
  var fillColor2 = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.fill) || null;
  if (fillColor2) ctx.fillColor(fillColor2);
};
var setFill = function setFill2(ctx, node) {
  if (hasLinearGradientFill(node)) return setLinearGradientFill(ctx, node);
  if (hasRadialGradientFill(node)) return setRadialGradientFill(ctx, node);
  return setFillColor(ctx, node);
};
var draw = function draw2(ctx, node) {
  var props = node.props || {};
  if (props.fill && props.stroke) {
    ctx.fillAndStroke(props.fillRule);
  } else if (props.fill) {
    ctx.fill(props.fillRule);
  } else if (props.stroke) {
    ctx.stroke();
  } else {
    ctx.save();
    ctx.opacity(0);
    ctx.fill(null);
    ctx.restore();
  }
};
var noop = function noop2() {
};
var renderFns$1 = (_renderFns$1 = {}, _renderFns$1[Tspan] = noop, _renderFns$1[TextInstance] = noop, _renderFns$1[Path] = renderPath, _renderFns$1[Rect] = renderRect, _renderFns$1[Line] = renderLine$1, _renderFns$1[G] = renderGroup, _renderFns$1[Text] = renderSvgText, _renderFns$1[Circle] = renderCircle, _renderFns$1[Image] = renderImage$1, _renderFns$1[Ellipse] = renderEllipse, _renderFns$1[Polygon] = renderPolygon, _renderFns$1[Polyline] = renderPolyline, _renderFns$1);
var renderNode$1 = function renderNode(ctx, node) {
  var renderFn = renderFns$1[node.type];
  if (renderFns$1) {
    renderFn(ctx, node);
  } else {
    console.warn("SVG node of type " + node.type + " is not currenty supported");
  }
};
var drawNode = function drawNode2(ctx, node) {
  setLineCap(ctx, node);
  setLineDash(ctx, node);
  setLineJoin(ctx, node);
  setStrokeWidth(ctx, node);
  setStrokeColor(ctx, node);
  setFill(ctx, node);
  setStrokeOpacity(ctx, node);
  setFillOpacity(ctx, node);
  setOpacity(ctx, node);
  applyTransformations(ctx, node);
  renderNode$1(ctx, node);
  draw(ctx, node);
};
var clipPath = function clipPath2(ctx, node) {
  var _node$props14;
  var value2 = (_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.clipPath;
  if (value2) {
    var children = value2.children || [];
    children.forEach(function(child) {
      return renderNode$1(ctx, child);
    });
    ctx.clip();
  }
};
var drawChildren = function drawChildren2(ctx, node) {
  var children = node.children || [];
  children.forEach(function(child) {
    ctx.save();
    clipPath(ctx, child);
    drawNode(ctx, child);
    drawChildren2(ctx, child);
    ctx.restore();
  });
};
var resolveAspectRatio = function resolveAspectRatio2(ctx, node) {
  var _node$box = node.box, width = _node$box.width, height5 = _node$box.height;
  var _node$props15 = node.props, viewBox = _node$props15.viewBox, _node$props15$preserv = _node$props15.preserveAspectRatio, preserveAspectRatio = _node$props15$preserv === void 0 ? {} : _node$props15$preserv;
  var _preserveAspectRatio$ = preserveAspectRatio.meetOrSlice, meetOrSlice = _preserveAspectRatio$ === void 0 ? "meet" : _preserveAspectRatio$, _preserveAspectRatio$2 = preserveAspectRatio.align, align = _preserveAspectRatio$2 === void 0 ? "xMidYMid" : _preserveAspectRatio$2;
  if (viewBox == null || width == null || height5 == null) return;
  var x = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minX) || 0;
  var y = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minY) || 0;
  var logicalWidth = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxX) || width;
  var logicalHeight = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxY) || height5;
  var logicalRatio = logicalWidth / logicalHeight;
  var physicalRatio = width / height5;
  var scaleX = width / logicalWidth;
  var scaleY = height5 / logicalHeight;
  if (align === "none") {
    ctx.scale(scaleX, scaleY);
    ctx.translate(-x, -y);
    return;
  }
  if (logicalRatio < physicalRatio && meetOrSlice === "meet" || logicalRatio >= physicalRatio && meetOrSlice === "slice") {
    ctx.scale(scaleY, scaleY);
    switch (align) {
      case "xMinYMin":
      case "xMinYMid":
      case "xMinYMax":
        ctx.translate(-x, -y);
        break;
      case "xMidYMin":
      case "xMidYMid":
      case "xMidYMax":
        ctx.translate(-x - (logicalWidth - width * logicalHeight / height5) / 2, -y);
        break;
      default:
        ctx.translate(-x - (logicalWidth - width * logicalHeight / height5), -y);
    }
  } else {
    ctx.scale(scaleX, scaleX);
    switch (align) {
      case "xMinYMin":
      case "xMidYMin":
      case "xMaxYMin":
        ctx.translate(-x, -y);
        break;
      case "xMinYMid":
      case "xMidYMid":
      case "xMaxYMid":
        ctx.translate(-x, -y - (logicalHeight - height5 * logicalWidth / width) / 2);
        break;
      default:
        ctx.translate(-x, -y - (logicalHeight - height5 * logicalWidth / width));
    }
  }
};
var moveToOrigin = function moveToOrigin2(ctx, node) {
  var _node$box2 = node.box, top = _node$box2.top, left = _node$box2.left;
  var paddingLeft = node.box.paddingLeft || 0;
  var paddingTop = node.box.paddingTop || 0;
  ctx.translate(left + paddingLeft, top + paddingTop);
};
var renderSvg = function renderSvg2(ctx, node) {
  ctx.save();
  clipNode(ctx, node);
  moveToOrigin(ctx, node);
  resolveAspectRatio(ctx, node);
  drawChildren(ctx, node);
  ctx.restore();
};
var black = {
  value: [0, 0, 0],
  opacity: 1
};
var parseColor = function parseColor2(hex) {
  var parsed = import_color_string.default.get(hex);
  if (!parsed) return black;
  var value2 = import_color_string.default.to.hex(parsed.value.slice(0, 3));
  var opacity2 = parsed.value[3];
  return {
    value: value2,
    opacity: opacity2
  };
};
var DEST_REGEXP = /^#.+/;
var isSrcId$1 = function isSrcId(src) {
  return src.match(DEST_REGEXP);
};
var renderAttachment = function renderAttachment2(ctx, attachment) {
  var _attachment$xOffset = attachment.xOffset, xOffset = _attachment$xOffset === void 0 ? 0 : _attachment$xOffset, _attachment$yOffset = attachment.yOffset, yOffset = _attachment$yOffset === void 0 ? 0 : _attachment$yOffset, width = attachment.width, height5 = attachment.height, image2 = attachment.image;
  ctx.translate(-width + xOffset, -height5 + yOffset);
  ctx.image(image2, 0, 0, {
    fit: [width, height5],
    align: "center",
    valign: "bottom"
  });
};
var renderAttachments = function renderAttachments2(ctx, run) {
  ctx.save();
  var font2 = run.attributes.font;
  var space = font2.glyphForCodePoint(32);
  var objectReplacement = font2.glyphForCodePoint(65532);
  var attachmentAdvance = 0;
  for (var i = 0; i < run.glyphs.length; i += 1) {
    var position = run.positions[i];
    var glyph = run.glyphs[i];
    attachmentAdvance += position.xAdvance || 0;
    if (glyph.id === objectReplacement.id && run.attributes.attachment) {
      ctx.translate(attachmentAdvance, position.yOffset || 0);
      renderAttachment(ctx, run.attributes.attachment);
      run.glyphs[i] = space;
      attachmentAdvance = 0;
    }
  }
  ctx.restore();
};
var renderRun2 = function renderRun3(ctx, run, options) {
  var _run$attributes = run.attributes, font2 = _run$attributes.font, fontSize2 = _run$attributes.fontSize, link2 = _run$attributes.link;
  var color = parseColor(run.attributes.color);
  var opacity2 = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;
  var height5 = run.height, descent3 = run.descent, xAdvance = run.xAdvance;
  if (options.outlineRuns) {
    ctx.rect(0, -height5, xAdvance, height5).stroke();
  }
  ctx.fillColor(color.value);
  ctx.fillOpacity(opacity2);
  if (link2) {
    if (isSrcId$1(link2)) {
      ctx.goTo(0, -height5 - descent3, xAdvance, height5, link2.slice(1));
    } else {
      ctx.link(0, -height5 - descent3, xAdvance, height5, link2);
    }
  }
  renderAttachments(ctx, run);
  if (font2.sbix || font2.COLR && font2.CPAL) {
    ctx.save();
    ctx.translate(0, -run.ascent);
    for (var i = 0; i < run.glyphs.length; i += 1) {
      var position = run.positions[i];
      var glyph = run.glyphs[i];
      ctx.save();
      ctx.translate(position.xOffset, position.yOffset);
      glyph.render(ctx, fontSize2);
      ctx.restore();
      ctx.translate(position.xAdvance, position.yAdvance);
    }
    ctx.restore();
  } else {
    ctx.font(typeof font2.name === "string" ? font2.name : font2, fontSize2);
    try {
      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);
    } catch (error) {
      console.log(error);
    }
  }
  ctx.translate(xAdvance, 0);
};
var renderBackground$1 = function renderBackground(ctx, rect2, backgroundColor) {
  var color = parseColor(backgroundColor);
  ctx.save();
  ctx.fillOpacity(color.opacity);
  ctx.rect(rect2.x, rect2.y, rect2.width, rect2.height);
  ctx.fill(color.value);
  ctx.restore();
};
var renderDecorationLine = function renderDecorationLine2(ctx, line2) {
  ctx.save();
  ctx.lineWidth(line2.rect.height);
  ctx.strokeOpacity(line2.opacity);
  if (/dashed/.test(line2.style)) {
    ctx.dash(3 * line2.rect.height);
  } else if (/dotted/.test(line2.style)) {
    ctx.dash(line2.rect.height);
  }
  if (/wavy/.test(line2.style)) {
    var dist = Math.max(2, line2.rect.height);
    var step = 1.1 * dist;
    var stepCount = Math.floor(line2.rect.width / (2 * step));
    var remainingWidth = line2.rect.width - stepCount * 2 * step;
    var adjustment = remainingWidth / stepCount / 2;
    step += adjustment;
    var cp1y = line2.rect.y + dist;
    var cp2y = line2.rect.y - dist;
    var x = line2.rect.x;
    ctx.moveTo(line2.rect.x, line2.rect.y);
    for (var i = 0; i < stepCount; i += 1) {
      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, line2.rect.y);
      x += 2 * step;
    }
  } else {
    ctx.moveTo(line2.rect.x, line2.rect.y);
    ctx.lineTo(line2.rect.x + line2.rect.width, line2.rect.y);
    if (/double/.test(line2.style)) {
      ctx.moveTo(line2.rect.x, line2.rect.y + line2.rect.height * 2);
      ctx.lineTo(line2.rect.x + line2.rect.width, line2.rect.y + line2.rect.height * 2);
    }
  }
  ctx.stroke(line2.color);
  ctx.restore();
};
var renderLine2 = function renderLine3(ctx, line2, options) {
  var lineAscent = line2.ascent;
  if (options.outlineLines) {
    ctx.rect(line2.box.x, line2.box.y, line2.box.width, line2.box.height).stroke();
  }
  ctx.save();
  ctx.translate(line2.box.x, line2.box.y + lineAscent);
  for (var i = 0; i < line2.runs.length; i += 1) {
    var run = line2.runs[i];
    var isLastRun = i === line2.runs.length - 1;
    if (run.attributes.backgroundColor) {
      var overflowRight = isLastRun ? line2.overflowRight : 0;
      var backgroundRect = {
        x: 0,
        y: -lineAscent,
        height: line2.box.height,
        width: run.xAdvance - overflowRight
      };
      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);
    }
    renderRun2(ctx, run, options);
  }
  ctx.restore();
  ctx.save();
  ctx.translate(line2.box.x, line2.box.y);
  for (var _i = 0; _i < line2.decorationLines.length; _i += 1) {
    var decorationLine = line2.decorationLines[_i];
    renderDecorationLine(ctx, decorationLine);
  }
  ctx.restore();
};
var renderBlock = function renderBlock2(ctx, block, options) {
  block.forEach(function(line2) {
    renderLine2(ctx, line2, options);
  });
};
var renderText = function renderText2(ctx, node) {
  var _node$box2, _node$box3;
  var _node$box = node.box, top = _node$box.top, left = _node$box.left;
  var blocks = [node.lines];
  var paddingTop = ((_node$box2 = node.box) === null || _node$box2 === void 0 ? void 0 : _node$box2.paddingTop) || 0;
  var paddingLeft = ((_node$box3 = node.box) === null || _node$box3 === void 0 ? void 0 : _node$box3.paddingLeft) || 0;
  var initialY = node.lines[0] ? node.lines[0].box.y : 0;
  var offsetX = node.alignOffset || 0;
  ctx.save();
  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);
  blocks.forEach(function(block) {
    renderBlock(ctx, block, {});
  });
  ctx.restore();
};
var renderPage = function renderPage2(ctx, node) {
  var _node$props;
  var _node$box = node.box, width = _node$box.width, height5 = _node$box.height;
  var dpi = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.dpi) || 72;
  var userUnit = dpi / 72;
  ctx.addPage({
    size: [width, height5],
    margin: 0,
    userUnit
  });
};
var renderNote = function renderNote2(ctx, node) {
  var _node$children, _node$style, _node$style2;
  var _node$box = node.box, top = _node$box.top, left = _node$box.left;
  var value2 = (node === null || node === void 0 ? void 0 : (_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children[0].value) || "";
  var color = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.backgroundColor) || null;
  var borderWidth = ((_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.borderWidth) || null;
  ctx.note(left, top, 0, 0, value2, {
    color,
    borderWidth
  });
};
var isNumeric = function isNumeric2(n) {
  return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);
};
var applyContainObjectFit = function applyContainObjectFit2(cw, ch, iw, ih, px2, py2) {
  var cr = cw / ch;
  var ir = iw / ih;
  var pxp = matchPercent(px2);
  var pyp = matchPercent(py2);
  var pxv = pxp ? pxp.percent : 0.5;
  var pyv = pyp ? pyp.percent : 0.5;
  if (cr > ir) {
    var _height = ch;
    var _width = _height * ir;
    var _yOffset = isNumeric(py2) ? py2 : 0;
    var _xOffset = isNumeric(px2) ? px2 : (cw - _width) * pxv;
    return {
      width: _width,
      height: _height,
      xOffset: _xOffset,
      yOffset: _yOffset
    };
  }
  var width = cw;
  var height5 = width / ir;
  var xOffset = isNumeric(px2) ? px2 : 0;
  var yOffset = isNumeric(py2) ? py2 : (ch - height5) * pyv;
  return {
    width,
    height: height5,
    yOffset,
    xOffset
  };
};
var applyNoneObjectFit = function applyNoneObjectFit2(cw, ch, iw, ih, px2, py2) {
  var width = iw;
  var height5 = ih;
  var pxp = matchPercent(px2);
  var pyp = matchPercent(py2);
  var pxv = pxp ? pxp.percent : 0.5;
  var pyv = pyp ? pyp.percent : 0.5;
  var xOffset = isNumeric(px2) ? px2 : (cw - width) * pxv;
  var yOffset = isNumeric(py2) ? py2 : (ch - height5) * pyv;
  return {
    width,
    height: height5,
    xOffset,
    yOffset
  };
};
var applyCoverObjectFit = function applyCoverObjectFit2(cw, ch, iw, ih, px2, py2) {
  var ir = iw / ih;
  var cr = cw / ch;
  var pxp = matchPercent(px2);
  var pyp = matchPercent(py2);
  var pxv = pxp ? pxp.percent : 0.5;
  var pyv = pyp ? pyp.percent : 0.5;
  if (cr > ir) {
    var _width2 = cw;
    var _height2 = _width2 / ir;
    var _xOffset2 = isNumeric(px2) ? px2 : 0;
    var _yOffset2 = isNumeric(py2) ? py2 : (ch - _height2) * pyv;
    return {
      width: _width2,
      height: _height2,
      yOffset: _yOffset2,
      xOffset: _xOffset2
    };
  }
  var height5 = ch;
  var width = height5 * ir;
  var xOffset = isNumeric(px2) ? px2 : (cw - width) * pxv;
  var yOffset = isNumeric(py2) ? py2 : 0;
  return {
    width,
    height: height5,
    xOffset,
    yOffset
  };
};
var applyScaleDownObjectFit = function applyScaleDownObjectFit2(cw, ch, iw, ih, px2, py2) {
  var containDimension = applyContainObjectFit(cw, ch, iw, ih, px2, py2);
  var noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px2, py2);
  return containDimension.width < noneDimension.width ? containDimension : noneDimension;
};
var applyFillObjectFit = function applyFillObjectFit2(cw, ch, px2, py2) {
  return {
    width: cw,
    height: ch,
    xOffset: matchPercent(px2) ? 0 : px2 || 0,
    yOffset: matchPercent(py2) ? 0 : py2 || 0
  };
};
var resolveObjectFit = function resolveObjectFit2(type2, cw, ch, iw, ih, px2, py2) {
  if (type2 === void 0) {
    type2 = "fill";
  }
  switch (type2) {
    case "contain":
      return applyContainObjectFit(cw, ch, iw, ih, px2, py2);
    case "cover":
      return applyCoverObjectFit(cw, ch, iw, ih, px2, py2);
    case "none":
      return applyNoneObjectFit(cw, ch, iw, ih, px2, py2);
    case "scale-down":
      return applyScaleDownObjectFit(cw, ch, iw, ih, px2, py2);
    default:
      return applyFillObjectFit(cw, ch, px2, py2);
  }
};
var drawImage = function drawImage2(ctx, node, options) {
  var _node$style, _node$style2, _node$style3, _node$style4;
  if (options === void 0) {
    options = {};
  }
  var _node$box = node.box, left = _node$box.left, top = _node$box.top;
  var opacity2 = (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity;
  var objectFit = (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.objectFit;
  var objectPositionX = (_node$style3 = node.style) === null || _node$style3 === void 0 ? void 0 : _node$style3.objectPositionX;
  var objectPositionY = (_node$style4 = node.style) === null || _node$style4 === void 0 ? void 0 : _node$style4.objectPositionY;
  var paddingTop = node.box.paddingTop || 0;
  var paddingRight = node.box.paddingRight || 0;
  var paddingBottom = node.box.paddingBottom || 0;
  var paddingLeft = node.box.paddingLeft || 0;
  var imageCache = options.imageCache || /* @__PURE__ */ new Map();
  var _resolveObjectFit = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY), width = _resolveObjectFit.width, height5 = _resolveObjectFit.height, xOffset = _resolveObjectFit.xOffset, yOffset = _resolveObjectFit.yOffset;
  if (node.image.data) {
    if (width !== 0 && height5 !== 0) {
      var cacheKey = node.image.key;
      var image2 = imageCache.get(cacheKey) || ctx.embedImage(node.image.data);
      if (cacheKey) imageCache.set(cacheKey, image2);
      var imageOpacity = isNil(opacity2) ? 1 : opacity2;
      ctx.fillOpacity(imageOpacity).image(image2, left + paddingLeft + xOffset, top + paddingTop + yOffset, {
        width,
        height: height5
      });
    } else {
      console.warn("Image with src '" + JSON.stringify(node.props.src) + "' skipped due to invalid dimensions");
    }
  }
};
var renderImage2 = function renderImage3(ctx, node, options) {
  ctx.save();
  clipNode(ctx, node);
  drawImage(ctx, node, options);
  ctx.restore();
};
var CONTENT_COLOR = "#a1c6e7";
var PADDING_COLOR = "#c4deb9";
var MARGIN_COLOR = "#f8cca1";
var debugContent = function debugContent2(ctx, node) {
  var _node$box = node.box, left = _node$box.left, top = _node$box.top, width = _node$box.width, height5 = _node$box.height, _node$box$paddingLeft = _node$box.paddingLeft, paddingLeft = _node$box$paddingLeft === void 0 ? 0 : _node$box$paddingLeft, _node$box$paddingTop = _node$box.paddingTop, paddingTop = _node$box$paddingTop === void 0 ? 0 : _node$box$paddingTop, _node$box$paddingRigh = _node$box.paddingRight, paddingRight = _node$box$paddingRigh === void 0 ? 0 : _node$box$paddingRigh, _node$box$paddingBott = _node$box.paddingBottom, paddingBottom = _node$box$paddingBott === void 0 ? 0 : _node$box$paddingBott, _node$box$borderLeftW = _node$box.borderLeftWidth, borderLeftWidth = _node$box$borderLeftW === void 0 ? 0 : _node$box$borderLeftW, _node$box$borderTopWi = _node$box.borderTopWidth, borderTopWidth = _node$box$borderTopWi === void 0 ? 0 : _node$box$borderTopWi, _node$box$borderRight = _node$box.borderRightWidth, borderRightWidth = _node$box$borderRight === void 0 ? 0 : _node$box$borderRight, _node$box$borderBotto = _node$box.borderBottomWidth, borderBottomWidth = _node$box$borderBotto === void 0 ? 0 : _node$box$borderBotto;
  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height5 - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();
};
var debugPadding = function debugPadding2(ctx, node) {
  var _node$box2 = node.box, left = _node$box2.left, top = _node$box2.top, width = _node$box2.width, height5 = _node$box2.height, _node$box2$paddingLef = _node$box2.paddingLeft, paddingLeft = _node$box2$paddingLef === void 0 ? 0 : _node$box2$paddingLef, _node$box2$paddingTop = _node$box2.paddingTop, paddingTop = _node$box2$paddingTop === void 0 ? 0 : _node$box2$paddingTop, _node$box2$paddingRig = _node$box2.paddingRight, paddingRight = _node$box2$paddingRig === void 0 ? 0 : _node$box2$paddingRig, _node$box2$paddingBot = _node$box2.paddingBottom, paddingBottom = _node$box2$paddingBot === void 0 ? 0 : _node$box2$paddingBot, _node$box2$borderLeft = _node$box2.borderLeftWidth, borderLeftWidth = _node$box2$borderLeft === void 0 ? 0 : _node$box2$borderLeft, _node$box2$borderTopW = _node$box2.borderTopWidth, borderTopWidth = _node$box2$borderTopW === void 0 ? 0 : _node$box2$borderTopW, _node$box2$borderRigh = _node$box2.borderRightWidth, borderRightWidth = _node$box2$borderRigh === void 0 ? 0 : _node$box2$borderRigh, _node$box2$borderBott = _node$box2.borderBottomWidth, borderBottomWidth = _node$box2$borderBott === void 0 ? 0 : _node$box2$borderBott;
  ctx.fillColor(PADDING_COLOR).opacity(0.5);
  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill();
  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height5 - borderTopWidth - borderBottomWidth).fill();
  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height5 - borderTopWidth - borderBottomWidth).fill();
  ctx.rect(left + paddingLeft + borderLeftWidth, top + height5 - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();
};
var getMargin = function getMargin2(box) {
  var marginLeft = box.marginLeft === "auto" ? 0 : box.marginLeft;
  var marginTop = box.marginTop === "auto" ? 0 : box.marginTop;
  var marginRight = box.marginRight === "auto" ? 0 : box.marginRight;
  var marginBottom = box.marginBottom === "auto" ? 0 : box.marginBottom;
  return {
    marginLeft,
    marginTop,
    marginRight,
    marginBottom
  };
};
var debugMargin = function debugMargin2(ctx, node) {
  var _node$box3 = node.box, left = _node$box3.left, top = _node$box3.top, width = _node$box3.width, height5 = _node$box3.height;
  var _getMargin = getMargin(node.box), _getMargin$marginLeft = _getMargin.marginLeft, marginLeft = _getMargin$marginLeft === void 0 ? 0 : _getMargin$marginLeft, _getMargin$marginTop = _getMargin.marginTop, marginTop = _getMargin$marginTop === void 0 ? 0 : _getMargin$marginTop, _getMargin$marginRigh = _getMargin.marginRight, marginRight = _getMargin$marginRigh === void 0 ? 0 : _getMargin$marginRigh, _getMargin$marginBott = _getMargin.marginBottom, marginBottom = _getMargin$marginBott === void 0 ? 0 : _getMargin$marginBott;
  ctx.fillColor(MARGIN_COLOR).opacity(0.5);
  ctx.rect(left, top - marginTop, width, marginTop).fill();
  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height5 + marginTop + marginBottom).fill();
  ctx.rect(left + width, top - marginTop, marginRight, height5 + marginTop + marginBottom).fill();
  ctx.rect(left, top + height5, width, marginBottom).fill();
};
var debugText = function debugText2(ctx, node) {
  var _node$box4 = node.box, left = _node$box4.left, top = _node$box4.top, width = _node$box4.width, height5 = _node$box4.height;
  var _getMargin2 = getMargin(node.box), _getMargin2$marginLef = _getMargin2.marginLeft, marginLeft = _getMargin2$marginLef === void 0 ? 0 : _getMargin2$marginLef, _getMargin2$marginTop = _getMargin2.marginTop, marginTop = _getMargin2$marginTop === void 0 ? 0 : _getMargin2$marginTop, _getMargin2$marginRig = _getMargin2.marginRight, marginRight = _getMargin2$marginRig === void 0 ? 0 : _getMargin2$marginRig, _getMargin2$marginBot = _getMargin2.marginBottom, marginBottom = _getMargin2$marginBot === void 0 ? 0 : _getMargin2$marginBot;
  var roundedWidth = Math.round(width + marginLeft + marginRight);
  var roundedHeight = Math.round(height5 + marginTop + marginBottom);
  ctx.fontSize(6).opacity(1).fillColor("black").text(roundedWidth + " x " + roundedHeight, left - marginLeft, Math.max(top - marginTop - 4, 1));
};
var debugOrigin = function debugOrigin2(ctx, node) {
  if (node.origin) {
    ctx.circle(node.origin.left, node.origin.top, 3).fill("red").circle(node.origin.left, node.origin.top, 5).stroke("red");
  }
};
var renderDebug = function renderDebug2(ctx, node) {
  var _node$props;
  if (!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.debug)) return;
  ctx.save();
  debugContent(ctx, node);
  debugPadding(ctx, node);
  debugMargin(ctx, node);
  debugText(ctx, node);
  debugOrigin(ctx, node);
  ctx.restore();
};
var availableMethods = ["dash", "clip", "save", "path", "fill", "font", "text", "rect", "scale", "moveTo", "lineTo", "stroke", "rotate", "circle", "lineCap", "opacity", "ellipse", "polygon", "restore", "lineJoin", "fontSize", "fillColor", "lineWidth", "translate", "miterLimit", "strokeColor", "fillOpacity", "roundedRect", "fillAndStroke", "strokeOpacity", "bezierCurveTo", "quadraticCurveTo", "linearGradient", "radialGradient"];
var painter = function painter2(ctx) {
  var p = availableMethods.reduce(function(acc, prop) {
    var _extends2;
    return _extends({}, acc, (_extends2 = {}, _extends2[prop] = function() {
      ctx[prop].apply(ctx, arguments);
      return p;
    }, _extends2));
  }, {});
  return p;
};
var renderCanvas = function renderCanvas2(ctx, node) {
  var _node$box = node.box, top = _node$box.top, left = _node$box.left, width = _node$box.width, height5 = _node$box.height;
  var paddingTop = node.box.paddingTop || 0;
  var paddingLeft = node.box.paddingLeft || 0;
  var paddingRight = node.box.paddingRight || 0;
  var paddingBottom = node.box.paddingBottom || 0;
  var availableWidth = width - paddingLeft - paddingRight;
  var availableHeight = height5 - paddingTop - paddingBottom;
  if (!availableWidth || !availableHeight) {
    console.warn("Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.");
  }
  ctx.save().translate(left + paddingLeft, top + paddingTop);
  if (node.props.paint) {
    node.props.paint(painter(ctx), availableWidth, availableHeight);
  }
  ctx.restore();
};
var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
var clipBorderTop = function clipBorderTop2(ctx, layout2, style, rtr, rtl) {
  var top = layout2.top, left = layout2.left, width = layout2.width, height5 = layout2.height;
  var borderTopWidth = style.borderTopWidth, borderRightWidth = style.borderRightWidth, borderLeftWidth = style.borderLeftWidth;
  ctx.moveTo(left + rtl, top);
  ctx.lineTo(left + width - rtr, top);
  var c0 = rtr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);
  var topRightYCoord = top + Math.max(borderTopWidth, rtr);
  ctx.lineTo(left + width, topRightYCoord);
  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);
  var innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);
  var innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);
  var c1 = innerTopRightRadiusX * (1 - KAPPA);
  var c2 = innerTopRightRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);
  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);
  var innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);
  var innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);
  var c3 = innerTopLeftRadiusX * (1 - KAPPA);
  var c4 = innerTopLeftRadiusY * (1 - KAPPA);
  var topLeftYCoord = top + Math.max(borderTopWidth, rtl);
  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);
  ctx.lineTo(left, topLeftYCoord);
  ctx.lineTo(left, top + rtl);
  var c5 = rtl * (1 - KAPPA);
  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);
  ctx.closePath();
  ctx.clip();
  if (borderRightWidth) {
    var trSlope = -borderTopWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left, top);
    ctx.lineTo(left, top + height5);
    ctx.closePath();
    ctx.clip();
  }
  if (borderLeftWidth) {
    var _trSlope = -borderTopWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, _trSlope * (-width / 2) + top);
    ctx.lineTo(left, top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left + width, top + height5);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderTop = function fillBorderTop2(ctx, layout2, style, rtr, rtl) {
  var top = layout2.top, left = layout2.left, width = layout2.width;
  var borderTopColor = style.borderTopColor, borderTopWidth = style.borderTopWidth, borderTopStyle = style.borderTopStyle, borderRightWidth = style.borderRightWidth, borderLeftWidth = style.borderLeftWidth;
  var c0 = rtl * (1 - KAPPA);
  var c1 = rtr * (1 - KAPPA);
  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));
  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);
  ctx.lineTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);
  ctx.strokeColor(borderTopColor);
  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);
  if (borderTopStyle === "dashed") {
    ctx.dash(borderTopWidth * 2, {
      space: borderTopWidth * 1.2
    });
  } else if (borderTopStyle === "dotted") {
    ctx.dash(borderTopWidth, {
      space: borderTopWidth * 1.2
    });
  }
  ctx.stroke();
  ctx.undash();
};
var clipBorderRight = function clipBorderRight2(ctx, layout2, style, rtr, rbr) {
  var top = layout2.top, left = layout2.left, width = layout2.width, height5 = layout2.height;
  var borderTopWidth = style.borderTopWidth, borderRightWidth = style.borderRightWidth, borderBottomWidth = style.borderBottomWidth;
  ctx.moveTo(left + width, top + rtr);
  ctx.lineTo(left + width, top + height5 - rbr);
  var c0 = rbr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width, top + height5 - c0, left + width - c0, top + height5, left + width - rbr, top + height5);
  var topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);
  ctx.lineTo(topBottomXCoord, top + height5);
  ctx.lineTo(topBottomXCoord, top + height5 - borderBottomWidth);
  var innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);
  var innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);
  var c1 = innerBottomRightRadiusX * (1 - KAPPA);
  var c2 = innerBottomRightRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height5 - borderBottomWidth, left + width - borderRightWidth, top + height5 - borderBottomWidth - c2, left + width - borderRightWidth, top + height5 - Math.max(rbr, borderBottomWidth));
  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));
  var innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);
  var innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);
  var c3 = innerTopRightRadiusX * (1 - KAPPA);
  var c4 = innerTopRightRadiusY * (1 - KAPPA);
  var topRightXCoord = left + width - Math.max(rtr, borderRightWidth);
  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);
  ctx.lineTo(topRightXCoord, top);
  ctx.lineTo(left + width - rtr, top);
  var c5 = rtr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);
  ctx.closePath();
  ctx.clip();
  if (borderTopWidth) {
    var trSlope = -borderTopWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left + width, top + height5);
    ctx.lineTo(left, top + height5);
    ctx.closePath();
    ctx.clip();
  }
  if (borderBottomWidth) {
    var brSlope = borderBottomWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height5);
    ctx.lineTo(left + width, top + height5);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left, top);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderRight = function fillBorderRight2(ctx, layout2, style, rtr, rbr) {
  var top = layout2.top, left = layout2.left, width = layout2.width, height5 = layout2.height;
  var borderRightColor = style.borderRightColor, borderRightStyle = style.borderRightStyle, borderRightWidth = style.borderRightWidth, borderTopWidth = style.borderTopWidth, borderBottomWidth = style.borderBottomWidth;
  var c0 = rbr * (1 - KAPPA);
  var c1 = rtr * (1 - KAPPA);
  ctx.moveTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);
  ctx.lineTo(left + width, top + height5 - rbr);
  ctx.bezierCurveTo(left + width, top + height5 - c0, left + width - c0, top + height5, left + width - rbr, top + height5);
  ctx.strokeColor(borderRightColor);
  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);
  if (borderRightStyle === "dashed") {
    ctx.dash(borderRightWidth * 2, {
      space: borderRightWidth * 1.2
    });
  } else if (borderRightStyle === "dotted") {
    ctx.dash(borderRightWidth, {
      space: borderRightWidth * 1.2
    });
  }
  ctx.stroke();
  ctx.undash();
};
var clipBorderBottom = function clipBorderBottom2(ctx, layout2, style, rbl, rbr) {
  var top = layout2.top, left = layout2.left, width = layout2.width, height5 = layout2.height;
  var borderBottomWidth = style.borderBottomWidth, borderRightWidth = style.borderRightWidth, borderLeftWidth = style.borderLeftWidth;
  ctx.moveTo(left + width - rbr, top + height5);
  ctx.lineTo(left + rbl, top + height5);
  var c0 = rbl * (1 - KAPPA);
  ctx.bezierCurveTo(left + c0, top + height5, left, top + height5 - c0, left, top + height5 - rbl);
  var bottomLeftYCoord = top + height5 - Math.max(borderBottomWidth, rbl);
  ctx.lineTo(left, bottomLeftYCoord);
  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);
  var innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);
  var innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);
  var c1 = innerBottomLeftRadiusX * (1 - KAPPA);
  var c2 = innerBottomLeftRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + borderLeftWidth, top + height5 - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height5 - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height5 - borderBottomWidth);
  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height5 - borderBottomWidth);
  var innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);
  var innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);
  var c3 = innerBottomRightRadiusX * (1 - KAPPA);
  var c4 = innerBottomRightRadiusY * (1 - KAPPA);
  var bottomRightYCoord = top + height5 - Math.max(borderBottomWidth, rbr);
  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height5 - borderBottomWidth, left + width - borderRightWidth, top + height5 - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);
  ctx.lineTo(left + width, bottomRightYCoord);
  ctx.lineTo(left + width, top + height5 - rbr);
  var c5 = rbr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width, top + height5 - c5, left + width - c5, top + height5, left + width - rbr, top + height5);
  ctx.closePath();
  ctx.clip();
  if (borderRightWidth) {
    var brSlope = borderBottomWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height5);
    ctx.lineTo(left + width, top + height5);
    ctx.lineTo(left, top + height5);
    ctx.lineTo(left, top);
    ctx.closePath();
    ctx.clip();
  }
  if (borderLeftWidth) {
    var trSlope = -borderBottomWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height5);
    ctx.lineTo(left, top + height5);
    ctx.lineTo(left + width, top + height5);
    ctx.lineTo(left + width, top);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderBottom = function fillBorderBottom2(ctx, layout2, style, rbl, rbr) {
  var top = layout2.top, left = layout2.left, width = layout2.width, height5 = layout2.height;
  var borderBottomColor = style.borderBottomColor, borderBottomStyle = style.borderBottomStyle, borderBottomWidth = style.borderBottomWidth, borderRightWidth = style.borderRightWidth, borderLeftWidth = style.borderLeftWidth;
  var c0 = rbl * (1 - KAPPA);
  var c1 = rbr * (1 - KAPPA);
  ctx.moveTo(left + width, top + height5 - rbr);
  ctx.bezierCurveTo(left + width, top + height5 - c1, left + width - c1, top + height5, left + width - rbr, top + height5);
  ctx.lineTo(left + rbl, top + height5);
  ctx.bezierCurveTo(left + c0, top + height5, left, top + height5 - c0, left, top + height5 - rbl);
  ctx.strokeColor(borderBottomColor);
  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);
  if (borderBottomStyle === "dashed") {
    ctx.dash(borderBottomWidth * 2, {
      space: borderBottomWidth * 1.2
    });
  } else if (borderBottomStyle === "dotted") {
    ctx.dash(borderBottomWidth, {
      space: borderBottomWidth * 1.2
    });
  }
  ctx.stroke();
  ctx.undash();
};
var clipBorderLeft = function clipBorderLeft2(ctx, layout2, style, rbl, rtl) {
  var top = layout2.top, left = layout2.left, width = layout2.width, height5 = layout2.height;
  var borderTopWidth = style.borderTopWidth, borderLeftWidth = style.borderLeftWidth, borderBottomWidth = style.borderBottomWidth;
  ctx.moveTo(left, top + height5 - rbl);
  ctx.lineTo(left, top + rtl);
  var c0 = rtl * (1 - KAPPA);
  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);
  var topLeftCoordX = left + Math.max(borderLeftWidth, rtl);
  ctx.lineTo(topLeftCoordX, top);
  ctx.lineTo(topLeftCoordX, top + borderTopWidth);
  var innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);
  var innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);
  var c1 = innerTopLeftRadiusX * (1 - KAPPA);
  var c2 = innerTopLeftRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));
  ctx.lineTo(left + borderLeftWidth, top + height5 - Math.max(rbl, borderBottomWidth));
  var innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);
  var innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);
  var c3 = innerBottomLeftRadiusX * (1 - KAPPA);
  var c4 = innerBottomLeftRadiusY * (1 - KAPPA);
  var bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);
  ctx.bezierCurveTo(left + borderLeftWidth, top + height5 - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height5 - borderBottomWidth, bottomLeftXCoord, top + height5 - borderBottomWidth);
  ctx.lineTo(bottomLeftXCoord, top + height5);
  ctx.lineTo(left + rbl, top + height5);
  var c5 = rbl * (1 - KAPPA);
  ctx.bezierCurveTo(left + c5, top + height5, left, top + height5 - c5, left, top + height5 - rbl);
  ctx.closePath();
  ctx.clip();
  if (borderBottomWidth) {
    var trSlope = -borderBottomWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height5);
    ctx.lineTo(left, top + height5);
    ctx.lineTo(left, top);
    ctx.lineTo(left + width, top);
    ctx.closePath();
    ctx.clip();
  }
  if (borderBottomWidth) {
    var _trSlope2 = -borderTopWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, _trSlope2 * (-width / 2) + top);
    ctx.lineTo(left, top);
    ctx.lineTo(left, top + height5);
    ctx.lineTo(left + width, top + height5);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderLeft = function fillBorderLeft2(ctx, layout2, style, rbl, rtl) {
  var top = layout2.top, left = layout2.left, height5 = layout2.height;
  var borderLeftColor = style.borderLeftColor, borderLeftStyle = style.borderLeftStyle, borderLeftWidth = style.borderLeftWidth, borderTopWidth = style.borderTopWidth, borderBottomWidth = style.borderBottomWidth;
  var c0 = rbl * (1 - KAPPA);
  var c1 = rtl * (1 - KAPPA);
  ctx.moveTo(left + rbl, top + height5);
  ctx.bezierCurveTo(left + c0, top + height5, left, top + height5 - c0, left, top + height5 - rbl);
  ctx.lineTo(left, top + rtl);
  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);
  ctx.strokeColor(borderLeftColor);
  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);
  if (borderLeftStyle === "dashed") {
    ctx.dash(borderLeftWidth * 2, {
      space: borderLeftWidth * 1.2
    });
  } else if (borderLeftStyle === "dotted") {
    ctx.dash(borderLeftWidth, {
      space: borderLeftWidth * 1.2
    });
  }
  ctx.stroke();
  ctx.undash();
};
var shouldRenderBorders = function shouldRenderBorders2(node) {
  return node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);
};
var renderBorders = function renderBorders2(ctx, node) {
  if (!shouldRenderBorders(node)) return;
  var _node$box = node.box, width = _node$box.width, height5 = _node$box.height, borderTopWidth = _node$box.borderTopWidth, borderLeftWidth = _node$box.borderLeftWidth, borderRightWidth = _node$box.borderRightWidth, borderBottomWidth = _node$box.borderBottomWidth;
  var _node$style = node.style, opacity2 = _node$style.opacity, _node$style$borderTop = _node$style.borderTopLeftRadius, borderTopLeftRadius = _node$style$borderTop === void 0 ? 0 : _node$style$borderTop, _node$style$borderTop2 = _node$style.borderTopRightRadius, borderTopRightRadius = _node$style$borderTop2 === void 0 ? 0 : _node$style$borderTop2, _node$style$borderBot = _node$style.borderBottomLeftRadius, borderBottomLeftRadius = _node$style$borderBot === void 0 ? 0 : _node$style$borderBot, _node$style$borderBot2 = _node$style.borderBottomRightRadius, borderBottomRightRadius = _node$style$borderBot2 === void 0 ? 0 : _node$style$borderBot2, _node$style$borderTop3 = _node$style.borderTopColor, borderTopColor = _node$style$borderTop3 === void 0 ? "black" : _node$style$borderTop3, _node$style$borderTop4 = _node$style.borderTopStyle, borderTopStyle = _node$style$borderTop4 === void 0 ? "solid" : _node$style$borderTop4, _node$style$borderLef = _node$style.borderLeftColor, borderLeftColor = _node$style$borderLef === void 0 ? "black" : _node$style$borderLef, _node$style$borderLef2 = _node$style.borderLeftStyle, borderLeftStyle = _node$style$borderLef2 === void 0 ? "solid" : _node$style$borderLef2, _node$style$borderRig = _node$style.borderRightColor, borderRightColor = _node$style$borderRig === void 0 ? "black" : _node$style$borderRig, _node$style$borderRig2 = _node$style.borderRightStyle, borderRightStyle = _node$style$borderRig2 === void 0 ? "solid" : _node$style$borderRig2, _node$style$borderBot3 = _node$style.borderBottomColor, borderBottomColor = _node$style$borderBot3 === void 0 ? "black" : _node$style$borderBot3, _node$style$borderBot4 = _node$style.borderBottomStyle, borderBottomStyle = _node$style$borderBot4 === void 0 ? "solid" : _node$style$borderBot4;
  var style = {
    borderTopColor,
    borderTopWidth,
    borderTopStyle,
    borderLeftColor,
    borderLeftWidth,
    borderLeftStyle,
    borderRightColor,
    borderRightWidth,
    borderRightStyle,
    borderBottomColor,
    borderBottomWidth,
    borderBottomStyle,
    borderTopLeftRadius,
    borderTopRightRadius,
    borderBottomLeftRadius,
    borderBottomRightRadius
  };
  var rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height5);
  var rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height5);
  var rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height5);
  var rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height5);
  ctx.save();
  ctx.strokeOpacity(opacity2);
  if (borderTopWidth) {
    ctx.save();
    clipBorderTop(ctx, node.box, style, rtr, rtl);
    fillBorderTop(ctx, node.box, style, rtr, rtl);
    ctx.restore();
  }
  if (borderRightWidth) {
    ctx.save();
    clipBorderRight(ctx, node.box, style, rtr, rbr);
    fillBorderRight(ctx, node.box, style, rtr, rbr);
    ctx.restore();
  }
  if (borderBottomWidth) {
    ctx.save();
    clipBorderBottom(ctx, node.box, style, rbl, rbr);
    fillBorderBottom(ctx, node.box, style, rbl, rbr);
    ctx.restore();
  }
  if (borderLeftWidth) {
    ctx.save();
    clipBorderLeft(ctx, node.box, style, rbl, rtl);
    fillBorderLeft(ctx, node.box, style, rbl, rtl);
    ctx.restore();
  }
  ctx.restore();
};
var drawBackground = function drawBackground2(ctx, node) {
  var _node$style;
  var _node$box = node.box, top = _node$box.top, left = _node$box.left, width = _node$box.width, height5 = _node$box.height;
  var color = parseColor(node.style.backgroundColor);
  var nodeOpacity = isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity) ? 1 : node.style.opacity;
  var opacity2 = Math.min(color.opacity, nodeOpacity);
  ctx.fillOpacity(opacity2).fillColor(color.value).rect(left, top, width, height5).fill();
};
var renderBackground2 = function renderBackground3(ctx, node) {
  var _node$style2;
  var hasBackground = !!node.box && !!((_node$style2 = node.style) !== null && _node$style2 !== void 0 && _node$style2.backgroundColor);
  if (hasBackground) {
    ctx.save();
    clipNode(ctx, node);
    drawBackground(ctx, node);
    ctx.restore();
  }
};
var isSrcId2 = function isSrcId3(value2) {
  return /^#.+/.test(value2);
};
var setLink = function setLink2(ctx, node) {
  var props = node.props || {};
  var _node$box = node.box, top = _node$box.top, left = _node$box.left, width = _node$box.width, height5 = _node$box.height;
  var src = props.src || props.href;
  if (src) {
    var isId = isSrcId2(src);
    var method = isId ? "goTo" : "link";
    var value2 = isId ? src.slice(1) : src;
    ctx[method](left, top, width, height5, value2);
  }
};
var setDestination = function setDestination2(ctx, node) {
  var _node$props;
  if ((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.id) {
    ctx.addNamedDestination(node.props.id, "XYZ", null, node.box.top, null);
  }
};
var _renderFns;
var isRecursiveNode = function isRecursiveNode2(node) {
  return node.type !== Text && node.type !== Svg;
};
var renderChildren = function renderChildren2(ctx, node, options) {
  ctx.save();
  if (node.box) {
    ctx.translate(node.box.left, node.box.top);
  }
  var children = node.children || [];
  var renderChild = function renderChild2(child) {
    return renderNode2(ctx, child, options);
  };
  children.forEach(renderChild);
  ctx.restore();
};
var renderFns = (_renderFns = {}, _renderFns[Text] = renderText, _renderFns[Note] = renderNote, _renderFns[Image] = renderImage2, _renderFns[Canvas] = renderCanvas, _renderFns[Svg] = renderSvg, _renderFns[Link] = setLink, _renderFns);
var renderNode2 = function renderNode3(ctx, node, options) {
  var _node$style;
  var overflowHidden = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.overflow) === "hidden";
  var shouldRenderChildren = isRecursiveNode(node);
  if (node.type === Page) renderPage(ctx, node);
  ctx.save();
  if (overflowHidden) clipNode(ctx, node);
  applyTransformations(ctx, node);
  renderBackground2(ctx, node);
  renderBorders(ctx, node);
  var renderFn = renderFns[node.type];
  if (renderFn) renderFn(ctx, node, options);
  if (shouldRenderChildren) renderChildren(ctx, node, options);
  setDestination(ctx, node);
  renderDebug(ctx, node);
  ctx.restore();
};
var setPDFMetadata = function setPDFMetadata2(target) {
  return function(key, value2) {
    if (value2) target.info[key] = value2;
  };
};
var addMetadata = function addMetadata2(ctx, doc) {
  var _props$creator, _props$producer;
  var setProp = setPDFMetadata(ctx);
  var props = doc.props || {};
  var title3 = props.title || null;
  var author2 = props.author || null;
  var subject = props.subject || null;
  var keywords = props.keywords || null;
  var creator = (_props$creator = props.creator) != null ? _props$creator : "react-pdf";
  var producer = (_props$producer = props.producer) != null ? _props$producer : "react-pdf";
  var creationDate = props.creationDate || /* @__PURE__ */ new Date();
  var modificationDate = props.modificationDate || null;
  setProp("Title", title3);
  setProp("Author", author2);
  setProp("Subject", subject);
  setProp("Keywords", keywords);
  setProp("Creator", creator);
  setProp("Producer", producer);
  setProp("CreationDate", creationDate);
  setProp("ModificationDate", modificationDate);
};
var addNodeBookmark = function addNodeBookmark2(ctx, node, pageNumber, registry) {
  var _node$props;
  var bookmark = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.bookmark;
  if (bookmark) {
    var title3 = bookmark.title, parent = bookmark.parent, expanded = bookmark.expanded, zoom = bookmark.zoom, fit = bookmark.fit;
    var outline = registry[parent] || ctx.outline;
    var top = bookmark.top || node.box.top;
    var left = bookmark.left || node.box.left;
    var instance = outline.addItem(title3, {
      pageNumber,
      expanded,
      top,
      left,
      zoom,
      fit
    });
    registry[bookmark.ref] = instance;
  }
  if (!node.children) return;
  node.children.forEach(function(child) {
    return addNodeBookmark2(ctx, child, pageNumber, registry);
  });
};
var addBookmarks = function addBookmarks2(ctx, root) {
  var registry = {};
  var pages = root.children || [];
  pages.forEach(function(page, i) {
    addNodeBookmark(ctx, page, i, registry);
  });
};
var render = function render2(ctx, doc) {
  var pages = doc.children || [];
  var options = {
    imageCache: /* @__PURE__ */ new Map()
  };
  addMetadata(ctx, doc);
  pages.forEach(function(page) {
    return renderNode2(ctx, page, options);
  });
  addBookmarks(ctx, doc);
  ctx.end();
  return ctx;
};

// ../../.yarn/cache/@babel-runtime-npm-7.25.0-a7bca33687-bd3faf2461.zip/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t2, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e2) {
    return t3.__proto__ = e2, t3;
  }, _setPrototypeOf(t2, e);
}

// ../../.yarn/cache/@babel-runtime-npm-7.25.0-a7bca33687-bd3faf2461.zip/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t2, o) {
  t2.prototype = Object.create(o.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o);
}

// ../../.yarn/cache/@babel-runtime-npm-7.25.0-a7bca33687-bd3faf2461.zip/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

// ../../.yarn/cache/@react-pdf-pdfkit-npm-3.1.10-a4a5df5869-62de5af0c3.zip/node_modules/@react-pdf/pdfkit/lib/pdfkit.browser.js
var import_zstream = __toESM(require_zstream());
var import_deflate = __toESM(require_deflate());
var import_inflate = __toESM(require_inflate());
var import_constants = __toESM(require_constants());

// ../../.yarn/cache/@babel-runtime-npm-7.25.0-a7bca33687-bd3faf2461.zip/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(r, a2) {
  (null == a2 || a2 > r.length) && (a2 = r.length);
  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
  return n;
}

// ../../.yarn/cache/@babel-runtime-npm-7.25.0-a7bca33687-bd3faf2461.zip/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(r, a2) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a2);
    var t2 = {}.toString.call(r).slice(8, -1);
    return "Object" === t2 && r.constructor && (t2 = r.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r, a2) : void 0;
  }
}

// ../../.yarn/cache/@babel-runtime-npm-7.25.0-a7bca33687-bd3faf2461.zip/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelperLoose.js
function _createForOfIteratorHelperLoose(r, e) {
  var t2 = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (t2) return (t2 = t2.call(r)).next.bind(t2);
  if (Array.isArray(r) || (t2 = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
    t2 && (r = t2);
    var o = 0;
    return function() {
      return o >= r.length ? {
        done: true
      } : {
        done: false,
        value: r[o++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// ../../.yarn/cache/@babel-runtime-npm-7.25.0-a7bca33687-bd3faf2461.zip/node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t2, r) {
  if ("object" != _typeof(t2) || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t2, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t2);
}

// ../../.yarn/cache/@babel-runtime-npm-7.25.0-a7bca33687-bd3faf2461.zip/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

// ../../.yarn/cache/@babel-runtime-npm-7.25.0-a7bca33687-bd3faf2461.zip/node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e, r) {
  for (var t2 = 0; t2 < r.length; t2++) {
    var o = r[t2];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t2) {
  return r && _defineProperties(e.prototype, r), t2 && _defineProperties(e, t2), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}

// ../../.yarn/cache/@react-pdf-pdfkit-npm-3.1.10-a4a5df5869-62de5af0c3.zip/node_modules/@react-pdf/pdfkit/lib/pdfkit.browser.js
var import_md5 = __toESM(require_md5());

// ../../.yarn/cache/jay-peg-npm-1.0.2-72f22f5a77-5681959a18.zip/node_modules/jay-peg/src/markers/dac.js
var DACTable = new Struct({
  identifier: new BufferT(1),
  value: new BufferT(1)
});
var DACMarker = {
  name: () => "DAC",
  length: uint16be,
  tables: new ArrayT(DACTable, (parent) => parent.length / 2)
};
var dac_default = DACMarker;

// ../../.yarn/cache/jay-peg-npm-1.0.2-72f22f5a77-5681959a18.zip/node_modules/jay-peg/src/markers/utils.js
var readUInt8 = (array, offset3) => {
  return array[offset3];
};
var readUInt16BE = (array, offset3) => {
  return array[offset3] << 8 | array[offset3 + 1];
};
var readUInt16LE = (array, offset3) => {
  return array[offset3] | array[offset3 + 1] << 8;
};
var readUInt32BE = (array, offset3) => {
  return array[offset3] << 24 | array[offset3 + 1] << 16 | array[offset3 + 2] << 8 | array[offset3 + 3];
};
var readUInt32LE = (array, offset3) => {
  return array[offset3] | array[offset3 + 1] << 8 | array[offset3 + 2] << 16 | array[offset3 + 3] << 24;
};
var uint8ArrayToHexString = (uint8Array) => {
  return Array.from(
    uint8Array,
    (byte) => byte.toString(16).padStart(2, "0")
  ).join("");
};
var decoder = new TextDecoder("utf-8");
var uint8ArrayToString = (uint8Array) => {
  return decoder.decode(uint8Array);
};
var concatenateUint8Arrays = (arrays) => {
  const totalLength = arrays.reduce((length4, arr) => length4 + arr.length, 0);
  const concatenatedArray = new Uint8Array(totalLength);
  let offset3 = 0;
  arrays.forEach((arr) => {
    concatenatedArray.set(arr, offset3);
    offset3 += arr.length;
  });
  return concatenatedArray;
};

// ../../.yarn/cache/jay-peg-npm-1.0.2-72f22f5a77-5681959a18.zip/node_modules/jay-peg/src/markers/dht.js
var HuffmanTableElements = class {
  decode(stream2, parent) {
    const tables = {};
    let buffer = stream2.buffer.slice(
      stream2.pos,
      stream2.pos + parent.length - 2
    );
    while (buffer.length > 0) {
      let offset3 = 1;
      const elements = [];
      const identifier = readUInt8(buffer, 0);
      const lengths = buffer.slice(offset3, offset3 + 16);
      offset3 += 16;
      for (const length4 of lengths) {
        elements.push(buffer.slice(offset3, offset3 + length4));
        offset3 += length4;
      }
      buffer = buffer.slice(offset3);
      tables[identifier] = concatenateUint8Arrays(elements);
    }
    stream2.pos += parent.length - 2;
    return tables;
  }
};
var DefineHuffmanTableMarker = {
  name: () => "DHT",
  length: uint16be,
  tables: new HuffmanTableElements()
};
var dht_default = DefineHuffmanTableMarker;

// ../../.yarn/cache/jay-peg-npm-1.0.2-72f22f5a77-5681959a18.zip/node_modules/jay-peg/src/markers/dqt.js
var DQTMarker = {
  name: () => "DQT",
  length: uint16be,
  tables: new ArrayT(
    new Struct({
      identifier: new BufferT(1),
      data: new BufferT(64)
    }),
    (parent) => (parent.length - 2) / 65
  )
};
var dqt_default = DQTMarker;

// ../../.yarn/cache/jay-peg-npm-1.0.2-72f22f5a77-5681959a18.zip/node_modules/jay-peg/src/markers/dri.js
var DRIMarker = {
  name: () => "DRI",
  length: uint16be,
  restartInterval: uint16be
};
var dri_default = DRIMarker;

// ../../.yarn/cache/jay-peg-npm-1.0.2-72f22f5a77-5681959a18.zip/node_modules/jay-peg/src/markers/eoi.js
var EndOfImageMarker = {
  name: () => "EOI"
};
var eoi_default = EndOfImageMarker;

// ../../.yarn/cache/jay-peg-npm-1.0.2-72f22f5a77-5681959a18.zip/node_modules/jay-peg/src/markers/exif.js
var tags = {
  ifd: {
    "010e": "imageDescription",
    "010f": "make",
    "011a": "xResolution",
    "011b": "yResolution",
    "011c": "planarConfiguration",
    "012d": "transferFunction",
    "013b": "artist",
    "013e": "whitePoint",
    "013f": "primaryChromaticities",
    "0100": "imageWidth",
    "0101": "imageHeight",
    "0102": "bitsPerSample",
    "0103": "compression",
    "0106": "photometricInterpretation",
    "0110": "model",
    "0111": "stripOffsets",
    "0112": "orientation",
    "0115": "samplesPerPixel",
    "0116": "rowsPerStrip",
    "0117": "stripByteCounts",
    "0128": "resolutionUnit",
    "0131": "software",
    "0132": "dateTime",
    "0201": "jpegInterchangeFormat",
    "0202": "jpegInterchangeFormatLength",
    "0211": "ycbCrCoefficients",
    "0212": "ycbCrSubSampling",
    "0213": "ycbCrPositioning",
    "0214": "referenceBlackWhite",
    "829a": "exposureTime",
    "829d": "fNumber",
    "920a": "focalLength",
    "927c": "makerNote",
    8298: "copyright",
    8769: "exifIFDPointer",
    8822: "exposureProgram",
    8824: "spectralSensitivity",
    8825: "gpsInfoIFDPointer",
    8827: "photographicSensitivity",
    8828: "oecf",
    8830: "sensitivityType",
    8831: "standardOutputSensitivity",
    8832: "recommendedExposureIndex",
    8833: "isoSpeed",
    8834: "isoSpeedLatitudeyyy",
    8835: "isoSpeedLatitudezzz",
    9e3: "exifVersion",
    9003: "dateTimeOriginal",
    9004: "dateTimeDigitized",
    9101: "componentsConfiguration",
    9102: "compressedBitsPerPixel",
    9201: "shutterSpeedValue",
    9202: "apertureValue",
    9203: "brightnessValue",
    9204: "exposureBiasValue",
    9205: "maxApertureValue",
    9206: "subjectDistance",
    9207: "meteringMode",
    9208: "lightSource",
    9209: "flash",
    9214: "subjectArea",
    9286: "userComment",
    9290: "subSecTime",
    9291: "subSecTimeOriginal",
    9292: "subSecTimeDigitized",
    a000: "flashpixVersion",
    a001: "colorSpace",
    a002: "pixelXDimension",
    a003: "pixelYDimension",
    a004: "relatedSoundFile",
    a005: "interoperabilityIFDPointer",
    a20b: "flashEnergy",
    a20c: "spatialFrequencyResponse",
    a20e: "focalPlaneXResolution",
    a20f: "focalPlaneYResolution",
    a40a: "sharpness",
    a40b: "deviceSettingDescription",
    a40c: "subjectDistanceRange",
    a210: "focalPlaneResolutionUnit",
    a214: "subjectLocation",
    a215: "exposureIndex",
    a217: "sensingMethod",
    a300: "fileSource",
    a301: "sceneType",
    a302: "cfaPattern",
    a401: "customRendered",
    a402: "exposureMode",
    a403: "whiteBalance",
    a404: "digitalZoomRatio",
    a405: "focalLengthIn35mmFilm",
    a406: "sceneCaptureType",
    a407: "gainControl",
    a408: "contrast",
    a409: "saturation",
    a420: "imageUniqueID",
    a430: "cameraOwnerName",
    a431: "bodySerialNumber",
    a432: "lensSpecification",
    a433: "lensMake",
    a434: "lensModel",
    a435: "lensSerialNumber",
    a500: "gamma"
  },
  gps: {
    "0000": "gpsVersionID",
    "0001": "gpsLatitudeRef",
    "0002": "gpsLatitude",
    "0003": "gpsLongitudeRef",
    "0004": "gpsLongitude",
    "0005": "gpsAltitudeRef",
    "0006": "gpsAltitude",
    "0007": "gpsTimeStamp",
    "0008": "gpsSatellites",
    "0009": "gpsStatus",
    "000a": "gpsMeasureMode",
    "000b": "gpsDOP",
    "000c": "gpsSpeedRef",
    "000d": "gpsSpeed",
    "000e": "gpsTrackRef",
    "000f": "gpsTrack",
    "0010": "gpsImgDirectionRef",
    "0011": "gpsImgDirection",
    "0012": "gpsMapDatum",
    "0013": "gpsDestLatitudeRef",
    "0014": "gpsDestLatitude",
    "0015": "gpsDestLongitudeRef",
    "0016": "gpsDestLongitude",
    "0017": "gpsDestBearingRef",
    "0018": "gpsDestBearing",
    "0019": "gpsDestDistanceRef",
    "001a": "gpsDestDistance",
    "001b": "gpsProcessingMethod",
    "001c": "gpsAreaInformation",
    "001d": "gpsDateStamp",
    "001e": "gpsDifferential",
    "001f": "gpsHPositioningError"
  }
};
var IDFEntries = class {
  constructor(bigEndian) {
    this.bigEndian = bigEndian;
    this.bytes = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8];
  }
  _getTagValue(dataValue, dataFormat) {
    const uint162 = (pos) => this.bigEndian ? readUInt16BE(dataValue, pos) : readUInt16LE(dataValue, pos);
    const uint322 = (pos) => this.bigEndian ? readUInt32BE(dataValue, pos) : readUInt32LE(dataValue, pos);
    switch (dataFormat) {
      case 1:
        return readUInt8(dataValue, 0);
      case 2:
        return dataValue.toString("ascii").replace(/\0+$/, "");
      case 3:
        return uint162(0);
      case 4:
        return uint322(0);
      case 5:
        const tagValue = [];
        for (var i = 0; i < dataValue.length; i += 8) {
          tagValue.push(uint322(i) / uint322(i + 4));
        }
        return tagValue;
      case 7:
        return null;
      case 10: {
        return uint322(0) / uint322(4);
      }
      default:
        return "0x" + dataValue.toString("hex");
    }
  }
  _decodeIDFEntries(buffer, tags2, offset3, log3 = false) {
    let pos = 2;
    const entries = {};
    const uint162 = (pos2) => this.bigEndian ? readUInt16BE(buffer, pos2) : readUInt16LE(buffer, pos2);
    const uint322 = (pos2) => this.bigEndian ? readUInt32BE(buffer, pos2) : readUInt32LE(buffer, pos2);
    const numberOfEntries = uint162(0);
    for (let i = 0; i < numberOfEntries; i++) {
      const tagAddress = buffer.slice(pos, pos + 2);
      const dataFormat = uint162(pos + 2);
      const componentsNumber = uint322(pos + 4);
      const componentsBytes = this.bytes[dataFormat];
      const dataLength = componentsNumber * componentsBytes;
      let dataValue = buffer.slice(pos + 8, pos + 12);
      if (dataLength > 4) {
        const valueOffset = this.bigEndian ? readUInt32BE(dataValue, 0) : readUInt32LE(dataValue, 0);
        const dataOffset = valueOffset - offset3;
        dataValue = buffer.slice(dataOffset, dataOffset + dataLength);
      }
      const tagValue = this._getTagValue(dataValue, dataFormat);
      const tagNumber = this.bigEndian ? uint8ArrayToHexString(tagAddress) : uint8ArrayToHexString(tagAddress.reverse());
      const tagName = tags2[tagNumber];
      entries[tagName] = tagValue;
      pos += 12;
    }
    return entries;
  }
  decode(stream2, parent) {
    let buffer = stream2.buffer.slice(stream2.pos);
    const offsetToFirstIFD = parent.offsetToFirstIFD;
    if (offsetToFirstIFD > buffer.length) {
      stream2.pos += parent.parent.length - 16;
      return {};
    }
    const entries = this._decodeIDFEntries(buffer, tags.ifd, offsetToFirstIFD);
    const { exifIFDPointer, gpsInfoIFDPointer } = entries;
    if (exifIFDPointer) {
      buffer = buffer.slice(exifIFDPointer - offsetToFirstIFD);
      entries.subExif = this._decodeIDFEntries(
        buffer,
        tags.ifd,
        exifIFDPointer
      );
    }
    if (gpsInfoIFDPointer) {
      const gps = gpsInfoIFDPointer;
      buffer = buffer.slice(
        exifIFDPointer ? gps - exifIFDPointer : gps - offsetToFirstIFD
      );
      entries.gpsInfo = this._decodeIDFEntries(buffer, tags.gps, gps, true);
    }
    stream2.pos += parent.parent.length - 16;
    return entries;
  }
};
var IFDData = (bigEndian) => {
  const uint162 = bigEndian ? uint16be : uint16le;
  const uint322 = bigEndian ? uint32be : uint32le;
  return new Struct({
    fortyTwo: uint162,
    offsetToFirstIFD: uint322,
    entries: new IDFEntries(bigEndian)
  });
};
var TIFFHeader = class {
  decode(stream2, parent) {
    const byteOrder = uint8ArrayToString(
      stream2.buffer.slice(stream2.pos, stream2.pos + 2)
    );
    const bigEndian = byteOrder === "MM";
    stream2.pos += 2;
    const data2 = IFDData(bigEndian).decode(stream2, parent);
    return data2.entries;
  }
};
var EXIFMarker = {
  name: () => "EXIF",
  length: uint16be,
  identifier: new StringT(6),
  entries: new TIFFHeader()
};
var exif_default = EXIFMarker;

// ../../.yarn/cache/jay-peg-npm-1.0.2-72f22f5a77-5681959a18.zip/node_modules/jay-peg/src/markers/jfif.js
var JFIFMarker = {
  name: () => "JFIF",
  length: uint16be,
  identifier: new StringT(5),
  version: uint16be,
  units: uint8,
  xDensity: uint16be,
  yDensity: uint16be,
  thumbnailWidth: uint8,
  thumbnailHeight: uint8
};
var jfif_default = JFIFMarker;

// ../../.yarn/cache/jay-peg-npm-1.0.2-72f22f5a77-5681959a18.zip/node_modules/jay-peg/src/markers/sos.js
var ImageData = class {
  decode(stream2) {
    const buffer = stream2.buffer.slice(stream2.pos);
    let length4 = 0;
    let i = buffer.indexOf(255);
    while (i !== -1) {
      length4 = i;
      const nextByte = buffer[length4 + 1];
      const comesRestart = nextByte >= 208 && nextByte <= 215;
      if (nextByte !== 0 && !comesRestart) break;
      i = buffer.indexOf(255, i + 1);
    }
    stream2.pos += length4;
    return buffer.slice(0, length4);
  }
};
var SOSComponentSpecification = new Struct({
  scanComponentSelector: uint8,
  entropyCodingTable: new BufferT(1)
});
var SOSMarker = {
  name: () => "SOS",
  length: uint16be,
  numberOfImageComponents: uint8,
  componentSpecifications: new ArrayT(
    SOSComponentSpecification,
    (parent) => parent.numberOfImageComponents
  ),
  startOfSpectral: uint8,
  endOfSpectral: uint8,
  successiveApproximationBit: new BufferT(1),
  data: new ImageData()
};
var sos_default = SOSMarker;

// ../../.yarn/cache/jay-peg-npm-1.0.2-72f22f5a77-5681959a18.zip/node_modules/jay-peg/src/markers/sof.js
var FrameColorComponent = new Struct({
  id: uint8,
  samplingFactors: uint8,
  quantizationTableId: uint8
});
var StartOfFrameMarker = {
  name: () => "SOF",
  length: uint16be,
  precision: uint8,
  height: uint16be,
  width: uint16be,
  numberOfComponents: uint8,
  components: new ArrayT(
    FrameColorComponent,
    (parent) => parent.numberOfComponents
  )
};
var sof_default = StartOfFrameMarker;

// ../../.yarn/cache/jay-peg-npm-1.0.2-72f22f5a77-5681959a18.zip/node_modules/jay-peg/src/markers/soi.js
var StartOfImageMarker = {
  name: () => "SOI"
};
var soi_default = StartOfImageMarker;

// ../../.yarn/cache/jay-peg-npm-1.0.2-72f22f5a77-5681959a18.zip/node_modules/jay-peg/src/index.js
var UnkownMarker = {
  length: uint16be,
  buf: new BufferT((parent) => parent.length - 2)
};
var unknownMarkers = Array(63).fill(0).reduce((acc, v2, i) => ({ ...acc, [i + 65472]: UnkownMarker }), {});
var Marker = new VersionedStruct(uint16be, {
  ...unknownMarkers,
  65472: sof_default,
  65473: sof_default,
  65474: sof_default,
  65475: sof_default,
  65476: dht_default,
  65477: sof_default,
  65478: sof_default,
  65479: sof_default,
  65481: sof_default,
  65482: sof_default,
  65483: sof_default,
  65484: dac_default,
  65485: sof_default,
  65486: sof_default,
  65487: sof_default,
  65496: soi_default,
  65497: eoi_default,
  65498: sos_default,
  65499: dqt_default,
  65501: dri_default,
  65504: jfif_default,
  65505: exif_default
});
var JPEG = new ArrayT(Marker);
var decode = (buffer) => {
  const markers = JPEG.fromBuffer(buffer);
  return markers.map(({ version: version4, ...rest }) => ({ type: version4, ...rest }));
};
var src_default = { decode };

// ../../.yarn/cache/@react-pdf-png-js-npm-2.3.1-e17b137dee-63f54ab19b.zip/node_modules/@react-pdf/png-js/lib/png-js.browser.js
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L2 = 0;
  for (i = 0, j = 0; i < l2; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L2++] = tmp >> 16 & 255;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L2++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint82, start3, end3) {
  var tmp;
  var output = [];
  for (var i = start3; i < end3; i += 3) {
    tmp = (uint82[i] << 16) + (uint82[i + 1] << 8) + uint82[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint82) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint82, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset3, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s2 = buffer[offset3 + i];
  i += d;
  e = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset3 + i], i += d, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer[offset3 + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
}
function write(buffer, value2, offset3, isLE, mLen, nBytes) {
  var e, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e)) < 1) {
      e--;
      c2 *= 2;
    }
    if (e + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e++;
      c2 /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset3 + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer[offset3 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset3 + i - d] |= s2 * 128;
}
var toString = {}.toString;
var isArray$1 = Array.isArray || function(arr) {
  return toString.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES = 50;
Buffer2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
var _kMaxLength = kMaxLength();
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length4) {
  if (kMaxLength() < length4) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length4);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length4);
    }
    that.length = length4;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length4) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length4);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length4);
}
Buffer2.poolSize = 8192;
Buffer2._augment = function(arr) {
  arr.__proto__ = Buffer2.prototype;
  return arr;
};
function from(that, value2, encodingOrOffset, length4) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value2, encodingOrOffset, length4);
  }
  if (typeof value2 === "string") {
    return fromString(that, value2, encodingOrOffset);
  }
  return fromObject(that, value2);
}
Buffer2.from = function(value2, encodingOrOffset, length4) {
  return from(null, value2, encodingOrOffset, length4);
};
if (Buffer2.TYPED_ARRAY_SUPPORT) {
  Buffer2.prototype.__proto__ = Uint8Array.prototype;
  Buffer2.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) ;
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill5, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill5 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill5, encoding) : createBuffer(that, size).fill(fill5);
  }
  return createBuffer(that, size);
}
Buffer2.alloc = function(size, fill5, encoding) {
  return alloc(null, size, fill5, encoding);
};
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
Buffer2.allocUnsafe = function(size) {
  return allocUnsafe(null, size);
};
Buffer2.allocUnsafeSlow = function(size) {
  return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length4 = byteLength2(string, encoding) | 0;
  that = createBuffer(that, length4);
  var actual = that.write(string, encoding);
  if (actual !== length4) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length4 = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length4);
  for (var i = 0; i < length4; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length4) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length4 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length4 === void 0) {
    array = new Uint8Array(array);
  } else if (length4 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length4);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray$1(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length4) {
  if (length4 >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length4 | 0;
}
function SlowBuffer(length4) {
  if (+length4 != length4) {
    length4 = 0;
  }
  return Buffer2.alloc(+length4);
}
Buffer2.isBuffer = isBuffer$1;
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
Buffer2.compare = function compare(a2, b) {
  if (!internalIsBuffer(a2) || !internalIsBuffer(b)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a2 === b) return 0;
  var x = a2.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a2[i] !== b[i]) {
      x = a2[i];
      y = b[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer2.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer2.concat = function concat(list, length4) {
  if (!isArray$1(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer2.alloc(0);
  }
  var i;
  if (length4 === void 0) {
    length4 = 0;
    for (i = 0; i < list.length; ++i) {
      length4 += list[i].length;
    }
  }
  var buffer = Buffer2.allocUnsafe(length4);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength2(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer2.byteLength = byteLength2;
function slowToString(encoding, start3, end3) {
  var loweredCase = false;
  if (start3 === void 0 || start3 < 0) {
    start3 = 0;
  }
  if (start3 > this.length) {
    return "";
  }
  if (end3 === void 0 || end3 > this.length) {
    end3 = this.length;
  }
  if (end3 <= 0) {
    return "";
  }
  end3 >>>= 0;
  start3 >>>= 0;
  if (end3 <= start3) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start3, end3);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start3, end3);
      case "ascii":
        return asciiSlice(this, start3, end3);
      case "latin1":
      case "binary":
        return latin1Slice(this, start3, end3);
      case "base64":
        return base64Slice(this, start3, end3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start3, end3);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer2.prototype._isBuffer = true;
function swap(b, n, m2) {
  var i = b[n];
  b[n] = b[m2];
  b[m2] = i;
}
Buffer2.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer2.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer2.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer2.prototype.toString = function toString2() {
  var length4 = this.length | 0;
  if (length4 === 0) return "";
  if (arguments.length === 0) return utf8Slice(this, 0, length4);
  return slowToString.apply(this, arguments);
};
Buffer2.prototype.equals = function equals(b) {
  if (!internalIsBuffer(b)) throw new TypeError("Argument must be a Buffer");
  if (this === b) return true;
  return Buffer2.compare(this, b) === 0;
};
Buffer2.prototype.inspect = function inspect() {
  var str = "";
  var max3 = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString("hex", 0, max3).match(/.{2}/g).join(" ");
    if (this.length > max3) str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer2.prototype.compare = function compare2(target, start3, end3, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start3 === void 0) {
    start3 = 0;
  }
  if (end3 === void 0) {
    end3 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start3 < 0 || end3 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start3 >= end3) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start3 >= end3) {
    return 1;
  }
  start3 >>>= 0;
  end3 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end3 - start3;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start3, end3);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read4(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read4(arr, i) === read4(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read4(arr, i + j) !== read4(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset3, length4) {
  offset3 = Number(offset3) || 0;
  var remaining = buf.length - offset3;
  if (!length4) {
    length4 = remaining;
  } else {
    length4 = Number(length4);
    if (length4 > remaining) {
      length4 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length4 > strLen / 2) {
    length4 = strLen / 2;
  }
  for (var i = 0; i < length4; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset3 + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset3, length4) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset3), buf, offset3, length4);
}
function asciiWrite(buf, string, offset3, length4) {
  return blitBuffer(asciiToBytes(string), buf, offset3, length4);
}
function latin1Write(buf, string, offset3, length4) {
  return asciiWrite(buf, string, offset3, length4);
}
function base64Write(buf, string, offset3, length4) {
  return blitBuffer(base64ToBytes(string), buf, offset3, length4);
}
function ucs2Write(buf, string, offset3, length4) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset3), buf, offset3, length4);
}
Buffer2.prototype.write = function write2(string, offset3, length4, encoding) {
  if (offset3 === void 0) {
    encoding = "utf8";
    length4 = this.length;
    offset3 = 0;
  } else if (length4 === void 0 && typeof offset3 === "string") {
    encoding = offset3;
    length4 = this.length;
    offset3 = 0;
  } else if (isFinite(offset3)) {
    offset3 = offset3 | 0;
    if (isFinite(length4)) {
      length4 = length4 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length4;
      length4 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset3;
  if (length4 === void 0 || length4 > remaining) length4 = remaining;
  if (string.length > 0 && (length4 < 0 || offset3 < 0) || offset3 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset3, length4);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset3, length4);
      case "ascii":
        return asciiWrite(this, string, offset3, length4);
      case "latin1":
      case "binary":
        return latin1Write(this, string, offset3, length4);
      case "base64":
        return base64Write(this, string, offset3, length4);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset3, length4);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer2.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start3, end3) {
  if (start3 === 0 && end3 === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start3, end3));
  }
}
function utf8Slice(buf, start3, end3) {
  end3 = Math.min(buf.length, end3);
  var res = [];
  var i = start3;
  while (i < end3) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end3) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start3, end3) {
  var ret = "";
  end3 = Math.min(buf.length, end3);
  for (var i = start3; i < end3; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start3, end3) {
  var ret = "";
  end3 = Math.min(buf.length, end3);
  for (var i = start3; i < end3; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start3, end3) {
  var len = buf.length;
  if (!start3 || start3 < 0) start3 = 0;
  if (!end3 || end3 < 0 || end3 > len) end3 = len;
  var out = "";
  for (var i = start3; i < end3; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start3, end3) {
  var bytes = buf.slice(start3, end3);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer2.prototype.slice = function slice(start3, end3) {
  var len = this.length;
  start3 = ~~start3;
  end3 = end3 === void 0 ? len : ~~end3;
  if (start3 < 0) {
    start3 += len;
    if (start3 < 0) start3 = 0;
  } else if (start3 > len) {
    start3 = len;
  }
  if (end3 < 0) {
    end3 += len;
    if (end3 < 0) end3 = 0;
  } else if (end3 > len) {
    end3 = len;
  }
  if (end3 < start3) end3 = start3;
  var newBuf;
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start3, end3);
    newBuf.__proto__ = Buffer2.prototype;
  } else {
    var sliceLen = end3 - start3;
    newBuf = new Buffer2(sliceLen, void 0);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start3];
    }
  }
  return newBuf;
};
function checkOffset(offset3, ext, length4) {
  if (offset3 % 1 !== 0 || offset3 < 0) throw new RangeError("offset is not uint");
  if (offset3 + ext > length4) throw new RangeError("Trying to access beyond buffer length");
}
Buffer2.prototype.readUIntLE = function readUIntLE(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset(offset3, byteLength5, this.length);
  var val = this[offset3];
  var mul = 1;
  var i = 0;
  while (++i < byteLength5 && (mul *= 256)) {
    val += this[offset3 + i] * mul;
  }
  return val;
};
Buffer2.prototype.readUIntBE = function readUIntBE(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset(offset3, byteLength5, this.length);
  }
  var val = this[offset3 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset3 + --byteLength5] * mul;
  }
  return val;
};
Buffer2.prototype.readUInt8 = function readUInt82(offset3, noAssert) {
  if (!noAssert) checkOffset(offset3, 1, this.length);
  return this[offset3];
};
Buffer2.prototype.readUInt16LE = function readUInt16LE2(offset3, noAssert) {
  if (!noAssert) checkOffset(offset3, 2, this.length);
  return this[offset3] | this[offset3 + 1] << 8;
};
Buffer2.prototype.readUInt16BE = function readUInt16BE2(offset3, noAssert) {
  if (!noAssert) checkOffset(offset3, 2, this.length);
  return this[offset3] << 8 | this[offset3 + 1];
};
Buffer2.prototype.readUInt32LE = function readUInt32LE2(offset3, noAssert) {
  if (!noAssert) checkOffset(offset3, 4, this.length);
  return (this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16) + this[offset3 + 3] * 16777216;
};
Buffer2.prototype.readUInt32BE = function readUInt32BE2(offset3, noAssert) {
  if (!noAssert) checkOffset(offset3, 4, this.length);
  return this[offset3] * 16777216 + (this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3]);
};
Buffer2.prototype.readIntLE = function readIntLE(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset(offset3, byteLength5, this.length);
  var val = this[offset3];
  var mul = 1;
  var i = 0;
  while (++i < byteLength5 && (mul *= 256)) {
    val += this[offset3 + i] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer2.prototype.readIntBE = function readIntBE(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset(offset3, byteLength5, this.length);
  var i = byteLength5;
  var mul = 1;
  var val = this[offset3 + --i];
  while (i > 0 && (mul *= 256)) {
    val += this[offset3 + --i] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer2.prototype.readInt8 = function readInt8(offset3, noAssert) {
  if (!noAssert) checkOffset(offset3, 1, this.length);
  if (!(this[offset3] & 128)) return this[offset3];
  return (255 - this[offset3] + 1) * -1;
};
Buffer2.prototype.readInt16LE = function readInt16LE(offset3, noAssert) {
  if (!noAssert) checkOffset(offset3, 2, this.length);
  var val = this[offset3] | this[offset3 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer2.prototype.readInt16BE = function readInt16BE(offset3, noAssert) {
  if (!noAssert) checkOffset(offset3, 2, this.length);
  var val = this[offset3 + 1] | this[offset3] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer2.prototype.readInt32LE = function readInt32LE(offset3, noAssert) {
  if (!noAssert) checkOffset(offset3, 4, this.length);
  return this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16 | this[offset3 + 3] << 24;
};
Buffer2.prototype.readInt32BE = function readInt32BE(offset3, noAssert) {
  if (!noAssert) checkOffset(offset3, 4, this.length);
  return this[offset3] << 24 | this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3];
};
Buffer2.prototype.readFloatLE = function readFloatLE(offset3, noAssert) {
  if (!noAssert) checkOffset(offset3, 4, this.length);
  return read(this, offset3, true, 23, 4);
};
Buffer2.prototype.readFloatBE = function readFloatBE(offset3, noAssert) {
  if (!noAssert) checkOffset(offset3, 4, this.length);
  return read(this, offset3, false, 23, 4);
};
Buffer2.prototype.readDoubleLE = function readDoubleLE(offset3, noAssert) {
  if (!noAssert) checkOffset(offset3, 8, this.length);
  return read(this, offset3, true, 52, 8);
};
Buffer2.prototype.readDoubleBE = function readDoubleBE(offset3, noAssert) {
  if (!noAssert) checkOffset(offset3, 8, this.length);
  return read(this, offset3, false, 52, 8);
};
function checkInt(buf, value2, offset3, ext, max3, min3) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max3 || value2 < min3) throw new RangeError('"value" argument is out of bounds');
  if (offset3 + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt(this, value2, offset3, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset3] = value2 & 255;
  while (++i < byteLength5 && (mul *= 256)) {
    this[offset3 + i] = value2 / mul & 255;
  }
  return offset3 + byteLength5;
};
Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt(this, value2, offset3, byteLength5, maxBytes, 0);
  }
  var i = byteLength5 - 1;
  var mul = 1;
  this[offset3 + i] = value2 & 255;
  while (--i >= 0 && (mul *= 256)) {
    this[offset3 + i] = value2 / mul & 255;
  }
  return offset3 + byteLength5;
};
Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt(this, value2, offset3, 1, 255, 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset3] = value2 & 255;
  return offset3 + 1;
};
function objectWriteUInt16(buf, value2, offset3, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i = 0, j = Math.min(buf.length - offset3, 2); i < j; ++i) {
    buf[offset3 + i] = (value2 & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt(this, value2, offset3, 2, 65535, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16(this, value2, offset3, true);
  }
  return offset3 + 2;
};
Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt(this, value2, offset3, 2, 65535, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
  } else {
    objectWriteUInt16(this, value2, offset3, false);
  }
  return offset3 + 2;
};
function objectWriteUInt32(buf, value2, offset3, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i = 0, j = Math.min(buf.length - offset3, 4); i < j; ++i) {
    buf[offset3 + i] = value2 >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt(this, value2, offset3, 4, 4294967295, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset3 + 3] = value2 >>> 24;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset3, true);
  }
  return offset3 + 4;
};
Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt(this, value2, offset3, 4, 4294967295, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset3, false);
  }
  return offset3 + 4;
};
Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt(this, value2, offset3, byteLength5, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset3] = value2 & 255;
  while (++i < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset3 + i - 1] !== 0) {
      sub = 1;
    }
    this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
  }
  return offset3 + byteLength5;
};
Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt(this, value2, offset3, byteLength5, limit - 1, -limit);
  }
  var i = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset3 + i] = value2 & 255;
  while (--i >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset3 + i + 1] !== 0) {
      sub = 1;
    }
    this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
  }
  return offset3 + byteLength5;
};
Buffer2.prototype.writeInt8 = function writeInt8(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt(this, value2, offset3, 1, 127, -128);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset3] = value2 & 255;
  return offset3 + 1;
};
Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt(this, value2, offset3, 2, 32767, -32768);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16(this, value2, offset3, true);
  }
  return offset3 + 2;
};
Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt(this, value2, offset3, 2, 32767, -32768);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
  } else {
    objectWriteUInt16(this, value2, offset3, false);
  }
  return offset3 + 2;
};
Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt(this, value2, offset3, 4, 2147483647, -2147483648);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt32(this, value2, offset3, true);
  }
  return offset3 + 4;
};
Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt(this, value2, offset3, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset3, false);
  }
  return offset3 + 4;
};
function checkIEEE754(buf, value2, offset3, ext, max3, min3) {
  if (offset3 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset3 < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value2, offset3, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value2, offset3, 4);
  }
  write(buf, value2, offset3, littleEndian, 23, 4);
  return offset3 + 4;
}
Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset3, noAssert) {
  return writeFloat(this, value2, offset3, true, noAssert);
};
Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset3, noAssert) {
  return writeFloat(this, value2, offset3, false, noAssert);
};
function writeDouble(buf, value2, offset3, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value2, offset3, 8);
  }
  write(buf, value2, offset3, littleEndian, 52, 8);
  return offset3 + 8;
}
Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset3, noAssert) {
  return writeDouble(this, value2, offset3, true, noAssert);
};
Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset3, noAssert) {
  return writeDouble(this, value2, offset3, false, noAssert);
};
Buffer2.prototype.copy = function copy(target, targetStart, start3, end3) {
  if (!start3) start3 = 0;
  if (!end3 && end3 !== 0) end3 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end3 > 0 && end3 < start3) end3 = start3;
  if (end3 === start3) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start3 < 0 || start3 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end3 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end3 > this.length) end3 = this.length;
  if (target.length - targetStart < end3 - start3) {
    end3 = target.length - targetStart + start3;
  }
  var len = end3 - start3;
  var i;
  if (this === target && start3 < targetStart && targetStart < end3) {
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start3];
    }
  } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start3];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start3, start3 + len),
      targetStart
    );
  }
  return len;
};
Buffer2.prototype.fill = function fill(val, start3, end3, encoding) {
  if (typeof val === "string") {
    if (typeof start3 === "string") {
      encoding = start3;
      start3 = 0;
      end3 = this.length;
    } else if (typeof end3 === "string") {
      encoding = end3;
      end3 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start3 < 0 || this.length < start3 || this.length < end3) {
    throw new RangeError("Out of range index");
  }
  if (end3 <= start3) {
    return this;
  }
  start3 = start3 >>> 0;
  end3 = end3 === void 0 ? this.length : end3 >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === "number") {
    for (i = start3; i < end3; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end3 - start3; ++i) {
      this[i + start3] = bytes[i % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16) return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length4 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length4; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length4) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c2 = str.charCodeAt(i);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset3, length4) {
  for (var i = 0; i < length4; ++i) {
    if (i + offset3 >= dst.length || i >= src.length) break;
    dst[i + offset3] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var _polyfillNode_buffer = Object.freeze({
  __proto__: null,
  Buffer: Buffer2,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  isBuffer: isBuffer$1,
  kMaxLength: _kMaxLength
});
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var platform = "browser";
var browser = true;
var env = {};
var argv = [];
var version = "";
var versions = {};
var release = {};
var config = {};
function noop3() {
}
var on = noop3;
var addListener = noop3;
var once = noop3;
var off = noop3;
var removeListener = noop3;
var removeAllListeners = noop3;
var emit = noop3;
function binding$1(name2) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance = global$1.performance || {};
var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = /* @__PURE__ */ new Date();
function uptime() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var browser$1 = {
  nextTick,
  title,
  browser,
  env,
  argv,
  version,
  versions,
  on,
  addListener,
  once,
  off,
  removeListener,
  removeAllListeners,
  emit,
  binding: binding$1,
  cwd,
  chdir,
  umask,
  hrtime,
  platform,
  release,
  config,
  uptime
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a2.prototype = f.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a2;
}
var lib = {};
var require$$0 = getAugmentedNamespace(_polyfillNode_buffer);
var domain;
function EventHandlers() {
}
EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
function EventEmitter() {
  EventEmitter.init.call(this);
}
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.prototype.domain = void 0;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._maxListeners = void 0;
EventEmitter.defaultMaxListeners = 10;
EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    if (domain.active) ;
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners3[i].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners3[i].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners3[i].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners3[i].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners3[i].apply(self2, args);
  }
}
EventEmitter.prototype.emit = function emit2(type2) {
  var er, handler, len, args, i, events2, domain3;
  var doError = type2 === "error";
  events2 = this._events;
  if (events2)
    doError = doError && events2.error == null;
  else if (!doError)
    return false;
  domain3 = this.domain;
  if (doError) {
    er = arguments[1];
    if (domain3) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain3;
      er.domainThrown = false;
      domain3.emit("error", er);
    } else if (er instanceof Error) {
      throw er;
    } else {
      var err2 = new Error('Uncaught, unspecified "error" event. (' + er + ")");
      err2.context = er;
      throw err2;
    }
    return false;
  }
  handler = events2[type2];
  if (!handler)
    return false;
  var isFn = typeof handler === "function";
  len = arguments.length;
  switch (len) {
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }
  return true;
};
function _addListener(target, type2, listener, prepend) {
  var m2;
  var events2;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = target._events;
  if (!events2) {
    events2 = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events2.newListener) {
      target.emit(
        "newListener",
        type2,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type2];
  }
  if (!existing) {
    existing = events2[type2] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m2 = $getMaxListeners(target);
      if (m2 && m2 > 0 && existing.length > m2) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type2;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn === "function" ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener2(type2, listener) {
  return _addListener(this, type2, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
  return _addListener(this, type2, listener, true);
};
function _onceWrap(target, type2, listener) {
  var fired = false;
  function g() {
    target.removeListener(type2, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
EventEmitter.prototype.once = function once2(type2, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.on(type2, _onceWrap(this, type2, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type2, _onceWrap(this, type2, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener2(type2, listener) {
  var list, events2, position, i, originalListener;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = this._events;
  if (!events2)
    return this;
  list = events2[type2];
  if (!list)
    return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events2[type2];
      if (events2.removeListener)
        this.emit("removeListener", type2, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i = list.length; i-- > 0; ) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0)
      return this;
    if (list.length === 1) {
      list[0] = void 0;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events2[type2];
      }
    } else {
      spliceOne(list, position);
    }
    if (events2.removeListener)
      this.emit("removeListener", type2, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = function(type2, listener) {
  return this.removeListener(type2, listener);
};
EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type2) {
  var listeners3, events2;
  events2 = this._events;
  if (!events2)
    return this;
  if (!events2.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events2[type2]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events2[type2];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    for (var i = 0, key; i < keys2.length; ++i) {
      key = keys2[i];
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }
  listeners3 = events2[type2];
  if (typeof listeners3 === "function") {
    this.removeListener(type2, listeners3);
  } else if (listeners3) {
    do {
      this.removeListener(type2, listeners3[listeners3.length - 1]);
    } while (listeners3[0]);
  }
  return this;
};
EventEmitter.prototype.listeners = function listeners(type2) {
  var evlistener;
  var ret;
  var events2 = this._events;
  if (!events2)
    ret = [];
  else {
    evlistener = events2[type2];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === "function")
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }
  return ret;
};
EventEmitter.listenerCount = function(emitter, type2) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type2);
  } else {
    return listenerCount$1.call(emitter, type2);
  }
};
EventEmitter.prototype.listenerCount = listenerCount$1;
function listenerCount$1(type2) {
  var events2 = this._events;
  if (events2) {
    var evlistener = events2[type2];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function spliceOne(list, index2) {
  for (var i = index2, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}
function arrayClone(arr, i) {
  var copy6 = new Array(i);
  while (i--)
    copy6[i] = arr[i];
  return copy6;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
var inherits;
if (typeof Object.create === "function") {
  inherits = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$1 = inherits;
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
  var keys2 = Object.keys(obj);
  var descriptors = {};
  for (var i = 0; i < keys2.length; i++) {
    descriptors[keys2[i]] = Object.getOwnPropertyDescriptor(obj, keys2[i]);
  }
  return descriptors;
};
var formatRegExp = /%[sdj%]/g;
function format(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect$1(arguments[i]));
    }
    return objects.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x2) {
    if (x2 === "%%") return "%";
    if (i >= len) return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect$1(x);
    }
  }
  return str;
}
function deprecate(fn, msg2) {
  if (isUndefined(global$1.process)) {
    return function() {
      return deprecate(fn, msg2).apply(this, arguments);
    };
  }
  if (browser$1.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1.throwDeprecation) {
        throw new Error(msg2);
      } else if (browser$1.traceDeprecation) {
        console.trace(msg2);
      } else {
        console.error(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
var debugs = {};
var debugEnviron;
function debuglog(set5) {
  if (isUndefined(debugEnviron))
    debugEnviron = browser$1.env.NODE_DEBUG || "";
  set5 = set5.toUpperCase();
  if (!debugs[set5]) {
    if (new RegExp("\\b" + set5 + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set5] = function() {
        var msg2 = format.apply(null, arguments);
        console.error("%s %d: %s", set5, pid, msg2);
      };
    } else {
      debugs[set5] = function() {
      };
    }
  }
  return debugs[set5];
}
function inspect$1(obj, opts2) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts2)) {
    ctx.showHidden = opts2;
  } else if (opts2) {
    _extend(ctx, opts2);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
inspect$1.colors = {
  "bold": [1, 22],
  "italic": [3, 23],
  "underline": [4, 24],
  "inverse": [7, 27],
  "white": [37, 39],
  "grey": [90, 39],
  "black": [30, 39],
  "blue": [34, 39],
  "cyan": [36, 39],
  "green": [32, 39],
  "magenta": [35, 39],
  "red": [31, 39],
  "yellow": [33, 39]
};
inspect$1.styles = {
  "special": "cyan",
  "number": "yellow",
  "boolean": "yellow",
  "undefined": "grey",
  "null": "bold",
  "string": "green",
  "date": "magenta",
  // "name": intentionally not styling
  "regexp": "red"
};
function stylizeWithColor(str, styleType) {
  var style = inspect$1.styles[styleType];
  if (style) {
    return "\x1B[" + inspect$1.colors[style][0] + "m" + str + "\x1B[" + inspect$1.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value2, recurseTimes) {
  if (ctx.customInspect && value2 && isFunction(value2.inspect) && // Filter out the util module, it's inspect function is special
  value2.inspect !== inspect$1 && // Also filter out any prototype objects using the circular check.
  !(value2.constructor && value2.constructor.prototype === value2)) {
    var ret = value2.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value2);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value2);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value2);
  }
  if (isError(value2) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value2);
  }
  if (keys2.length === 0) {
    if (isFunction(value2)) {
      var name2 = value2.name ? ": " + value2.name : "";
      return ctx.stylize("[Function" + name2 + "]", "special");
    }
    if (isRegExp(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    }
    if (isDate(value2)) {
      return ctx.stylize(Date.prototype.toString.call(value2), "date");
    }
    if (isError(value2)) {
      return formatError(value2);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value2)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value2)) {
    var n = value2.name ? ": " + value2.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value2)) {
    base = " " + RegExp.prototype.toString.call(value2);
  }
  if (isDate(value2)) {
    base = " " + Date.prototype.toUTCString.call(value2);
  }
  if (isError(value2)) {
    base = " " + formatError(value2);
  }
  if (keys2.length === 0 && (!array || value2.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value2);
  var output;
  if (array) {
    output = formatArray(ctx, value2, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value2) {
  if (isUndefined(value2))
    return ctx.stylize("undefined", "undefined");
  if (isString(value2)) {
    var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value2))
    return ctx.stylize("" + value2, "number");
  if (isBoolean(value2))
    return ctx.stylize("" + value2, "boolean");
  if (isNull(value2))
    return ctx.stylize("null", "null");
}
function formatError(value2) {
  return "[" + Error.prototype.toString.call(value2) + "]";
}
function formatArray(ctx, value2, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i = 0, l2 = value2.length; i < l2; ++i) {
    if (hasOwnProperty(value2, String(i))) {
      output.push(formatProperty(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        String(i),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array) {
  var name2, str, desc;
  desc = Object.getOwnPropertyDescriptor(value2, key) || { value: value2[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name2 = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line2) {
            return "  " + line2;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line2) {
            return "   " + line2;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name2)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name2 = JSON.stringify("" + key);
    if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name2 = name2.substr(1, name2.length - 2);
      name2 = ctx.stylize(name2, "name");
    } else {
      name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name2 = ctx.stylize(name2, "string");
    }
  }
  return name2 + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var length4 = output.reduce(function(prev, cur) {
    if (cur.indexOf("\n") >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length4 > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isSymbol(arg) {
  return typeof arg === "symbol";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function isPrimitive(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
function isBuffer(maybeBuf) {
  return Buffer2.isBuffer(maybeBuf);
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? "0" + n.toString(10) : n.toString(10);
}
var months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp() {
  var d = /* @__PURE__ */ new Date();
  var time = [
    pad(d.getHours()),
    pad(d.getMinutes()),
    pad(d.getSeconds())
  ].join(":");
  return [d.getDate(), months[d.getMonth()], time].join(" ");
}
function log() {
  console.log("%s - %s", timestamp(), format.apply(null, arguments));
}
function _extend(origin, add3) {
  if (!add3 || !isObject(add3)) return origin;
  var keys2 = Object.keys(add3);
  var i = keys2.length;
  while (i--) {
    origin[keys2[i]] = add3[keys2[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
function promisify(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== "function") {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }
  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function(resolve3, reject) {
      promiseResolve = resolve3;
      promiseReject = reject;
    });
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function(err2, value2) {
      if (err2) {
        promiseReject(err2);
      } else {
        promiseResolve(value2);
      }
    });
    try {
      original.apply(this, args);
    } catch (err2) {
      promiseReject(err2);
    }
    return promise;
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}
promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
  if (!reason) {
    var newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
function callbackify(original) {
  if (typeof original !== "function") {
    throw new TypeError('The "original" argument must be of type Function');
  }
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    var maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new TypeError("The last argument must be of type Function");
    }
    var self2 = this;
    var cb = function() {
      return maybeCb.apply(self2, arguments);
    };
    original.apply(this, args).then(
      function(ret) {
        browser$1.nextTick(cb.bind(null, null, ret));
      },
      function(rej) {
        browser$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
      }
    );
  }
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}
var _polyfillNode_util = {
  inherits: inherits$1,
  _extend,
  log,
  isBuffer,
  isPrimitive,
  isFunction,
  isError,
  isDate,
  isObject,
  isRegExp,
  isUndefined,
  isSymbol,
  isString,
  isNumber,
  isNullOrUndefined,
  isNull,
  isBoolean,
  isArray,
  inspect: inspect$1,
  deprecate,
  format,
  debuglog,
  promisify,
  callbackify
};
var _polyfillNode_util$1 = Object.freeze({
  __proto__: null,
  _extend,
  callbackify,
  debuglog,
  default: _polyfillNode_util,
  deprecate,
  format,
  inherits: inherits$1,
  inspect: inspect$1,
  isArray,
  isBoolean,
  isBuffer,
  isDate,
  isError,
  isFunction,
  isNull,
  isNullOrUndefined,
  isNumber,
  isObject,
  isPrimitive,
  isRegExp,
  isString,
  isSymbol,
  isUndefined,
  log,
  promisify
});
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
BufferList.prototype.push = function(v2) {
  var entry = { data: v2, next: null };
  if (this.length > 0) this.tail.next = entry;
  else this.head = entry;
  this.tail = entry;
  ++this.length;
};
BufferList.prototype.unshift = function(v2) {
  var entry = { data: v2, next: this.head };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};
BufferList.prototype.shift = function() {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;
  else this.head = this.head.next;
  --this.length;
  return ret;
};
BufferList.prototype.clear = function() {
  this.head = this.tail = null;
  this.length = 0;
};
BufferList.prototype.join = function(s2) {
  if (this.length === 0) return "";
  var p = this.head;
  var ret = "" + p.data;
  while (p = p.next) {
    ret += s2 + p.data;
  }
  return ret;
};
BufferList.prototype.concat = function(n) {
  if (this.length === 0) return Buffer2.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = Buffer2.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};
var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
StringDecoder.prototype.write = function(buffer) {
  var charStr = "";
  while (this.charLength) {
    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;
    if (this.charReceived < this.charLength) {
      return "";
    }
    buffer = buffer.slice(available, buffer.length);
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 55296 && charCode <= 56319) {
      this.charLength += this.surrogateSize;
      charStr = "";
      continue;
    }
    this.charReceived = this.charLength = 0;
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }
  this.detectIncompleteChar(buffer);
  var end3 = buffer.length;
  if (this.charLength) {
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end3);
    end3 -= this.charReceived;
  }
  charStr += buffer.toString(this.encoding, 0, end3);
  var end3 = charStr.length - 1;
  var charCode = charStr.charCodeAt(end3);
  if (charCode >= 55296 && charCode <= 56319) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end3);
  }
  return charStr;
};
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  var i = buffer.length >= 3 ? 3 : buffer.length;
  for (; i > 0; i--) {
    var c2 = buffer[buffer.length - i];
    if (i == 1 && c2 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (i <= 2 && c2 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (i <= 3 && c2 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};
StringDecoder.prototype.end = function(buffer) {
  var res = "";
  if (buffer && buffer.length)
    res = this.write(buffer);
  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }
  return res;
};
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
Readable.ReadableState = ReadableState;
var debug = debuglog("stream");
inherits$1(Readable, EventEmitter);
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount(emitter, type2) {
  return emitter.listeners(type2).length;
}
function ReadableState(options, stream2) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream2 instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function") this._read = options.read;
  EventEmitter.call(this);
}
Readable.prototype.push = function(chunk, encoding) {
  var state2 = this._readableState;
  if (!state2.objectMode && typeof chunk === "string") {
    encoding = encoding || state2.defaultEncoding;
    if (encoding !== state2.encoding) {
      chunk = Buffer2.from(chunk, encoding);
      encoding = "";
    }
  }
  return readableAddChunk(this, state2, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk) {
  var state2 = this._readableState;
  return readableAddChunk(this, state2, chunk, "", true);
};
Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
function readableAddChunk(stream2, state2, chunk, encoding, addToFront) {
  var er = chunkInvalid(state2, chunk);
  if (er) {
    stream2.emit("error", er);
  } else if (chunk === null) {
    state2.reading = false;
    onEofChunk(stream2, state2);
  } else if (state2.objectMode || chunk && chunk.length > 0) {
    if (state2.ended && !addToFront) {
      var e = new Error("stream.push() after EOF");
      stream2.emit("error", e);
    } else if (state2.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream2.emit("error", _e);
    } else {
      var skipAdd;
      if (state2.decoder && !addToFront && !encoding) {
        chunk = state2.decoder.write(chunk);
        skipAdd = !state2.objectMode && chunk.length === 0;
      }
      if (!addToFront) state2.reading = false;
      if (!skipAdd) {
        if (state2.flowing && state2.length === 0 && !state2.sync) {
          stream2.emit("data", chunk);
          stream2.read(0);
        } else {
          state2.length += state2.objectMode ? 1 : chunk.length;
          if (addToFront) state2.buffer.unshift(chunk);
          else state2.buffer.push(chunk);
          if (state2.needReadable) emitReadable(stream2);
        }
      }
      maybeReadMore(stream2, state2);
    }
  } else if (!addToFront) {
    state2.reading = false;
  }
  return needMoreData(state2);
}
function needMoreData(state2) {
  return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
}
Readable.prototype.setEncoding = function(enc) {
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};
var MAX_HWM = 8388608;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state2) {
  if (n <= 0 || state2.length === 0 && state2.ended) return 0;
  if (state2.objectMode) return 1;
  if (n !== n) {
    if (state2.flowing && state2.length) return state2.buffer.head.data.length;
    else return state2.length;
  }
  if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state2.length) return n;
  if (!state2.ended) {
    state2.needReadable = true;
    return 0;
  }
  return state2.length;
}
Readable.prototype.read = function(n) {
  debug("read", n);
  n = parseInt(n, 10);
  var state2 = this._readableState;
  var nOrig = n;
  if (n !== 0) state2.emittedReadable = false;
  if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
    debug("read: emitReadable", state2.length, state2.ended);
    if (state2.length === 0 && state2.ended) endReadable(this);
    else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state2);
  if (n === 0 && state2.ended) {
    if (state2.length === 0) endReadable(this);
    return null;
  }
  var doRead = state2.needReadable;
  debug("need readable", doRead);
  if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
    doRead = true;
    debug("length less than watermark", doRead);
  }
  if (state2.ended || state2.reading) {
    doRead = false;
    debug("reading or ended", doRead);
  } else if (doRead) {
    debug("do read");
    state2.reading = true;
    state2.sync = true;
    if (state2.length === 0) state2.needReadable = true;
    this._read(state2.highWaterMark);
    state2.sync = false;
    if (!state2.reading) n = howMuchToRead(nOrig, state2);
  }
  var ret;
  if (n > 0) ret = fromList(n, state2);
  else ret = null;
  if (ret === null) {
    state2.needReadable = true;
    n = 0;
  } else {
    state2.length -= n;
  }
  if (state2.length === 0) {
    if (!state2.ended) state2.needReadable = true;
    if (nOrig !== n && state2.ended) endReadable(this);
  }
  if (ret !== null) this.emit("data", ret);
  return ret;
};
function chunkInvalid(state2, chunk) {
  var er = null;
  if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state2.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream2, state2) {
  if (state2.ended) return;
  if (state2.decoder) {
    var chunk = state2.decoder.end();
    if (chunk && chunk.length) {
      state2.buffer.push(chunk);
      state2.length += state2.objectMode ? 1 : chunk.length;
    }
  }
  state2.ended = true;
  emitReadable(stream2);
}
function emitReadable(stream2) {
  var state2 = stream2._readableState;
  state2.needReadable = false;
  if (!state2.emittedReadable) {
    debug("emitReadable", state2.flowing);
    state2.emittedReadable = true;
    if (state2.sync) nextTick(emitReadable_, stream2);
    else emitReadable_(stream2);
  }
}
function emitReadable_(stream2) {
  debug("emit readable");
  stream2.emit("readable");
  flow(stream2);
}
function maybeReadMore(stream2, state2) {
  if (!state2.readingMore) {
    state2.readingMore = true;
    nextTick(maybeReadMore_, stream2, state2);
  }
}
function maybeReadMore_(stream2, state2) {
  var len = state2.length;
  while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
    debug("maybeReadMore read 0");
    stream2.read(0);
    if (len === state2.length)
      break;
    else len = state2.length;
  }
  state2.readingMore = false;
}
Readable.prototype._read = function(n) {
  this.emit("error", new Error("not implemented"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state2 = this._readableState;
  switch (state2.pipesCount) {
    case 0:
      state2.pipes = dest;
      break;
    case 1:
      state2.pipes = [state2.pipes, dest];
      break;
    default:
      state2.pipes.push(dest);
      break;
  }
  state2.pipesCount += 1;
  debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
  var doEnd = !pipeOpts || pipeOpts.end !== false;
  var endFn = doEnd ? onend3 : cleanup;
  if (state2.endEmitted) nextTick(endFn);
  else src.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable) {
    debug("onunpipe");
    if (readable === src) {
      cleanup();
    }
  }
  function onend3() {
    debug("onend");
    dest.end();
  }
  var ondrain = pipeOnDrain(src);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend3);
    src.removeListener("end", cleanup);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  var increasedAwaitDrain = false;
  src.on("data", ondata);
  function ondata(chunk) {
    debug("ondata");
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
        debug("false write response, pause", src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }
  function onerror(er) {
    debug("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (listenerCount(dest, "error") === 0) dest.emit("error", er);
  }
  prependListener2(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug("unpipe");
    src.unpipe(dest);
  }
  dest.emit("pipe", src);
  if (!state2.flowing) {
    debug("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function() {
    var state2 = src._readableState;
    debug("pipeOnDrain", state2.awaitDrain);
    if (state2.awaitDrain) state2.awaitDrain--;
    if (state2.awaitDrain === 0 && src.listeners("data").length) {
      state2.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function(dest) {
  var state2 = this._readableState;
  if (state2.pipesCount === 0) return this;
  if (state2.pipesCount === 1) {
    if (dest && dest !== state2.pipes) return this;
    if (!dest) dest = state2.pipes;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    if (dest) dest.emit("unpipe", this);
    return this;
  }
  if (!dest) {
    var dests = state2.pipes;
    var len = state2.pipesCount;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit("unpipe", this);
    }
    return this;
  }
  var i = indexOf2(state2.pipes, dest);
  if (i === -1) return this;
  state2.pipes.splice(i, 1);
  state2.pipesCount -= 1;
  if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
  dest.emit("unpipe", this);
  return this;
};
Readable.prototype.on = function(ev, fn) {
  var res = EventEmitter.prototype.on.call(this, ev, fn);
  if (ev === "data") {
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === "readable") {
    var state2 = this._readableState;
    if (!state2.endEmitted && !state2.readableListening) {
      state2.readableListening = state2.needReadable = true;
      state2.emittedReadable = false;
      if (!state2.reading) {
        nextTick(nReadingNextTick, this);
      } else if (state2.length) {
        emitReadable(this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
Readable.prototype.resume = function() {
  var state2 = this._readableState;
  if (!state2.flowing) {
    debug("resume");
    state2.flowing = true;
    resume(this, state2);
  }
  return this;
};
function resume(stream2, state2) {
  if (!state2.resumeScheduled) {
    state2.resumeScheduled = true;
    nextTick(resume_, stream2, state2);
  }
}
function resume_(stream2, state2) {
  if (!state2.reading) {
    debug("resume read 0");
    stream2.read(0);
  }
  state2.resumeScheduled = false;
  state2.awaitDrain = 0;
  stream2.emit("resume");
  flow(stream2);
  if (state2.flowing && !state2.reading) stream2.read(0);
}
Readable.prototype.pause = function() {
  debug("call pause flowing=%j", this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  return this;
};
function flow(stream2) {
  var state2 = stream2._readableState;
  debug("flow", state2.flowing);
  while (state2.flowing && stream2.read() !== null) {
  }
}
Readable.prototype.wrap = function(stream2) {
  var state2 = this._readableState;
  var paused = false;
  var self2 = this;
  stream2.on("end", function() {
    debug("wrapped end");
    if (state2.decoder && !state2.ended) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) self2.push(chunk);
    }
    self2.push(null);
  });
  stream2.on("data", function(chunk) {
    debug("wrapped data");
    if (state2.decoder) chunk = state2.decoder.write(chunk);
    if (state2.objectMode && (chunk === null || chunk === void 0)) return;
    else if (!state2.objectMode && (!chunk || !chunk.length)) return;
    var ret = self2.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i in stream2) {
    if (this[i] === void 0 && typeof stream2[i] === "function") {
      this[i] = /* @__PURE__ */ function(method) {
        return function() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i);
    }
  }
  var events2 = ["error", "close", "destroy", "pause", "resume"];
  forEach(events2, function(ev) {
    stream2.on(ev, self2.emit.bind(self2, ev));
  });
  self2._read = function(n) {
    debug("wrapped _read", n);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return self2;
};
Readable._fromList = fromList;
function fromList(n, state2) {
  if (state2.length === 0) return null;
  var ret;
  if (state2.objectMode) ret = state2.buffer.shift();
  else if (!n || n >= state2.length) {
    if (state2.decoder) ret = state2.buffer.join("");
    else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
    else ret = state2.buffer.concat(state2.length);
    state2.buffer.clear();
  } else {
    ret = fromListPartial(n, state2.buffer, state2.decoder);
  }
  return ret;
}
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}
function copyFromBufferString(n, list) {
  var p = list.head;
  var c2 = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;
    else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c2;
        if (p.next) list.head = p.next;
        else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c2;
  }
  list.length -= c2;
  return ret;
}
function copyFromBuffer(n, list) {
  var ret = Buffer2.allocUnsafe(n);
  var p = list.head;
  var c2 = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c2;
        if (p.next) list.head = p.next;
        else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c2;
  }
  list.length -= c2;
  return ret;
}
function endReadable(stream2) {
  var state2 = stream2._readableState;
  if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
  if (!state2.endEmitted) {
    state2.ended = true;
    nextTick(endReadableNT, state2, stream2);
  }
}
function endReadableNT(state2, stream2) {
  if (!state2.endEmitted && state2.length === 0) {
    state2.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
  }
}
function forEach(xs, f) {
  for (var i = 0, l2 = xs.length; i < l2; i++) {
    f(xs[i], i);
  }
}
function indexOf2(xs, x) {
  for (var i = 0, l2 = xs.length; i < l2; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
Writable.WritableState = WritableState;
inherits$1(Writable, EventEmitter);
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream2) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream2 instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream2, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function") this._write = options.write;
    if (typeof options.writev === "function") this._writev = options.writev;
  }
  EventEmitter.call(this);
}
Writable.prototype.pipe = function() {
  this.emit("error", new Error("Cannot pipe, not readable"));
};
function writeAfterEnd(stream2, cb) {
  var er = new Error("write after end");
  stream2.emit("error", er);
  nextTick(cb, er);
}
function validChunk(stream2, state2, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream2.emit("error", er);
    nextTick(cb, er);
    valid = false;
  }
  return valid;
}
Writable.prototype.write = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  var ret = false;
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (Buffer2.isBuffer(chunk)) encoding = "buffer";
  else if (!encoding) encoding = state2.defaultEncoding;
  if (typeof cb !== "function") cb = nop;
  if (state2.ended) writeAfterEnd(this, cb);
  else if (validChunk(this, state2, chunk, cb)) {
    state2.pendingcb++;
    ret = writeOrBuffer(this, state2, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function() {
  var state2 = this._writableState;
  state2.corked++;
};
Writable.prototype.uncork = function() {
  var state2 = this._writableState;
  if (state2.corked) {
    state2.corked--;
    if (!state2.writing && !state2.corked && !state2.finished && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  if (typeof encoding === "string") encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
function decodeChunk(state2, chunk, encoding) {
  if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream2, state2, chunk, encoding, cb) {
  chunk = decodeChunk(state2, chunk, encoding);
  if (Buffer2.isBuffer(chunk)) encoding = "buffer";
  var len = state2.objectMode ? 1 : chunk.length;
  state2.length += len;
  var ret = state2.length < state2.highWaterMark;
  if (!ret) state2.needDrain = true;
  if (state2.writing || state2.corked) {
    var last3 = state2.lastBufferedRequest;
    state2.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last3) {
      last3.next = state2.lastBufferedRequest;
    } else {
      state2.bufferedRequest = state2.lastBufferedRequest;
    }
    state2.bufferedRequestCount += 1;
  } else {
    doWrite(stream2, state2, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
  state2.writelen = len;
  state2.writecb = cb;
  state2.writing = true;
  state2.sync = true;
  if (writev) stream2._writev(chunk, state2.onwrite);
  else stream2._write(chunk, encoding, state2.onwrite);
  state2.sync = false;
}
function onwriteError(stream2, state2, sync, er, cb) {
  --state2.pendingcb;
  if (sync) nextTick(cb, er);
  else cb(er);
  stream2._writableState.errorEmitted = true;
  stream2.emit("error", er);
}
function onwriteStateUpdate(state2) {
  state2.writing = false;
  state2.writecb = null;
  state2.length -= state2.writelen;
  state2.writelen = 0;
}
function onwrite(stream2, er) {
  var state2 = stream2._writableState;
  var sync = state2.sync;
  var cb = state2.writecb;
  onwriteStateUpdate(state2);
  if (er) onwriteError(stream2, state2, sync, er, cb);
  else {
    var finished = needFinish(state2);
    if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
      clearBuffer(stream2, state2);
    }
    if (sync) {
      nextTick(afterWrite, stream2, state2, finished, cb);
    } else {
      afterWrite(stream2, state2, finished, cb);
    }
  }
}
function afterWrite(stream2, state2, finished, cb) {
  if (!finished) onwriteDrain(stream2, state2);
  state2.pendingcb--;
  cb();
  finishMaybe(stream2, state2);
}
function onwriteDrain(stream2, state2) {
  if (state2.length === 0 && state2.needDrain) {
    state2.needDrain = false;
    stream2.emit("drain");
  }
}
function clearBuffer(stream2, state2) {
  state2.bufferProcessing = true;
  var entry = state2.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l2 = state2.bufferedRequestCount;
    var buffer = new Array(l2);
    var holder = state2.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
    state2.pendingcb++;
    state2.lastBufferedRequest = null;
    if (holder.next) {
      state2.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state2.corkedRequestsFree = new CorkedRequest(state2);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state2.objectMode ? 1 : chunk.length;
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state2.writing) {
        break;
      }
    }
    if (entry === null) state2.lastBufferedRequest = null;
  }
  state2.bufferedRequestCount = 0;
  state2.bufferedRequest = entry;
  state2.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error("not implemented"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
  if (state2.corked) {
    state2.corked = 1;
    this.uncork();
  }
  if (!state2.ending && !state2.finished) endWritable(this, state2, cb);
};
function needFinish(state2) {
  return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
}
function prefinish(stream2, state2) {
  if (!state2.prefinished) {
    state2.prefinished = true;
    stream2.emit("prefinish");
  }
}
function finishMaybe(stream2, state2) {
  var need = needFinish(state2);
  if (need) {
    if (state2.pendingcb === 0) {
      prefinish(stream2, state2);
      state2.finished = true;
      stream2.emit("finish");
    } else {
      prefinish(stream2, state2);
    }
  }
  return need;
}
function endWritable(stream2, state2, cb) {
  state2.ending = true;
  finishMaybe(stream2, state2);
  if (cb) {
    if (state2.finished) nextTick(cb);
    else stream2.once("finish", cb);
  }
  state2.ended = true;
  stream2.writable = false;
}
function CorkedRequest(state2) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err2) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    if (state2.corkedRequestsFree) {
      state2.corkedRequestsFree.next = _this;
    } else {
      state2.corkedRequestsFree = _this;
    }
  };
}
inherits$1(Duplex, Readable);
var keys = Object.keys(Writable.prototype);
for (v2 = 0; v2 < keys.length; v2++) {
  method = keys[v2];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}
var method;
var v2;
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended) return;
  nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
inherits$1(Transform2, Duplex);
function TransformState(stream2) {
  this.afterTransform = function(er, data2) {
    return afterTransform(stream2, er, data2);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream2, er, data2) {
  var ts = stream2._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb) return stream2.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 !== null && data2 !== void 0) stream2.push(data2);
  cb(er);
  var rs = stream2._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream2._read(rs.highWaterMark);
  }
}
function Transform2(options) {
  if (!(this instanceof Transform2)) return new Transform2(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream2 = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function") this._transform = options.transform;
    if (typeof options.flush === "function") this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function") this._flush(function(er) {
      done(stream2, er);
    });
    else done(stream2);
  });
}
Transform2.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform2.prototype._transform = function(chunk, encoding, cb) {
  throw new Error("Not implemented");
};
Transform2.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};
Transform2.prototype._read = function(n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
function done(stream2, er) {
  if (er) return stream2.emit("error", er);
  var ws = stream2._writableState;
  var ts = stream2._transformState;
  if (ws.length) throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming) throw new Error("Calling transform done when still transforming");
  return stream2.push(null);
}
inherits$1(PassThrough, Transform2);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform2.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
inherits$1(Stream, EventEmitter);
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform2;
Stream.PassThrough = PassThrough;
Stream.Stream = Stream;
function Stream() {
  EventEmitter.call(this);
}
Stream.prototype.pipe = function(dest, options) {
  var source = this;
  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on("end", onend3);
    source.on("close", onclose);
  }
  var didOnEnd = false;
  function onend3() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === "function") dest.destroy();
  }
  function onerror(er) {
    cleanup();
    if (EventEmitter.listenerCount(this, "error") === 0) {
      throw er;
    }
  }
  source.on("error", onerror);
  dest.on("error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend3);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
var _polyfillNode_stream = Object.freeze({
  __proto__: null,
  Duplex,
  PassThrough,
  Readable,
  Stream,
  Transform: Transform2,
  Writable,
  default: Stream
});
var require$$1 = getAugmentedNamespace(_polyfillNode_stream);
var binding = {};
function compare3(a2, b) {
  if (a2 === b) {
    return 0;
  }
  var x = a2.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a2[i] !== b[i]) {
      x = a2[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var hasOwn = Object.prototype.hasOwnProperty;
var objectKeys = Object.keys || function(obj) {
  var keys2 = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys2.push(key);
  }
  return keys2;
};
var pSlice = Array.prototype.slice;
var _functionsHaveNames;
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== "undefined") {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = function() {
    return (function foo() {
    }).name === "foo";
  }();
}
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer$1(arrbuf)) {
    return false;
  }
  if (typeof global$1.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
function assert(value2, message) {
  if (!value2) fail(value2, true, message, "==", ok);
}
var regex = /\s*function\s+([^\(\s]*)\s*/;
function getName(func) {
  if (!isFunction(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = AssertionError;
function AssertionError(options) {
  this.name = "AssertionError";
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err2 = new Error();
    if (err2.stack) {
      var out = err2.stack;
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
inherits$1(AssertionError, Error);
function truncate(s2, n) {
  if (typeof s2 === "string") {
    return s2.length < n ? s2 : s2.slice(0, n);
  } else {
    return s2;
  }
}
function inspect2(something) {
  if (functionsHaveNames() || !isFunction(something)) {
    return inspect$1(something);
  }
  var rawname = getName(something);
  var name2 = rawname ? ": " + rawname : "";
  return "[Function" + name2 + "]";
}
function getMessage(self2) {
  return truncate(inspect2(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect2(self2.expected), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
assert.fail = fail;
function ok(value2, message) {
  if (!value2) fail(value2, true, message, "==", ok);
}
assert.ok = ok;
assert.equal = equal;
function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, "==", equal);
}
assert.notEqual = notEqual;
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, "!=", notEqual);
  }
}
assert.deepEqual = deepEqual;
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "deepEqual", deepEqual);
  }
}
assert.deepStrictEqual = deepStrictEqual;
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "deepStrictEqual", deepStrictEqual);
  }
}
function _deepEqual(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer$1(actual) && isBuffer$1(expected)) {
    return compare3(actual, expected) === 0;
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare3(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (isBuffer$1(actual) !== isBuffer$1(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv(a2, b, strict, actualVisitedObjects) {
  if (a2 === null || a2 === void 0 || b === null || b === void 0)
    return false;
  if (isPrimitive(a2) || isPrimitive(b))
    return a2 === b;
  if (strict && Object.getPrototypeOf(a2) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a2);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a2 = pSlice.call(a2);
    b = pSlice.call(b);
    return _deepEqual(a2, b, strict);
  }
  var ka = objectKeys(a2);
  var kb = objectKeys(b);
  var key, i;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a2[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
assert.notDeepEqual = notDeepEqual;
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, "notDeepEqual", notDeepEqual);
  }
}
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
  }
}
assert.strictEqual = strictEqual;
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, "===", strictEqual);
  }
}
assert.notStrictEqual = notStrictEqual;
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, "!==", notStrictEqual);
  }
}
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}
function _throws(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
assert.throws = throws;
function throws(block, error, message) {
  _throws(true, block, error, message);
}
assert.doesNotThrow = doesNotThrow;
function doesNotThrow(block, error, message) {
  _throws(false, block, error, message);
}
assert.ifError = ifError;
function ifError(err2) {
  if (err2) throw err2;
}
var _polyfillNode_assert = Object.freeze({
  __proto__: null,
  AssertionError,
  assert: ok,
  deepEqual,
  deepStrictEqual,
  default: assert,
  doesNotThrow,
  equal,
  fail,
  ifError,
  notDeepEqual,
  notDeepStrictEqual,
  notEqual,
  notStrictEqual,
  ok,
  strictEqual,
  throws
});
var require$$4 = getAugmentedNamespace(_polyfillNode_assert);
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var deflate$1 = {};
var common = {};
(function(exports2) {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports2.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports2.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function flattenChunks(chunks) {
      var i, l2, len, pos, chunk, result;
      len = 0;
      for (i = 0, l2 = chunks.length; i < l2; i++) {
        len += chunks[i].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i = 0, l2 = chunks.length; i < l2; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function flattenChunks(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports2.setTyped = function(on3) {
    if (on3) {
      exports2.Buf8 = Uint8Array;
      exports2.Buf16 = Uint16Array;
      exports2.Buf32 = Int32Array;
      exports2.assign(exports2, fnTyped);
    } else {
      exports2.Buf8 = Array;
      exports2.Buf16 = Array;
      exports2.Buf32 = Array;
      exports2.assign(exports2, fnUntyped);
    }
  };
  exports2.setTyped(TYPED_OK);
})(common);
var trees$1 = {};
var utils$3 = common;
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
function put_short(s2, w) {
  s2.pending_buf[s2.pending++] = w & 255;
  s2.pending_buf[s2.pending++] = w >>> 8 & 255;
}
function send_bits(s2, value2, length4) {
  if (s2.bi_valid > Buf_size - length4) {
    s2.bi_buf |= value2 << s2.bi_valid & 65535;
    put_short(s2, s2.bi_buf);
    s2.bi_buf = value2 >> Buf_size - s2.bi_valid;
    s2.bi_valid += length4 - Buf_size;
  } else {
    s2.bi_buf |= value2 << s2.bi_valid & 65535;
    s2.bi_valid += length4;
  }
}
function send_code(s2, c2, tree) {
  send_bits(
    s2,
    tree[c2 * 2],
    tree[c2 * 2 + 1]
    /*.Len*/
  );
}
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}
function bi_flush(s2) {
  if (s2.bi_valid === 16) {
    put_short(s2, s2.bi_buf);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  } else if (s2.bi_valid >= 8) {
    s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
    s2.bi_buf >>= 8;
    s2.bi_valid -= 8;
  }
}
function gen_bitlen(s2, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h2;
  var n, m2;
  var bits;
  var xbits;
  var f;
  var overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s2.bl_count[bits] = 0;
  }
  tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
  for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE$1; h2++) {
    n = s2.heap[h2];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s2.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s2.opt_len += f * (bits + xbits);
    if (has_stree) {
      s2.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s2.bl_count[bits] === 0) {
      bits--;
    }
    s2.bl_count[bits]--;
    s2.bl_count[bits + 1] += 2;
    s2.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s2.bl_count[bits];
    while (n !== 0) {
      m2 = s2.heap[--h2];
      if (m2 > max_code) {
        continue;
      }
      if (tree[m2 * 2 + 1] !== bits) {
        s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
        tree[m2 * 2 + 1] = bits;
      }
      n--;
    }
  }
}
function gen_codes(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS$1 + 1);
  var code = 0;
  var bits;
  var n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
}
function tr_static_init() {
  var n;
  var bits;
  var length4;
  var code;
  var dist;
  var bl_count = new Array(MAX_BITS$1 + 1);
  length4 = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length4;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length4++] = code;
    }
  }
  _length_code[length4 - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
}
function init_block(s2) {
  var n;
  for (n = 0; n < L_CODES$1; n++) {
    s2.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s2.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s2.bl_tree[n * 2] = 0;
  }
  s2.dyn_ltree[END_BLOCK * 2] = 1;
  s2.opt_len = s2.static_len = 0;
  s2.last_lit = s2.matches = 0;
}
function bi_windup(s2) {
  if (s2.bi_valid > 8) {
    put_short(s2, s2.bi_buf);
  } else if (s2.bi_valid > 0) {
    s2.pending_buf[s2.pending++] = s2.bi_buf;
  }
  s2.bi_buf = 0;
  s2.bi_valid = 0;
}
function copy_block(s2, buf, len, header) {
  bi_windup(s2);
  if (header) {
    put_short(s2, len);
    put_short(s2, ~len);
  }
  utils$3.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
  s2.pending += len;
}
function smaller(tree, n, m2, depth) {
  var _n2 = n * 2;
  var _m2 = m2 * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m2];
}
function pqdownheap(s2, tree, k) {
  var v2 = s2.heap[k];
  var j = k << 1;
  while (j <= s2.heap_len) {
    if (j < s2.heap_len && smaller(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
      j++;
    }
    if (smaller(tree, v2, s2.heap[j], s2.depth)) {
      break;
    }
    s2.heap[k] = s2.heap[j];
    k = j;
    j <<= 1;
  }
  s2.heap[k] = v2;
}
function compress_block(s2, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code;
  var extra;
  if (s2.last_lit !== 0) {
    do {
      dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
      lc = s2.pending_buf[s2.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s2, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s2, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s2, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s2, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s2, dist, extra);
        }
      }
    } while (lx < s2.last_lit);
  }
  send_code(s2, END_BLOCK, ltree);
}
function build_tree(s2, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m2;
  var max_code = -1;
  var node;
  s2.heap_len = 0;
  s2.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s2.heap[++s2.heap_len] = max_code = n;
      s2.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s2.heap_len < 2) {
    node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s2.depth[node] = 0;
    s2.opt_len--;
    if (has_stree) {
      s2.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s2.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s2, tree, n);
  }
  node = elems;
  do {
    n = s2.heap[
      1
      /*SMALLEST*/
    ];
    s2.heap[
      1
      /*SMALLEST*/
    ] = s2.heap[s2.heap_len--];
    pqdownheap(
      s2,
      tree,
      1
      /*SMALLEST*/
    );
    m2 = s2.heap[
      1
      /*SMALLEST*/
    ];
    s2.heap[--s2.heap_max] = n;
    s2.heap[--s2.heap_max] = m2;
    tree[node * 2] = tree[n * 2] + tree[m2 * 2];
    s2.depth[node] = (s2.depth[n] >= s2.depth[m2] ? s2.depth[n] : s2.depth[m2]) + 1;
    tree[n * 2 + 1] = tree[m2 * 2 + 1] = node;
    s2.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s2,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s2.heap_len >= 2);
  s2.heap[--s2.heap_max] = s2.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s2, desc);
  gen_codes(tree, max_code, s2.bl_count);
}
function scan_tree(s2, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s2.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s2.bl_tree[curlen * 2]++;
      }
      s2.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s2.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s2.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree(s2, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s2, curlen, s2.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s2, curlen, s2.bl_tree);
        count--;
      }
      send_code(s2, REP_3_6, s2.bl_tree);
      send_bits(s2, count - 3, 2);
    } else if (count <= 10) {
      send_code(s2, REPZ_3_10, s2.bl_tree);
      send_bits(s2, count - 3, 3);
    } else {
      send_code(s2, REPZ_11_138, s2.bl_tree);
      send_bits(s2, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree(s2) {
  var max_blindex;
  scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
  scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
  build_tree(s2, s2.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees(s2, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits(s2, lcodes - 257, 5);
  send_bits(s2, dcodes - 1, 5);
  send_bits(s2, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s2, s2.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s2, s2.dyn_ltree, lcodes - 1);
  send_tree(s2, s2.dyn_dtree, dcodes - 1);
}
function detect_data_type(s2) {
  var black_mask = 4093624447;
  var n;
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s2.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s2.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
}
var static_init_done = false;
function _tr_init(s2) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
  s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
  s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
  s2.bi_buf = 0;
  s2.bi_valid = 0;
  init_block(s2);
}
function _tr_stored_block(s2, buf, stored_len, last3) {
  send_bits(s2, (STORED_BLOCK << 1) + (last3 ? 1 : 0), 3);
  copy_block(s2, buf, stored_len, true);
}
function _tr_align(s2) {
  send_bits(s2, STATIC_TREES << 1, 3);
  send_code(s2, END_BLOCK, static_ltree);
  bi_flush(s2);
}
function _tr_flush_block(s2, buf, stored_len, last3) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s2.level > 0) {
    if (s2.strm.data_type === Z_UNKNOWN$1) {
      s2.strm.data_type = detect_data_type(s2);
    }
    build_tree(s2, s2.l_desc);
    build_tree(s2, s2.d_desc);
    max_blindex = build_bl_tree(s2);
    opt_lenb = s2.opt_len + 3 + 7 >>> 3;
    static_lenb = s2.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s2, buf, stored_len, last3);
  } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s2, (STATIC_TREES << 1) + (last3 ? 1 : 0), 3);
    compress_block(s2, static_ltree, static_dtree);
  } else {
    send_bits(s2, (DYN_TREES << 1) + (last3 ? 1 : 0), 3);
    send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
  }
  init_block(s2);
  if (last3) {
    bi_windup(s2);
  }
}
function _tr_tally(s2, dist, lc) {
  s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
  s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
  s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
  s2.last_lit++;
  if (dist === 0) {
    s2.dyn_ltree[lc * 2]++;
  } else {
    s2.matches++;
    dist--;
    s2.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s2.dyn_dtree[d_code(dist) * 2]++;
  }
  return s2.last_lit === s2.lit_bufsize - 1;
}
trees$1._tr_init = _tr_init;
trees$1._tr_stored_block = _tr_stored_block;
trees$1._tr_flush_block = _tr_flush_block;
trees$1._tr_tally = _tr_tally;
trees$1._tr_align = _tr_align;
function adler32$2(adler, buf, len, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
var adler32_1 = adler32$2;
function makeTable() {
  var c2, table = [];
  for (var n = 0; n < 256; n++) {
    c2 = n;
    for (var k = 0; k < 8; k++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table[n] = c2;
  }
  return table;
}
var crcTable = makeTable();
function crc32$2(crc, buf, len, pos) {
  var t2 = crcTable, end3 = pos + len;
  crc ^= -1;
  for (var i = pos; i < end3; i++) {
    crc = crc >>> 8 ^ t2[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
var crc32_1 = crc32$2;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var utils$2 = common;
var trees = trees$1;
var adler32$1 = adler32_1;
var crc32$1 = crc32_1;
var msg = messages;
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
var Z_FULL_FLUSH = 3;
var Z_FINISH$1 = 4;
var Z_BLOCK$1 = 5;
var Z_OK$1 = 0;
var Z_STREAM_END$1 = 1;
var Z_STREAM_ERROR$1 = -2;
var Z_DATA_ERROR$1 = -3;
var Z_BUF_ERROR$1 = -5;
var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
var Z_UNKNOWN = 2;
var Z_DEFLATED$1 = 8;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}
function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}
function zero(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function flush_pending(strm) {
  var s2 = strm.state;
  var len = s2.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  utils$2.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
  strm.next_out += len;
  s2.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s2.pending -= len;
  if (s2.pending === 0) {
    s2.pending_out = 0;
  }
}
function flush_block_only(s2, last3) {
  trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last3);
  s2.block_start = s2.strstart;
  flush_pending(s2.strm);
}
function put_byte(s2, b) {
  s2.pending_buf[s2.pending++] = b;
}
function putShortMSB(s2, b) {
  s2.pending_buf[s2.pending++] = b >>> 8 & 255;
  s2.pending_buf[s2.pending++] = b & 255;
}
function read_buf(strm, buf, start3, size) {
  var len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  utils$2.arraySet(buf, strm.input, strm.next_in, len, start3);
  if (strm.state.wrap === 1) {
    strm.adler = adler32$1(strm.adler, buf, len, start3);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32$1(strm.adler, buf, len, start3);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
}
function longest_match(s2, cur_match) {
  var chain_length = s2.max_chain_length;
  var scan = s2.strstart;
  var match;
  var len;
  var best_len = s2.prev_length;
  var nice_match = s2.nice_match;
  var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
  var _win = s2.window;
  var wmask = s2.w_mask;
  var prev = s2.prev;
  var strend = s2.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s2.prev_length >= s2.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s2.lookahead) {
    nice_match = s2.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s2.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s2.lookahead) {
    return best_len;
  }
  return s2.lookahead;
}
function fill_window(s2) {
  var _w_size = s2.w_size;
  var p, n, m2, more, str;
  do {
    more = s2.window_size - s2.lookahead - s2.strstart;
    if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      utils$2.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
      s2.match_start -= _w_size;
      s2.strstart -= _w_size;
      s2.block_start -= _w_size;
      n = s2.hash_size;
      p = n;
      do {
        m2 = s2.head[--p];
        s2.head[p] = m2 >= _w_size ? m2 - _w_size : 0;
      } while (--n);
      n = _w_size;
      p = n;
      do {
        m2 = s2.prev[--p];
        s2.prev[p] = m2 >= _w_size ? m2 - _w_size : 0;
      } while (--n);
      more += _w_size;
    }
    if (s2.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
    s2.lookahead += n;
    if (s2.lookahead + s2.insert >= MIN_MATCH) {
      str = s2.strstart - s2.insert;
      s2.ins_h = s2.window[str];
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
      while (s2.insert) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
        s2.insert--;
        if (s2.lookahead + s2.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
}
function deflate_stored(s2, flush) {
  var max_block_size = 65535;
  if (max_block_size > s2.pending_buf_size - 5) {
    max_block_size = s2.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s2.lookahead <= 1) {
      fill_window(s2);
      if (s2.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.strstart += s2.lookahead;
    s2.lookahead = 0;
    var max_start = s2.block_start + max_block_size;
    if (s2.strstart === 0 || s2.strstart >= max_start) {
      s2.lookahead = s2.strstart - max_start;
      s2.strstart = max_start;
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.strstart > s2.block_start) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
}
function deflate_fast(s2, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
        s2.match_length--;
        do {
          s2.strstart++;
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        } while (--s2.match_length !== 0);
        s2.strstart++;
      } else {
        s2.strstart += s2.match_length;
        s2.match_length = 0;
        s2.ins_h = s2.window[s2.strstart];
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
      }
    } else {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_slow(s2, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    s2.prev_length = s2.match_length;
    s2.prev_match = s2.match_start;
    s2.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
      if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
        s2.match_length = MIN_MATCH - 1;
      }
    }
    if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
      max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
      bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
      s2.lookahead -= s2.prev_length - 1;
      s2.prev_length -= 2;
      do {
        if (++s2.strstart <= max_insert) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
      } while (--s2.prev_length !== 0);
      s2.match_available = 0;
      s2.match_length = MIN_MATCH - 1;
      s2.strstart++;
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s2.match_available) {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      if (bflush) {
        flush_block_only(s2, false);
      }
      s2.strstart++;
      s2.lookahead--;
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s2.match_available = 1;
      s2.strstart++;
      s2.lookahead--;
    }
  }
  if (s2.match_available) {
    bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
    s2.match_available = 0;
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_rle(s2, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s2.window;
  for (; ; ) {
    if (s2.lookahead <= MAX_MATCH) {
      fill_window(s2);
      if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.match_length = 0;
    if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
      scan = s2.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s2.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s2.match_length = MAX_MATCH - (strend - scan);
        if (s2.match_length > s2.lookahead) {
          s2.match_length = s2.lookahead;
        }
      }
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      s2.strstart += s2.match_length;
      s2.match_length = 0;
    } else {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_huff(s2, flush) {
  var bflush;
  for (; ; ) {
    if (s2.lookahead === 0) {
      fill_window(s2);
      if (s2.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s2.match_length = 0;
    bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
    s2.lookahead--;
    s2.strstart++;
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table;
configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
function lm_init(s2) {
  s2.window_size = 2 * s2.w_size;
  zero(s2.head);
  s2.max_lazy_match = configuration_table[s2.level].max_lazy;
  s2.good_match = configuration_table[s2.level].good_length;
  s2.nice_match = configuration_table[s2.level].nice_length;
  s2.max_chain_length = configuration_table[s2.level].max_chain;
  s2.strstart = 0;
  s2.block_start = 0;
  s2.lookahead = 0;
  s2.insert = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  s2.ins_h = 0;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$1;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new utils$2.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils$2.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils$2.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new utils$2.Buf16(MAX_BITS + 1);
  this.heap = new utils$2.Buf16(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new utils$2.Buf16(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep(strm) {
  var s2;
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s2 = strm.state;
  s2.pending = 0;
  s2.pending_out = 0;
  if (s2.wrap < 0) {
    s2.wrap = -s2.wrap;
  }
  s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s2.wrap === 2 ? 0 : 1;
  s2.last_flush = Z_NO_FLUSH;
  trees._tr_init(s2);
  return Z_OK$1;
}
function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK$1) {
    lm_init(strm.state);
  }
  return ret;
}
function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$1;
  }
  strm.state.gzhead = head;
  return Z_OK$1;
}
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  var wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$1 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s2 = new DeflateState();
  strm.state = s2;
  s2.strm = strm;
  s2.wrap = wrap;
  s2.gzhead = null;
  s2.w_bits = windowBits;
  s2.w_size = 1 << s2.w_bits;
  s2.w_mask = s2.w_size - 1;
  s2.hash_bits = memLevel + 7;
  s2.hash_size = 1 << s2.hash_bits;
  s2.hash_mask = s2.hash_size - 1;
  s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s2.window = new utils$2.Buf8(s2.w_size * 2);
  s2.head = new utils$2.Buf16(s2.hash_size);
  s2.prev = new utils$2.Buf16(s2.w_size);
  s2.lit_bufsize = 1 << memLevel + 6;
  s2.pending_buf_size = s2.lit_bufsize * 4;
  s2.pending_buf = new utils$2.Buf8(s2.pending_buf_size);
  s2.d_buf = 1 * s2.lit_bufsize;
  s2.l_buf = (1 + 2) * s2.lit_bufsize;
  s2.level = level;
  s2.strategy = strategy;
  s2.method = method;
  return deflateReset(strm);
}
function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED$1, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}
function deflate(strm, flush) {
  var old_flush, s2;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$1) : Z_STREAM_ERROR$1;
  }
  s2 = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH$1) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$1);
  }
  s2.strm = strm;
  old_flush = s2.last_flush;
  s2.last_flush = flush;
  if (s2.status === INIT_STATE) {
    if (s2.wrap === 2) {
      strm.adler = 0;
      put_byte(s2, 31);
      put_byte(s2, 139);
      put_byte(s2, 8);
      if (!s2.gzhead) {
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
        put_byte(s2, OS_CODE);
        s2.status = BUSY_STATE;
      } else {
        put_byte(s2, (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16));
        put_byte(s2, s2.gzhead.time & 255);
        put_byte(s2, s2.gzhead.time >> 8 & 255);
        put_byte(s2, s2.gzhead.time >> 16 & 255);
        put_byte(s2, s2.gzhead.time >> 24 & 255);
        put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
        put_byte(s2, s2.gzhead.os & 255);
        if (s2.gzhead.extra && s2.gzhead.extra.length) {
          put_byte(s2, s2.gzhead.extra.length & 255);
          put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
        }
        if (s2.gzhead.hcrc) {
          strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending, 0);
        }
        s2.gzindex = 0;
        s2.status = EXTRA_STATE;
      }
    } else {
      var header = Z_DEFLATED$1 + (s2.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
        level_flags = 0;
      } else if (s2.level < 6) {
        level_flags = 1;
      } else if (s2.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s2.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s2.status = BUSY_STATE;
      putShortMSB(s2, header);
      if (s2.strstart !== 0) {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s2.status === EXTRA_STATE) {
    if (s2.gzhead.extra) {
      beg = s2.pending;
      while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            break;
          }
        }
        put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
        s2.gzindex++;
      }
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (s2.gzindex === s2.gzhead.extra.length) {
        s2.gzindex = 0;
        s2.status = NAME_STATE;
      }
    } else {
      s2.status = NAME_STATE;
    }
  }
  if (s2.status === NAME_STATE) {
    if (s2.gzhead.name) {
      beg = s2.pending;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s2.gzindex < s2.gzhead.name.length) {
          val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (val === 0) {
        s2.gzindex = 0;
        s2.status = COMMENT_STATE;
      }
    } else {
      s2.status = COMMENT_STATE;
    }
  }
  if (s2.status === COMMENT_STATE) {
    if (s2.gzhead.comment) {
      beg = s2.pending;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s2.gzindex < s2.gzhead.comment.length) {
          val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (val === 0) {
        s2.status = HCRC_STATE;
      }
    } else {
      s2.status = HCRC_STATE;
    }
  }
  if (s2.status === HCRC_STATE) {
    if (s2.gzhead.hcrc) {
      if (s2.pending + 2 > s2.pending_buf_size) {
        flush_pending(strm);
      }
      if (s2.pending + 2 <= s2.pending_buf_size) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        strm.adler = 0;
        s2.status = BUSY_STATE;
      }
    } else {
      s2.status = BUSY_STATE;
    }
  }
  if (s2.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s2.last_flush = -1;
      return Z_OK$1;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$1) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
    var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s2.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
      }
      return Z_OK$1;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s2);
      } else if (flush !== Z_BLOCK$1) {
        trees._tr_stored_block(s2, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero(s2.head);
          if (s2.lookahead === 0) {
            s2.strstart = 0;
            s2.block_start = 0;
            s2.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK$1;
      }
    }
  }
  if (flush !== Z_FINISH$1) {
    return Z_OK$1;
  }
  if (s2.wrap <= 0) {
    return Z_STREAM_END$1;
  }
  if (s2.wrap === 2) {
    put_byte(s2, strm.adler & 255);
    put_byte(s2, strm.adler >> 8 & 255);
    put_byte(s2, strm.adler >> 16 & 255);
    put_byte(s2, strm.adler >> 24 & 255);
    put_byte(s2, strm.total_in & 255);
    put_byte(s2, strm.total_in >> 8 & 255);
    put_byte(s2, strm.total_in >> 16 & 255);
    put_byte(s2, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s2, strm.adler >>> 16);
    putShortMSB(s2, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s2.wrap > 0) {
    s2.wrap = -s2.wrap;
  }
  return s2.pending !== 0 ? Z_OK$1 : Z_STREAM_END$1;
}
function deflateEnd(strm) {
  var status;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$1) : Z_OK$1;
}
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s2;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  s2 = strm.state;
  wrap = s2.wrap;
  if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
    return Z_STREAM_ERROR$1;
  }
  if (wrap === 1) {
    strm.adler = adler32$1(strm.adler, dictionary, dictLength, 0);
  }
  s2.wrap = 0;
  if (dictLength >= s2.w_size) {
    if (wrap === 0) {
      zero(s2.head);
      s2.strstart = 0;
      s2.block_start = 0;
      s2.insert = 0;
    }
    tmpDict = new utils$2.Buf8(s2.w_size);
    utils$2.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
    dictionary = tmpDict;
    dictLength = s2.w_size;
  }
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s2);
  while (s2.lookahead >= MIN_MATCH) {
    str = s2.strstart;
    n = s2.lookahead - (MIN_MATCH - 1);
    do {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
      s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = str;
      str++;
    } while (--n);
    s2.strstart = str;
    s2.lookahead = MIN_MATCH - 1;
    fill_window(s2);
  }
  s2.strstart += s2.lookahead;
  s2.block_start = s2.strstart;
  s2.insert = s2.lookahead;
  s2.lookahead = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s2.wrap = wrap;
  return Z_OK$1;
}
deflate$1.deflateInit = deflateInit;
deflate$1.deflateInit2 = deflateInit2;
deflate$1.deflateReset = deflateReset;
deflate$1.deflateResetKeep = deflateResetKeep;
deflate$1.deflateSetHeader = deflateSetHeader;
deflate$1.deflate = deflate;
deflate$1.deflateEnd = deflateEnd;
deflate$1.deflateSetDictionary = deflateSetDictionary;
deflate$1.deflateInfo = "pako deflate (from Nodeca project)";
var inflate$1 = {};
var BAD$1 = 30;
var TYPE$1 = 12;
var inffast = function inflate_fast(strm, start3) {
  var state2;
  var _in;
  var last3;
  var _out;
  var beg;
  var end3;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len;
  var dist;
  var from4;
  var from_source;
  var input, output;
  state2 = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last3 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start3 - strm.avail_out);
  end3 = _out + (strm.avail_out - 257);
  dmax = state2.dmax;
  wsize = state2.wsize;
  whave = state2.whave;
  wnext = state2.wnext;
  s_window = state2.window;
  hold = state2.hold;
  bits = state2.bits;
  lcode = state2.lencode;
  dcode = state2.distcode;
  lmask = (1 << state2.lenbits) - 1;
  dmask = (1 << state2.distbits) - 1;
  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }
    here = lcode[hold & lmask];
    dolen: for (; ; ) {
      op = here >>> 24;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 255;
      if (op === 0) {
        output[_out++] = here & 65535;
      } else if (op & 16) {
        len = here & 65535;
        op &= 15;
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        }
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];
        dodist: for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op & 16) {
            dist = here & 65535;
            op &= 15;
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & (1 << op) - 1;
            if (dist > dmax) {
              strm.msg = "invalid distance too far back";
              state2.mode = BAD$1;
              break top;
            }
            hold >>>= op;
            bits -= op;
            op = _out - beg;
            if (dist > op) {
              op = dist - op;
              if (op > whave) {
                if (state2.sane) {
                  strm.msg = "invalid distance too far back";
                  state2.mode = BAD$1;
                  break top;
                }
              }
              from4 = 0;
              from_source = s_window;
              if (wnext === 0) {
                from4 += wsize - op;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from4++];
                  } while (--op);
                  from4 = _out - dist;
                  from_source = output;
                }
              } else if (wnext < op) {
                from4 += wsize + wnext - op;
                op -= wnext;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from4++];
                  } while (--op);
                  from4 = 0;
                  if (wnext < len) {
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from4++];
                    } while (--op);
                    from4 = _out - dist;
                    from_source = output;
                  }
                }
              } else {
                from4 += wnext - op;
                if (op < len) {
                  len -= op;
                  do {
                    output[_out++] = s_window[from4++];
                  } while (--op);
                  from4 = _out - dist;
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from4++];
                output[_out++] = from_source[from4++];
                output[_out++] = from_source[from4++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from4++];
                if (len > 1) {
                  output[_out++] = from_source[from4++];
                }
              }
            } else {
              from4 = _out - dist;
              do {
                output[_out++] = output[from4++];
                output[_out++] = output[from4++];
                output[_out++] = output[from4++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from4++];
                if (len > 1) {
                  output[_out++] = output[from4++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = "invalid distance code";
            state2.mode = BAD$1;
            break top;
          }
          break;
        }
      } else if ((op & 64) === 0) {
        here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        state2.mode = TYPE$1;
        break top;
      } else {
        strm.msg = "invalid literal/length code";
        state2.mode = BAD$1;
        break top;
      }
      break;
    }
  } while (_in < last3 && _out < end3);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last3 ? 5 + (last3 - _in) : 5 - (_in - last3);
  strm.avail_out = _out < end3 ? 257 + (end3 - _out) : 257 - (_out - end3);
  state2.hold = hold;
  state2.bits = bits;
  return;
};
var utils$1 = common;
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
var inftrees = function inflate_table(type2, lens, lens_index, codes2, table, table_index, work, opts2) {
  var bits = opts2.bits;
  var len = 0;
  var sym = 0;
  var min3 = 0, max3 = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill5;
  var low;
  var mask;
  var next;
  var base = null;
  var base_index = 0;
  var end3;
  var count = new utils$1.Buf16(MAXBITS + 1);
  var offs = new utils$1.Buf16(MAXBITS + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes2; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max3 = MAXBITS; max3 >= 1; max3--) {
    if (count[max3] !== 0) {
      break;
    }
  }
  if (root > max3) {
    root = max3;
  }
  if (max3 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts2.bits = 1;
    return 0;
  }
  for (min3 = 1; min3 < max3; min3++) {
    if (count[min3] !== 0) {
      break;
    }
  }
  if (root < min3) {
    root = min3;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type2 === CODES$1 || max3 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes2; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type2 === CODES$1) {
    base = extra = work;
    end3 = 19;
  } else if (type2 === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end3 = 256;
  } else {
    base = dbase;
    extra = dext;
    end3 = -1;
  }
  huff = 0;
  sym = 0;
  len = min3;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end3) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end3) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill5 = 1 << curr;
    min3 = fill5;
    do {
      fill5 -= incr;
      table[next + (huff >> drop) + fill5] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill5 !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max3) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min3;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max3) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts2.bits = root;
  return 0;
};
var utils = common;
var adler32 = adler32_1;
var crc32 = crc32_1;
var inflate_fast2 = inffast;
var inflate_table2 = inftrees;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
var Z_DEFLATED = 8;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
function zswap32(q2) {
  return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new utils.Buf16(320);
  this.work = new utils.Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  strm.total_in = strm.total_out = state2.total = 0;
  strm.msg = "";
  if (state2.wrap) {
    strm.adler = state2.wrap & 1;
  }
  state2.mode = HEAD;
  state2.last = 0;
  state2.havedict = 0;
  state2.dmax = 32768;
  state2.head = null;
  state2.hold = 0;
  state2.bits = 0;
  state2.lencode = state2.lendyn = new utils.Buf32(ENOUGH_LENS);
  state2.distcode = state2.distdyn = new utils.Buf32(ENOUGH_DISTS);
  state2.sane = 1;
  state2.back = -1;
  return Z_OK;
}
function inflateReset(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  state2.wsize = 0;
  state2.whave = 0;
  state2.wnext = 0;
  return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
  var wrap;
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state2.window !== null && state2.wbits !== windowBits) {
    state2.window = null;
  }
  state2.wrap = wrap;
  state2.wbits = windowBits;
  return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
  var ret;
  var state2;
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  state2 = new InflateState();
  strm.state = state2;
  state2.window = null;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null;
  }
  return ret;
}
function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}
var virgin = true;
var lenfix;
var distfix;
function fixedtables(state2) {
  if (virgin) {
    var sym;
    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);
    sym = 0;
    while (sym < 144) {
      state2.lens[sym++] = 8;
    }
    while (sym < 256) {
      state2.lens[sym++] = 9;
    }
    while (sym < 280) {
      state2.lens[sym++] = 7;
    }
    while (sym < 288) {
      state2.lens[sym++] = 8;
    }
    inflate_table2(LENS, state2.lens, 0, 288, lenfix, 0, state2.work, {
      bits: 9
    });
    sym = 0;
    while (sym < 32) {
      state2.lens[sym++] = 5;
    }
    inflate_table2(DISTS, state2.lens, 0, 32, distfix, 0, state2.work, {
      bits: 5
    });
    virgin = false;
  }
  state2.lencode = lenfix;
  state2.lenbits = 9;
  state2.distcode = distfix;
  state2.distbits = 5;
}
function updatewindow(strm, src, end3, copy6) {
  var dist;
  var state2 = strm.state;
  if (state2.window === null) {
    state2.wsize = 1 << state2.wbits;
    state2.wnext = 0;
    state2.whave = 0;
    state2.window = new utils.Buf8(state2.wsize);
  }
  if (copy6 >= state2.wsize) {
    utils.arraySet(state2.window, src, end3 - state2.wsize, state2.wsize, 0);
    state2.wnext = 0;
    state2.whave = state2.wsize;
  } else {
    dist = state2.wsize - state2.wnext;
    if (dist > copy6) {
      dist = copy6;
    }
    utils.arraySet(state2.window, src, end3 - copy6, dist, state2.wnext);
    copy6 -= dist;
    if (copy6) {
      utils.arraySet(state2.window, src, end3 - copy6, copy6, 0);
      state2.wnext = copy6;
      state2.whave = state2.wsize;
    } else {
      state2.wnext += dist;
      if (state2.wnext === state2.wsize) {
        state2.wnext = 0;
      }
      if (state2.whave < state2.wsize) {
        state2.whave += dist;
      }
    }
  }
  return 0;
}
function inflate(strm, flush) {
  var state2;
  var input, output;
  var next;
  var put;
  var have, left;
  var hold;
  var bits;
  var _in, _out;
  var copy6;
  var from4;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len;
  var ret;
  var hbuf = new utils.Buf8(4);
  var opts2;
  var n;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (state2.mode === TYPE) {
    state2.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state2.hold;
  bits = state2.bits;
  _in = have;
  _out = left;
  ret = Z_OK;
  inf_leave:
    for (; ; ) {
      switch (state2.mode) {
        case HEAD:
          if (state2.wrap === 0) {
            state2.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.wrap & 2 && hold === 35615) {
            state2.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state2.mode = FLAGS;
            break;
          }
          state2.flags = 0;
          if (state2.head) {
            state2.head.done = false;
          }
          if (!(state2.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state2.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state2.wbits === 0) {
            state2.wbits = len;
          } else if (len > state2.wbits) {
            strm.msg = "invalid window size";
            state2.mode = BAD;
            break;
          }
          state2.dmax = 1 << len;
          strm.adler = state2.check = 1;
          state2.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.flags = hold;
          if ((state2.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          if (state2.flags & 57344) {
            strm.msg = "unknown header flags set";
            state2.mode = BAD;
            break;
          }
          if (state2.head) {
            state2.head.text = hold >> 8 & 1;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.time = hold;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state2.check = crc32(state2.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.xflags = hold & 255;
            state2.head.os = hold >> 8;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = EXLEN;
        case EXLEN:
          if (state2.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length = hold;
            if (state2.head) {
              state2.head.extra_len = hold;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state2.head) {
            state2.head.extra = null;
          }
          state2.mode = EXTRA;
        case EXTRA:
          if (state2.flags & 1024) {
            copy6 = state2.length;
            if (copy6 > have) {
              copy6 = have;
            }
            if (copy6) {
              if (state2.head) {
                len = state2.head.extra_len - state2.length;
                if (!state2.head.extra) {
                  state2.head.extra = new Array(state2.head.extra_len);
                }
                utils.arraySet(
                  state2.head.extra,
                  input,
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy6,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state2.flags & 512) {
                state2.check = crc32(state2.check, input, copy6, next);
              }
              have -= copy6;
              next += copy6;
              state2.length -= copy6;
            }
            if (state2.length) {
              break inf_leave;
            }
          }
          state2.length = 0;
          state2.mode = NAME;
        case NAME:
          if (state2.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy6 = 0;
            do {
              len = input[next + copy6++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.name += String.fromCharCode(len);
              }
            } while (len && copy6 < have);
            if (state2.flags & 512) {
              state2.check = crc32(state2.check, input, copy6, next);
            }
            have -= copy6;
            next += copy6;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.name = null;
          }
          state2.length = 0;
          state2.mode = COMMENT;
        case COMMENT:
          if (state2.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy6 = 0;
            do {
              len = input[next + copy6++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.comment += String.fromCharCode(len);
              }
            } while (len && copy6 < have);
            if (state2.flags & 512) {
              state2.check = crc32(state2.check, input, copy6, next);
            }
            have -= copy6;
            next += copy6;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.comment = null;
          }
          state2.mode = HCRC;
        case HCRC:
          if (state2.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state2.check & 65535)) {
              strm.msg = "header crc mismatch";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state2.head) {
            state2.head.hcrc = state2.flags >> 9 & 1;
            state2.head.done = true;
          }
          strm.adler = state2.check = 0;
          state2.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state2.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state2.mode = DICT;
        case DICT:
          if (state2.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            return Z_NEED_DICT;
          }
          strm.adler = state2.check = 1;
          state2.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state2.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state2.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state2.mode = STORED;
              break;
            case 1:
              fixedtables(state2);
              state2.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state2.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state2.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state2.mode = BAD;
            break;
          }
          state2.length = hold & 65535;
          hold = 0;
          bits = 0;
          state2.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state2.mode = COPY;
        case COPY:
          copy6 = state2.length;
          if (copy6) {
            if (copy6 > have) {
              copy6 = have;
            }
            if (copy6 > left) {
              copy6 = left;
            }
            if (copy6 === 0) {
              break inf_leave;
            }
            utils.arraySet(output, input, next, copy6, put);
            have -= copy6;
            next += copy6;
            left -= copy6;
            put += copy6;
            state2.length -= copy6;
            break;
          }
          state2.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state2.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state2.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state2.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state2.nlen > 286 || state2.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = LENLENS;
        case LENLENS:
          while (state2.have < state2.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.lens[order[state2.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state2.have < 19) {
            state2.lens[order[state2.have++]] = 0;
          }
          state2.lencode = state2.lendyn;
          state2.lenbits = 7;
          opts2 = {
            bits: state2.lenbits
          };
          ret = inflate_table2(CODES, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts2);
          state2.lenbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = CODELENS;
        case CODELENS:
          while (state2.have < state2.nlen + state2.ndist) {
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state2.lens[state2.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state2.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD;
                  break;
                }
                len = state2.lens[state2.have - 1];
                copy6 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy6 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy6 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state2.have + copy6 > state2.nlen + state2.ndist) {
                strm.msg = "invalid bit length repeat";
                state2.mode = BAD;
                break;
              }
              while (copy6--) {
                state2.lens[state2.have++] = len;
              }
            }
          }
          if (state2.mode === BAD) {
            break;
          }
          if (state2.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state2.mode = BAD;
            break;
          }
          state2.lenbits = 9;
          opts2 = {
            bits: state2.lenbits
          };
          ret = inflate_table2(LENS, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts2);
          state2.lenbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state2.mode = BAD;
            break;
          }
          state2.distbits = 6;
          state2.distcode = state2.distdyn;
          opts2 = {
            bits: state2.distbits
          };
          ret = inflate_table2(DISTS, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts2);
          state2.distbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state2.mode = BAD;
            break;
          }
          state2.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state2.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            inflate_fast2(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state2.hold;
            bits = state2.bits;
            if (state2.mode === TYPE) {
              state2.back = -1;
            }
            break;
          }
          state2.back = 0;
          for (; ; ) {
            here = state2.lencode[hold & (1 << state2.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          state2.length = here_val;
          if (here_op === 0) {
            state2.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state2.back = -1;
            state2.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD;
            break;
          }
          state2.extra = here_op & 15;
          state2.mode = LENEXT;
        case LENEXT:
          if (state2.extra) {
            n = state2.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.length += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          state2.was = state2.length;
          state2.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state2.distcode[hold & (1 << state2.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state2.mode = BAD;
            break;
          }
          state2.offset = here_val;
          state2.extra = here_op & 15;
          state2.mode = DISTEXT;
        case DISTEXT:
          if (state2.extra) {
            n = state2.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.offset += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          if (state2.offset > state2.dmax) {
            strm.msg = "invalid distance too far back";
            state2.mode = BAD;
            break;
          }
          state2.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy6 = _out - left;
          if (state2.offset > copy6) {
            copy6 = state2.offset - copy6;
            if (copy6 > state2.whave) {
              if (state2.sane) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD;
                break;
              }
            }
            if (copy6 > state2.wnext) {
              copy6 -= state2.wnext;
              from4 = state2.wsize - copy6;
            } else {
              from4 = state2.wnext - copy6;
            }
            if (copy6 > state2.length) {
              copy6 = state2.length;
            }
            from_source = state2.window;
          } else {
            from_source = output;
            from4 = put - state2.offset;
            copy6 = state2.length;
          }
          if (copy6 > left) {
            copy6 = left;
          }
          left -= copy6;
          state2.length -= copy6;
          do {
            output[put++] = from_source[from4++];
          } while (--copy6);
          if (state2.length === 0) {
            state2.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state2.length;
          left--;
          state2.mode = LEN;
          break;
        case CHECK:
          if (state2.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state2.total += _out;
            if (_out) {
              strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
              state2.flags ? crc32(state2.check, output, _out, put - _out) : adler32(state2.check, output, _out, put - _out);
            }
            _out = left;
            if ((state2.flags ? hold : zswap32(hold)) !== state2.check) {
              strm.msg = "incorrect data check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = LENGTH;
        case LENGTH:
          if (state2.wrap && state2.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state2.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = DONE;
        case DONE:
          ret = Z_STREAM_END;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        default:
          return Z_STREAM_ERROR;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state2.hold = hold;
  state2.bits = bits;
  if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD && (state2.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state2.total += _out;
  if (state2.wrap && _out) {
    strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state2.flags ? crc32(state2.check, output, _out, strm.next_out - _out) : adler32(state2.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE ? 128 : 0) + (state2.mode === LEN_ || state2.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  var state2 = strm.state;
  if (state2.window) {
    state2.window = null;
  }
  strm.state = null;
  return Z_OK;
}
function inflateGetHeader(strm, head) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if ((state2.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  state2.head = head;
  head.done = false;
  return Z_OK;
}
function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state2;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (state2.wrap !== 0 && state2.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  if (state2.mode === DICT) {
    dictid = 1;
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state2.check) {
      return Z_DATA_ERROR;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state2.mode = MEM;
    return Z_MEM_ERROR;
  }
  state2.havedict = 1;
  return Z_OK;
}
inflate$1.inflateReset = inflateReset;
inflate$1.inflateReset2 = inflateReset2;
inflate$1.inflateResetKeep = inflateResetKeep;
inflate$1.inflateInit = inflateInit;
inflate$1.inflateInit2 = inflateInit2;
inflate$1.inflate = inflate;
inflate$1.inflateEnd = inflateEnd;
inflate$1.inflateGetHeader = inflateGetHeader;
inflate$1.inflateSetDictionary = inflateSetDictionary;
inflate$1.inflateInfo = "pako inflate (from Nodeca project)";
var constants = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
(function(exports2) {
  var assert3 = require$$4;
  var Zstream = zstream;
  var zlib_deflate = deflate$1;
  var zlib_inflate = inflate$1;
  var constants$1 = constants;
  for (var key in constants$1) {
    exports2[key] = constants$1[key];
  }
  exports2.NONE = 0;
  exports2.DEFLATE = 1;
  exports2.INFLATE = 2;
  exports2.GZIP = 3;
  exports2.GUNZIP = 4;
  exports2.DEFLATERAW = 5;
  exports2.INFLATERAW = 6;
  exports2.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib(mode) {
    if (typeof mode !== "number" || mode < exports2.DEFLATE || mode > exports2.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  Zlib.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert3(this.init_done, "close before init");
    assert3(this.mode <= exports2.UNZIP);
    if (this.mode === exports2.DEFLATE || this.mode === exports2.GZIP || this.mode === exports2.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports2.INFLATE || this.mode === exports2.GUNZIP || this.mode === exports2.INFLATERAW || this.mode === exports2.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports2.NONE;
    this.dictionary = null;
  };
  Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert3.equal(arguments.length, 8);
    assert3(this.init_done, "write before init");
    assert3(this.mode !== exports2.NONE, "already finalized");
    assert3.equal(false, this.write_in_progress, "write already in progress");
    assert3.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert3.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports2.Z_NO_FLUSH && flush !== exports2.Z_PARTIAL_FLUSH && flush !== exports2.Z_SYNC_FLUSH && flush !== exports2.Z_FULL_FLUSH && flush !== exports2.Z_FINISH && flush !== exports2.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer2.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    browser$1.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports2.DEFLATE:
      case exports2.GZIP:
      case exports2.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports2.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports2.INFLATE;
              break;
            }
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports2.GUNZIP;
            } else {
              this.mode = exports2.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      case exports2.INFLATE:
      case exports2.GUNZIP:
      case exports2.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports2.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports2.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports2.Z_DATA_ERROR) {
            this.err = exports2.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports2.GUNZIP && this.err === exports2.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib.prototype._checkError = function() {
    switch (this.err) {
      case exports2.Z_OK:
      case exports2.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports2.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports2.Z_STREAM_END:
        break;
      case exports2.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    assert3(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert3(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert3(level >= -1 && level <= 9, "invalid compression level");
    assert3(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert3(strategy === exports2.Z_FILTERED || strategy === exports2.Z_HUFFMAN_ONLY || strategy === exports2.Z_RLE || strategy === exports2.Z_FIXED || strategy === exports2.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
  };
  Zlib.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports2.Z_NO_FLUSH;
    this.err = exports2.Z_OK;
    if (this.mode === exports2.GZIP || this.mode === exports2.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports2.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports2.DEFLATERAW || this.mode === exports2.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports2.DEFLATE:
      case exports2.GZIP:
      case exports2.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports2.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports2.INFLATE:
      case exports2.GUNZIP:
      case exports2.INFLATERAW:
      case exports2.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports2.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports2.Z_OK;
    switch (this.mode) {
      case exports2.DEFLATE:
      case exports2.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports2.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib.prototype._reset = function() {
    this.err = exports2.Z_OK;
    switch (this.mode) {
      case exports2.DEFLATE:
      case exports2.DEFLATERAW:
      case exports2.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports2.INFLATE:
      case exports2.INFLATERAW:
      case exports2.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports2.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports2.Zlib = Zlib;
})(binding);
var require$$3 = getAugmentedNamespace(_polyfillNode_util$1);
(function(exports2) {
  var Buffer5 = require$$0.Buffer;
  var Transform3 = require$$1.Transform;
  var binding$13 = binding;
  var util = require$$3;
  var assert3 = require$$4.ok;
  var kMaxLength4 = require$$0.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength4.toString(16) + " bytes";
  binding$13.Z_MIN_WINDOWBITS = 8;
  binding$13.Z_MAX_WINDOWBITS = 15;
  binding$13.Z_DEFAULT_WINDOWBITS = 15;
  binding$13.Z_MIN_CHUNK = 64;
  binding$13.Z_MAX_CHUNK = Infinity;
  binding$13.Z_DEFAULT_CHUNK = 16 * 1024;
  binding$13.Z_MIN_MEMLEVEL = 1;
  binding$13.Z_MAX_MEMLEVEL = 9;
  binding$13.Z_DEFAULT_MEMLEVEL = 8;
  binding$13.Z_MIN_LEVEL = -1;
  binding$13.Z_MAX_LEVEL = 9;
  binding$13.Z_DEFAULT_LEVEL = binding$13.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding$13);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports2, bkey, {
        enumerable: true,
        value: binding$13[bkey],
        writable: false
      });
    }
  }
  var codes2 = {
    Z_OK: binding$13.Z_OK,
    Z_STREAM_END: binding$13.Z_STREAM_END,
    Z_NEED_DICT: binding$13.Z_NEED_DICT,
    Z_ERRNO: binding$13.Z_ERRNO,
    Z_STREAM_ERROR: binding$13.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding$13.Z_DATA_ERROR,
    Z_MEM_ERROR: binding$13.Z_MEM_ERROR,
    Z_BUF_ERROR: binding$13.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding$13.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes2);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes2[codes2[ckey]] = ckey;
  }
  Object.defineProperty(exports2, "codes", {
    enumerable: true,
    value: Object.freeze(codes2),
    writable: false
  });
  exports2.Deflate = Deflate;
  exports2.Inflate = Inflate;
  exports2.Gzip = Gzip;
  exports2.Gunzip = Gunzip;
  exports2.DeflateRaw = DeflateRaw;
  exports2.InflateRaw = InflateRaw;
  exports2.Unzip = Unzip;
  exports2.createDeflate = function(o) {
    return new Deflate(o);
  };
  exports2.createInflate = function(o) {
    return new Inflate(o);
  };
  exports2.createDeflateRaw = function(o) {
    return new DeflateRaw(o);
  };
  exports2.createInflateRaw = function(o) {
    return new InflateRaw(o);
  };
  exports2.createGzip = function(o) {
    return new Gzip(o);
  };
  exports2.createGunzip = function(o) {
    return new Gunzip(o);
  };
  exports2.createUnzip = function(o) {
    return new Unzip(o);
  };
  exports2.deflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Deflate(opts2), buffer, callback);
  };
  exports2.deflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Deflate(opts2), buffer);
  };
  exports2.gzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gzip(opts2), buffer, callback);
  };
  exports2.gzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gzip(opts2), buffer);
  };
  exports2.deflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new DeflateRaw(opts2), buffer, callback);
  };
  exports2.deflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new DeflateRaw(opts2), buffer);
  };
  exports2.unzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Unzip(opts2), buffer, callback);
  };
  exports2.unzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Unzip(opts2), buffer);
  };
  exports2.inflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Inflate(opts2), buffer, callback);
  };
  exports2.inflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Inflate(opts2), buffer);
  };
  exports2.gunzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gunzip(opts2), buffer, callback);
  };
  exports2.gunzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gunzip(opts2), buffer);
  };
  exports2.inflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new InflateRaw(opts2), buffer, callback);
  };
  exports2.inflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new InflateRaw(opts2), buffer);
  };
  function zlibBuffer(engine2, buffer, callback) {
    var buffers = [];
    var nread = 0;
    engine2.on("error", onError);
    engine2.on("end", onEnd);
    engine2.end(buffer);
    flow3();
    function flow3() {
      var chunk;
      while (null !== (chunk = engine2.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine2.once("readable", flow3);
    }
    function onError(err2) {
      engine2.removeListener("end", onEnd);
      engine2.removeListener("readable", flow3);
      callback(err2);
    }
    function onEnd() {
      var buf;
      var err2 = null;
      if (nread >= kMaxLength4) {
        err2 = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer5.concat(buffers, nread);
      }
      buffers = [];
      engine2.close();
      callback(err2, buf);
    }
  }
  function zlibBufferSync(engine2, buffer) {
    if (typeof buffer === "string") buffer = Buffer5.from(buffer);
    if (!Buffer5.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
    var flushFlag = engine2._finishFlushFlag;
    return engine2._processChunk(buffer, flushFlag);
  }
  function Deflate(opts2) {
    if (!(this instanceof Deflate)) return new Deflate(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATE);
  }
  function Inflate(opts2) {
    if (!(this instanceof Inflate)) return new Inflate(opts2);
    Zlib.call(this, opts2, binding$13.INFLATE);
  }
  function Gzip(opts2) {
    if (!(this instanceof Gzip)) return new Gzip(opts2);
    Zlib.call(this, opts2, binding$13.GZIP);
  }
  function Gunzip(opts2) {
    if (!(this instanceof Gunzip)) return new Gunzip(opts2);
    Zlib.call(this, opts2, binding$13.GUNZIP);
  }
  function DeflateRaw(opts2) {
    if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATERAW);
  }
  function InflateRaw(opts2) {
    if (!(this instanceof InflateRaw)) return new InflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.INFLATERAW);
  }
  function Unzip(opts2) {
    if (!(this instanceof Unzip)) return new Unzip(opts2);
    Zlib.call(this, opts2, binding$13.UNZIP);
  }
  function isValidFlushFlag(flag) {
    return flag === binding$13.Z_NO_FLUSH || flag === binding$13.Z_PARTIAL_FLUSH || flag === binding$13.Z_SYNC_FLUSH || flag === binding$13.Z_FULL_FLUSH || flag === binding$13.Z_FINISH || flag === binding$13.Z_BLOCK;
  }
  function Zlib(opts2, mode) {
    var _this = this;
    this._opts = opts2 = opts2 || {};
    this._chunkSize = opts2.chunkSize || exports2.Z_DEFAULT_CHUNK;
    Transform3.call(this, opts2);
    if (opts2.flush && !isValidFlushFlag(opts2.flush)) {
      throw new Error("Invalid flush flag: " + opts2.flush);
    }
    if (opts2.finishFlush && !isValidFlushFlag(opts2.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts2.finishFlush);
    }
    this._flushFlag = opts2.flush || binding$13.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts2.finishFlush !== "undefined" ? opts2.finishFlush : binding$13.Z_FINISH;
    if (opts2.chunkSize) {
      if (opts2.chunkSize < exports2.Z_MIN_CHUNK || opts2.chunkSize > exports2.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts2.chunkSize);
      }
    }
    if (opts2.windowBits) {
      if (opts2.windowBits < exports2.Z_MIN_WINDOWBITS || opts2.windowBits > exports2.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts2.windowBits);
      }
    }
    if (opts2.level) {
      if (opts2.level < exports2.Z_MIN_LEVEL || opts2.level > exports2.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts2.level);
      }
    }
    if (opts2.memLevel) {
      if (opts2.memLevel < exports2.Z_MIN_MEMLEVEL || opts2.memLevel > exports2.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts2.memLevel);
      }
    }
    if (opts2.strategy) {
      if (opts2.strategy != exports2.Z_FILTERED && opts2.strategy != exports2.Z_HUFFMAN_ONLY && opts2.strategy != exports2.Z_RLE && opts2.strategy != exports2.Z_FIXED && opts2.strategy != exports2.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts2.strategy);
      }
    }
    if (opts2.dictionary) {
      if (!Buffer5.isBuffer(opts2.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding$13.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
      _close(self2);
      self2._hadError = true;
      var error = new Error(message);
      error.errno = errno;
      error.code = exports2.codes[errno];
      self2.emit("error", error);
    };
    var level = exports2.Z_DEFAULT_COMPRESSION;
    if (typeof opts2.level === "number") level = opts2.level;
    var strategy = exports2.Z_DEFAULT_STRATEGY;
    if (typeof opts2.strategy === "number") strategy = opts2.strategy;
    this._handle.init(opts2.windowBits || exports2.Z_DEFAULT_WINDOWBITS, level, opts2.memLevel || exports2.Z_DEFAULT_MEMLEVEL, strategy, opts2.dictionary);
    this._buffer = Buffer5.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: function get16() {
        return !_this._handle;
      },
      configurable: true,
      enumerable: true
    });
  }
  util.inherits(Zlib, Transform3);
  Zlib.prototype.params = function(level, strategy, callback) {
    if (level < exports2.Z_MIN_LEVEL || level > exports2.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports2.Z_FILTERED && strategy != exports2.Z_HUFFMAN_ONLY && strategy != exports2.Z_RLE && strategy != exports2.Z_FIXED && strategy != exports2.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding$13.Z_SYNC_FLUSH, function() {
        assert3(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback) callback();
        }
      });
    } else {
      browser$1.nextTick(callback);
    }
  };
  Zlib.prototype.reset = function() {
    assert3(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib.prototype._flush = function(callback) {
    this._transform(Buffer5.alloc(0), "", callback);
  };
  Zlib.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding$13.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback) browser$1.nextTick(callback);
    } else if (ws.ending) {
      if (callback) this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer5.alloc(0), "", callback);
    }
  };
  Zlib.prototype.close = function(callback) {
    _close(this, callback);
    browser$1.nextTick(emitCloseNT2, this);
  };
  function _close(engine2, callback) {
    if (callback) browser$1.nextTick(callback);
    if (!engine2._handle) return;
    engine2._handle.close();
    engine2._handle = null;
  }
  function emitCloseNT2(self2) {
    self2.emit("close");
  }
  Zlib.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last3 = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer5.isBuffer(chunk)) return cb(new Error("invalid input"));
    if (!this._handle) return cb(new Error("zlib binding closed"));
    if (last3) flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding$13.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(er) {
        error = er;
      });
      assert3(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength4) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer5.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert3(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError) return;
      var have = availOutBefore - availOutAfter;
      assert3(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer5.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async) return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async) return false;
      cb();
    }
  };
  util.inherits(Deflate, Zlib);
  util.inherits(Inflate, Zlib);
  util.inherits(Gzip, Zlib);
  util.inherits(Gunzip, Zlib);
  util.inherits(DeflateRaw, Zlib);
  util.inherits(InflateRaw, Zlib);
  util.inherits(Unzip, Zlib);
})(lib);
var zlib = getDefaultExportFromCjs(lib);
var PNG = function() {
  PNG2.decode = function decode2(path2, fn) {
    {
      throw new Error("PNG.decode not available in browser build");
    }
  };
  PNG2.load = function load(path2) {
    {
      throw new Error("PNG.load not available in browser build");
    }
  };
  function PNG2(data2) {
    var i;
    this.data = data2;
    this.pos = 8;
    this.palette = [];
    this.imgData = [];
    this.transparency = {};
    this.text = {};
    while (true) {
      var chunkSize = this.readUInt32();
      var section = "";
      for (i = 0; i < 4; i++) {
        section += String.fromCharCode(this.data[this.pos++]);
      }
      switch (section) {
        case "IHDR":
          this.width = this.readUInt32();
          this.height = this.readUInt32();
          this.bits = this.data[this.pos++];
          this.colorType = this.data[this.pos++];
          this.compressionMethod = this.data[this.pos++];
          this.filterMethod = this.data[this.pos++];
          this.interlaceMethod = this.data[this.pos++];
          break;
        case "PLTE":
          this.palette = this.read(chunkSize);
          break;
        case "IDAT":
          for (i = 0; i < chunkSize; i++) {
            this.imgData.push(this.data[this.pos++]);
          }
          break;
        case "tRNS":
          this.transparency = {};
          switch (this.colorType) {
            case 3:
              this.transparency.indexed = this.read(chunkSize);
              var short = 255 - this.transparency.indexed.length;
              if (short > 0) {
                for (i = 0; i < short; i++) {
                  this.transparency.indexed.push(255);
                }
              }
              break;
            case 0:
              this.transparency.grayscale = this.read(chunkSize)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(chunkSize);
              break;
          }
          break;
        case "tEXt":
          var text2 = this.read(chunkSize);
          var index2 = text2.indexOf(0);
          var key = String.fromCharCode.apply(String, text2.slice(0, index2));
          this.text[key] = String.fromCharCode.apply(String, text2.slice(index2 + 1));
          break;
        case "IEND":
          switch (this.colorType) {
            case 0:
            case 3:
            case 4:
              this.colors = 1;
              break;
            case 2:
            case 6:
              this.colors = 3;
              break;
          }
          this.hasAlphaChannel = [4, 6].includes(this.colorType);
          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
          this.pixelBitlength = this.bits * colors;
          switch (this.colors) {
            case 1:
              this.colorSpace = "DeviceGray";
              break;
            case 3:
              this.colorSpace = "DeviceRGB";
              break;
          }
          this.imgData = Buffer2.from(this.imgData);
          return;
        default:
          this.pos += chunkSize;
      }
      this.pos += 4;
      if (this.pos > this.data.length) {
        throw new Error("Incomplete or corrupt PNG file");
      }
    }
  }
  var _proto = PNG2.prototype;
  _proto.read = function read4(bytes) {
    var result = new Array(bytes);
    for (var i = 0; i < bytes; i++) {
      result[i] = this.data[this.pos++];
    }
    return result;
  };
  _proto.readUInt32 = function readUInt32() {
    var b1 = this.data[this.pos++] << 24;
    var b2 = this.data[this.pos++] << 16;
    var b3 = this.data[this.pos++] << 8;
    var b4 = this.data[this.pos++];
    return b1 | b2 | b3 | b4;
  };
  _proto.readUInt16 = function readUInt16() {
    var b1 = this.data[this.pos++] << 8;
    var b2 = this.data[this.pos++];
    return b1 | b2;
  };
  _proto.decodePixels = function decodePixels(fn) {
    var _this = this;
    return zlib.inflate(this.imgData, function(err2, data2) {
      if (err2) throw err2;
      var pos = 0;
      var width = _this.width, height5 = _this.height;
      var pixelBytes = _this.pixelBitlength / 8;
      var pixels = Buffer2.alloc(width * height5 * pixelBytes);
      function pass(x0, y0, dx, dy, singlePass) {
        if (singlePass === void 0) {
          singlePass = false;
        }
        var w = Math.ceil((width - x0) / dx);
        var h2 = Math.ceil((height5 - y0) / dy);
        var scanlineLength = pixelBytes * w;
        var buffer = singlePass ? pixels : Buffer2.alloc(scanlineLength * h2);
        var row = 0;
        var c2 = 0;
        while (row < h2 && pos < data2.length) {
          var byte;
          var col;
          var i;
          var left;
          var upper;
          switch (data2[pos++]) {
            case 0:
              for (i = 0; i < scanlineLength; i++) {
                buffer[c2++] = data2[pos++];
              }
              break;
            case 1:
              for (i = 0; i < scanlineLength; i++) {
                byte = data2[pos++];
                left = i < pixelBytes ? 0 : buffer[c2 - pixelBytes];
                buffer[c2++] = (byte + left) % 256;
              }
              break;
            case 2:
              for (i = 0; i < scanlineLength; i++) {
                byte = data2[pos++];
                col = (i - i % pixelBytes) / pixelBytes;
                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                buffer[c2++] = (upper + byte) % 256;
              }
              break;
            case 3:
              for (i = 0; i < scanlineLength; i++) {
                byte = data2[pos++];
                col = (i - i % pixelBytes) / pixelBytes;
                left = i < pixelBytes ? 0 : buffer[c2 - pixelBytes];
                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                buffer[c2++] = (byte + Math.floor((left + upper) / 2)) % 256;
              }
              break;
            case 4:
              for (i = 0; i < scanlineLength; i++) {
                var paeth;
                var upperLeft;
                byte = data2[pos++];
                col = (i - i % pixelBytes) / pixelBytes;
                left = i < pixelBytes ? 0 : buffer[c2 - pixelBytes];
                if (row === 0) {
                  upper = upperLeft = 0;
                } else {
                  upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                  upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];
                }
                var p = left + upper - upperLeft;
                var pa = Math.abs(p - left);
                var pb = Math.abs(p - upper);
                var pc = Math.abs(p - upperLeft);
                if (pa <= pb && pa <= pc) {
                  paeth = left;
                } else if (pb <= pc) {
                  paeth = upper;
                } else {
                  paeth = upperLeft;
                }
                buffer[c2++] = (byte + paeth) % 256;
              }
              break;
            default:
              throw new Error("Invalid filter algorithm: " + data2[pos - 1]);
          }
          if (!singlePass) {
            var pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;
            var bufferPos = row * scanlineLength;
            for (i = 0; i < w; i++) {
              for (var j = 0; j < pixelBytes; j++) pixels[pixelsPos++] = buffer[bufferPos++];
              pixelsPos += (dx - 1) * pixelBytes;
            }
          }
          row++;
        }
      }
      if (_this.interlaceMethod === 1) {
        pass(0, 0, 8, 8);
        pass(4, 0, 8, 8);
        pass(0, 4, 4, 8);
        pass(2, 0, 4, 4);
        pass(0, 2, 2, 4);
        pass(1, 0, 2, 2);
        pass(0, 1, 1, 2);
      } else {
        pass(0, 0, 1, 1, true);
      }
      return fn(pixels);
    });
  };
  _proto.decodePalette = function decodePalette() {
    var palette = this.palette;
    var length4 = palette.length;
    var transparency = this.transparency.indexed || [];
    var ret = Buffer2.alloc(transparency.length + length4);
    var pos = 0;
    var c2 = 0;
    for (var i = 0; i < length4; i += 3) {
      var left;
      ret[pos++] = palette[i];
      ret[pos++] = palette[i + 1];
      ret[pos++] = palette[i + 2];
      ret[pos++] = (left = transparency[c2++]) != null ? left : 255;
    }
    return ret;
  };
  _proto.copyToImageData = function copyToImageData(imageData, pixels) {
    var j;
    var k;
    var colors = this.colors;
    var palette = null;
    var alpha = this.hasAlphaChannel;
    if (this.palette.length) {
      palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());
      colors = 4;
      alpha = true;
    }
    var data2 = imageData.data || imageData;
    var length4 = data2.length;
    var input = palette || pixels;
    var i = j = 0;
    if (colors === 1) {
      while (i < length4) {
        k = palette ? pixels[i / 4] * 4 : j;
        var v2 = input[k++];
        data2[i++] = v2;
        data2[i++] = v2;
        data2[i++] = v2;
        data2[i++] = alpha ? input[k++] : 255;
        j = k;
      }
    } else {
      while (i < length4) {
        k = palette ? pixels[i / 4] * 4 : j;
        data2[i++] = input[k++];
        data2[i++] = input[k++];
        data2[i++] = input[k++];
        data2[i++] = alpha ? input[k++] : 255;
        j = k;
      }
    }
  };
  _proto.decode = function decode2(fn) {
    var _this2 = this;
    var ret = Buffer2.alloc(this.width * this.height * 4);
    return this.decodePixels(function(pixels) {
      _this2.copyToImageData(ret, pixels);
      return fn(ret);
    });
  };
  return PNG2;
}();

// ../../.yarn/cache/@react-pdf-pdfkit-npm-3.1.10-a4a5df5869-62de5af0c3.zip/node_modules/@react-pdf/pdfkit/lib/pdfkit.browser.js
var CryptoJS = __toESM(require_core());
var global$12 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup2 = [];
var revLookup2 = [];
var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited2 = false;
function init2() {
  inited2 = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup2[i] = code[i];
    revLookup2[code.charCodeAt(i)] = i;
  }
  revLookup2["-".charCodeAt(0)] = 62;
  revLookup2["_".charCodeAt(0)] = 63;
}
function toByteArray2(b64) {
  if (!inited2) {
    init2();
  }
  var i, j, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr2(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L2 = 0;
  for (i = 0, j = 0; i < l2; i += 4, j += 3) {
    tmp = revLookup2[b64.charCodeAt(i)] << 18 | revLookup2[b64.charCodeAt(i + 1)] << 12 | revLookup2[b64.charCodeAt(i + 2)] << 6 | revLookup2[b64.charCodeAt(i + 3)];
    arr[L2++] = tmp >> 16 & 255;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup2[b64.charCodeAt(i)] << 2 | revLookup2[b64.charCodeAt(i + 1)] >> 4;
    arr[L2++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup2[b64.charCodeAt(i)] << 10 | revLookup2[b64.charCodeAt(i + 1)] << 4 | revLookup2[b64.charCodeAt(i + 2)] >> 2;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  return arr;
}
function tripletToBase642(num) {
  return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
}
function encodeChunk2(uint82, start3, end3) {
  var tmp;
  var output = [];
  for (var i = start3; i < end3; i += 3) {
    tmp = (uint82[i] << 16) + (uint82[i + 1] << 8) + uint82[i + 2];
    output.push(tripletToBase642(tmp));
  }
  return output.join("");
}
function fromByteArray2(uint82) {
  if (!inited2) {
    init2();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk2(uint82, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup2[tmp >> 2];
    output += lookup2[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup2[tmp >> 10];
    output += lookup2[tmp >> 4 & 63];
    output += lookup2[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read2(buffer, offset3, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s2 = buffer[offset3 + i];
  i += d;
  e = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset3 + i], i += d, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer[offset3 + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
}
function write3(buffer, value2, offset3, isLE, mLen, nBytes) {
  var e, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e)) < 1) {
      e--;
      c2 *= 2;
    }
    if (e + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e++;
      c2 /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset3 + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer[offset3 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset3 + i - d] |= s2 * 128;
}
var toString3 = {}.toString;
var isArray$12 = Array.isArray || function(arr) {
  return toString3.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES2 = 50;
Buffer$2.TYPED_ARRAY_SUPPORT = global$12.TYPED_ARRAY_SUPPORT !== void 0 ? global$12.TYPED_ARRAY_SUPPORT : true;
var _kMaxLength2 = kMaxLength2();
function kMaxLength2() {
  return Buffer$2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer2(that, length4) {
  if (kMaxLength2() < length4) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length4);
    that.__proto__ = Buffer$2.prototype;
  } else {
    if (that === null) {
      that = new Buffer$2(length4);
    }
    that.length = length4;
  }
  return that;
}
function Buffer$2(arg, encodingOrOffset, length4) {
  if (!Buffer$2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$2)) {
    return new Buffer$2(arg, encodingOrOffset, length4);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe2(this, arg);
  }
  return from$1(this, arg, encodingOrOffset, length4);
}
Buffer$2.poolSize = 8192;
Buffer$2._augment = function(arr) {
  arr.__proto__ = Buffer$2.prototype;
  return arr;
};
function from$1(that, value2, encodingOrOffset, length4) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer2(that, value2, encodingOrOffset, length4);
  }
  if (typeof value2 === "string") {
    return fromString2(that, value2, encodingOrOffset);
  }
  return fromObject2(that, value2);
}
Buffer$2.from = function(value2, encodingOrOffset, length4) {
  return from$1(null, value2, encodingOrOffset, length4);
};
if (Buffer$2.TYPED_ARRAY_SUPPORT) {
  Buffer$2.prototype.__proto__ = Uint8Array.prototype;
  Buffer$2.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer$2[Symbol.species] === Buffer$2) ;
}
function assertSize2(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc2(that, size, fill5, encoding) {
  assertSize2(size);
  if (size <= 0) {
    return createBuffer2(that, size);
  }
  if (fill5 !== void 0) {
    return typeof encoding === "string" ? createBuffer2(that, size).fill(fill5, encoding) : createBuffer2(that, size).fill(fill5);
  }
  return createBuffer2(that, size);
}
Buffer$2.alloc = function(size, fill5, encoding) {
  return alloc2(null, size, fill5, encoding);
};
function allocUnsafe2(that, size) {
  assertSize2(size);
  that = createBuffer2(that, size < 0 ? 0 : checked2(size) | 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
Buffer$2.allocUnsafe = function(size) {
  return allocUnsafe2(null, size);
};
Buffer$2.allocUnsafeSlow = function(size) {
  return allocUnsafe2(null, size);
};
function fromString2(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer$2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length4 = byteLength3(string, encoding) | 0;
  that = createBuffer2(that, length4);
  var actual = that.write(string, encoding);
  if (actual !== length4) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike2(that, array) {
  var length4 = array.length < 0 ? 0 : checked2(array.length) | 0;
  that = createBuffer2(that, length4);
  for (var i = 0; i < length4; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer2(that, array, byteOffset, length4) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length4 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length4 === void 0) {
    array = new Uint8Array(array);
  } else if (length4 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length4);
  }
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer$2.prototype;
  } else {
    that = fromArrayLike2(that, array);
  }
  return that;
}
function fromObject2(that, obj) {
  if (internalIsBuffer2(obj)) {
    var len = checked2(obj.length) | 0;
    that = createBuffer2(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan2(obj.length)) {
        return createBuffer2(that, 0);
      }
      return fromArrayLike2(that, obj);
    }
    if (obj.type === "Buffer" && isArray$12(obj.data)) {
      return fromArrayLike2(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked2(length4) {
  if (length4 >= kMaxLength2()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2().toString(16) + " bytes");
  }
  return length4 | 0;
}
function SlowBuffer2(length4) {
  if (+length4 != length4) {
    length4 = 0;
  }
  return Buffer$2.alloc(+length4);
}
Buffer$2.isBuffer = isBuffer$12;
function internalIsBuffer2(b) {
  return !!(b != null && b._isBuffer);
}
Buffer$2.compare = function compare4(a2, b) {
  if (!internalIsBuffer2(a2) || !internalIsBuffer2(b)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a2 === b) return 0;
  var x = a2.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a2[i] !== b[i]) {
      x = a2[i];
      y = b[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer$2.isEncoding = function isEncoding2(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer$2.concat = function concat2(list, length4) {
  if (!isArray$12(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer$2.alloc(0);
  }
  var i;
  if (length4 === void 0) {
    length4 = 0;
    for (i = 0; i < list.length; ++i) {
      length4 += list[i].length;
    }
  }
  var buffer = Buffer$2.allocUnsafe(length4);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer2(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength3(string, encoding) {
  if (internalIsBuffer2(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes2(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes2(string).length;
      default:
        if (loweredCase) return utf8ToBytes2(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.byteLength = byteLength3;
function slowToString2(encoding, start3, end3) {
  var loweredCase = false;
  if (start3 === void 0 || start3 < 0) {
    start3 = 0;
  }
  if (start3 > this.length) {
    return "";
  }
  if (end3 === void 0 || end3 > this.length) {
    end3 = this.length;
  }
  if (end3 <= 0) {
    return "";
  }
  end3 >>>= 0;
  start3 >>>= 0;
  if (end3 <= start3) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice2(this, start3, end3);
      case "utf8":
      case "utf-8":
        return utf8Slice2(this, start3, end3);
      case "ascii":
        return asciiSlice2(this, start3, end3);
      case "latin1":
      case "binary":
        return latin1Slice2(this, start3, end3);
      case "base64":
        return base64Slice2(this, start3, end3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice2(this, start3, end3);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$2.prototype._isBuffer = true;
function swap2(b, n, m2) {
  var i = b[n];
  b[n] = b[m2];
  b[m2] = i;
}
Buffer$2.prototype.swap16 = function swap162() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i = 0; i < len; i += 2) {
    swap2(this, i, i + 1);
  }
  return this;
};
Buffer$2.prototype.swap32 = function swap322() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i = 0; i < len; i += 4) {
    swap2(this, i, i + 3);
    swap2(this, i + 1, i + 2);
  }
  return this;
};
Buffer$2.prototype.swap64 = function swap642() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i = 0; i < len; i += 8) {
    swap2(this, i, i + 7);
    swap2(this, i + 1, i + 6);
    swap2(this, i + 2, i + 5);
    swap2(this, i + 3, i + 4);
  }
  return this;
};
Buffer$2.prototype.toString = function toString4() {
  var length4 = this.length | 0;
  if (length4 === 0) return "";
  if (arguments.length === 0) return utf8Slice2(this, 0, length4);
  return slowToString2.apply(this, arguments);
};
Buffer$2.prototype.equals = function equals2(b) {
  if (!internalIsBuffer2(b)) throw new TypeError("Argument must be a Buffer");
  if (this === b) return true;
  return Buffer$2.compare(this, b) === 0;
};
Buffer$2.prototype.inspect = function inspect3() {
  var str = "";
  var max3 = INSPECT_MAX_BYTES2;
  if (this.length > 0) {
    str = this.toString("hex", 0, max3).match(/.{2}/g).join(" ");
    if (this.length > max3) str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer$2.prototype.compare = function compare5(target, start3, end3, thisStart, thisEnd) {
  if (!internalIsBuffer2(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start3 === void 0) {
    start3 = 0;
  }
  if (end3 === void 0) {
    end3 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start3 < 0 || end3 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start3 >= end3) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start3 >= end3) {
    return 1;
  }
  start3 >>>= 0;
  end3 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end3 - start3;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start3, end3);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
function bidirectionalIndexOf2(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer$2.from(val, encoding);
  }
  if (internalIsBuffer2(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf2(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer$2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf2(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf2(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read4(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read4(arr, i) === read4(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read4(arr, i + j) !== read4(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer$2.prototype.includes = function includes2(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer$2.prototype.indexOf = function indexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
};
Buffer$2.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
};
function hexWrite2(buf, string, offset3, length4) {
  offset3 = Number(offset3) || 0;
  var remaining = buf.length - offset3;
  if (!length4) {
    length4 = remaining;
  } else {
    length4 = Number(length4);
    if (length4 > remaining) {
      length4 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length4 > strLen / 2) {
    length4 = strLen / 2;
  }
  for (var i = 0; i < length4; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset3 + i] = parsed;
  }
  return i;
}
function utf8Write2(buf, string, offset3, length4) {
  return blitBuffer2(utf8ToBytes2(string, buf.length - offset3), buf, offset3, length4);
}
function asciiWrite2(buf, string, offset3, length4) {
  return blitBuffer2(asciiToBytes2(string), buf, offset3, length4);
}
function latin1Write2(buf, string, offset3, length4) {
  return asciiWrite2(buf, string, offset3, length4);
}
function base64Write2(buf, string, offset3, length4) {
  return blitBuffer2(base64ToBytes2(string), buf, offset3, length4);
}
function ucs2Write2(buf, string, offset3, length4) {
  return blitBuffer2(utf16leToBytes2(string, buf.length - offset3), buf, offset3, length4);
}
Buffer$2.prototype.write = function write4(string, offset3, length4, encoding) {
  if (offset3 === void 0) {
    encoding = "utf8";
    length4 = this.length;
    offset3 = 0;
  } else if (length4 === void 0 && typeof offset3 === "string") {
    encoding = offset3;
    length4 = this.length;
    offset3 = 0;
  } else if (isFinite(offset3)) {
    offset3 = offset3 | 0;
    if (isFinite(length4)) {
      length4 = length4 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length4;
      length4 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset3;
  if (length4 === void 0 || length4 > remaining) length4 = remaining;
  if (string.length > 0 && (length4 < 0 || offset3 < 0) || offset3 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite2(this, string, offset3, length4);
      case "utf8":
      case "utf-8":
        return utf8Write2(this, string, offset3, length4);
      case "ascii":
        return asciiWrite2(this, string, offset3, length4);
      case "latin1":
      case "binary":
        return latin1Write2(this, string, offset3, length4);
      case "base64":
        return base64Write2(this, string, offset3, length4);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write2(this, string, offset3, length4);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer$2.prototype.toJSON = function toJSON2() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice2(buf, start3, end3) {
  if (start3 === 0 && end3 === buf.length) {
    return fromByteArray2(buf);
  } else {
    return fromByteArray2(buf.slice(start3, end3));
  }
}
function utf8Slice2(buf, start3, end3) {
  end3 = Math.min(buf.length, end3);
  var res = [];
  var i = start3;
  while (i < end3) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end3) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
var MAX_ARGUMENTS_LENGTH2 = 4096;
function decodeCodePointsArray2(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
    );
  }
  return res;
}
function asciiSlice2(buf, start3, end3) {
  var ret = "";
  end3 = Math.min(buf.length, end3);
  for (var i = start3; i < end3; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice2(buf, start3, end3) {
  var ret = "";
  end3 = Math.min(buf.length, end3);
  for (var i = start3; i < end3; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice2(buf, start3, end3) {
  var len = buf.length;
  if (!start3 || start3 < 0) start3 = 0;
  if (!end3 || end3 < 0 || end3 > len) end3 = len;
  var out = "";
  for (var i = start3; i < end3; ++i) {
    out += toHex$1(buf[i]);
  }
  return out;
}
function utf16leSlice2(buf, start3, end3) {
  var bytes = buf.slice(start3, end3);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer$2.prototype.slice = function slice2(start3, end3) {
  var len = this.length;
  start3 = ~~start3;
  end3 = end3 === void 0 ? len : ~~end3;
  if (start3 < 0) {
    start3 += len;
    if (start3 < 0) start3 = 0;
  } else if (start3 > len) {
    start3 = len;
  }
  if (end3 < 0) {
    end3 += len;
    if (end3 < 0) end3 = 0;
  } else if (end3 > len) {
    end3 = len;
  }
  if (end3 < start3) end3 = start3;
  var newBuf;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start3, end3);
    newBuf.__proto__ = Buffer$2.prototype;
  } else {
    var sliceLen = end3 - start3;
    newBuf = new Buffer$2(sliceLen, void 0);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start3];
    }
  }
  return newBuf;
};
function checkOffset2(offset3, ext, length4) {
  if (offset3 % 1 !== 0 || offset3 < 0) throw new RangeError("offset is not uint");
  if (offset3 + ext > length4) throw new RangeError("Trying to access beyond buffer length");
}
Buffer$2.prototype.readUIntLE = function readUIntLE2(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset2(offset3, byteLength5, this.length);
  var val = this[offset3];
  var mul = 1;
  var i = 0;
  while (++i < byteLength5 && (mul *= 256)) {
    val += this[offset3 + i] * mul;
  }
  return val;
};
Buffer$2.prototype.readUIntBE = function readUIntBE2(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset2(offset3, byteLength5, this.length);
  }
  var val = this[offset3 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset3 + --byteLength5] * mul;
  }
  return val;
};
Buffer$2.prototype.readUInt8 = function readUInt83(offset3, noAssert) {
  if (!noAssert) checkOffset2(offset3, 1, this.length);
  return this[offset3];
};
Buffer$2.prototype.readUInt16LE = function readUInt16LE3(offset3, noAssert) {
  if (!noAssert) checkOffset2(offset3, 2, this.length);
  return this[offset3] | this[offset3 + 1] << 8;
};
Buffer$2.prototype.readUInt16BE = function readUInt16BE3(offset3, noAssert) {
  if (!noAssert) checkOffset2(offset3, 2, this.length);
  return this[offset3] << 8 | this[offset3 + 1];
};
Buffer$2.prototype.readUInt32LE = function readUInt32LE3(offset3, noAssert) {
  if (!noAssert) checkOffset2(offset3, 4, this.length);
  return (this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16) + this[offset3 + 3] * 16777216;
};
Buffer$2.prototype.readUInt32BE = function readUInt32BE3(offset3, noAssert) {
  if (!noAssert) checkOffset2(offset3, 4, this.length);
  return this[offset3] * 16777216 + (this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3]);
};
Buffer$2.prototype.readIntLE = function readIntLE2(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset2(offset3, byteLength5, this.length);
  var val = this[offset3];
  var mul = 1;
  var i = 0;
  while (++i < byteLength5 && (mul *= 256)) {
    val += this[offset3 + i] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer$2.prototype.readIntBE = function readIntBE2(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset2(offset3, byteLength5, this.length);
  var i = byteLength5;
  var mul = 1;
  var val = this[offset3 + --i];
  while (i > 0 && (mul *= 256)) {
    val += this[offset3 + --i] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer$2.prototype.readInt8 = function readInt82(offset3, noAssert) {
  if (!noAssert) checkOffset2(offset3, 1, this.length);
  if (!(this[offset3] & 128)) return this[offset3];
  return (255 - this[offset3] + 1) * -1;
};
Buffer$2.prototype.readInt16LE = function readInt16LE2(offset3, noAssert) {
  if (!noAssert) checkOffset2(offset3, 2, this.length);
  var val = this[offset3] | this[offset3 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$2.prototype.readInt16BE = function readInt16BE2(offset3, noAssert) {
  if (!noAssert) checkOffset2(offset3, 2, this.length);
  var val = this[offset3 + 1] | this[offset3] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$2.prototype.readInt32LE = function readInt32LE2(offset3, noAssert) {
  if (!noAssert) checkOffset2(offset3, 4, this.length);
  return this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16 | this[offset3 + 3] << 24;
};
Buffer$2.prototype.readInt32BE = function readInt32BE2(offset3, noAssert) {
  if (!noAssert) checkOffset2(offset3, 4, this.length);
  return this[offset3] << 24 | this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3];
};
Buffer$2.prototype.readFloatLE = function readFloatLE2(offset3, noAssert) {
  if (!noAssert) checkOffset2(offset3, 4, this.length);
  return read2(this, offset3, true, 23, 4);
};
Buffer$2.prototype.readFloatBE = function readFloatBE2(offset3, noAssert) {
  if (!noAssert) checkOffset2(offset3, 4, this.length);
  return read2(this, offset3, false, 23, 4);
};
Buffer$2.prototype.readDoubleLE = function readDoubleLE2(offset3, noAssert) {
  if (!noAssert) checkOffset2(offset3, 8, this.length);
  return read2(this, offset3, true, 52, 8);
};
Buffer$2.prototype.readDoubleBE = function readDoubleBE2(offset3, noAssert) {
  if (!noAssert) checkOffset2(offset3, 8, this.length);
  return read2(this, offset3, false, 52, 8);
};
function checkInt2(buf, value2, offset3, ext, max3, min3) {
  if (!internalIsBuffer2(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max3 || value2 < min3) throw new RangeError('"value" argument is out of bounds');
  if (offset3 + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer$2.prototype.writeUIntLE = function writeUIntLE2(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt2(this, value2, offset3, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset3] = value2 & 255;
  while (++i < byteLength5 && (mul *= 256)) {
    this[offset3 + i] = value2 / mul & 255;
  }
  return offset3 + byteLength5;
};
Buffer$2.prototype.writeUIntBE = function writeUIntBE2(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt2(this, value2, offset3, byteLength5, maxBytes, 0);
  }
  var i = byteLength5 - 1;
  var mul = 1;
  this[offset3 + i] = value2 & 255;
  while (--i >= 0 && (mul *= 256)) {
    this[offset3 + i] = value2 / mul & 255;
  }
  return offset3 + byteLength5;
};
Buffer$2.prototype.writeUInt8 = function writeUInt82(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt2(this, value2, offset3, 1, 255, 0);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset3] = value2 & 255;
  return offset3 + 1;
};
function objectWriteUInt162(buf, value2, offset3, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i = 0, j = Math.min(buf.length - offset3, 2); i < j; ++i) {
    buf[offset3 + i] = (value2 & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer$2.prototype.writeUInt16LE = function writeUInt16LE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt2(this, value2, offset3, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt162(this, value2, offset3, true);
  }
  return offset3 + 2;
};
Buffer$2.prototype.writeUInt16BE = function writeUInt16BE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt2(this, value2, offset3, 2, 65535, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
  } else {
    objectWriteUInt162(this, value2, offset3, false);
  }
  return offset3 + 2;
};
function objectWriteUInt322(buf, value2, offset3, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i = 0, j = Math.min(buf.length - offset3, 4); i < j; ++i) {
    buf[offset3 + i] = value2 >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
Buffer$2.prototype.writeUInt32LE = function writeUInt32LE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt2(this, value2, offset3, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset3 + 3] = value2 >>> 24;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset3, true);
  }
  return offset3 + 4;
};
Buffer$2.prototype.writeUInt32BE = function writeUInt32BE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt2(this, value2, offset3, 4, 4294967295, 0);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset3, false);
  }
  return offset3 + 4;
};
Buffer$2.prototype.writeIntLE = function writeIntLE2(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt2(this, value2, offset3, byteLength5, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset3] = value2 & 255;
  while (++i < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset3 + i - 1] !== 0) {
      sub = 1;
    }
    this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
  }
  return offset3 + byteLength5;
};
Buffer$2.prototype.writeIntBE = function writeIntBE2(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt2(this, value2, offset3, byteLength5, limit - 1, -limit);
  }
  var i = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset3 + i] = value2 & 255;
  while (--i >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset3 + i + 1] !== 0) {
      sub = 1;
    }
    this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
  }
  return offset3 + byteLength5;
};
Buffer$2.prototype.writeInt8 = function writeInt82(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt2(this, value2, offset3, 1, 127, -128);
  if (!Buffer$2.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset3] = value2 & 255;
  return offset3 + 1;
};
Buffer$2.prototype.writeInt16LE = function writeInt16LE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt2(this, value2, offset3, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt162(this, value2, offset3, true);
  }
  return offset3 + 2;
};
Buffer$2.prototype.writeInt16BE = function writeInt16BE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt2(this, value2, offset3, 2, 32767, -32768);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
  } else {
    objectWriteUInt162(this, value2, offset3, false);
  }
  return offset3 + 2;
};
Buffer$2.prototype.writeInt32LE = function writeInt32LE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt2(this, value2, offset3, 4, 2147483647, -2147483648);
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt322(this, value2, offset3, true);
  }
  return offset3 + 4;
};
Buffer$2.prototype.writeInt32BE = function writeInt32BE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt2(this, value2, offset3, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer$2.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset3, false);
  }
  return offset3 + 4;
};
function checkIEEE7542(buf, value2, offset3, ext, max3, min3) {
  if (offset3 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset3 < 0) throw new RangeError("Index out of range");
}
function writeFloat2(buf, value2, offset3, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value2, offset3, 4);
  }
  write3(buf, value2, offset3, littleEndian, 23, 4);
  return offset3 + 4;
}
Buffer$2.prototype.writeFloatLE = function writeFloatLE2(value2, offset3, noAssert) {
  return writeFloat2(this, value2, offset3, true, noAssert);
};
Buffer$2.prototype.writeFloatBE = function writeFloatBE2(value2, offset3, noAssert) {
  return writeFloat2(this, value2, offset3, false, noAssert);
};
function writeDouble2(buf, value2, offset3, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value2, offset3, 8);
  }
  write3(buf, value2, offset3, littleEndian, 52, 8);
  return offset3 + 8;
}
Buffer$2.prototype.writeDoubleLE = function writeDoubleLE2(value2, offset3, noAssert) {
  return writeDouble2(this, value2, offset3, true, noAssert);
};
Buffer$2.prototype.writeDoubleBE = function writeDoubleBE2(value2, offset3, noAssert) {
  return writeDouble2(this, value2, offset3, false, noAssert);
};
Buffer$2.prototype.copy = function copy2(target, targetStart, start3, end3) {
  if (!start3) start3 = 0;
  if (!end3 && end3 !== 0) end3 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end3 > 0 && end3 < start3) end3 = start3;
  if (end3 === start3) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start3 < 0 || start3 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end3 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end3 > this.length) end3 = this.length;
  if (target.length - targetStart < end3 - start3) {
    end3 = target.length - targetStart + start3;
  }
  var len = end3 - start3;
  var i;
  if (this === target && start3 < targetStart && targetStart < end3) {
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start3];
    }
  } else if (len < 1e3 || !Buffer$2.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start3];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start3, start3 + len),
      targetStart
    );
  }
  return len;
};
Buffer$2.prototype.fill = function fill2(val, start3, end3, encoding) {
  if (typeof val === "string") {
    if (typeof start3 === "string") {
      encoding = start3;
      start3 = 0;
      end3 = this.length;
    } else if (typeof end3 === "string") {
      encoding = end3;
      end3 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer$2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start3 < 0 || this.length < start3 || this.length < end3) {
    throw new RangeError("Out of range index");
  }
  if (end3 <= start3) {
    return this;
  }
  start3 = start3 >>> 0;
  end3 = end3 === void 0 ? this.length : end3 >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === "number") {
    for (i = start3; i < end3; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer2(val) ? val : utf8ToBytes2(new Buffer$2(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end3 - start3; ++i) {
      this[i + start3] = bytes[i % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE2 = /[^+\/0-9A-Za-z-_]/g;
function base64clean2(str) {
  str = stringtrim2(str).replace(INVALID_BASE64_RE2, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim2(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex$1(n) {
  if (n < 16) return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes2(string, units) {
  units = units || Infinity;
  var codePoint;
  var length4 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length4; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length4) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes2(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes2(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c2 = str.charCodeAt(i);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes2(str) {
  return toByteArray2(base64clean2(str));
}
function blitBuffer2(src, dst, offset3, length4) {
  for (var i = 0; i < length4; ++i) {
    if (i + offset3 >= dst.length || i >= src.length) break;
    dst[i + offset3] = src[i];
  }
  return i;
}
function isnan2(val) {
  return val !== val;
}
function isBuffer$12(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer2(obj) || isSlowBuffer2(obj));
}
function isFastBuffer2(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer2(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer2(obj.slice(0, 0));
}
var _polyfillNode_buffer2 = Object.freeze({
  __proto__: null,
  Buffer: Buffer$2,
  INSPECT_MAX_BYTES: INSPECT_MAX_BYTES2,
  SlowBuffer: SlowBuffer2,
  isBuffer: isBuffer$12,
  kMaxLength: _kMaxLength2
});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs2(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace2(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a2.prototype = f.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a2;
}
var readableBrowser = { exports: {} };
var _registry = {};
function defaultSetTimout2() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout2() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout2 = defaultSetTimout2;
var cachedClearTimeout2 = defaultClearTimeout2;
if (typeof global$12.setTimeout === "function") {
  cachedSetTimeout2 = setTimeout;
}
if (typeof global$12.clearTimeout === "function") {
  cachedClearTimeout2 = clearTimeout;
}
function runTimeout2(fun) {
  if (cachedSetTimeout2 === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
    cachedSetTimeout2 = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout2(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout2.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout2.call(this, fun, 0);
    }
  }
}
function runClearTimeout2(marker) {
  if (cachedClearTimeout2 === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
    cachedClearTimeout2 = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout2(marker);
  } catch (e) {
    try {
      return cachedClearTimeout2.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout2.call(this, marker);
    }
  }
}
var queue2 = [];
var draining2 = false;
var currentQueue2;
var queueIndex2 = -1;
function cleanUpNextTick2() {
  if (!draining2 || !currentQueue2) {
    return;
  }
  draining2 = false;
  if (currentQueue2.length) {
    queue2 = currentQueue2.concat(queue2);
  } else {
    queueIndex2 = -1;
  }
  if (queue2.length) {
    drainQueue2();
  }
}
function drainQueue2() {
  if (draining2) {
    return;
  }
  var timeout = runTimeout2(cleanUpNextTick2);
  draining2 = true;
  var len = queue2.length;
  while (len) {
    currentQueue2 = queue2;
    queue2 = [];
    while (++queueIndex2 < len) {
      if (currentQueue2) {
        currentQueue2[queueIndex2].run();
      }
    }
    queueIndex2 = -1;
    len = queue2.length;
  }
  currentQueue2 = null;
  draining2 = false;
  runClearTimeout2(timeout);
}
function nextTick2(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue2.push(new Item2(fun, args));
  if (queue2.length === 1 && !draining2) {
    runTimeout2(drainQueue2);
  }
}
function Item2(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title2 = "browser";
var platform2 = "browser";
var browser$12 = true;
var env2 = {};
var argv2 = [];
var version2 = "";
var versions2 = {};
var release2 = {};
var config$1 = {};
function noop$2() {
}
var on2 = noop$2;
var addListener3 = noop$2;
var once$2 = noop$2;
var off2 = noop$2;
var removeListener3 = noop$2;
var removeAllListeners3 = noop$2;
var emit3 = noop$2;
function binding$12(name2) {
  throw new Error("process.binding is not supported");
}
function cwd2() {
  return "/";
}
function chdir2(dir) {
  throw new Error("process.chdir is not supported");
}
function umask2() {
  return 0;
}
var performance2 = global$12.performance || {};
var performanceNow2 = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime2(previousTimestamp) {
  var clocktime = performanceNow2.call(performance2) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime2 = /* @__PURE__ */ new Date();
function uptime2() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime2;
  return dif / 1e3;
}
var browser$1$1 = {
  nextTick: nextTick2,
  title: title2,
  browser: browser$12,
  env: env2,
  argv: argv2,
  version: version2,
  versions: versions2,
  on: on2,
  addListener: addListener3,
  once: once$2,
  off: off2,
  removeListener: removeListener3,
  removeAllListeners: removeAllListeners3,
  emit: emit3,
  binding: binding$12,
  cwd: cwd2,
  chdir: chdir2,
  umask: umask2,
  hrtime: hrtime2,
  platform: platform2,
  release: release2,
  config: config$1,
  uptime: uptime2
};
var domain2;
function EventHandlers2() {
}
EventHandlers2.prototype = /* @__PURE__ */ Object.create(null);
function EventEmitter2() {
  EventEmitter2.init.call(this);
}
EventEmitter2.EventEmitter = EventEmitter2;
EventEmitter2.usingDomains = false;
EventEmitter2.prototype.domain = void 0;
EventEmitter2.prototype._events = void 0;
EventEmitter2.prototype._maxListeners = void 0;
EventEmitter2.defaultMaxListeners = 10;
EventEmitter2.init = function() {
  this.domain = null;
  if (EventEmitter2.usingDomains) {
    if (domain2.active) ;
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers2();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter2.prototype.setMaxListeners = function setMaxListeners2(n) {
  if (typeof n !== "number" || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};
function $getMaxListeners2(that) {
  if (that._maxListeners === void 0)
    return EventEmitter2.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter2.prototype.getMaxListeners = function getMaxListeners2() {
  return $getMaxListeners2(this);
};
function emitNone2(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i = 0; i < len; ++i)
      listeners3[i].call(self2);
  }
}
function emitOne2(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i = 0; i < len; ++i)
      listeners3[i].call(self2, arg1);
  }
}
function emitTwo2(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i = 0; i < len; ++i)
      listeners3[i].call(self2, arg1, arg2);
  }
}
function emitThree2(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i = 0; i < len; ++i)
      listeners3[i].call(self2, arg1, arg2, arg3);
  }
}
function emitMany2(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i = 0; i < len; ++i)
      listeners3[i].apply(self2, args);
  }
}
EventEmitter2.prototype.emit = function emit4(type2) {
  var er, handler, len, args, i, events2, domain3;
  var doError = type2 === "error";
  events2 = this._events;
  if (events2)
    doError = doError && events2.error == null;
  else if (!doError)
    return false;
  domain3 = this.domain;
  if (doError) {
    er = arguments[1];
    if (domain3) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain3;
      er.domainThrown = false;
      domain3.emit("error", er);
    } else if (er instanceof Error) {
      throw er;
    } else {
      var err2 = new Error('Uncaught, unspecified "error" event. (' + er + ")");
      err2.context = er;
      throw err2;
    }
    return false;
  }
  handler = events2[type2];
  if (!handler)
    return false;
  var isFn = typeof handler === "function";
  len = arguments.length;
  switch (len) {
    case 1:
      emitNone2(handler, isFn, this);
      break;
    case 2:
      emitOne2(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo2(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree2(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany2(handler, isFn, this, args);
  }
  return true;
};
function _addListener2(target, type2, listener, prepend) {
  var m2;
  var events2;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = target._events;
  if (!events2) {
    events2 = target._events = new EventHandlers2();
    target._eventsCount = 0;
  } else {
    if (events2.newListener) {
      target.emit(
        "newListener",
        type2,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type2];
  }
  if (!existing) {
    existing = events2[type2] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m2 = $getMaxListeners2(target);
      if (m2 && m2 > 0 && existing.length > m2) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type2;
        w.count = existing.length;
        emitWarning2(w);
      }
    }
  }
  return target;
}
function emitWarning2(e) {
  typeof console.warn === "function" ? console.warn(e) : console.log(e);
}
EventEmitter2.prototype.addListener = function addListener4(type2, listener) {
  return _addListener2(this, type2, listener, false);
};
EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
EventEmitter2.prototype.prependListener = function prependListener3(type2, listener) {
  return _addListener2(this, type2, listener, true);
};
function _onceWrap2(target, type2, listener) {
  var fired = false;
  function g() {
    target.removeListener(type2, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
EventEmitter2.prototype.once = function once3(type2, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.on(type2, _onceWrap2(this, type2, listener));
  return this;
};
EventEmitter2.prototype.prependOnceListener = function prependOnceListener2(type2, listener) {
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  this.prependListener(type2, _onceWrap2(this, type2, listener));
  return this;
};
EventEmitter2.prototype.removeListener = function removeListener4(type2, listener) {
  var list, events2, position, i, originalListener;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events2 = this._events;
  if (!events2)
    return this;
  list = events2[type2];
  if (!list)
    return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers2();
    else {
      delete events2[type2];
      if (events2.removeListener)
        this.emit("removeListener", type2, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i = list.length; i-- > 0; ) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0)
      return this;
    if (list.length === 1) {
      list[0] = void 0;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers2();
        return this;
      } else {
        delete events2[type2];
      }
    } else {
      spliceOne2(list, position);
    }
    if (events2.removeListener)
      this.emit("removeListener", type2, originalListener || listener);
  }
  return this;
};
EventEmitter2.prototype.off = function(type2, listener) {
  return this.removeListener(type2, listener);
};
EventEmitter2.prototype.removeAllListeners = function removeAllListeners4(type2) {
  var listeners3, events2;
  events2 = this._events;
  if (!events2)
    return this;
  if (!events2.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers2();
      this._eventsCount = 0;
    } else if (events2[type2]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers2();
      else
        delete events2[type2];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    for (var i = 0, key; i < keys2.length; ++i) {
      key = keys2[i];
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = new EventHandlers2();
    this._eventsCount = 0;
    return this;
  }
  listeners3 = events2[type2];
  if (typeof listeners3 === "function") {
    this.removeListener(type2, listeners3);
  } else if (listeners3) {
    do {
      this.removeListener(type2, listeners3[listeners3.length - 1]);
    } while (listeners3[0]);
  }
  return this;
};
EventEmitter2.prototype.listeners = function listeners2(type2) {
  var evlistener;
  var ret;
  var events2 = this._events;
  if (!events2)
    ret = [];
  else {
    evlistener = events2[type2];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === "function")
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners2(evlistener);
  }
  return ret;
};
EventEmitter2.listenerCount = function(emitter, type2) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type2);
  } else {
    return listenerCount2.call(emitter, type2);
  }
};
EventEmitter2.prototype.listenerCount = listenerCount2;
function listenerCount2(type2) {
  var events2 = this._events;
  if (events2) {
    var evlistener = events2[type2];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter2.prototype.eventNames = function eventNames2() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function spliceOne2(list, index2) {
  for (var i = index2, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}
function arrayClone2(arr, i) {
  var copy6 = new Array(i);
  while (i--)
    copy6[i] = arr[i];
  return copy6;
}
function unwrapListeners2(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
var _polyfillNode_events = Object.freeze({
  __proto__: null,
  EventEmitter: EventEmitter2,
  default: EventEmitter2
});
var require$$1$1 = getAugmentedNamespace2(_polyfillNode_events);
var streamBrowser = require$$1$1.EventEmitter;
var require$$02 = getAugmentedNamespace2(_polyfillNode_buffer2);
var inherits$2;
if (typeof Object.create === "function") {
  inherits$2 = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits$2 = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$3 = inherits$2;
var getOwnPropertyDescriptors3 = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors4(obj) {
  var keys2 = Object.keys(obj);
  var descriptors = {};
  for (var i = 0; i < keys2.length; i++) {
    descriptors[keys2[i]] = Object.getOwnPropertyDescriptor(obj, keys2[i]);
  }
  return descriptors;
};
var formatRegExp2 = /%[sdj%]/g;
function format2(f) {
  if (!isString2(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect$12(arguments[i]));
    }
    return objects.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp2, function(x2) {
    if (x2 === "%%") return "%";
    if (i >= len) return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull2(x) || !isObject2(x)) {
      str += " " + x;
    } else {
      str += " " + inspect$12(x);
    }
  }
  return str;
}
function deprecate$1(fn, msg2) {
  if (isUndefined2(global$12.process)) {
    return function() {
      return deprecate$1(fn, msg2).apply(this, arguments);
    };
  }
  if (browser$1$1.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (browser$1$1.throwDeprecation) {
        throw new Error(msg2);
      } else if (browser$1$1.traceDeprecation) {
        console.trace(msg2);
      } else {
        console.error(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
var debugs2 = {};
var debugEnviron2;
function debuglog2(set5) {
  if (isUndefined2(debugEnviron2))
    debugEnviron2 = browser$1$1.env.NODE_DEBUG || "";
  set5 = set5.toUpperCase();
  if (!debugs2[set5]) {
    if (new RegExp("\\b" + set5 + "\\b", "i").test(debugEnviron2)) {
      var pid = 0;
      debugs2[set5] = function() {
        var msg2 = format2.apply(null, arguments);
        console.error("%s %d: %s", set5, pid, msg2);
      };
    } else {
      debugs2[set5] = function() {
      };
    }
  }
  return debugs2[set5];
}
function inspect$12(obj, opts2) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor2
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean2(opts2)) {
    ctx.showHidden = opts2;
  } else if (opts2) {
    _extend2(ctx, opts2);
  }
  if (isUndefined2(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined2(ctx.depth)) ctx.depth = 2;
  if (isUndefined2(ctx.colors)) ctx.colors = false;
  if (isUndefined2(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor2;
  return formatValue2(ctx, obj, ctx.depth);
}
inspect$12.colors = {
  "bold": [1, 22],
  "italic": [3, 23],
  "underline": [4, 24],
  "inverse": [7, 27],
  "white": [37, 39],
  "grey": [90, 39],
  "black": [30, 39],
  "blue": [34, 39],
  "cyan": [36, 39],
  "green": [32, 39],
  "magenta": [35, 39],
  "red": [31, 39],
  "yellow": [33, 39]
};
inspect$12.styles = {
  "special": "cyan",
  "number": "yellow",
  "boolean": "yellow",
  "undefined": "grey",
  "null": "bold",
  "string": "green",
  "date": "magenta",
  // "name": intentionally not styling
  "regexp": "red"
};
function stylizeWithColor2(str, styleType) {
  var style = inspect$12.styles[styleType];
  if (style) {
    return "\x1B[" + inspect$12.colors[style][0] + "m" + str + "\x1B[" + inspect$12.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor2(str, styleType) {
  return str;
}
function arrayToHash2(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue2(ctx, value2, recurseTimes) {
  if (ctx.customInspect && value2 && isFunction2(value2.inspect) && // Filter out the util module, it's inspect function is special
  value2.inspect !== inspect$12 && // Also filter out any prototype objects using the circular check.
  !(value2.constructor && value2.constructor.prototype === value2)) {
    var ret = value2.inspect(recurseTimes, ctx);
    if (!isString2(ret)) {
      ret = formatValue2(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive2(ctx, value2);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value2);
  var visibleKeys = arrayToHash2(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value2);
  }
  if (isError2(value2) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError2(value2);
  }
  if (keys2.length === 0) {
    if (isFunction2(value2)) {
      var name2 = value2.name ? ": " + value2.name : "";
      return ctx.stylize("[Function" + name2 + "]", "special");
    }
    if (isRegExp2(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    }
    if (isDate2(value2)) {
      return ctx.stylize(Date.prototype.toString.call(value2), "date");
    }
    if (isError2(value2)) {
      return formatError2(value2);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray2(value2)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction2(value2)) {
    var n = value2.name ? ": " + value2.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp2(value2)) {
    base = " " + RegExp.prototype.toString.call(value2);
  }
  if (isDate2(value2)) {
    base = " " + Date.prototype.toUTCString.call(value2);
  }
  if (isError2(value2)) {
    base = " " + formatError2(value2);
  }
  if (keys2.length === 0 && (!array || value2.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp2(value2)) {
      return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value2);
  var output;
  if (array) {
    output = formatArray2(ctx, value2, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty2(ctx, value2, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString2(output, base, braces);
}
function formatPrimitive2(ctx, value2) {
  if (isUndefined2(value2))
    return ctx.stylize("undefined", "undefined");
  if (isString2(value2)) {
    var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber2(value2))
    return ctx.stylize("" + value2, "number");
  if (isBoolean2(value2))
    return ctx.stylize("" + value2, "boolean");
  if (isNull2(value2))
    return ctx.stylize("null", "null");
}
function formatError2(value2) {
  return "[" + Error.prototype.toString.call(value2) + "]";
}
function formatArray2(ctx, value2, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i = 0, l2 = value2.length; i < l2; ++i) {
    if (hasOwnProperty2(value2, String(i))) {
      output.push(formatProperty2(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        String(i),
        true
      ));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty2(
        ctx,
        value2,
        recurseTimes,
        visibleKeys,
        key,
        true
      ));
    }
  });
  return output;
}
function formatProperty2(ctx, value2, recurseTimes, visibleKeys, key, array) {
  var name2, str, desc;
  desc = Object.getOwnPropertyDescriptor(value2, key) || { value: value2[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty2(visibleKeys, key)) {
    name2 = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull2(recurseTimes)) {
        str = formatValue2(ctx, desc.value, null);
      } else {
        str = formatValue2(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line2) {
            return "  " + line2;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line2) {
            return "   " + line2;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined2(name2)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name2 = JSON.stringify("" + key);
    if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name2 = name2.substr(1, name2.length - 2);
      name2 = ctx.stylize(name2, "name");
    } else {
      name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name2 = ctx.stylize(name2, "string");
    }
  }
  return name2 + ": " + str;
}
function reduceToSingleString2(output, base, braces) {
  var length4 = output.reduce(function(prev, cur) {
    if (cur.indexOf("\n") >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length4 > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray2(ar) {
  return Array.isArray(ar);
}
function isBoolean2(arg) {
  return typeof arg === "boolean";
}
function isNull2(arg) {
  return arg === null;
}
function isNullOrUndefined2(arg) {
  return arg == null;
}
function isNumber2(arg) {
  return typeof arg === "number";
}
function isString2(arg) {
  return typeof arg === "string";
}
function isSymbol2(arg) {
  return typeof arg === "symbol";
}
function isUndefined2(arg) {
  return arg === void 0;
}
function isRegExp2(re) {
  return isObject2(re) && objectToString2(re) === "[object RegExp]";
}
function isObject2(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate2(d) {
  return isObject2(d) && objectToString2(d) === "[object Date]";
}
function isError2(e) {
  return isObject2(e) && (objectToString2(e) === "[object Error]" || e instanceof Error);
}
function isFunction2(arg) {
  return typeof arg === "function";
}
function isPrimitive2(arg) {
  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
  typeof arg === "undefined";
}
function isBuffer2(maybeBuf) {
  return Buffer$2.isBuffer(maybeBuf);
}
function objectToString2(o) {
  return Object.prototype.toString.call(o);
}
function pad$1(n) {
  return n < 10 ? "0" + n.toString(10) : n.toString(10);
}
var months2 = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function timestamp2() {
  var d = /* @__PURE__ */ new Date();
  var time = [
    pad$1(d.getHours()),
    pad$1(d.getMinutes()),
    pad$1(d.getSeconds())
  ].join(":");
  return [d.getDate(), months2[d.getMonth()], time].join(" ");
}
function log2() {
  console.log("%s - %s", timestamp2(), format2.apply(null, arguments));
}
function _extend2(origin, add3) {
  if (!add3 || !isObject2(add3)) return origin;
  var keys2 = Object.keys(add3);
  var i = keys2.length;
  while (i--) {
    origin[keys2[i]] = add3[keys2[i]];
  }
  return origin;
}
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol2 = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
function promisify2(original) {
  if (typeof original !== "function")
    throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol2 && original[kCustomPromisifiedSymbol2]) {
    var fn = original[kCustomPromisifiedSymbol2];
    if (typeof fn !== "function") {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol2, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }
  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function(resolve3, reject) {
      promiseResolve = resolve3;
      promiseReject = reject;
    });
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function(err2, value2) {
      if (err2) {
        promiseReject(err2);
      } else {
        promiseResolve(value2);
      }
    });
    try {
      original.apply(this, args);
    } catch (err2) {
      promiseReject(err2);
    }
    return promise;
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol2) Object.defineProperty(fn, kCustomPromisifiedSymbol2, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors3(original)
  );
}
promisify2.custom = kCustomPromisifiedSymbol2;
function callbackifyOnRejected2(reason, cb) {
  if (!reason) {
    var newReason = new Error("Promise was rejected with a falsy value");
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
function callbackify2(original) {
  if (typeof original !== "function") {
    throw new TypeError('The "original" argument must be of type Function');
  }
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    var maybeCb = args.pop();
    if (typeof maybeCb !== "function") {
      throw new TypeError("The last argument must be of type Function");
    }
    var self2 = this;
    var cb = function() {
      return maybeCb.apply(self2, arguments);
    };
    original.apply(this, args).then(
      function(ret) {
        browser$1$1.nextTick(cb.bind(null, null, ret));
      },
      function(rej) {
        browser$1$1.nextTick(callbackifyOnRejected2.bind(null, rej, cb));
      }
    );
  }
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors3(original));
  return callbackified;
}
var _polyfillNode_util2 = {
  inherits: inherits$3,
  _extend: _extend2,
  log: log2,
  isBuffer: isBuffer2,
  isPrimitive: isPrimitive2,
  isFunction: isFunction2,
  isError: isError2,
  isDate: isDate2,
  isObject: isObject2,
  isRegExp: isRegExp2,
  isUndefined: isUndefined2,
  isSymbol: isSymbol2,
  isString: isString2,
  isNumber: isNumber2,
  isNullOrUndefined: isNullOrUndefined2,
  isNull: isNull2,
  isBoolean: isBoolean2,
  isArray: isArray2,
  inspect: inspect$12,
  deprecate: deprecate$1,
  format: format2,
  debuglog: debuglog2,
  promisify: promisify2,
  callbackify: callbackify2
};
var _polyfillNode_util$12 = Object.freeze({
  __proto__: null,
  _extend: _extend2,
  callbackify: callbackify2,
  debuglog: debuglog2,
  default: _polyfillNode_util2,
  deprecate: deprecate$1,
  format: format2,
  inherits: inherits$3,
  inspect: inspect$12,
  isArray: isArray2,
  isBoolean: isBoolean2,
  isBuffer: isBuffer2,
  isDate: isDate2,
  isError: isError2,
  isFunction: isFunction2,
  isNull: isNull2,
  isNullOrUndefined: isNullOrUndefined2,
  isNumber: isNumber2,
  isObject: isObject2,
  isPrimitive: isPrimitive2,
  isRegExp: isRegExp2,
  isString: isString2,
  isSymbol: isSymbol2,
  isUndefined: isUndefined2,
  log: log2,
  promisify: promisify2
});
var require$$32 = getAugmentedNamespace2(_polyfillNode_util$12);
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties2(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties2(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties2(Constructor, staticProps);
    return Constructor;
  }
  var _require2 = require$$02, Buffer5 = _require2.Buffer;
  var _require22 = require$$32, inspect6 = _require22.inspect;
  var custom = inspect6 && inspect6.custom || "inspect";
  function copyBuffer(src, target, offset3) {
    Buffer5.prototype.copy.call(src, target, offset3);
  }
  buffer_list = function() {
    function BufferList3() {
      _classCallCheck(this, BufferList3);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass2(BufferList3, [{
      key: "push",
      value: function push(v2) {
        var entry = {
          data: v2,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v2) {
        var entry = {
          data: v2,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s2) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s2 + p.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat6(n) {
        if (this.length === 0) return Buffer5.alloc(0);
        var ret = Buffer5.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c2 = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c2;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer5.allocUnsafe(n);
        var p = this.head;
        var c2 = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c2;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value2(_, options) {
        return inspect6(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList3;
  }();
  return buffer_list;
}
function destroy(err2, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err2);
    } else if (err2) {
      if (!this._writableState) {
        browser$1$1.nextTick(emitErrorNT, this, err2);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        browser$1$1.nextTick(emitErrorNT, this, err2);
      }
    }
    return this;
  }
  if (this._readableState) {
    this._readableState.destroyed = true;
  }
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err2 || null, function(err3) {
    if (!cb && err3) {
      if (!_this._writableState) {
        browser$1$1.nextTick(emitErrorAndCloseNT, _this, err3);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        browser$1$1.nextTick(emitErrorAndCloseNT, _this, err3);
      } else {
        browser$1$1.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      browser$1$1.nextTick(emitCloseNT, _this);
      cb(err3);
    } else {
      browser$1$1.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self2, err2) {
  emitErrorNT(self2, err2);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  if (self2._writableState && !self2._writableState.emitClose) return;
  if (self2._readableState && !self2._readableState.emitClose) return;
  self2.emit("close");
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self2, err2) {
  self2.emit("error", err2);
}
function errorOrDestroy$2(stream2, err2) {
  var rState = stream2._readableState;
  var wState = stream2._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream2.destroy(err2);
  else stream2.emit("error", err2);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy: errorOrDestroy$2
};
var errorsBrowser = {};
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code, message, Base2) {
  if (!Base2) {
    Base2 = Error;
  }
  function getMessage3(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = function(_Base) {
    _inheritsLoose2(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      return _Base.call(this, getMessage3(arg1, arg2, arg3)) || this;
    }
    return NodeError2;
  }(Base2);
  NodeError.prototype.name = Base2.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
}
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function(i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
function endsWith(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function includes3(str, search, start3) {
  if (typeof start3 !== "number") {
    start3 = 0;
  }
  if (start3 + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start3) !== -1;
  }
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value2) {
  return 'The value "' + value2 + '" is invalid for option "' + name2 + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
  var determiner;
  if (typeof expected === "string" && startsWith(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg2;
  if (endsWith(name2, " argument")) {
    msg2 = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  } else {
    var type2 = includes3(name2, ".") ? "property" : "argument";
    msg2 = 'The "'.concat(name2, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  }
  msg2 += ". Received type ".concat(typeof actual);
  return msg2;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
  return "The " + name2 + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name2) {
  return "Cannot call " + name2 + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
  return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark$2(state2, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name2 = isDuplex ? duplexKey : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(name2, hwm);
    }
    return Math.floor(hwm);
  }
  return state2.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark: getHighWaterMark$2
};
var inherits2;
if (typeof Object.create === "function") {
  inherits2 = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits2 = function inherits3(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$12 = inherits2;
var _polyfillNode_inherits = Object.freeze({
  __proto__: null,
  default: inherits$12
});
var require$$12 = getAugmentedNamespace2(_polyfillNode_inherits);
var isBufferEncoding2 = Buffer$2.isEncoding || function(encoding) {
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function assertEncoding2(encoding) {
  if (encoding && !isBufferEncoding2(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder$1(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding2(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar2;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar2;
      break;
    default:
      this.write = passThroughWrite2;
      return;
  }
  this.charBuffer = new Buffer$2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
StringDecoder$1.prototype.write = function(buffer) {
  var charStr = "";
  while (this.charLength) {
    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;
    if (this.charReceived < this.charLength) {
      return "";
    }
    buffer = buffer.slice(available, buffer.length);
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 55296 && charCode <= 56319) {
      this.charLength += this.surrogateSize;
      charStr = "";
      continue;
    }
    this.charReceived = this.charLength = 0;
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }
  this.detectIncompleteChar(buffer);
  var end3 = buffer.length;
  if (this.charLength) {
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end3);
    end3 -= this.charReceived;
  }
  charStr += buffer.toString(this.encoding, 0, end3);
  var end3 = charStr.length - 1;
  var charCode = charStr.charCodeAt(end3);
  if (charCode >= 55296 && charCode <= 56319) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end3);
  }
  return charStr;
};
StringDecoder$1.prototype.detectIncompleteChar = function(buffer) {
  var i = buffer.length >= 3 ? 3 : buffer.length;
  for (; i > 0; i--) {
    var c2 = buffer[buffer.length - i];
    if (i == 1 && c2 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (i <= 2 && c2 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (i <= 3 && c2 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};
StringDecoder$1.prototype.end = function(buffer) {
  var res = "";
  if (buffer && buffer.length)
    res = this.write(buffer);
  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }
  return res;
};
function passThroughWrite2(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar2(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar2(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var _polyfillNode_string_decoder = Object.freeze({
  __proto__: null,
  StringDecoder: StringDecoder$1
});
var require$$10 = getAugmentedNamespace2(_polyfillNode_string_decoder);
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(callback) {
  var called = false;
  return function() {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop$1() {
}
function isRequest$1(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function eos$1(stream2, opts2, callback) {
  if (typeof opts2 === "function") return eos$1(stream2, null, opts2);
  if (!opts2) opts2 = {};
  callback = once$1(callback || noop$1);
  var readable = opts2.readable || opts2.readable !== false && stream2.readable;
  var writable = opts2.writable || opts2.writable !== false && stream2.writable;
  var onlegacyfinish = function onlegacyfinish2() {
    if (!stream2.writable) onfinish();
  };
  var writableEnded = stream2._writableState && stream2._writableState.finished;
  var onfinish = function onfinish2() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream2);
  };
  var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
  var onend3 = function onend4() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream2);
  };
  var onerror = function onerror2(err2) {
    callback.call(stream2, err2);
  };
  var onclose = function onclose2() {
    var err2;
    if (readable && !readableEnded) {
      if (!stream2._readableState || !stream2._readableState.ended) err2 = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err2);
    }
    if (writable && !writableEnded) {
      if (!stream2._writableState || !stream2._writableState.ended) err2 = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err2);
    }
  };
  var onrequest = function onrequest2() {
    stream2.req.on("finish", onfinish);
  };
  if (isRequest$1(stream2)) {
    stream2.on("complete", onfinish);
    stream2.on("abort", onclose);
    if (stream2.req) onrequest();
    else stream2.on("request", onrequest);
  } else if (writable && !stream2._writableState) {
    stream2.on("end", onlegacyfinish);
    stream2.on("close", onlegacyfinish);
  }
  stream2.on("end", onend3);
  stream2.on("finish", onfinish);
  if (opts2.error !== false) stream2.on("error", onerror);
  stream2.on("close", onclose);
  return function() {
    stream2.removeListener("complete", onfinish);
    stream2.removeListener("abort", onclose);
    stream2.removeListener("request", onrequest);
    if (stream2.req) stream2.req.removeListener("finish", onfinish);
    stream2.removeListener("end", onlegacyfinish);
    stream2.removeListener("close", onlegacyfinish);
    stream2.removeListener("finish", onfinish);
    stream2.removeListener("end", onend3);
    stream2.removeListener("error", onerror);
    stream2.removeListener("close", onclose);
  };
}
var endOfStream = eos$1;
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  var finished = endOfStream;
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value2, done3) {
    return {
      value: value2,
      done: done3
    };
  }
  function readAndResolve(iter) {
    var resolve3 = iter[kLastResolve];
    if (resolve3 !== null) {
      var data2 = iter[kStream].read();
      if (data2 !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve3(createIterResult(data2, false));
      }
    }
  }
  function onReadable(iter) {
    browser$1$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve3, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve3(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve3, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve3, reject) {
          browser$1$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve3(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data2 = this[kStream].read();
        if (data2 !== null) {
          return Promise.resolve(createIterResult(data2, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve3, reject) {
      _this2[kStream].destroy(null, function(err2) {
        if (err2) {
          reject(err2);
          return;
        }
        resolve3(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator2 = function createReadableStreamAsyncIterator3(stream2) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream2,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value2(resolve3, reject) {
        var data2 = iterator[kStream].read();
        if (data2) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve3(createIterResult(data2, false));
        } else {
          iterator[kLastResolve] = resolve3;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream2, function(err2) {
      if (err2 && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err2);
        }
        iterator[kError] = err2;
        return;
      }
      var resolve3 = iterator[kLastResolve];
      if (resolve3 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve3(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream2.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator2;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser) return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function fromBrowser2() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var Registry$4 = _registry;
Registry$4.Readable = Readable2;
Readable2.ReadableState = ReadableState2;
require$$1$1.EventEmitter;
var EElistenerCount = function EElistenerCount2(emitter, type2) {
  return emitter.listeners(type2).length;
};
var Stream$1 = streamBrowser;
var Buffer$1 = require$$02.Buffer;
var OurUint8Array$1 = commonjsGlobal.Uint8Array || function() {
};
function _uint8ArrayToBuffer$1(chunk) {
  return Buffer$1.from(chunk);
}
function _isUint8Array$1(obj) {
  return Buffer$1.isBuffer(obj) || obj instanceof OurUint8Array$1;
}
var debugUtil = require$$32;
var debug2;
if (debugUtil && debugUtil.debuglog) {
  debug2 = debugUtil.debuglog("stream");
} else {
  debug2 = function debug3() {
  };
}
var BufferList2 = requireBuffer_list();
var destroyImpl$1 = destroy_1;
var _require$1 = state;
var getHighWaterMark$1 = _require$1.getHighWaterMark;
var _require$codes$3 = errorsBrowser.codes;
var ERR_INVALID_ARG_TYPE$1 = _require$codes$3.ERR_INVALID_ARG_TYPE;
var ERR_STREAM_PUSH_AFTER_EOF = _require$codes$3.ERR_STREAM_PUSH_AFTER_EOF;
var ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$3.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
var StringDecoder2;
var createReadableStreamAsyncIterator;
var from2;
require$$12(Readable2, Stream$1);
var errorOrDestroy$1 = destroyImpl$1.errorOrDestroy;
var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
function prependListener4(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
  else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
  else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState2(options, stream2, isDuplex) {
  options = options || {};
  if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Registry$4.Duplex;
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
  this.highWaterMark = getHighWaterMark$1(this, options, "readableHighWaterMark", isDuplex);
  this.buffer = new BufferList2();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;
  this.emitClose = options.emitClose !== false;
  this.autoDestroy = !!options.autoDestroy;
  this.destroyed = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder2) StringDecoder2 = require$$10.StringDecoder;
    this.decoder = new StringDecoder2(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable2(options) {
  if (!(this instanceof Readable2)) return new Readable2(options);
  var isDuplex = this instanceof Registry$4.Duplex;
  this._readableState = new ReadableState2(options, this, isDuplex);
  this.readable = true;
  if (options) {
    if (typeof options.read === "function") this._read = options.read;
    if (typeof options.destroy === "function") this._destroy = options.destroy;
  }
  Stream$1.call(this);
}
Object.defineProperty(Readable2.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get3() {
    if (this._readableState === void 0) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value2) {
    if (!this._readableState) {
      return;
    }
    this._readableState.destroyed = value2;
  }
});
Readable2.prototype.destroy = destroyImpl$1.destroy;
Readable2.prototype._undestroy = destroyImpl$1.undestroy;
Readable2.prototype._destroy = function(err2, cb) {
  cb(err2);
};
Readable2.prototype.push = function(chunk, encoding) {
  var state2 = this._readableState;
  var skipChunkCheck;
  if (!state2.objectMode) {
    if (typeof chunk === "string") {
      encoding = encoding || state2.defaultEncoding;
      if (encoding !== state2.encoding) {
        chunk = Buffer$1.from(chunk, encoding);
        encoding = "";
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
};
Readable2.prototype.unshift = function(chunk) {
  return readableAddChunk2(this, chunk, null, true, false);
};
function readableAddChunk2(stream2, chunk, encoding, addToFront, skipChunkCheck) {
  debug2("readableAddChunk", chunk);
  var state2 = stream2._readableState;
  if (chunk === null) {
    state2.reading = false;
    onEofChunk2(stream2, state2);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid2(state2, chunk);
    if (er) {
      errorOrDestroy$1(stream2, er);
    } else if (state2.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer$1.prototype) {
        chunk = _uint8ArrayToBuffer$1(chunk);
      }
      if (addToFront) {
        if (state2.endEmitted) errorOrDestroy$1(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
        else addChunk(stream2, state2, chunk, true);
      } else if (state2.ended) {
        errorOrDestroy$1(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state2.destroyed) {
        return false;
      } else {
        state2.reading = false;
        if (state2.decoder && !encoding) {
          chunk = state2.decoder.write(chunk);
          if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
          else maybeReadMore2(stream2, state2);
        } else {
          addChunk(stream2, state2, chunk, false);
        }
      }
    } else if (!addToFront) {
      state2.reading = false;
      maybeReadMore2(stream2, state2);
    }
  }
  return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
}
function addChunk(stream2, state2, chunk, addToFront) {
  if (state2.flowing && state2.length === 0 && !state2.sync) {
    state2.awaitDrain = 0;
    stream2.emit("data", chunk);
  } else {
    state2.length += state2.objectMode ? 1 : chunk.length;
    if (addToFront) state2.buffer.unshift(chunk);
    else state2.buffer.push(chunk);
    if (state2.needReadable) emitReadable2(stream2);
  }
  maybeReadMore2(stream2, state2);
}
function chunkInvalid2(state2, chunk) {
  var er;
  if (!_isUint8Array$1(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
    er = new ERR_INVALID_ARG_TYPE$1("chunk", ["string", "Buffer", "Uint8Array"], chunk);
  }
  return er;
}
Readable2.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
Readable2.prototype.setEncoding = function(enc) {
  if (!StringDecoder2) StringDecoder2 = require$$10.StringDecoder;
  var decoder2 = new StringDecoder2(enc);
  this._readableState.decoder = decoder2;
  this._readableState.encoding = this._readableState.decoder.encoding;
  var p = this._readableState.buffer.head;
  var content = "";
  while (p !== null) {
    content += decoder2.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== "") this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};
var MAX_HWM2 = 1073741824;
function computeNewHighWaterMark2(n) {
  if (n >= MAX_HWM2) {
    n = MAX_HWM2;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead2(n, state2) {
  if (n <= 0 || state2.length === 0 && state2.ended) return 0;
  if (state2.objectMode) return 1;
  if (n !== n) {
    if (state2.flowing && state2.length) return state2.buffer.head.data.length;
    else return state2.length;
  }
  if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark2(n);
  if (n <= state2.length) return n;
  if (!state2.ended) {
    state2.needReadable = true;
    return 0;
  }
  return state2.length;
}
Readable2.prototype.read = function(n) {
  debug2("read", n);
  n = parseInt(n, 10);
  var state2 = this._readableState;
  var nOrig = n;
  if (n !== 0) state2.emittedReadable = false;
  if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
    debug2("read: emitReadable", state2.length, state2.ended);
    if (state2.length === 0 && state2.ended) endReadable2(this);
    else emitReadable2(this);
    return null;
  }
  n = howMuchToRead2(n, state2);
  if (n === 0 && state2.ended) {
    if (state2.length === 0) endReadable2(this);
    return null;
  }
  var doRead = state2.needReadable;
  debug2("need readable", doRead);
  if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
    doRead = true;
    debug2("length less than watermark", doRead);
  }
  if (state2.ended || state2.reading) {
    doRead = false;
    debug2("reading or ended", doRead);
  } else if (doRead) {
    debug2("do read");
    state2.reading = true;
    state2.sync = true;
    if (state2.length === 0) state2.needReadable = true;
    this._read(state2.highWaterMark);
    state2.sync = false;
    if (!state2.reading) n = howMuchToRead2(nOrig, state2);
  }
  var ret;
  if (n > 0) ret = fromList2(n, state2);
  else ret = null;
  if (ret === null) {
    state2.needReadable = state2.length <= state2.highWaterMark;
    n = 0;
  } else {
    state2.length -= n;
    state2.awaitDrain = 0;
  }
  if (state2.length === 0) {
    if (!state2.ended) state2.needReadable = true;
    if (nOrig !== n && state2.ended) endReadable2(this);
  }
  if (ret !== null) this.emit("data", ret);
  return ret;
};
function onEofChunk2(stream2, state2) {
  debug2("onEofChunk");
  if (state2.ended) return;
  if (state2.decoder) {
    var chunk = state2.decoder.end();
    if (chunk && chunk.length) {
      state2.buffer.push(chunk);
      state2.length += state2.objectMode ? 1 : chunk.length;
    }
  }
  state2.ended = true;
  if (state2.sync) {
    emitReadable2(stream2);
  } else {
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      state2.emittedReadable = true;
      emitReadable_2(stream2);
    }
  }
}
function emitReadable2(stream2) {
  var state2 = stream2._readableState;
  debug2("emitReadable", state2.needReadable, state2.emittedReadable);
  state2.needReadable = false;
  if (!state2.emittedReadable) {
    debug2("emitReadable", state2.flowing);
    state2.emittedReadable = true;
    browser$1$1.nextTick(emitReadable_2, stream2);
  }
}
function emitReadable_2(stream2) {
  var state2 = stream2._readableState;
  debug2("emitReadable_", state2.destroyed, state2.length, state2.ended);
  if (!state2.destroyed && (state2.length || state2.ended)) {
    stream2.emit("readable");
    state2.emittedReadable = false;
  }
  state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
  flow2(stream2);
}
function maybeReadMore2(stream2, state2) {
  if (!state2.readingMore) {
    state2.readingMore = true;
    browser$1$1.nextTick(maybeReadMore_2, stream2, state2);
  }
}
function maybeReadMore_2(stream2, state2) {
  while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
    var len = state2.length;
    debug2("maybeReadMore read 0");
    stream2.read(0);
    if (len === state2.length)
      break;
  }
  state2.readingMore = false;
}
Readable2.prototype._read = function(n) {
  errorOrDestroy$1(this, new ERR_METHOD_NOT_IMPLEMENTED$2("_read()"));
};
Readable2.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state2 = this._readableState;
  switch (state2.pipesCount) {
    case 0:
      state2.pipes = dest;
      break;
    case 1:
      state2.pipes = [state2.pipes, dest];
      break;
    default:
      state2.pipes.push(dest);
      break;
  }
  state2.pipesCount += 1;
  debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== browser$1$1.stdout && dest !== browser$1$1.stderr;
  var endFn = doEnd ? onend3 : unpipe;
  if (state2.endEmitted) browser$1$1.nextTick(endFn);
  else src.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug2("onunpipe");
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend3() {
    debug2("onend");
    dest.end();
  }
  var ondrain = pipeOnDrain2(src);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug2("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src.removeListener("end", onend3);
    src.removeListener("end", unpipe);
    src.removeListener("data", ondata);
    cleanedUp = true;
    if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on("data", ondata);
  function ondata(chunk) {
    debug2("ondata");
    var ret = dest.write(chunk);
    debug2("dest.write", ret);
    if (ret === false) {
      if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf4(state2.pipes, dest) !== -1) && !cleanedUp) {
        debug2("false write response, pause", state2.awaitDrain);
        state2.awaitDrain++;
      }
      src.pause();
    }
  }
  function onerror(er) {
    debug2("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (EElistenerCount(dest, "error") === 0) errorOrDestroy$1(dest, er);
  }
  prependListener4(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug2("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug2("unpipe");
    src.unpipe(dest);
  }
  dest.emit("pipe", src);
  if (!state2.flowing) {
    debug2("pipe resume");
    src.resume();
  }
  return dest;
};
function pipeOnDrain2(src) {
  return function pipeOnDrainFunctionResult() {
    var state2 = src._readableState;
    debug2("pipeOnDrain", state2.awaitDrain);
    if (state2.awaitDrain) state2.awaitDrain--;
    if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
      state2.flowing = true;
      flow2(src);
    }
  };
}
Readable2.prototype.unpipe = function(dest) {
  var state2 = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };
  if (state2.pipesCount === 0) return this;
  if (state2.pipesCount === 1) {
    if (dest && dest !== state2.pipes) return this;
    if (!dest) dest = state2.pipes;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    if (dest) dest.emit("unpipe", this, unpipeInfo);
    return this;
  }
  if (!dest) {
    var dests = state2.pipes;
    var len = state2.pipesCount;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    for (var i = 0; i < len; i++) {
      dests[i].emit("unpipe", this, {
        hasUnpiped: false
      });
    }
    return this;
  }
  var index2 = indexOf4(state2.pipes, dest);
  if (index2 === -1) return this;
  state2.pipes.splice(index2, 1);
  state2.pipesCount -= 1;
  if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
  dest.emit("unpipe", this, unpipeInfo);
  return this;
};
Readable2.prototype.on = function(ev, fn) {
  var res = Stream$1.prototype.on.call(this, ev, fn);
  var state2 = this._readableState;
  if (ev === "data") {
    state2.readableListening = this.listenerCount("readable") > 0;
    if (state2.flowing !== false) this.resume();
  } else if (ev === "readable") {
    if (!state2.endEmitted && !state2.readableListening) {
      state2.readableListening = state2.needReadable = true;
      state2.flowing = false;
      state2.emittedReadable = false;
      debug2("on readable", state2.length, state2.reading);
      if (state2.length) {
        emitReadable2(this);
      } else if (!state2.reading) {
        browser$1$1.nextTick(nReadingNextTick2, this);
      }
    }
  }
  return res;
};
Readable2.prototype.addListener = Readable2.prototype.on;
Readable2.prototype.removeListener = function(ev, fn) {
  var res = Stream$1.prototype.removeListener.call(this, ev, fn);
  if (ev === "readable") {
    browser$1$1.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable2.prototype.removeAllListeners = function(ev) {
  var res = Stream$1.prototype.removeAllListeners.apply(this, arguments);
  if (ev === "readable" || ev === void 0) {
    browser$1$1.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self2) {
  var state2 = self2._readableState;
  state2.readableListening = self2.listenerCount("readable") > 0;
  if (state2.resumeScheduled && !state2.paused) {
    state2.flowing = true;
  } else if (self2.listenerCount("data") > 0) {
    self2.resume();
  }
}
function nReadingNextTick2(self2) {
  debug2("readable nexttick read 0");
  self2.read(0);
}
Readable2.prototype.resume = function() {
  var state2 = this._readableState;
  if (!state2.flowing) {
    debug2("resume");
    state2.flowing = !state2.readableListening;
    resume2(this, state2);
  }
  state2.paused = false;
  return this;
};
function resume2(stream2, state2) {
  if (!state2.resumeScheduled) {
    state2.resumeScheduled = true;
    browser$1$1.nextTick(resume_2, stream2, state2);
  }
}
function resume_2(stream2, state2) {
  debug2("resume", state2.reading);
  if (!state2.reading) {
    stream2.read(0);
  }
  state2.resumeScheduled = false;
  stream2.emit("resume");
  flow2(stream2);
  if (state2.flowing && !state2.reading) stream2.read(0);
}
Readable2.prototype.pause = function() {
  debug2("call pause flowing=%j", this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug2("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  this._readableState.paused = true;
  return this;
};
function flow2(stream2) {
  var state2 = stream2._readableState;
  debug2("flow", state2.flowing);
  while (state2.flowing && stream2.read() !== null) {
  }
}
Readable2.prototype.wrap = function(stream2) {
  var _this = this;
  var state2 = this._readableState;
  var paused = false;
  stream2.on("end", function() {
    debug2("wrapped end");
    if (state2.decoder && !state2.ended) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream2.on("data", function(chunk) {
    debug2("wrapped data");
    if (state2.decoder) chunk = state2.decoder.write(chunk);
    if (state2.objectMode && (chunk === null || chunk === void 0)) return;
    else if (!state2.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i in stream2) {
    if (this[i] === void 0 && typeof stream2[i] === "function") {
      this[i] = /* @__PURE__ */ function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i);
    }
  }
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }
  this._read = function(n2) {
    debug2("wrapped _read", n2);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return this;
};
if (typeof Symbol === "function") {
  Readable2.prototype[Symbol.asyncIterator] = function() {
    if (createReadableStreamAsyncIterator === void 0) {
      createReadableStreamAsyncIterator = requireAsync_iterator();
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get4() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable2.prototype, "readableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get5() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable2.prototype, "readableFlowing", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get6() {
    return this._readableState.flowing;
  },
  set: function set2(state2) {
    if (this._readableState) {
      this._readableState.flowing = state2;
    }
  }
});
Readable2._fromList = fromList2;
Object.defineProperty(Readable2.prototype, "readableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get7() {
    return this._readableState.length;
  }
});
function fromList2(n, state2) {
  if (state2.length === 0) return null;
  var ret;
  if (state2.objectMode) ret = state2.buffer.shift();
  else if (!n || n >= state2.length) {
    if (state2.decoder) ret = state2.buffer.join("");
    else if (state2.buffer.length === 1) ret = state2.buffer.first();
    else ret = state2.buffer.concat(state2.length);
    state2.buffer.clear();
  } else {
    ret = state2.buffer.consume(n, state2.decoder);
  }
  return ret;
}
function endReadable2(stream2) {
  var state2 = stream2._readableState;
  debug2("endReadable", state2.endEmitted);
  if (!state2.endEmitted) {
    state2.ended = true;
    browser$1$1.nextTick(endReadableNT2, state2, stream2);
  }
}
function endReadableNT2(state2, stream2) {
  debug2("endReadableNT", state2.endEmitted, state2.length);
  if (!state2.endEmitted && state2.length === 0) {
    state2.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
    if (state2.autoDestroy) {
      var wState = stream2._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream2.destroy();
      }
    }
  }
}
if (typeof Symbol === "function") {
  Readable2.from = function(iterable, opts2) {
    if (from2 === void 0) {
      from2 = requireFromBrowser();
    }
    return from2(Readable2, iterable, opts2);
  };
}
function indexOf4(xs, x) {
  for (var i = 0, l2 = xs.length; i < l2; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
var browser2 = deprecate2;
function deprecate2(fn, msg2) {
  if (config2("noDeprecation")) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config2("throwDeprecation")) {
        throw new Error(msg2);
      } else if (config2("traceDeprecation")) {
        console.trace(msg2);
      } else {
        console.warn(msg2);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function config2(name2) {
  try {
    if (!commonjsGlobal.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = commonjsGlobal.localStorage[name2];
  if (null == val) return false;
  return String(val).toLowerCase() === "true";
}
var Registry$3 = _registry;
Registry$3.Writable = Writable2;
function CorkedRequest2(state2) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function() {
    onCorkedFinish(_this, state2);
  };
}
Writable2.WritableState = WritableState2;
var internalUtil = {
  deprecate: browser2
};
var Stream2 = streamBrowser;
var Buffer3 = require$$02.Buffer;
var OurUint8Array = commonjsGlobal.Uint8Array || function() {
};
function _uint8ArrayToBuffer(chunk) {
  return Buffer3.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = destroy_1;
var _require = state;
var getHighWaterMark = _require.getHighWaterMark;
var _require$codes$2 = errorsBrowser.codes;
var ERR_INVALID_ARG_TYPE = _require$codes$2.ERR_INVALID_ARG_TYPE;
var ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_MULTIPLE_CALLBACK$1 = _require$codes$2.ERR_MULTIPLE_CALLBACK;
var ERR_STREAM_CANNOT_PIPE = _require$codes$2.ERR_STREAM_CANNOT_PIPE;
var ERR_STREAM_DESTROYED$1 = _require$codes$2.ERR_STREAM_DESTROYED;
var ERR_STREAM_NULL_VALUES = _require$codes$2.ERR_STREAM_NULL_VALUES;
var ERR_STREAM_WRITE_AFTER_END = _require$codes$2.ERR_STREAM_WRITE_AFTER_END;
var ERR_UNKNOWN_ENCODING = _require$codes$2.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require$$12(Writable2, Stream2);
function nop2() {
}
function WritableState2(options, stream2, isDuplex) {
  options = options || {};
  if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Registry$3.Duplex;
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
  this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
  this.finalCalled = false;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  this.destroyed = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite2(stream2, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.emitClose = options.emitClose !== false;
  this.autoDestroy = !!options.autoDestroy;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest2(this);
}
WritableState2.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function() {
  try {
    Object.defineProperty(WritableState2.prototype, "buffer", {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
    });
  } catch (_) {
  }
})();
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable2, Symbol.hasInstance, {
    value: function value2(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable2) return false;
      return object && object._writableState instanceof WritableState2;
    }
  });
} else {
  realHasInstance = function realHasInstance2(object) {
    return object instanceof this;
  };
}
function Writable2(options) {
  var isDuplex = this instanceof Registry$3.Duplex;
  if (!isDuplex && !realHasInstance.call(Writable2, this)) return new Writable2(options);
  this._writableState = new WritableState2(options, this, isDuplex);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function") this._write = options.write;
    if (typeof options.writev === "function") this._writev = options.writev;
    if (typeof options.destroy === "function") this._destroy = options.destroy;
    if (typeof options.final === "function") this._final = options.final;
  }
  Stream2.call(this);
}
Writable2.prototype.pipe = function() {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd2(stream2, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  errorOrDestroy(stream2, er);
  browser$1$1.nextTick(cb, er);
}
function validChunk2(stream2, state2, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== "string" && !state2.objectMode) {
    er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
  }
  if (er) {
    errorOrDestroy(stream2, er);
    browser$1$1.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable2.prototype.write = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  var ret = false;
  var isBuf = !state2.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer3.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = "buffer";
  else if (!encoding) encoding = state2.defaultEncoding;
  if (typeof cb !== "function") cb = nop2;
  if (state2.ending) writeAfterEnd2(this, cb);
  else if (isBuf || validChunk2(this, state2, chunk, cb)) {
    state2.pendingcb++;
    ret = writeOrBuffer2(this, state2, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable2.prototype.cork = function() {
  this._writableState.corked++;
};
Writable2.prototype.uncork = function() {
  var state2 = this._writableState;
  if (state2.corked) {
    state2.corked--;
    if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer2(this, state2);
  }
};
Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
  if (typeof encoding === "string") encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable2.prototype, "writableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get8() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk2(state2, chunk, encoding) {
  if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer3.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get9() {
    return this._writableState.highWaterMark;
  }
});
function writeOrBuffer2(stream2, state2, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk2(state2, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = "buffer";
      chunk = newChunk;
    }
  }
  var len = state2.objectMode ? 1 : chunk.length;
  state2.length += len;
  var ret = state2.length < state2.highWaterMark;
  if (!ret) state2.needDrain = true;
  if (state2.writing || state2.corked) {
    var last3 = state2.lastBufferedRequest;
    state2.lastBufferedRequest = {
      chunk,
      encoding,
      isBuf,
      callback: cb,
      next: null
    };
    if (last3) {
      last3.next = state2.lastBufferedRequest;
    } else {
      state2.bufferedRequest = state2.lastBufferedRequest;
    }
    state2.bufferedRequestCount += 1;
  } else {
    doWrite2(stream2, state2, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite2(stream2, state2, writev, len, chunk, encoding, cb) {
  state2.writelen = len;
  state2.writecb = cb;
  state2.writing = true;
  state2.sync = true;
  if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED$1("write"));
  else if (writev) stream2._writev(chunk, state2.onwrite);
  else stream2._write(chunk, encoding, state2.onwrite);
  state2.sync = false;
}
function onwriteError2(stream2, state2, sync, er, cb) {
  --state2.pendingcb;
  if (sync) {
    browser$1$1.nextTick(cb, er);
    browser$1$1.nextTick(finishMaybe2, stream2, state2);
    stream2._writableState.errorEmitted = true;
    errorOrDestroy(stream2, er);
  } else {
    cb(er);
    stream2._writableState.errorEmitted = true;
    errorOrDestroy(stream2, er);
    finishMaybe2(stream2, state2);
  }
}
function onwriteStateUpdate2(state2) {
  state2.writing = false;
  state2.writecb = null;
  state2.length -= state2.writelen;
  state2.writelen = 0;
}
function onwrite2(stream2, er) {
  var state2 = stream2._writableState;
  var sync = state2.sync;
  var cb = state2.writecb;
  if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK$1();
  onwriteStateUpdate2(state2);
  if (er) onwriteError2(stream2, state2, sync, er, cb);
  else {
    var finished = needFinish2(state2) || stream2.destroyed;
    if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
      clearBuffer2(stream2, state2);
    }
    if (sync) {
      browser$1$1.nextTick(afterWrite2, stream2, state2, finished, cb);
    } else {
      afterWrite2(stream2, state2, finished, cb);
    }
  }
}
function afterWrite2(stream2, state2, finished, cb) {
  if (!finished) onwriteDrain2(stream2, state2);
  state2.pendingcb--;
  cb();
  finishMaybe2(stream2, state2);
}
function onwriteDrain2(stream2, state2) {
  if (state2.length === 0 && state2.needDrain) {
    state2.needDrain = false;
    stream2.emit("drain");
  }
}
function clearBuffer2(stream2, state2) {
  state2.bufferProcessing = true;
  var entry = state2.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l2 = state2.bufferedRequestCount;
    var buffer = new Array(l2);
    var holder = state2.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite2(stream2, state2, true, state2.length, buffer, "", holder.finish);
    state2.pendingcb++;
    state2.lastBufferedRequest = null;
    if (holder.next) {
      state2.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state2.corkedRequestsFree = new CorkedRequest2(state2);
    }
    state2.bufferedRequestCount = 0;
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state2.objectMode ? 1 : chunk.length;
      doWrite2(stream2, state2, false, len, chunk, encoding, cb);
      entry = entry.next;
      state2.bufferedRequestCount--;
      if (state2.writing) {
        break;
      }
    }
    if (entry === null) state2.lastBufferedRequest = null;
  }
  state2.bufferedRequest = entry;
  state2.bufferProcessing = false;
}
Writable2.prototype._write = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED$1("_write()"));
};
Writable2.prototype._writev = null;
Writable2.prototype.end = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
  if (state2.corked) {
    state2.corked = 1;
    this.uncork();
  }
  if (!state2.ending) endWritable2(this, state2, cb);
  return this;
};
Object.defineProperty(Writable2.prototype, "writableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get10() {
    return this._writableState.length;
  }
});
function needFinish2(state2) {
  return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
}
function callFinal(stream2, state2) {
  stream2._final(function(err2) {
    state2.pendingcb--;
    if (err2) {
      errorOrDestroy(stream2, err2);
    }
    state2.prefinished = true;
    stream2.emit("prefinish");
    finishMaybe2(stream2, state2);
  });
}
function prefinish$1(stream2, state2) {
  if (!state2.prefinished && !state2.finalCalled) {
    if (typeof stream2._final === "function" && !state2.destroyed) {
      state2.pendingcb++;
      state2.finalCalled = true;
      browser$1$1.nextTick(callFinal, stream2, state2);
    } else {
      state2.prefinished = true;
      stream2.emit("prefinish");
    }
  }
}
function finishMaybe2(stream2, state2) {
  var need = needFinish2(state2);
  if (need) {
    prefinish$1(stream2, state2);
    if (state2.pendingcb === 0) {
      state2.finished = true;
      stream2.emit("finish");
      if (state2.autoDestroy) {
        var rState = stream2._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream2.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable2(stream2, state2, cb) {
  state2.ending = true;
  finishMaybe2(stream2, state2);
  if (cb) {
    if (state2.finished) browser$1$1.nextTick(cb);
    else stream2.once("finish", cb);
  }
  state2.ended = true;
  stream2.writable = false;
}
function onCorkedFinish(corkReq, state2, err2) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state2.pendingcb--;
    cb(err2);
    entry = entry.next;
  }
  state2.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable2.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get11() {
    if (this._writableState === void 0) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set3(value2) {
    if (!this._writableState) {
      return;
    }
    this._writableState.destroyed = value2;
  }
});
Writable2.prototype.destroy = destroyImpl.destroy;
Writable2.prototype._undestroy = destroyImpl.undestroy;
Writable2.prototype._destroy = function(err2, cb) {
  cb(err2);
};
var objectKeys$1 = Object.keys || function(obj) {
  var keys2 = [];
  for (var key in obj) {
    keys2.push(key);
  }
  return keys2;
};
var Registry$2 = _registry;
Registry$2.Duplex = Duplex2;
require$$12(Duplex2, Registry$2.Readable);
{
  keys2 = objectKeys$1(Registry$2.Writable.prototype);
  for (v2 = 0; v2 < keys2.length; v2++) {
    method = keys2[v2];
    if (!Duplex2.prototype[method]) Duplex2.prototype[method] = Registry$2.Writable.prototype[method];
  }
}
var keys2;
var method;
var v2;
function Duplex2(options) {
  if (!(this instanceof Duplex2)) return new Duplex2(options);
  Registry$2.Readable.call(this, options);
  Registry$2.Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once("end", onend2);
    }
  }
}
Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get12() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex2.prototype, "writableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get13() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex2.prototype, "writableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get14() {
    return this._writableState.length;
  }
});
function onend2() {
  if (this._writableState.ended) return;
  browser$1$1.nextTick(onEndNT2, this);
}
function onEndNT2(self2) {
  self2.end();
}
Object.defineProperty(Duplex2.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get15() {
    if (this._readableState === void 0 || this._writableState === void 0) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set4(value2) {
    if (this._readableState === void 0 || this._writableState === void 0) {
      return;
    }
    this._readableState.destroyed = value2;
    this._writableState.destroyed = value2;
  }
});
var Registry$1 = _registry;
Registry$1.Transform = Transform$1;
var _require$codes$1 = errorsBrowser.codes;
var ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK;
var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING;
var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
require$$12(Transform$1, Registry$1.Duplex);
function afterTransform2(er, data2) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 != null)
    this.push(data2);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform$1(options) {
  if (!(this instanceof Transform$1)) return new Transform$1(options);
  Registry$1.Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform2.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function") this._transform = options.transform;
    if (typeof options.flush === "function") this._flush = options.flush;
  }
  this.on("prefinish", prefinish2);
}
function prefinish2() {
  var _this = this;
  if (typeof this._flush === "function" && !this._readableState.destroyed) {
    this._flush(function(er, data2) {
      done2(_this, er, data2);
    });
  } else {
    done2(this, null, null);
  }
}
Transform$1.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Registry$1.Duplex.prototype.push.call(this, chunk, encoding);
};
Transform$1.prototype._transform = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$1.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};
Transform$1.prototype._read = function(n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
Transform$1.prototype._destroy = function(err2, cb) {
  Registry$1.Duplex.prototype._destroy.call(this, err2, function(err22) {
    cb(err22);
  });
};
function done2(stream2, er, data2) {
  if (er) return stream2.emit("error", er);
  if (data2 != null)
    stream2.push(data2);
  if (stream2._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream2._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream2.push(null);
}
var Registry = _registry;
Registry.PassThrough = PassThrough2;
require$$12(PassThrough2, Registry.Transform);
function PassThrough2(options) {
  if (!(this instanceof PassThrough2)) return new PassThrough2(options);
  Transform.call(this, options);
}
PassThrough2.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
var eos;
function once4(callback) {
  var called = false;
  return function() {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = errorsBrowser.codes;
var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop4(err2) {
  if (err2) throw err2;
}
function isRequest(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function destroyer(stream2, reading, writing, callback) {
  callback = once4(callback);
  var closed = false;
  stream2.on("close", function() {
    closed = true;
  });
  if (eos === void 0) eos = endOfStream;
  eos(stream2, {
    readable: reading,
    writable: writing
  }, function(err2) {
    if (err2) return callback(err2);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err2) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;
    if (isRequest(stream2)) return stream2.abort();
    if (typeof stream2.destroy === "function") return stream2.destroy();
    callback(err2 || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function call(fn) {
  fn();
}
function pipe(from4, to) {
  return from4.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop4;
  if (typeof streams[streams.length - 1] !== "function") return noop4;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  var error;
  var destroys = streams.map(function(stream2, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream2, reading, writing, function(err2) {
      if (!error) error = err2;
      if (err2) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(module2, exports2) {
  var Registry2 = _registry;
  exports2 = module2.exports = Registry2.Readable;
  exports2.Stream = Registry2.Readable;
  exports2.Readable = Registry2.Readable;
  exports2.Writable = Registry2.Writable;
  exports2.Duplex = Registry2.Duplex;
  exports2.Transform = Registry2.Transform;
  exports2.PassThrough = Registry2.PassThrough;
  exports2.finished = endOfStream;
  exports2.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports;
var stream = getDefaultExportFromCjs2(readableBrowserExports);
var lib3 = {};
var binding2 = {};
function compare6(a2, b) {
  if (a2 === b) {
    return 0;
  }
  var x = a2.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a2[i] !== b[i]) {
      x = a2[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var hasOwn2 = Object.prototype.hasOwnProperty;
var objectKeys2 = Object.keys || function(obj) {
  var keys2 = [];
  for (var key in obj) {
    if (hasOwn2.call(obj, key)) keys2.push(key);
  }
  return keys2;
};
var pSlice2 = Array.prototype.slice;
var _functionsHaveNames2;
function functionsHaveNames2() {
  if (typeof _functionsHaveNames2 !== "undefined") {
    return _functionsHaveNames2;
  }
  return _functionsHaveNames2 = function() {
    return (function foo() {
    }).name === "foo";
  }();
}
function pToString2(obj) {
  return Object.prototype.toString.call(obj);
}
function isView2(arrbuf) {
  if (isBuffer$12(arrbuf)) {
    return false;
  }
  if (typeof global$12.ArrayBuffer !== "function") {
    return false;
  }
  if (typeof ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
function assert2(value2, message) {
  if (!value2) fail2(value2, true, message, "==", ok2);
}
var regex2 = /\s*function\s+([^\(\s]*)\s*/;
function getName2(func) {
  if (!isFunction2(func)) {
    return;
  }
  if (functionsHaveNames2()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex2);
  return match && match[1];
}
assert2.AssertionError = AssertionError2;
function AssertionError2(options) {
  this.name = "AssertionError";
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage2(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail2;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    var err2 = new Error();
    if (err2.stack) {
      var out = err2.stack;
      var fn_name = getName2(stackStartFunction);
      var idx = out.indexOf("\n" + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf("\n", idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
}
inherits$3(AssertionError2, Error);
function truncate2(s2, n) {
  if (typeof s2 === "string") {
    return s2.length < n ? s2 : s2.slice(0, n);
  } else {
    return s2;
  }
}
function inspect4(something) {
  if (functionsHaveNames2() || !isFunction2(something)) {
    return inspect$12(something);
  }
  var rawname = getName2(something);
  var name2 = rawname ? ": " + rawname : "";
  return "[Function" + name2 + "]";
}
function getMessage2(self2) {
  return truncate2(inspect4(self2.actual), 128) + " " + self2.operator + " " + truncate2(inspect4(self2.expected), 128);
}
function fail2(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError2({
    message,
    actual,
    expected,
    operator,
    stackStartFunction
  });
}
assert2.fail = fail2;
function ok2(value2, message) {
  if (!value2) fail2(value2, true, message, "==", ok2);
}
assert2.ok = ok2;
assert2.equal = equal2;
function equal2(actual, expected, message) {
  if (actual != expected) fail2(actual, expected, message, "==", equal2);
}
assert2.notEqual = notEqual2;
function notEqual2(actual, expected, message) {
  if (actual == expected) {
    fail2(actual, expected, message, "!=", notEqual2);
  }
}
assert2.deepEqual = deepEqual2;
function deepEqual2(actual, expected, message) {
  if (!_deepEqual2(actual, expected, false)) {
    fail2(actual, expected, message, "deepEqual", deepEqual2);
  }
}
assert2.deepStrictEqual = deepStrictEqual2;
function deepStrictEqual2(actual, expected, message) {
  if (!_deepEqual2(actual, expected, true)) {
    fail2(actual, expected, message, "deepStrictEqual", deepStrictEqual2);
  }
}
function _deepEqual2(actual, expected, strict, memos) {
  if (actual === expected) {
    return true;
  } else if (isBuffer$12(actual) && isBuffer$12(expected)) {
    return compare6(actual, expected) === 0;
  } else if (isDate2(actual) && isDate2(expected)) {
    return actual.getTime() === expected.getTime();
  } else if (isRegExp2(actual) && isRegExp2(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  } else if (isView2(actual) && isView2(expected) && pToString2(actual) === pToString2(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare6(
      new Uint8Array(actual.buffer),
      new Uint8Array(expected.buffer)
    ) === 0;
  } else if (isBuffer$12(actual) !== isBuffer$12(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv2(actual, expected, strict, memos);
  }
}
function isArguments2(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv2(a2, b, strict, actualVisitedObjects) {
  if (a2 === null || a2 === void 0 || b === null || b === void 0)
    return false;
  if (isPrimitive2(a2) || isPrimitive2(b))
    return a2 === b;
  if (strict && Object.getPrototypeOf(a2) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments2(a2);
  var bIsArgs = isArguments2(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a2 = pSlice2.call(a2);
    b = pSlice2.call(b);
    return _deepEqual2(a2, b, strict);
  }
  var ka = objectKeys2(a2);
  var kb = objectKeys2(b);
  var key, i;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual2(a2[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}
assert2.notDeepEqual = notDeepEqual2;
function notDeepEqual2(actual, expected, message) {
  if (_deepEqual2(actual, expected, false)) {
    fail2(actual, expected, message, "notDeepEqual", notDeepEqual2);
  }
}
assert2.notDeepStrictEqual = notDeepStrictEqual2;
function notDeepStrictEqual2(actual, expected, message) {
  if (_deepEqual2(actual, expected, true)) {
    fail2(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual2);
  }
}
assert2.strictEqual = strictEqual2;
function strictEqual2(actual, expected, message) {
  if (actual !== expected) {
    fail2(actual, expected, message, "===", strictEqual2);
  }
}
assert2.notStrictEqual = notStrictEqual2;
function notStrictEqual2(actual, expected, message) {
  if (actual === expected) {
    fail2(actual, expected, message, "!==", notStrictEqual2);
  }
}
function expectedException2(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == "[object RegExp]") {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock2(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}
function _throws2(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== "function") {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === "string") {
    message = expected;
    expected = null;
  }
  actual = _tryBlock2(block);
  message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
  if (shouldThrow && !actual) {
    fail2(actual, expected, "Missing expected exception" + message);
  }
  var userProvidedMessage = typeof message === "string";
  var isUnwantedException = !shouldThrow && isError2(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException2(actual, expected) || isUnexpectedException) {
    fail2(actual, expected, "Got unwanted exception" + message);
  }
  if (shouldThrow && actual && expected && !expectedException2(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}
assert2.throws = throws2;
function throws2(block, error, message) {
  _throws2(true, block, error, message);
}
assert2.doesNotThrow = doesNotThrow2;
function doesNotThrow2(block, error, message) {
  _throws2(false, block, error, message);
}
assert2.ifError = ifError2;
function ifError2(err2) {
  if (err2) throw err2;
}
var _polyfillNode_assert2 = Object.freeze({
  __proto__: null,
  AssertionError: AssertionError2,
  assert: ok2,
  deepEqual: deepEqual2,
  deepStrictEqual: deepStrictEqual2,
  default: assert2,
  doesNotThrow: doesNotThrow2,
  equal: equal2,
  fail: fail2,
  ifError: ifError2,
  notDeepEqual: notDeepEqual2,
  notDeepStrictEqual: notDeepStrictEqual2,
  notEqual: notEqual2,
  notStrictEqual: notStrictEqual2,
  ok: ok2,
  strictEqual: strictEqual2,
  throws: throws2
});
var require$$42 = getAugmentedNamespace2(_polyfillNode_assert2);
(function(exports2) {
  var assert3 = require$$42;
  var Zstream = import_zstream.default;
  var zlib_deflate = import_deflate.default;
  var zlib_inflate = import_inflate.default;
  var constants2 = import_constants.default;
  for (var key in constants2) {
    exports2[key] = constants2[key];
  }
  exports2.NONE = 0;
  exports2.DEFLATE = 1;
  exports2.INFLATE = 2;
  exports2.GZIP = 3;
  exports2.GUNZIP = 4;
  exports2.DEFLATERAW = 5;
  exports2.INFLATERAW = 6;
  exports2.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib(mode) {
    if (typeof mode !== "number" || mode < exports2.DEFLATE || mode > exports2.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  Zlib.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert3(this.init_done, "close before init");
    assert3(this.mode <= exports2.UNZIP);
    if (this.mode === exports2.DEFLATE || this.mode === exports2.GZIP || this.mode === exports2.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports2.INFLATE || this.mode === exports2.GUNZIP || this.mode === exports2.INFLATERAW || this.mode === exports2.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports2.NONE;
    this.dictionary = null;
  };
  Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert3.equal(arguments.length, 8);
    assert3(this.init_done, "write before init");
    assert3(this.mode !== exports2.NONE, "already finalized");
    assert3.equal(false, this.write_in_progress, "write already in progress");
    assert3.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert3.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports2.Z_NO_FLUSH && flush !== exports2.Z_PARTIAL_FLUSH && flush !== exports2.Z_SYNC_FLUSH && flush !== exports2.Z_FULL_FLUSH && flush !== exports2.Z_FINISH && flush !== exports2.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer$2.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    browser$1$1.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports2.DEFLATE:
      case exports2.GZIP:
      case exports2.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports2.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports2.INFLATE;
              break;
            }
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports2.GUNZIP;
            } else {
              this.mode = exports2.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      case exports2.INFLATE:
      case exports2.GUNZIP:
      case exports2.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports2.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports2.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports2.Z_DATA_ERROR) {
            this.err = exports2.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports2.GUNZIP && this.err === exports2.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib.prototype._checkError = function() {
    switch (this.err) {
      case exports2.Z_OK:
      case exports2.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports2.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports2.Z_STREAM_END:
        break;
      case exports2.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    assert3(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert3(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert3(level >= -1 && level <= 9, "invalid compression level");
    assert3(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert3(strategy === exports2.Z_FILTERED || strategy === exports2.Z_HUFFMAN_ONLY || strategy === exports2.Z_RLE || strategy === exports2.Z_FIXED || strategy === exports2.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
  };
  Zlib.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports2.Z_NO_FLUSH;
    this.err = exports2.Z_OK;
    if (this.mode === exports2.GZIP || this.mode === exports2.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports2.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports2.DEFLATERAW || this.mode === exports2.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports2.DEFLATE:
      case exports2.GZIP:
      case exports2.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports2.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports2.INFLATE:
      case exports2.GUNZIP:
      case exports2.INFLATERAW:
      case exports2.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports2.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports2.Z_OK;
    switch (this.mode) {
      case exports2.DEFLATE:
      case exports2.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports2.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib.prototype._reset = function() {
    this.err = exports2.Z_OK;
    switch (this.mode) {
      case exports2.DEFLATE:
      case exports2.DEFLATERAW:
      case exports2.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports2.INFLATE:
      case exports2.INFLATERAW:
      case exports2.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports2.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports2.Zlib = Zlib;
})(binding2);
(function(exports2) {
  var Buffer5 = require$$02.Buffer;
  var Transform3 = readableBrowserExports.Transform;
  var binding$13 = binding2;
  var util = require$$32;
  var assert3 = require$$42.ok;
  var kMaxLength4 = require$$02.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength4.toString(16) + " bytes";
  binding$13.Z_MIN_WINDOWBITS = 8;
  binding$13.Z_MAX_WINDOWBITS = 15;
  binding$13.Z_DEFAULT_WINDOWBITS = 15;
  binding$13.Z_MIN_CHUNK = 64;
  binding$13.Z_MAX_CHUNK = Infinity;
  binding$13.Z_DEFAULT_CHUNK = 16 * 1024;
  binding$13.Z_MIN_MEMLEVEL = 1;
  binding$13.Z_MAX_MEMLEVEL = 9;
  binding$13.Z_DEFAULT_MEMLEVEL = 8;
  binding$13.Z_MIN_LEVEL = -1;
  binding$13.Z_MAX_LEVEL = 9;
  binding$13.Z_DEFAULT_LEVEL = binding$13.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding$13);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports2, bkey, {
        enumerable: true,
        value: binding$13[bkey],
        writable: false
      });
    }
  }
  var codes2 = {
    Z_OK: binding$13.Z_OK,
    Z_STREAM_END: binding$13.Z_STREAM_END,
    Z_NEED_DICT: binding$13.Z_NEED_DICT,
    Z_ERRNO: binding$13.Z_ERRNO,
    Z_STREAM_ERROR: binding$13.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding$13.Z_DATA_ERROR,
    Z_MEM_ERROR: binding$13.Z_MEM_ERROR,
    Z_BUF_ERROR: binding$13.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding$13.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes2);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes2[codes2[ckey]] = ckey;
  }
  Object.defineProperty(exports2, "codes", {
    enumerable: true,
    value: Object.freeze(codes2),
    writable: false
  });
  exports2.Deflate = Deflate;
  exports2.Inflate = Inflate;
  exports2.Gzip = Gzip;
  exports2.Gunzip = Gunzip;
  exports2.DeflateRaw = DeflateRaw;
  exports2.InflateRaw = InflateRaw;
  exports2.Unzip = Unzip;
  exports2.createDeflate = function(o) {
    return new Deflate(o);
  };
  exports2.createInflate = function(o) {
    return new Inflate(o);
  };
  exports2.createDeflateRaw = function(o) {
    return new DeflateRaw(o);
  };
  exports2.createInflateRaw = function(o) {
    return new InflateRaw(o);
  };
  exports2.createGzip = function(o) {
    return new Gzip(o);
  };
  exports2.createGunzip = function(o) {
    return new Gunzip(o);
  };
  exports2.createUnzip = function(o) {
    return new Unzip(o);
  };
  exports2.deflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Deflate(opts2), buffer, callback);
  };
  exports2.deflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Deflate(opts2), buffer);
  };
  exports2.gzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gzip(opts2), buffer, callback);
  };
  exports2.gzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gzip(opts2), buffer);
  };
  exports2.deflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new DeflateRaw(opts2), buffer, callback);
  };
  exports2.deflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new DeflateRaw(opts2), buffer);
  };
  exports2.unzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Unzip(opts2), buffer, callback);
  };
  exports2.unzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Unzip(opts2), buffer);
  };
  exports2.inflate = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Inflate(opts2), buffer, callback);
  };
  exports2.inflateSync = function(buffer, opts2) {
    return zlibBufferSync(new Inflate(opts2), buffer);
  };
  exports2.gunzip = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gunzip(opts2), buffer, callback);
  };
  exports2.gunzipSync = function(buffer, opts2) {
    return zlibBufferSync(new Gunzip(opts2), buffer);
  };
  exports2.inflateRaw = function(buffer, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new InflateRaw(opts2), buffer, callback);
  };
  exports2.inflateRawSync = function(buffer, opts2) {
    return zlibBufferSync(new InflateRaw(opts2), buffer);
  };
  function zlibBuffer(engine2, buffer, callback) {
    var buffers = [];
    var nread = 0;
    engine2.on("error", onError);
    engine2.on("end", onEnd);
    engine2.end(buffer);
    flow3();
    function flow3() {
      var chunk;
      while (null !== (chunk = engine2.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine2.once("readable", flow3);
    }
    function onError(err2) {
      engine2.removeListener("end", onEnd);
      engine2.removeListener("readable", flow3);
      callback(err2);
    }
    function onEnd() {
      var buf;
      var err2 = null;
      if (nread >= kMaxLength4) {
        err2 = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer5.concat(buffers, nread);
      }
      buffers = [];
      engine2.close();
      callback(err2, buf);
    }
  }
  function zlibBufferSync(engine2, buffer) {
    if (typeof buffer === "string") buffer = Buffer5.from(buffer);
    if (!Buffer5.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
    var flushFlag = engine2._finishFlushFlag;
    return engine2._processChunk(buffer, flushFlag);
  }
  function Deflate(opts2) {
    if (!(this instanceof Deflate)) return new Deflate(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATE);
  }
  function Inflate(opts2) {
    if (!(this instanceof Inflate)) return new Inflate(opts2);
    Zlib.call(this, opts2, binding$13.INFLATE);
  }
  function Gzip(opts2) {
    if (!(this instanceof Gzip)) return new Gzip(opts2);
    Zlib.call(this, opts2, binding$13.GZIP);
  }
  function Gunzip(opts2) {
    if (!(this instanceof Gunzip)) return new Gunzip(opts2);
    Zlib.call(this, opts2, binding$13.GUNZIP);
  }
  function DeflateRaw(opts2) {
    if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATERAW);
  }
  function InflateRaw(opts2) {
    if (!(this instanceof InflateRaw)) return new InflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.INFLATERAW);
  }
  function Unzip(opts2) {
    if (!(this instanceof Unzip)) return new Unzip(opts2);
    Zlib.call(this, opts2, binding$13.UNZIP);
  }
  function isValidFlushFlag(flag) {
    return flag === binding$13.Z_NO_FLUSH || flag === binding$13.Z_PARTIAL_FLUSH || flag === binding$13.Z_SYNC_FLUSH || flag === binding$13.Z_FULL_FLUSH || flag === binding$13.Z_FINISH || flag === binding$13.Z_BLOCK;
  }
  function Zlib(opts2, mode) {
    var _this = this;
    this._opts = opts2 = opts2 || {};
    this._chunkSize = opts2.chunkSize || exports2.Z_DEFAULT_CHUNK;
    Transform3.call(this, opts2);
    if (opts2.flush && !isValidFlushFlag(opts2.flush)) {
      throw new Error("Invalid flush flag: " + opts2.flush);
    }
    if (opts2.finishFlush && !isValidFlushFlag(opts2.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts2.finishFlush);
    }
    this._flushFlag = opts2.flush || binding$13.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts2.finishFlush !== "undefined" ? opts2.finishFlush : binding$13.Z_FINISH;
    if (opts2.chunkSize) {
      if (opts2.chunkSize < exports2.Z_MIN_CHUNK || opts2.chunkSize > exports2.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts2.chunkSize);
      }
    }
    if (opts2.windowBits) {
      if (opts2.windowBits < exports2.Z_MIN_WINDOWBITS || opts2.windowBits > exports2.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts2.windowBits);
      }
    }
    if (opts2.level) {
      if (opts2.level < exports2.Z_MIN_LEVEL || opts2.level > exports2.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts2.level);
      }
    }
    if (opts2.memLevel) {
      if (opts2.memLevel < exports2.Z_MIN_MEMLEVEL || opts2.memLevel > exports2.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts2.memLevel);
      }
    }
    if (opts2.strategy) {
      if (opts2.strategy != exports2.Z_FILTERED && opts2.strategy != exports2.Z_HUFFMAN_ONLY && opts2.strategy != exports2.Z_RLE && opts2.strategy != exports2.Z_FIXED && opts2.strategy != exports2.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts2.strategy);
      }
    }
    if (opts2.dictionary) {
      if (!Buffer5.isBuffer(opts2.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding$13.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
      _close(self2);
      self2._hadError = true;
      var error = new Error(message);
      error.errno = errno;
      error.code = exports2.codes[errno];
      self2.emit("error", error);
    };
    var level = exports2.Z_DEFAULT_COMPRESSION;
    if (typeof opts2.level === "number") level = opts2.level;
    var strategy = exports2.Z_DEFAULT_STRATEGY;
    if (typeof opts2.strategy === "number") strategy = opts2.strategy;
    this._handle.init(opts2.windowBits || exports2.Z_DEFAULT_WINDOWBITS, level, opts2.memLevel || exports2.Z_DEFAULT_MEMLEVEL, strategy, opts2.dictionary);
    this._buffer = Buffer5.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: function get16() {
        return !_this._handle;
      },
      configurable: true,
      enumerable: true
    });
  }
  util.inherits(Zlib, Transform3);
  Zlib.prototype.params = function(level, strategy, callback) {
    if (level < exports2.Z_MIN_LEVEL || level > exports2.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports2.Z_FILTERED && strategy != exports2.Z_HUFFMAN_ONLY && strategy != exports2.Z_RLE && strategy != exports2.Z_FIXED && strategy != exports2.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding$13.Z_SYNC_FLUSH, function() {
        assert3(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback) callback();
        }
      });
    } else {
      browser$1$1.nextTick(callback);
    }
  };
  Zlib.prototype.reset = function() {
    assert3(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib.prototype._flush = function(callback) {
    this._transform(Buffer5.alloc(0), "", callback);
  };
  Zlib.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding$13.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback) browser$1$1.nextTick(callback);
    } else if (ws.ending) {
      if (callback) this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer5.alloc(0), "", callback);
    }
  };
  Zlib.prototype.close = function(callback) {
    _close(this, callback);
    browser$1$1.nextTick(emitCloseNT2, this);
  };
  function _close(engine2, callback) {
    if (callback) browser$1$1.nextTick(callback);
    if (!engine2._handle) return;
    engine2._handle.close();
    engine2._handle = null;
  }
  function emitCloseNT2(self2) {
    self2.emit("close");
  }
  Zlib.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last3 = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer5.isBuffer(chunk)) return cb(new Error("invalid input"));
    if (!this._handle) return cb(new Error("zlib binding closed"));
    if (last3) flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding$13.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(er) {
        error = er;
      });
      assert3(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength4) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer5.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert3(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError) return;
      var have = availOutBefore - availOutAfter;
      assert3(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer5.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async) return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async) return false;
      cb();
    }
  };
  util.inherits(Deflate, Zlib);
  util.inherits(Inflate, Zlib);
  util.inherits(Gzip, Zlib);
  util.inherits(Gunzip, Zlib);
  util.inherits(DeflateRaw, Zlib);
  util.inherits(InflateRaw, Zlib);
  util.inherits(Unzip, Zlib);
})(lib3);
var zlib2 = getDefaultExportFromCjs2(lib3);
var PDFReference = function(_stream$Writable) {
  _inheritsLoose(PDFReference2, _stream$Writable);
  function PDFReference2(document2, id, data2) {
    var _this;
    _this = _stream$Writable.call(this, {
      decodeStrings: false
    }) || this;
    _this.finalize = _this.finalize.bind(_assertThisInitialized(_this));
    _this.document = document2;
    _this.id = id;
    if (data2 == null) {
      data2 = {};
    }
    _this.data = data2;
    _this.gen = 0;
    _this.deflate = null;
    _this.compress = _this.document.compress && !_this.data.Filter;
    _this.uncompressedLength = 0;
    _this.chunks = [];
    return _this;
  }
  var _proto = PDFReference2.prototype;
  _proto.initDeflate = function initDeflate() {
    var _this2 = this;
    this.data.Filter = "FlateDecode";
    this.deflate = zlib2.createDeflate();
    this.deflate.on("data", function(chunk) {
      _this2.chunks.push(chunk);
      return _this2.data.Length += chunk.length;
    });
    return this.deflate.on("end", this.finalize);
  };
  _proto._write = function _write(chunk, encoding, callback) {
    if (!(chunk instanceof Uint8Array)) {
      chunk = Buffer$2.from(chunk + "\n", "binary");
    }
    this.uncompressedLength += chunk.length;
    if (this.data.Length == null) {
      this.data.Length = 0;
    }
    if (this.compress) {
      if (!this.deflate) {
        this.initDeflate();
      }
      this.deflate.write(chunk);
    } else {
      this.chunks.push(chunk);
      this.data.Length += chunk.length;
    }
    return callback();
  };
  _proto.end = function end3() {
    _stream$Writable.prototype.end.apply(this, arguments);
    if (this.deflate) {
      return this.deflate.end();
    }
    return this.finalize();
  };
  _proto.finalize = function finalize() {
    this.offset = this.document._offset;
    this.document._write(this.id + " " + this.gen + " obj");
    this.document._write(PDFObject$1.convert(this.data));
    if (this.chunks.length) {
      this.document._write("stream");
      for (var _i = 0, _Array$from = Array.from(this.chunks); _i < _Array$from.length; _i++) {
        var chunk = _Array$from[_i];
        this.document._write(chunk);
      }
      this.chunks.length = 0;
      this.document._write("\nendstream");
    }
    this.document._write("endobj");
    return this.document._refEnd(this);
  };
  _proto.toString = function toString7() {
    return this.id + " " + this.gen + " R";
  };
  return PDFReference2;
}(stream.Writable);
var PDFTree = function() {
  function PDFTree2(options) {
    if (options === void 0) {
      options = {};
    }
    this._items = {};
    this.limits = typeof options.limits === "boolean" ? options.limits : true;
  }
  var _proto = PDFTree2.prototype;
  _proto.add = function add3(key, val) {
    return this._items[key] = val;
  };
  _proto.get = function get16(key) {
    return this._items[key];
  };
  _proto.toString = function toString7() {
    var _this = this;
    var sortedKeys = Object.keys(this._items).sort(function(a2, b) {
      return _this._compareKeys(a2, b);
    });
    var out = ["<<"];
    if (this.limits && sortedKeys.length > 1) {
      var first = sortedKeys[0], last3 = sortedKeys[sortedKeys.length - 1];
      out.push("  /Limits " + PDFObject$1.convert([this._dataForKey(first), this._dataForKey(last3)]));
    }
    out.push("  /" + this._keysName() + " [");
    for (var _iterator = _createForOfIteratorHelperLoose(sortedKeys), _step; !(_step = _iterator()).done; ) {
      var key = _step.value;
      out.push("    " + PDFObject$1.convert(this._dataForKey(key)) + " " + PDFObject$1.convert(this._items[key]));
    }
    out.push("]");
    out.push(">>");
    return out.join("\n");
  };
  _proto._compareKeys = function _compareKeys() {
    throw new Error("Must be implemented by subclasses");
  };
  _proto._keysName = function _keysName() {
    throw new Error("Must be implemented by subclasses");
  };
  _proto._dataForKey = function _dataForKey() {
    throw new Error("Must be implemented by subclasses");
  };
  return PDFTree2;
}();
var PDFNameTree = function(_PDFTree) {
  _inheritsLoose(PDFNameTree2, _PDFTree);
  function PDFNameTree2() {
    return _PDFTree.apply(this, arguments) || this;
  }
  var _proto = PDFNameTree2.prototype;
  _proto._compareKeys = function _compareKeys(a2, b) {
    return a2.localeCompare(b);
  };
  _proto._keysName = function _keysName() {
    return "Names";
  };
  _proto._dataForKey = function _dataForKey(k) {
    return new String(k);
  };
  return PDFNameTree2;
}(PDFTree);
var escapableRe = /[\n\r\t\b\f\(\)\\]/g;
var escapable = {
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\b": "\\b",
  "\f": "\\f",
  "\\": "\\\\",
  "(": "\\(",
  ")": "\\)"
};
var pad2 = function pad3(str, length4) {
  return (Array(length4 + 1).join("0") + str).slice(-length4);
};
var swapBytes = function swapBytes2(buff) {
  var l2 = buff.length;
  if (l2 & 1) {
    throw new Error("Buffer length must be even");
  } else {
    for (var i = 0, end3 = l2 - 1; i < end3; i += 2) {
      var a2 = buff[i];
      buff[i] = buff[i + 1];
      buff[i + 1] = a2;
    }
  }
  return buff;
};
var PDFObject = function() {
  function PDFObject2() {
  }
  PDFObject2.convert = function convert(object) {
    if (typeof object === "string") {
      return "/" + object;
    }
    if (object instanceof String) {
      var string = object;
      var isUnicode = false;
      for (var i = 0, end3 = string.length; i < end3; i++) {
        if (string.charCodeAt(i) > 127) {
          isUnicode = true;
          break;
        }
      }
      if (isUnicode) {
        string = swapBytes(Buffer$2.from("\uFEFF" + string, "utf16le")).toString("binary");
      }
      string = string.replace(escapableRe, function(c2) {
        return escapable[c2];
      });
      return "(" + string + ")";
    }
    if (Buffer$2.isBuffer(object)) {
      return "<" + object.toString("hex") + ">";
    }
    if (object instanceof PDFReference || object instanceof PDFNameTree) {
      return object.toString();
    }
    if (object instanceof Date) {
      return "(D:" + pad2(object.getUTCFullYear(), 4) + pad2(object.getUTCMonth() + 1, 2) + pad2(object.getUTCDate(), 2) + pad2(object.getUTCHours(), 2) + pad2(object.getUTCMinutes(), 2) + pad2(object.getUTCSeconds(), 2) + "Z)";
    }
    if (Array.isArray(object)) {
      var items = Array.from(object).map(function(e) {
        return PDFObject2.convert(e);
      }).join(" ");
      return "[" + items + "]";
    }
    if ({}.toString.call(object) === "[object Object]") {
      var out = ["<<"];
      for (var key in object) {
        var val = object[key];
        out.push("/" + key + " " + PDFObject2.convert(val));
      }
      out.push(">>");
      return out.join("\n");
    }
    if (typeof object === "number") {
      return PDFObject2.number(object);
    }
    return "" + object;
  };
  PDFObject2.number = function number2(n) {
    if (n > -1e21 && n < 1e21) {
      return Math.round(n * 1e6) / 1e6;
    }
    throw new Error("unsupported number: " + n);
  };
  return PDFObject2;
}();
var PDFObject$1 = PDFObject;
var DEFAULT_MARGINS = {
  top: 72,
  left: 72,
  bottom: 72,
  right: 72
};
var SIZES = {
  "4A0": [4767.87, 6740.79],
  "2A0": [3370.39, 4767.87],
  A0: [2383.94, 3370.39],
  A1: [1683.78, 2383.94],
  A2: [1190.55, 1683.78],
  A3: [841.89, 1190.55],
  A4: [595.28, 841.89],
  A5: [419.53, 595.28],
  A6: [297.64, 419.53],
  A7: [209.76, 297.64],
  A8: [147.4, 209.76],
  A9: [104.88, 147.4],
  A10: [73.7, 104.88],
  B0: [2834.65, 4008.19],
  B1: [2004.09, 2834.65],
  B2: [1417.32, 2004.09],
  B3: [1000.63, 1417.32],
  B4: [708.66, 1000.63],
  B5: [498.9, 708.66],
  B6: [354.33, 498.9],
  B7: [249.45, 354.33],
  B8: [175.75, 249.45],
  B9: [124.72, 175.75],
  B10: [87.87, 124.72],
  C0: [2599.37, 3676.54],
  C1: [1836.85, 2599.37],
  C2: [1298.27, 1836.85],
  C3: [918.43, 1298.27],
  C4: [649.13, 918.43],
  C5: [459.21, 649.13],
  C6: [323.15, 459.21],
  C7: [229.61, 323.15],
  C8: [161.57, 229.61],
  C9: [113.39, 161.57],
  C10: [79.37, 113.39],
  RA0: [2437.8, 3458.27],
  RA1: [1729.13, 2437.8],
  RA2: [1218.9, 1729.13],
  RA3: [864.57, 1218.9],
  RA4: [609.45, 864.57],
  SRA0: [2551.18, 3628.35],
  SRA1: [1814.17, 2551.18],
  SRA2: [1275.59, 1814.17],
  SRA3: [907.09, 1275.59],
  SRA4: [637.8, 907.09],
  EXECUTIVE: [521.86, 756],
  FOLIO: [612, 936],
  LEGAL: [612, 1008],
  LETTER: [612, 792],
  TABLOID: [792, 1224]
};
var PDFPage = function() {
  function PDFPage2(document2, options) {
    if (options === void 0) {
      options = {};
    }
    this.document = document2;
    this.size = options.size || "letter";
    this.layout = options.layout || "portrait";
    this.userUnit = options.userUnit || 1;
    if (typeof options.margin === "number") {
      this.margins = {
        top: options.margin,
        left: options.margin,
        bottom: options.margin,
        right: options.margin
      };
    } else {
      this.margins = options.margins || DEFAULT_MARGINS;
    }
    var dimensions = Array.isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()];
    this.width = dimensions[this.layout === "portrait" ? 0 : 1];
    this.height = dimensions[this.layout === "portrait" ? 1 : 0];
    this.content = this.document.ref();
    this.resources = this.document.ref({
      ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"]
    });
    this.dictionary = this.document.ref({
      Type: "Page",
      Parent: this.document._root.data.Pages,
      MediaBox: [0, 0, this.width, this.height],
      Contents: this.content,
      Resources: this.resources,
      UserUnit: this.userUnit
    });
    this.markings = [];
  }
  var _proto = PDFPage2.prototype;
  _proto.maxY = function maxY() {
    return this.height - this.margins.bottom;
  };
  _proto.write = function write7(chunk) {
    return this.content.write(chunk);
  };
  _proto.end = function end3() {
    this.dictionary.end();
    this.resources.end();
    return this.content.end();
  };
  _createClass(PDFPage2, [{
    key: "fonts",
    get: function get16() {
      var data2 = this.resources.data;
      return data2.Font != null ? data2.Font : data2.Font = {};
    }
  }, {
    key: "xobjects",
    get: function get16() {
      var data2 = this.resources.data;
      return data2.XObject != null ? data2.XObject : data2.XObject = {};
    }
  }, {
    key: "ext_gstates",
    get: function get16() {
      var data2 = this.resources.data;
      return data2.ExtGState != null ? data2.ExtGState : data2.ExtGState = {};
    }
  }, {
    key: "patterns",
    get: function get16() {
      var data2 = this.resources.data;
      return data2.Pattern != null ? data2.Pattern : data2.Pattern = {};
    }
  }, {
    key: "colorSpaces",
    get: function get16() {
      var data2 = this.resources.data;
      return data2.ColorSpace || (data2.ColorSpace = {});
    }
  }, {
    key: "annotations",
    get: function get16() {
      var data2 = this.dictionary.data;
      return data2.Annots != null ? data2.Annots : data2.Annots = [];
    }
  }, {
    key: "structParentTreeKey",
    get: function get16() {
      var data2 = this.dictionary.data;
      return data2.StructParents != null ? data2.StructParents : data2.StructParents = this.document.createStructParentTreeNextKey();
    }
  }]);
  return PDFPage2;
}();
var wordArrayToBuffer = function wordArrayToBuffer2(wordArray) {
  var byteArray = [];
  for (var i = 0; i < wordArray.sigBytes; i++) {
    byteArray.push(wordArray.words[Math.floor(i / 4)] >> 8 * (3 - i % 4) & 255);
  }
  return Buffer$2.from(byteArray);
};
var PDFSecurity = function() {
  function PDFSecurity2() {
  }
  PDFSecurity2.generateFileID = function generateFileID(info) {
    if (info === void 0) {
      info = {};
    }
    var infoStr = info.CreationDate.getTime() + "\n";
    for (var key in info) {
      if (!info.hasOwnProperty(key)) continue;
      infoStr += key + ": " + info[key].valueOf() + "\n";
    }
    return wordArrayToBuffer((0, import_md5.default)(infoStr));
  };
  return PDFSecurity2;
}();
var number$2 = PDFObject$1.number;
var PDFGradient$1 = function() {
  function PDFGradient2(doc) {
    this.doc = doc;
    this.stops = [];
    this.embedded = false;
    this.transform = [1, 0, 0, 1, 0, 0];
  }
  var _proto = PDFGradient2.prototype;
  _proto.stop = function stop(pos, color, opacity2) {
    if (opacity2 == null) {
      opacity2 = 1;
    }
    color = this.doc._normalizeColor(color);
    if (this.stops.length === 0) {
      if (color.length === 3) {
        this._colorSpace = "DeviceRGB";
      } else if (color.length === 4) {
        this._colorSpace = "DeviceCMYK";
      } else if (color.length === 1) {
        this._colorSpace = "DeviceGray";
      } else {
        throw new Error("Unknown color space");
      }
    } else if (this._colorSpace === "DeviceRGB" && color.length !== 3 || this._colorSpace === "DeviceCMYK" && color.length !== 4 || this._colorSpace === "DeviceGray" && color.length !== 1) {
      throw new Error("All gradient stops must use the same color space");
    }
    opacity2 = Math.max(0, Math.min(1, opacity2));
    this.stops.push([pos, color, opacity2]);
    return this;
  };
  _proto.setTransform = function setTransform(m11, m12, m21, m22, dx, dy) {
    this.transform = [m11, m12, m21, m22, dx, dy];
    return this;
  };
  _proto.embed = function embed(m2) {
    var fn;
    var stopsLength = this.stops.length;
    if (stopsLength === 0) {
      return;
    }
    this.embedded = true;
    this.matrix = m2;
    var last3 = this.stops[stopsLength - 1];
    if (last3[0] < 1) {
      this.stops.push([1, last3[1], last3[2]]);
    }
    var bounds = [];
    var encode = [];
    var stops = [];
    for (var i = 0; i < stopsLength - 1; i++) {
      encode.push(0, 1);
      if (i + 2 !== stopsLength) {
        bounds.push(this.stops[i + 1][0]);
      }
      fn = this.doc.ref({
        FunctionType: 2,
        Domain: [0, 1],
        C0: this.stops[i + 0][1],
        C1: this.stops[i + 1][1],
        N: 1
      });
      stops.push(fn);
      fn.end();
    }
    if (stopsLength === 1) {
      fn = stops[0];
    } else {
      fn = this.doc.ref({
        FunctionType: 3,
        // stitching function
        Domain: [0, 1],
        Functions: stops,
        Bounds: bounds,
        Encode: encode
      });
      fn.end();
    }
    this.id = "Sh" + ++this.doc._gradCount;
    var shader = this.shader(fn);
    shader.end();
    var pattern4 = this.doc.ref({
      Type: "Pattern",
      PatternType: 2,
      Shading: shader,
      Matrix: this.matrix.map(number$2)
    });
    pattern4.end();
    if (this.stops.some(function(stop2) {
      return stop2[2] < 1;
    })) {
      var grad = this.opacityGradient();
      grad._colorSpace = "DeviceGray";
      for (var _iterator = _createForOfIteratorHelperLoose(this.stops), _step; !(_step = _iterator()).done; ) {
        var stop = _step.value;
        grad.stop(stop[0], [stop[2]]);
      }
      grad = grad.embed(this.matrix);
      var pageBBox = [0, 0, this.doc.page.width, this.doc.page.height];
      var form = this.doc.ref({
        Type: "XObject",
        Subtype: "Form",
        FormType: 1,
        BBox: pageBBox,
        Group: {
          Type: "Group",
          S: "Transparency",
          CS: "DeviceGray"
        },
        Resources: {
          ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
          Pattern: {
            Sh1: grad
          }
        }
      });
      form.write("/Pattern cs /Sh1 scn");
      form.end(pageBBox.join(" ") + " re f");
      var gstate = this.doc.ref({
        Type: "ExtGState",
        SMask: {
          Type: "Mask",
          S: "Luminosity",
          G: form
        }
      });
      gstate.end();
      var opacityPattern = this.doc.ref({
        Type: "Pattern",
        PatternType: 1,
        PaintType: 1,
        TilingType: 2,
        BBox: pageBBox,
        XStep: pageBBox[2],
        YStep: pageBBox[3],
        Resources: {
          ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
          Pattern: {
            Sh1: pattern4
          },
          ExtGState: {
            Gs1: gstate
          }
        }
      });
      opacityPattern.write("/Gs1 gs /Pattern cs /Sh1 scn");
      opacityPattern.end(pageBBox.join(" ") + " re f");
      this.doc.page.patterns[this.id] = opacityPattern;
    } else {
      this.doc.page.patterns[this.id] = pattern4;
    }
    return pattern4;
  };
  _proto.apply = function apply2(stroke2) {
    var _this$doc$_ctm = this.doc._ctm, m0 = _this$doc$_ctm[0], m1 = _this$doc$_ctm[1], m2 = _this$doc$_ctm[2], m3 = _this$doc$_ctm[3], m4 = _this$doc$_ctm[4], m5 = _this$doc$_ctm[5];
    var _this$transform = this.transform, m11 = _this$transform[0], m12 = _this$transform[1], m21 = _this$transform[2], m22 = _this$transform[3], dx = _this$transform[4], dy = _this$transform[5];
    var m6 = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];
    if (!this.embedded || m6.join(" ") !== this.matrix.join(" ")) {
      this.embed(m6);
    }
    this.doc._setColorSpace("Pattern", stroke2);
    var op = stroke2 ? "SCN" : "scn";
    return this.doc.addContent("/" + this.id + " " + op);
  };
  return PDFGradient2;
}();
var PDFLinearGradient$1 = function(_PDFGradient) {
  _inheritsLoose(PDFLinearGradient2, _PDFGradient);
  function PDFLinearGradient2(doc, x1, y1, x2, y2) {
    var _this;
    _this = _PDFGradient.call(this, doc) || this;
    _this.x1 = x1;
    _this.y1 = y1;
    _this.x2 = x2;
    _this.y2 = y2;
    return _this;
  }
  var _proto2 = PDFLinearGradient2.prototype;
  _proto2.shader = function shader(fn) {
    return this.doc.ref({
      ShadingType: 2,
      ColorSpace: this._colorSpace,
      Coords: [this.x1, this.y1, this.x2, this.y2],
      Function: fn,
      Extend: [true, true]
    });
  };
  _proto2.opacityGradient = function opacityGradient() {
    return new PDFLinearGradient2(this.doc, this.x1, this.y1, this.x2, this.y2);
  };
  return PDFLinearGradient2;
}(PDFGradient$1);
var PDFRadialGradient$1 = function(_PDFGradient2) {
  _inheritsLoose(PDFRadialGradient2, _PDFGradient2);
  function PDFRadialGradient2(doc, x1, y1, r1, x2, y2, r2) {
    var _this2;
    _this2 = _PDFGradient2.call(this, doc) || this;
    _this2.doc = doc;
    _this2.x1 = x1;
    _this2.y1 = y1;
    _this2.r1 = r1;
    _this2.x2 = x2;
    _this2.y2 = y2;
    _this2.r2 = r2;
    return _this2;
  }
  var _proto3 = PDFRadialGradient2.prototype;
  _proto3.shader = function shader(fn) {
    return this.doc.ref({
      ShadingType: 3,
      ColorSpace: this._colorSpace,
      Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],
      Function: fn,
      Extend: [true, true]
    });
  };
  _proto3.opacityGradient = function opacityGradient() {
    return new PDFRadialGradient2(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);
  };
  return PDFRadialGradient2;
}(PDFGradient$1);
var Gradient = {
  PDFGradient: PDFGradient$1,
  PDFLinearGradient: PDFLinearGradient$1,
  PDFRadialGradient: PDFRadialGradient$1
};
var underlyingColorSpaces = ["DeviceCMYK", "DeviceRGB"];
var PDFTilingPattern$1 = function() {
  function PDFTilingPattern2(doc, bBox, xStep, yStep, stream2) {
    this.doc = doc;
    this.bBox = bBox;
    this.xStep = xStep;
    this.yStep = yStep;
    this.stream = stream2;
  }
  var _proto = PDFTilingPattern2.prototype;
  _proto.createPattern = function createPattern() {
    var resources = this.doc.ref();
    resources.end();
    var _this$doc$_ctm = this.doc._ctm, m0 = _this$doc$_ctm[0], m1 = _this$doc$_ctm[1], m2 = _this$doc$_ctm[2], m3 = _this$doc$_ctm[3], m4 = _this$doc$_ctm[4], m5 = _this$doc$_ctm[5];
    var m11 = 1, m12 = 0, m21 = 0, m22 = 1, dx = 0, dy = 0;
    var m6 = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];
    var pattern4 = this.doc.ref({
      Type: "Pattern",
      PatternType: 1,
      // tiling
      PaintType: 2,
      // 1-colored, 2-uncolored
      TilingType: 2,
      // 2-no distortion
      BBox: this.bBox,
      XStep: this.xStep,
      YStep: this.yStep,
      Matrix: m6.map(function(v2) {
        return +v2.toFixed(5);
      }),
      Resources: resources
    });
    pattern4.end(this.stream);
    return pattern4;
  };
  _proto.embedPatternColorSpaces = function embedPatternColorSpaces() {
    var _this = this;
    underlyingColorSpaces.forEach(function(csName) {
      var csId = _this.getPatternColorSpaceId(csName);
      if (_this.doc.page.colorSpaces[csId]) return;
      var cs = _this.doc.ref(["Pattern", csName]);
      cs.end();
      _this.doc.page.colorSpaces[csId] = cs;
    });
  };
  _proto.getPatternColorSpaceId = function getPatternColorSpaceId(underlyingColorspace) {
    return "CsP" + underlyingColorspace;
  };
  _proto.embed = function embed() {
    if (!this.id) {
      this.doc._patternCount = this.doc._patternCount + 1;
      this.id = "P" + this.doc._patternCount;
      this.pattern = this.createPattern();
    }
    if (!this.doc.page.patterns[this.id]) {
      this.doc.page.patterns[this.id] = this.pattern;
    }
  };
  _proto.apply = function apply2(stroke2, patternColor) {
    this.embedPatternColorSpaces();
    this.embed();
    var normalizedColor = this.doc._normalizeColor(patternColor);
    if (!normalizedColor) throw Error("invalid pattern color. (value: " + patternColor + ")");
    var csId = this.getPatternColorSpaceId(this.doc._getColorSpace(normalizedColor));
    this.doc._setColorSpace(csId, stroke2);
    var op = stroke2 ? "SCN" : "scn";
    return this.doc.addContent(normalizedColor.join(" ") + " /" + this.id + " " + op);
  };
  return PDFTilingPattern2;
}();
var pattern = {
  PDFTilingPattern: PDFTilingPattern$1
};
var PDFGradient = Gradient.PDFGradient;
var PDFLinearGradient = Gradient.PDFLinearGradient;
var PDFRadialGradient = Gradient.PDFRadialGradient;
var PDFTilingPattern = pattern.PDFTilingPattern;
var ColorMixin = {
  initColor: function initColor() {
    this._opacityRegistry = {};
    this._opacityCount = 0;
    this._patternCount = 0;
    return this._gradCount = 0;
  },
  _normalizeColor: function _normalizeColor(color) {
    if (typeof color === "string") {
      if (color.charAt(0) === "#") {
        if (color.length === 4) {
          color = color.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, "#$1$1$2$2$3$3");
        }
        var hex = parseInt(color.slice(1), 16);
        color = [hex >> 16, hex >> 8 & 255, hex & 255];
      } else if (namedColors[color]) {
        color = namedColors[color];
      }
    }
    if (Array.isArray(color)) {
      if (color.length === 3) {
        color = color.map(function(part) {
          return part / 255;
        });
      } else if (color.length === 4) {
        color = color.map(function(part) {
          return part / 100;
        });
      }
      return color;
    }
    return null;
  },
  _setColor: function _setColor(color, stroke2) {
    if (color instanceof PDFGradient) {
      color.apply(stroke2);
      return true;
    } else if (Array.isArray(color) && color[0] instanceof PDFTilingPattern) {
      color[0].apply(stroke2, color[1]);
      return true;
    }
    return this._setColorCore(color, stroke2);
  },
  _setColorCore: function _setColorCore(color, stroke2) {
    color = this._normalizeColor(color);
    if (!color) {
      return false;
    }
    var op = stroke2 ? "SCN" : "scn";
    var space = this._getColorSpace(color);
    this._setColorSpace(space, stroke2);
    color = color.join(" ");
    this.addContent(color + " " + op);
    return true;
  },
  _setColorSpace: function _setColorSpace(space, stroke2) {
    var op = stroke2 ? "CS" : "cs";
    return this.addContent("/" + space + " " + op);
  },
  _getColorSpace: function _getColorSpace(color) {
    return color.length === 4 ? "DeviceCMYK" : "DeviceRGB";
  },
  fillColor: function fillColor(color, opacity2) {
    var set5 = this._setColor(color, false);
    if (set5) {
      this.fillOpacity(opacity2);
    }
    this._fillColor = [color, opacity2];
    return this;
  },
  strokeColor: function strokeColor(color, opacity2) {
    var set5 = this._setColor(color, true);
    if (set5) {
      this.strokeOpacity(opacity2);
    }
    return this;
  },
  opacity: function opacity(_opacity) {
    this._doOpacity(_opacity, _opacity);
    return this;
  },
  fillOpacity: function fillOpacity(opacity2) {
    this._doOpacity(opacity2, null);
    return this;
  },
  strokeOpacity: function strokeOpacity(opacity2) {
    this._doOpacity(null, opacity2);
    return this;
  },
  _doOpacity: function _doOpacity(fillOpacity2, strokeOpacity2) {
    var dictionary, name2;
    if (fillOpacity2 == null && strokeOpacity2 == null) {
      return;
    }
    if (fillOpacity2 != null) {
      fillOpacity2 = Math.max(0, Math.min(1, fillOpacity2));
    }
    if (strokeOpacity2 != null) {
      strokeOpacity2 = Math.max(0, Math.min(1, strokeOpacity2));
    }
    var key = fillOpacity2 + "_" + strokeOpacity2;
    if (this._opacityRegistry[key]) {
      var _this$_opacityRegistr = this._opacityRegistry[key];
      dictionary = _this$_opacityRegistr[0];
      name2 = _this$_opacityRegistr[1];
    } else {
      dictionary = {
        Type: "ExtGState"
      };
      if (fillOpacity2 != null) {
        dictionary.ca = fillOpacity2;
      }
      if (strokeOpacity2 != null) {
        dictionary.CA = strokeOpacity2;
      }
      dictionary = this.ref(dictionary);
      dictionary.end();
      var id = ++this._opacityCount;
      name2 = "Gs" + id;
      this._opacityRegistry[key] = [dictionary, name2];
    }
    this.page.ext_gstates[name2] = dictionary;
    return this.addContent("/" + name2 + " gs");
  },
  linearGradient: function linearGradient(x1, y1, x2, y2) {
    return new PDFLinearGradient(this, x1, y1, x2, y2);
  },
  radialGradient: function radialGradient(x1, y1, r1, x2, y2, r2) {
    return new PDFRadialGradient(this, x1, y1, r1, x2, y2, r2);
  },
  pattern: function pattern2(bbox, xStep, yStep, stream2) {
    return new PDFTilingPattern(this, bbox, xStep, yStep, stream2);
  }
};
var namedColors = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
var cx;
var cy;
var px;
var py;
var sx;
var sy;
cx = cy = px = py = sx = sy = 0;
var argsCountPerCommand = {
  M: 2,
  m: 2,
  Z: 0,
  z: 0,
  L: 2,
  l: 2,
  H: 1,
  h: 1,
  V: 1,
  v: 1,
  C: 6,
  c: 6,
  S: 4,
  s: 4,
  Q: 4,
  q: 4,
  T: 2,
  t: 2,
  A: 7,
  a: 7
};
var isCommand = function isCommand2(c2) {
  return c2 in argsCountPerCommand;
};
var isWsp = function isWsp2(c2) {
  var codePoint = c2.codePointAt(0);
  return codePoint === 32 || codePoint === 9 || codePoint === 13 || codePoint === 10;
};
var isDigit = function isDigit2(c2) {
  var codePoint = c2.codePointAt(0);
  if (codePoint == null) {
    return false;
  }
  return 48 <= codePoint && codePoint <= 57;
};
var readNumber = function readNumber2(string, cursor) {
  var i = cursor;
  var value2 = "";
  var state2 = (
    /** @type {ReadNumberState} */
    "none"
  );
  for (; i < string.length; i += 1) {
    var c2 = string[i];
    if (c2 === "+" || c2 === "-") {
      if (state2 === "none") {
        state2 = "sign";
        value2 += c2;
        continue;
      }
      if (state2 === "e") {
        state2 = "exponent_sign";
        value2 += c2;
        continue;
      }
    }
    if (isDigit(c2)) {
      if (state2 === "none" || state2 === "sign" || state2 === "whole") {
        state2 = "whole";
        value2 += c2;
        continue;
      }
      if (state2 === "decimal_point" || state2 === "decimal") {
        state2 = "decimal";
        value2 += c2;
        continue;
      }
      if (state2 === "e" || state2 === "exponent_sign" || state2 === "exponent") {
        state2 = "exponent";
        value2 += c2;
        continue;
      }
    }
    if (c2 === ".") {
      if (state2 === "none" || state2 === "sign" || state2 === "whole") {
        state2 = "decimal_point";
        value2 += c2;
        continue;
      }
    }
    if (c2 === "E" || c2 === "e") {
      if (state2 === "whole" || state2 === "decimal_point" || state2 === "decimal") {
        state2 = "e";
        value2 += c2;
        continue;
      }
    }
    break;
  }
  var number2 = Number.parseFloat(value2);
  if (Number.isNaN(number2)) {
    return [cursor, null];
  }
  return [i - 1, number2];
};
var parsePathData = function parsePathData2(string) {
  var pathData = [];
  var command = null;
  var args = (
    /** @type {number[]} */
    []
  );
  var argsCount = 0;
  var canHaveComma = false;
  var hadComma = false;
  for (var i = 0; i < string.length; i += 1) {
    var c2 = string.charAt(i);
    if (isWsp(c2)) {
      continue;
    }
    if (canHaveComma && c2 === ",") {
      if (hadComma) {
        break;
      }
      hadComma = true;
      continue;
    }
    if (isCommand(c2)) {
      if (hadComma) {
        return pathData;
      }
      if (command == null) {
        if (c2 !== "M" && c2 !== "m") {
          return pathData;
        }
      } else {
        if (args.length !== 0) {
          return pathData;
        }
      }
      command = c2;
      args = [];
      argsCount = argsCountPerCommand[command];
      canHaveComma = false;
      if (argsCount === 0) {
        pathData.push({
          command,
          args
        });
      }
      continue;
    }
    if (command == null) {
      return pathData;
    }
    var newCursor = i;
    var number2 = null;
    if (command === "A" || command === "a") {
      var position = args.length;
      if (position === 0 || position === 1) {
        if (c2 !== "+" && c2 !== "-") {
          var _readNumber = readNumber(string, i);
          newCursor = _readNumber[0];
          number2 = _readNumber[1];
        }
      }
      if (position === 2 || position === 5 || position === 6) {
        var _readNumber2 = readNumber(string, i);
        newCursor = _readNumber2[0];
        number2 = _readNumber2[1];
      }
      if (position === 3 || position === 4) {
        if (c2 === "0") {
          number2 = 0;
        }
        if (c2 === "1") {
          number2 = 1;
        }
      }
    } else {
      var _readNumber3 = readNumber(string, i);
      newCursor = _readNumber3[0];
      number2 = _readNumber3[1];
    }
    if (number2 == null) {
      return pathData;
    }
    args.push(number2);
    canHaveComma = true;
    hadComma = false;
    i = newCursor;
    if (args.length === argsCount) {
      pathData.push({
        command,
        args
      });
      if (command === "M") {
        command = "L";
      }
      if (command === "m") {
        command = "l";
      }
      args = [];
    }
  }
  return pathData;
};
var _apply = function apply(commands, doc) {
  cx = cy = px = py = sx = sy = 0;
  for (var i = 0; i < commands.length; i++) {
    var _commands$i = commands[i], command = _commands$i.command, args = _commands$i.args;
    if (typeof runners[command] === "function") {
      runners[command](doc, args);
    }
  }
};
var runners = {
  M: function M(doc, a2) {
    cx = a2[0];
    cy = a2[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return doc.moveTo(cx, cy);
  },
  m: function m(doc, a2) {
    cx += a2[0];
    cy += a2[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return doc.moveTo(cx, cy);
  },
  C: function C(doc, a2) {
    cx = a2[4];
    cy = a2[5];
    px = a2[2];
    py = a2[3];
    return doc.bezierCurveTo.apply(doc, a2);
  },
  c: function c(doc, a2) {
    doc.bezierCurveTo(a2[0] + cx, a2[1] + cy, a2[2] + cx, a2[3] + cy, a2[4] + cx, a2[5] + cy);
    px = cx + a2[2];
    py = cy + a2[3];
    cx += a2[4];
    return cy += a2[5];
  },
  S: function S(doc, a2) {
    if (px === null) {
      px = cx;
      py = cy;
    }
    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a2[0], a2[1], a2[2], a2[3]);
    px = a2[0];
    py = a2[1];
    cx = a2[2];
    return cy = a2[3];
  },
  s: function s(doc, a2) {
    if (px === null) {
      px = cx;
      py = cy;
    }
    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a2[0], cy + a2[1], cx + a2[2], cy + a2[3]);
    px = cx + a2[0];
    py = cy + a2[1];
    cx += a2[2];
    return cy += a2[3];
  },
  Q: function Q(doc, a2) {
    px = a2[0];
    py = a2[1];
    cx = a2[2];
    cy = a2[3];
    return doc.quadraticCurveTo(a2[0], a2[1], cx, cy);
  },
  q: function q(doc, a2) {
    doc.quadraticCurveTo(a2[0] + cx, a2[1] + cy, a2[2] + cx, a2[3] + cy);
    px = cx + a2[0];
    py = cy + a2[1];
    cx += a2[2];
    return cy += a2[3];
  },
  T: function T(doc, a2) {
    if (px === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    doc.quadraticCurveTo(px, py, a2[0], a2[1]);
    px = cx - (px - cx);
    py = cy - (py - cy);
    cx = a2[0];
    return cy = a2[1];
  },
  t: function t(doc, a2) {
    if (px === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    doc.quadraticCurveTo(px, py, cx + a2[0], cy + a2[1]);
    cx += a2[0];
    return cy += a2[1];
  },
  A: function A(doc, a2) {
    solveArc(doc, cx, cy, a2);
    cx = a2[5];
    return cy = a2[6];
  },
  a: function a(doc, _a) {
    _a[5] += cx;
    _a[6] += cy;
    solveArc(doc, cx, cy, _a);
    cx = _a[5];
    return cy = _a[6];
  },
  L: function L(doc, a2) {
    cx = a2[0];
    cy = a2[1];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  l: function l(doc, a2) {
    cx += a2[0];
    cy += a2[1];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  H: function H(doc, a2) {
    cx = a2[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  h: function h(doc, a2) {
    cx += a2[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  V: function V(doc, a2) {
    cy = a2[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  v: function v(doc, a2) {
    cy += a2[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  Z: function Z(doc) {
    doc.closePath();
    cx = sx;
    return cy = sy;
  },
  z: function z(doc) {
    doc.closePath();
    cx = sx;
    return cy = sy;
  }
};
var solveArc = function solveArc2(doc, x, y, coords) {
  var rx = coords[0], ry = coords[1], rot = coords[2], large = coords[3], sweep = coords[4], ex = coords[5], ey = coords[6];
  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);
  for (var _iterator = _createForOfIteratorHelperLoose(segs), _step; !(_step = _iterator()).done; ) {
    var seg = _step.value;
    var bez = segmentToBezier.apply(void 0, seg);
    doc.bezierCurveTo.apply(doc, bez);
  }
};
var arcToSegments = function arcToSegments2(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
  var th = rotateX * (Math.PI / 180);
  var sin_th = Math.sin(th);
  var cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
  py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
  var pl = px * px / (rx * rx) + py * py / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  var a00 = cos_th / rx;
  var a01 = sin_th / rx;
  var a10 = -sin_th / ry;
  var a11 = cos_th / ry;
  var x0 = a00 * ox + a01 * oy;
  var y0 = a10 * ox + a11 * oy;
  var x1 = a00 * x + a01 * y;
  var y1 = a10 * x + a11 * y;
  var d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
  var sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0) {
    sfactor_sq = 0;
  }
  var sfactor = Math.sqrt(sfactor_sq);
  if (sweep === large) {
    sfactor = -sfactor;
  }
  var xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
  var yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
  var th0 = Math.atan2(y0 - yc, x0 - xc);
  var th1 = Math.atan2(y1 - yc, x1 - xc);
  var th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += 2 * Math.PI;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= 2 * Math.PI;
  }
  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 1e-3)));
  var result = [];
  for (var i = 0; i < segments; i++) {
    var th2 = th0 + i * th_arc / segments;
    var th3 = th0 + (i + 1) * th_arc / segments;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return result;
};
var segmentToBezier = function segmentToBezier2(cx2, cy2, th0, th1, rx, ry, sin_th, cos_th) {
  var a00 = cos_th * rx;
  var a01 = -sin_th * ry;
  var a10 = sin_th * rx;
  var a11 = cos_th * ry;
  var th_half = 0.5 * (th1 - th0);
  var t2 = 8 / 3 * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);
  var x1 = cx2 + Math.cos(th0) - t2 * Math.sin(th0);
  var y1 = cy2 + Math.sin(th0) + t2 * Math.cos(th0);
  var x3 = cx2 + Math.cos(th1);
  var y3 = cy2 + Math.sin(th1);
  var x2 = x3 + t2 * Math.sin(th1);
  var y2 = y3 - t2 * Math.cos(th1);
  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
};
var SVGPath = function() {
  function SVGPath2() {
  }
  SVGPath2.apply = function apply2(doc, path2) {
    var commands = parsePathData(path2);
    _apply(commands, doc);
  };
  return SVGPath2;
}();
var number$1 = PDFObject$1.number;
var KAPPA2 = 4 * ((Math.sqrt(2) - 1) / 3);
var VectorMixin = {
  initVector: function initVector() {
    this._ctm = [1, 0, 0, 1, 0, 0];
    return this._ctmStack = [];
  },
  save: function save() {
    this._ctmStack.push(this._ctm.slice());
    return this.addContent("q");
  },
  restore: function restore() {
    this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];
    return this.addContent("Q");
  },
  closePath: function closePath() {
    return this.addContent("h");
  },
  lineWidth: function lineWidth(w) {
    return this.addContent(number$1(w) + " w");
  },
  _CAP_STYLES: {
    BUTT: 0,
    ROUND: 1,
    SQUARE: 2
  },
  lineCap: function lineCap(c2) {
    if (typeof c2 === "string") {
      c2 = this._CAP_STYLES[c2.toUpperCase()];
    }
    return this.addContent(c2 + " J");
  },
  _JOIN_STYLES: {
    MITER: 0,
    ROUND: 1,
    BEVEL: 2
  },
  lineJoin: function lineJoin(j) {
    if (typeof j === "string") {
      j = this._JOIN_STYLES[j.toUpperCase()];
    }
    return this.addContent(j + " j");
  },
  miterLimit: function miterLimit(m2) {
    return this.addContent(number$1(m2) + " M");
  },
  dash: function dash(length4, options) {
    if (options === void 0) {
      options = {};
    }
    var originalLength = length4;
    if (!Array.isArray(length4)) {
      length4 = [length4, options.space || length4];
    }
    var valid = length4.every(function(x) {
      return Number.isFinite(x) && x >= 0;
    });
    if (!valid) {
      throw new Error("dash(" + JSON.stringify(originalLength) + ", " + JSON.stringify(options) + ") invalid, lengths must be numeric and greater than or equal to zero");
    }
    length4 = length4.map(number$1).join(" ");
    return this.addContent("[" + length4 + "] " + number$1(options.phase || 0) + " d");
  },
  undash: function undash() {
    return this.addContent("[] 0 d");
  },
  moveTo: function moveTo(x, y) {
    return this.addContent(number$1(x) + " " + number$1(y) + " m");
  },
  lineTo: function lineTo(x, y) {
    return this.addContent(number$1(x) + " " + number$1(y) + " l");
  },
  bezierCurveTo: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    return this.addContent(number$1(cp1x) + " " + number$1(cp1y) + " " + number$1(cp2x) + " " + number$1(cp2y) + " " + number$1(x) + " " + number$1(y) + " c");
  },
  quadraticCurveTo: function quadraticCurveTo(cpx, cpy, x, y) {
    return this.addContent(number$1(cpx) + " " + number$1(cpy) + " " + number$1(x) + " " + number$1(y) + " v");
  },
  rect: function rect(x, y, w, h2) {
    return this.addContent(number$1(x) + " " + number$1(y) + " " + number$1(w) + " " + number$1(h2) + " re");
  },
  roundedRect: function roundedRect(x, y, w, h2, r) {
    if (r == null) {
      r = 0;
    }
    r = Math.min(r, 0.5 * w, 0.5 * h2);
    var c2 = r * (1 - KAPPA2);
    this.moveTo(x + r, y);
    this.lineTo(x + w - r, y);
    this.bezierCurveTo(x + w - c2, y, x + w, y + c2, x + w, y + r);
    this.lineTo(x + w, y + h2 - r);
    this.bezierCurveTo(x + w, y + h2 - c2, x + w - c2, y + h2, x + w - r, y + h2);
    this.lineTo(x + r, y + h2);
    this.bezierCurveTo(x + c2, y + h2, x, y + h2 - c2, x, y + h2 - r);
    this.lineTo(x, y + r);
    this.bezierCurveTo(x, y + c2, x + c2, y, x + r, y);
    return this.closePath();
  },
  ellipse: function ellipse(x, y, r1, r2) {
    if (r2 == null) {
      r2 = r1;
    }
    x -= r1;
    y -= r2;
    var ox = r1 * KAPPA2;
    var oy = r2 * KAPPA2;
    var xe = x + r1 * 2;
    var ye = y + r2 * 2;
    var xm = x + r1;
    var ym = y + r2;
    this.moveTo(x, ym);
    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
    return this.closePath();
  },
  circle: function circle(x, y, radius) {
    return this.ellipse(x, y, radius);
  },
  arc: function arc(x, y, radius, startAngle, endAngle, anticlockwise) {
    if (anticlockwise == null) {
      anticlockwise = false;
    }
    var TWO_PI = 2 * Math.PI;
    var HALF_PI = 0.5 * Math.PI;
    var deltaAng = endAngle - startAngle;
    if (Math.abs(deltaAng) > TWO_PI) {
      deltaAng = TWO_PI;
    } else if (deltaAng !== 0 && anticlockwise !== deltaAng < 0) {
      var dir = anticlockwise ? -1 : 1;
      deltaAng = dir * TWO_PI + deltaAng;
    }
    var numSegs = Math.ceil(Math.abs(deltaAng) / HALF_PI);
    var segAng = deltaAng / numSegs;
    var handleLen = segAng / HALF_PI * KAPPA2 * radius;
    var curAng = startAngle;
    var deltaCx = -Math.sin(curAng) * handleLen;
    var deltaCy = Math.cos(curAng) * handleLen;
    var ax = x + Math.cos(curAng) * radius;
    var ay = y + Math.sin(curAng) * radius;
    this.moveTo(ax, ay);
    for (var segIdx = 0; segIdx < numSegs; segIdx++) {
      var cp1x = ax + deltaCx;
      var cp1y = ay + deltaCy;
      curAng += segAng;
      ax = x + Math.cos(curAng) * radius;
      ay = y + Math.sin(curAng) * radius;
      deltaCx = -Math.sin(curAng) * handleLen;
      deltaCy = Math.cos(curAng) * handleLen;
      var cp2x = ax - deltaCx;
      var cp2y = ay - deltaCy;
      this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ax, ay);
    }
    return this;
  },
  polygon: function polygon() {
    for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
      points[_key] = arguments[_key];
    }
    this.moveTo.apply(this, points.shift() || []);
    for (var _i = 0, _points = points; _i < _points.length; _i++) {
      var point = _points[_i];
      this.lineTo.apply(this, point || []);
    }
    return this.closePath();
  },
  path: function path(_path) {
    SVGPath.apply(this, _path);
    return this;
  },
  _windingRule: function _windingRule(rule) {
    if (/even-?odd/.test(rule)) {
      return "*";
    }
    return "";
  },
  fill: function fill3(color, rule) {
    if (/(even-?odd)|(non-?zero)/.test(color)) {
      rule = color;
      color = null;
    }
    if (color) {
      this.fillColor(color);
    }
    return this.addContent("f" + this._windingRule(rule));
  },
  stroke: function stroke(color) {
    if (color) {
      this.strokeColor(color);
    }
    return this.addContent("S");
  },
  fillAndStroke: function fillAndStroke(fillColor2, strokeColor2, rule) {
    if (strokeColor2 == null) {
      strokeColor2 = fillColor2;
    }
    var isFillRule = /(even-?odd)|(non-?zero)/;
    if (isFillRule.test(fillColor2)) {
      rule = fillColor2;
      fillColor2 = null;
    }
    if (isFillRule.test(strokeColor2)) {
      rule = strokeColor2;
      strokeColor2 = fillColor2;
    }
    if (fillColor2) {
      this.fillColor(fillColor2);
      this.strokeColor(strokeColor2);
    }
    return this.addContent("B" + this._windingRule(rule));
  },
  clip: function clip(rule) {
    return this.addContent("W" + this._windingRule(rule) + " n");
  },
  transform: function transform(m11, m12, m21, m22, dx, dy) {
    if (m11 === 1 && m12 === 0 && m21 === 0 && m22 === 1 && dx === 0 && dy === 0) {
      return this;
    }
    var m2 = this._ctm;
    var m0 = m2[0], m1 = m2[1], m23 = m2[2], m3 = m2[3], m4 = m2[4], m5 = m2[5];
    m2[0] = m0 * m11 + m23 * m12;
    m2[1] = m1 * m11 + m3 * m12;
    m2[2] = m0 * m21 + m23 * m22;
    m2[3] = m1 * m21 + m3 * m22;
    m2[4] = m0 * dx + m23 * dy + m4;
    m2[5] = m1 * dx + m3 * dy + m5;
    var values = [m11, m12, m21, m22, dx, dy].map(function(v2) {
      return number$1(v2);
    }).join(" ");
    return this.addContent(values + " cm");
  },
  translate: function translate(x, y) {
    return this.transform(1, 0, 0, 1, x, y);
  },
  rotate: function rotate(angle, options) {
    if (options === void 0) {
      options = {};
    }
    var y;
    var rad = angle * Math.PI / 180;
    var cos = Math.cos(rad);
    var sin = Math.sin(rad);
    var x = y = 0;
    if (options.origin != null) {
      var _options$origin = options.origin;
      x = _options$origin[0];
      y = _options$origin[1];
      var x1 = x * cos - y * sin;
      var y1 = x * sin + y * cos;
      x -= x1;
      y -= y1;
    }
    return this.transform(cos, sin, -sin, cos, x, y);
  },
  scale: function scale(xFactor, yFactor, options) {
    if (options === void 0) {
      options = {};
    }
    var y;
    if (yFactor == null) {
      yFactor = xFactor;
    }
    if (typeof yFactor === "object") {
      options = yFactor;
      yFactor = xFactor;
    }
    var x = y = 0;
    if (options.origin != null) {
      var _options$origin2 = options.origin;
      x = _options$origin2[0];
      y = _options$origin2[1];
      x -= xFactor * x;
      y -= yFactor * y;
    }
    return this.transform(xFactor, 0, 0, yFactor, x, y);
  }
};
var fs = {};
var range = function range2(left, right, inclusive) {
  var range3 = [];
  var ascending = left < right;
  var end3 = !inclusive ? right : ascending ? right + 1 : right - 1;
  for (var i = left; ascending ? i < end3 : i > end3; ascending ? i++ : i--) {
    range3.push(i);
  }
  return range3;
};
var WIN_ANSI_MAP = {
  402: 131,
  8211: 150,
  8212: 151,
  8216: 145,
  8217: 146,
  8218: 130,
  8220: 147,
  8221: 148,
  8222: 132,
  8224: 134,
  8225: 135,
  8226: 149,
  8230: 133,
  8364: 128,
  8240: 137,
  8249: 139,
  8250: 155,
  710: 136,
  8482: 153,
  338: 140,
  339: 156,
  732: 152,
  352: 138,
  353: 154,
  376: 159,
  381: 142,
  382: 158
};
var characters = ".notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n\nspace         exclam         quotedbl       numbersign\ndollar        percent        ampersand      quotesingle\nparenleft     parenright     asterisk       plus\ncomma         hyphen         period         slash\nzero          one            two            three\nfour          five           six            seven\neight         nine           colon          semicolon\nless          equal          greater        question\n\nat            A              B              C\nD             E              F              G\nH             I              J              K\nL             M              N              O\nP             Q              R              S\nT             U              V              W\nX             Y              Z              bracketleft\nbackslash     bracketright   asciicircum    underscore\n\ngrave         a              b              c\nd             e              f              g\nh             i              j              k\nl             m              n              o\np             q              r              s\nt             u              v              w\nx             y              z              braceleft\nbar           braceright     asciitilde     .notdef\n\nEuro          .notdef        quotesinglbase florin\nquotedblbase  ellipsis       dagger         daggerdbl\ncircumflex    perthousand    Scaron         guilsinglleft\nOE            .notdef        Zcaron         .notdef\n.notdef       quoteleft      quoteright     quotedblleft\nquotedblright bullet         endash         emdash\ntilde         trademark      scaron         guilsinglright\noe            .notdef        zcaron         ydieresis\n\nspace         exclamdown     cent           sterling\ncurrency      yen            brokenbar      section\ndieresis      copyright      ordfeminine    guillemotleft\nlogicalnot    hyphen         registered     macron\ndegree        plusminus      twosuperior    threesuperior\nacute         mu             paragraph      periodcentered\ncedilla       onesuperior    ordmasculine   guillemotright\nonequarter    onehalf        threequarters  questiondown\n\nAgrave        Aacute         Acircumflex    Atilde\nAdieresis     Aring          AE             Ccedilla\nEgrave        Eacute         Ecircumflex    Edieresis\nIgrave        Iacute         Icircumflex    Idieresis\nEth           Ntilde         Ograve         Oacute\nOcircumflex   Otilde         Odieresis      multiply\nOslash        Ugrave         Uacute         Ucircumflex\nUdieresis     Yacute         Thorn          germandbls\n\nagrave        aacute         acircumflex    atilde\nadieresis     aring          ae             ccedilla\negrave        eacute         ecircumflex    edieresis\nigrave        iacute         icircumflex    idieresis\neth           ntilde         ograve         oacute\nocircumflex   otilde         odieresis      divide\noslash        ugrave         uacute         ucircumflex\nudieresis     yacute         thorn          ydieresis".split(/\s+/);
function _parse(contents) {
  var obj = {
    attributes: {},
    glyphWidths: {},
    kernPairs: {}
  };
  var section = "";
  for (var _iterator = _createForOfIteratorHelperLoose(contents.split("\n")), _step; !(_step = _iterator()).done; ) {
    var line2 = _step.value;
    var match;
    var a2;
    if (match = line2.match(/^Start(\w+)/)) {
      section = match[1];
      continue;
    } else if (match = line2.match(/^End(\w+)/)) {
      section = "";
      continue;
    }
    switch (section) {
      case "FontMetrics":
        match = line2.match(/(^\w+)\s+(.*)/);
        var key = match[1];
        var value2 = match[2];
        if (a2 = obj.attributes[key]) {
          if (!Array.isArray(a2)) {
            a2 = obj.attributes[key] = [a2];
          }
          a2.push(value2);
        } else {
          obj.attributes[key] = value2;
        }
        break;
      case "CharMetrics":
        if (!/^CH?\s/.test(line2)) {
          continue;
        }
        var name2 = line2.match(/\bN\s+(\.?\w+)\s*;/)[1];
        obj.glyphWidths[name2] = +line2.match(/\bWX\s+(\d+)\s*;/)[1];
        break;
      case "KernPairs":
        match = line2.match(/^KPX\s+(\.?\w+)\s+(\.?\w+)\s+(-?\d+)/);
        if (match) {
          obj.kernPairs[match[1] + match[2]] = parseInt(match[3]);
        }
        break;
    }
  }
  return obj;
}
var AFMFont = function() {
  AFMFont2.open = function open(filename) {
    {
      throw new Error("AFMFont.open not available on browser build");
    }
  };
  AFMFont2.fromJson = function fromJson(json) {
    return new AFMFont2(json);
  };
  function AFMFont2(contents) {
    var _this = this;
    if (typeof contents === "string") {
      this.contents = contents;
      this.parse();
    } else {
      this.attributes = contents.attributes;
      this.glyphWidths = contents.glyphWidths;
      this.kernPairs = contents.kernPairs;
    }
    this.charWidths = range(0, 255, true).map(function(i) {
      return _this.glyphWidths[characters[i]];
    });
    this.bbox = Array.from(this.attributes.FontBBox.split(/\s+/)).map(function(e) {
      return +e;
    });
    this.ascender = +(this.attributes.Ascender || 0);
    this.descender = +(this.attributes.Descender || 0);
    this.xHeight = +(this.attributes.XHeight || 0);
    this.capHeight = +(this.attributes.CapHeight || 0);
    this.lineGap = this.bbox[3] - this.bbox[1] - (this.ascender - this.descender);
  }
  var _proto = AFMFont2.prototype;
  _proto.parse = function parse3() {
    var parsed = _parse(this.contents);
    this.attributes = parsed.attributes;
    this.glyphWidths = parsed.glyphWidths;
    this.kernPairs = parsed.kernPairs;
  };
  _proto.encodeText = function encodeText(text2) {
    var res = [];
    for (var i = 0, end3 = text2.length, asc = 0 <= end3; asc ? i < end3 : i > end3; asc ? i++ : i--) {
      var char = text2.charCodeAt(i);
      char = WIN_ANSI_MAP[char] || char;
      res.push(char.toString(16));
    }
    return res;
  };
  _proto.glyphsForString = function glyphsForString(string) {
    var glyphs = [];
    for (var i = 0, end3 = string.length, asc = 0 <= end3; asc ? i < end3 : i > end3; asc ? i++ : i--) {
      var charCode = string.charCodeAt(i);
      glyphs.push(this.characterToGlyph(charCode));
    }
    return glyphs;
  };
  _proto.characterToGlyph = function characterToGlyph(character) {
    return characters[WIN_ANSI_MAP[character] || character] || ".notdef";
  };
  _proto.widthOfGlyph = function widthOfGlyph(glyph) {
    return this.glyphWidths[glyph] || 0;
  };
  _proto.getKernPair = function getKernPair(left, right) {
    return this.kernPairs[left + right] || 0;
  };
  _proto.advancesForGlyphs = function advancesForGlyphs(glyphs) {
    var advances = [];
    for (var index2 = 0; index2 < glyphs.length; index2++) {
      var left = glyphs[index2];
      var right = glyphs[index2 + 1];
      advances.push(this.widthOfGlyph(left) + this.getKernPair(left, right));
    }
    return advances;
  };
  return AFMFont2;
}();
var attributes = [
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:43:52 1997",
      "UniqueID 43052",
      "VMusage 37169 48194"
    ],
    FontName: "Helvetica-Bold",
    FullName: "Helvetica Bold",
    FamilyName: "Helvetica",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-170 -228 1003 962 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "532",
    Ascender: "718",
    Descender: "-207",
    StdHW: "118",
    StdVW: "140"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:45:12 1997",
      "UniqueID 43053",
      "VMusage 14482 68586"
    ],
    FontName: "Helvetica-BoldOblique",
    FullName: "Helvetica Bold Oblique",
    FamilyName: "Helvetica",
    Weight: "Bold",
    ItalicAngle: "-12",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-174 -228 1114 962",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "532",
    Ascender: "718",
    Descender: "-207",
    StdHW: "118",
    StdVW: "140"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:44:31 1997",
      "UniqueID 43055",
      "VMusage 14960 69346"
    ],
    FontName: "Helvetica-Oblique",
    FullName: "Helvetica Oblique",
    FamilyName: "Helvetica",
    Weight: "Medium",
    ItalicAngle: "-12",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-170 -225 1116 931 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "523",
    Ascender: "718",
    Descender: "-207",
    StdHW: "76",
    StdVW: "88"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:38:23 1997",
      "UniqueID 43054",
      "VMusage 37069 48094"
    ],
    FontName: "Helvetica",
    FullName: "Helvetica",
    FamilyName: "Helvetica",
    Weight: "Medium",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-166 -225 1000 931 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "523",
    Ascender: "718",
    Descender: "-207",
    StdHW: "76",
    StdVW: "88"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:52:56 1997",
      "UniqueID 43065",
      "VMusage 41636 52661"
    ],
    FontName: "Times-Bold",
    FullName: "Times Bold",
    FamilyName: "Times",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-168 -218 1000 935 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "676",
    XHeight: "461",
    Ascender: "683",
    Descender: "-217",
    StdHW: "44",
    StdVW: "139"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 13:04:06 1997",
      "UniqueID 43066",
      "VMusage 45874 56899"
    ],
    FontName: "Times-BoldItalic",
    FullName: "Times Bold Italic",
    FamilyName: "Times",
    Weight: "Bold",
    ItalicAngle: "-15",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-200 -218 996 921",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "669",
    XHeight: "462",
    Ascender: "683",
    Descender: "-217",
    StdHW: "42",
    StdVW: "121"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:56:55 1997",
      "UniqueID 43067",
      "VMusage 47727 58752"
    ],
    FontName: "Times-Italic",
    FullName: "Times Italic",
    FamilyName: "Times",
    Weight: "Medium",
    ItalicAngle: "-15.5",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-169 -217 1010 883 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "653",
    XHeight: "441",
    Ascender: "683",
    Descender: "-217",
    StdHW: "32",
    StdVW: "76"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:49:17 1997",
      "UniqueID 43068",
      "VMusage 43909 54934"
    ],
    FontName: "Times-Roman",
    FullName: "Times Roman",
    FamilyName: "Times",
    Weight: "Roman",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-168 -218 1000 898 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "662",
    XHeight: "450",
    Ascender: "683",
    Descender: "-217",
    StdHW: "28",
    StdVW: "84"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Mon Jun 23 16:28:00 1997",
      "UniqueID 43048",
      "VMusage 41139 52164"
    ],
    FontName: "Courier-Bold",
    FullName: "Courier Bold",
    FamilyName: "Courier",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-113 -250 749 801 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "439",
    Ascender: "629",
    Descender: "-157",
    StdHW: "84",
    StdVW: "106"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Mon Jun 23 16:28:46 1997",
      "UniqueID 43049",
      "VMusage 17529 79244"
    ],
    FontName: "Courier-BoldOblique",
    FullName: "Courier Bold Oblique",
    FamilyName: "Courier",
    Weight: "Bold",
    ItalicAngle: "-12",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-57 -250 869 801",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "439",
    Ascender: "629",
    Descender: "-157",
    StdHW: "84",
    StdVW: "106"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 17:37:52 1997",
      "UniqueID 43051",
      "VMusage 16248 75829"
    ],
    FontName: "Courier-Oblique",
    FullName: "Courier Oblique",
    FamilyName: "Courier",
    Weight: "Medium",
    ItalicAngle: "-12",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-27 -250 849 805 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "426",
    Ascender: "629",
    Descender: "-157",
    StdHW: "51",
    StdVW: "51"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 17:27:09 1997",
      "UniqueID 43050",
      "VMusage 39754 50779"
    ],
    FontName: "Courier",
    FullName: "Courier",
    FamilyName: "Courier",
    Weight: "Medium",
    ItalicAngle: "0",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-23 -250 715 805 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "426",
    Ascender: "629",
    Descender: "-157",
    StdHW: "51",
    StdVW: "51"
  }
];
var glyphWidths = {
  space: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  exclam: [
    333,
    333,
    278,
    278,
    333,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  quotedbl: [
    474,
    474,
    355,
    355,
    555,
    555,
    420,
    408,
    600,
    600,
    600,
    600
  ],
  numbersign: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  dollar: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  percent: [
    889,
    889,
    889,
    889,
    1e3,
    833,
    833,
    833,
    600,
    600,
    600,
    600
  ],
  ampersand: [
    722,
    722,
    667,
    667,
    833,
    778,
    778,
    778,
    600,
    600,
    600,
    600
  ],
  quoteright: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  parenleft: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  parenright: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  asterisk: [
    389,
    389,
    389,
    389,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  plus: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  comma: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  hyphen: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  period: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  slash: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  zero: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  one: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  two: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  three: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  four: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  five: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  six: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  seven: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  eight: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  nine: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  colon: [
    333,
    333,
    278,
    278,
    333,
    333,
    333,
    278,
    600,
    600,
    600,
    600
  ],
  semicolon: [
    333,
    333,
    278,
    278,
    333,
    333,
    333,
    278,
    600,
    600,
    600,
    600
  ],
  less: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  equal: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  greater: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  question: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  at: [
    975,
    975,
    1015,
    1015,
    930,
    832,
    920,
    921,
    600,
    600,
    600,
    600
  ],
  A: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  B: [
    722,
    722,
    667,
    667,
    667,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  C: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  D: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  E: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  F: [
    611,
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  G: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  H: [
    722,
    722,
    722,
    722,
    778,
    778,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  I: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  J: [
    556,
    556,
    500,
    500,
    500,
    500,
    444,
    389,
    600,
    600,
    600,
    600
  ],
  K: [
    722,
    722,
    667,
    667,
    778,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  L: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  M: [
    833,
    833,
    833,
    833,
    944,
    889,
    833,
    889,
    600,
    600,
    600,
    600
  ],
  N: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  O: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  P: [
    667,
    667,
    667,
    667,
    611,
    611,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  Q: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  R: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  S: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  T: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  U: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  V: [
    667,
    667,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  W: [
    944,
    944,
    944,
    944,
    1e3,
    889,
    833,
    944,
    600,
    600,
    600,
    600
  ],
  X: [
    667,
    667,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Y: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  Z: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  bracketleft: [
    333,
    333,
    278,
    278,
    333,
    333,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  backslash: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  bracketright: [
    333,
    333,
    278,
    278,
    333,
    333,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  asciicircum: [
    584,
    584,
    469,
    469,
    581,
    570,
    422,
    469,
    600,
    600,
    600,
    600
  ],
  underscore: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  quoteleft: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  a: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  b: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  c: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  d: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  e: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  f: [
    333,
    333,
    278,
    278,
    333,
    333,
    278,
    333,
    600,
    600,
    600,
    600
  ],
  g: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  h: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  i: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  j: [
    278,
    278,
    222,
    222,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  k: [
    556,
    556,
    500,
    500,
    556,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  l: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  m: [
    889,
    889,
    833,
    833,
    833,
    778,
    722,
    778,
    600,
    600,
    600,
    600
  ],
  n: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  o: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  p: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  q: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  r: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  s: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  t: [
    333,
    333,
    278,
    278,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  u: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  v: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  w: [
    778,
    778,
    722,
    722,
    722,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  x: [
    556,
    556,
    500,
    500,
    500,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  y: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  z: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  braceleft: [
    389,
    389,
    334,
    334,
    394,
    348,
    400,
    480,
    600,
    600,
    600,
    600
  ],
  bar: [
    280,
    280,
    260,
    260,
    220,
    220,
    275,
    200,
    600,
    600,
    600,
    600
  ],
  braceright: [
    389,
    389,
    334,
    334,
    394,
    348,
    400,
    480,
    600,
    600,
    600,
    600
  ],
  asciitilde: [
    584,
    584,
    584,
    584,
    520,
    570,
    541,
    541,
    600,
    600,
    600,
    600
  ],
  exclamdown: [
    333,
    333,
    333,
    333,
    333,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  cent: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  sterling: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  fraction: [
    167,
    167,
    167,
    167,
    167,
    167,
    167,
    167,
    600,
    600,
    600,
    600
  ],
  yen: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  florin: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  section: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  currency: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  quotesingle: [
    238,
    238,
    191,
    191,
    278,
    278,
    214,
    180,
    600,
    600,
    600,
    600
  ],
  quotedblleft: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  guillemotleft: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  guilsinglleft: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  guilsinglright: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  fi: [
    611,
    611,
    500,
    500,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  fl: [
    611,
    611,
    500,
    500,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  endash: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  dagger: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  daggerdbl: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  periodcentered: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  paragraph: [
    556,
    556,
    537,
    537,
    540,
    500,
    523,
    453,
    600,
    600,
    600,
    600
  ],
  bullet: [
    350,
    350,
    350,
    350,
    350,
    350,
    350,
    350,
    600,
    600,
    600,
    600
  ],
  quotesinglbase: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  quotedblbase: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  quotedblright: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  guillemotright: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ellipsis: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    889,
    1e3,
    600,
    600,
    600,
    600
  ],
  perthousand: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    600,
    600,
    600,
    600
  ],
  questiondown: [
    611,
    611,
    611,
    611,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  grave: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  acute: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  circumflex: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  tilde: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  macron: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  breve: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  dotaccent: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  dieresis: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ring: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  cedilla: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  hungarumlaut: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ogonek: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  caron: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  emdash: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    889,
    1e3,
    600,
    600,
    600,
    600
  ],
  AE: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    944,
    889,
    889,
    600,
    600,
    600,
    600
  ],
  ordfeminine: [
    370,
    370,
    370,
    370,
    300,
    266,
    276,
    276,
    600,
    600,
    600,
    600
  ],
  Lslash: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Oslash: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  OE: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    944,
    944,
    889,
    600,
    600,
    600,
    600
  ],
  ordmasculine: [
    365,
    365,
    365,
    365,
    330,
    300,
    310,
    310,
    600,
    600,
    600,
    600
  ],
  ae: [
    889,
    889,
    889,
    889,
    722,
    722,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  dotlessi: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  lslash: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  oslash: [
    611,
    611,
    611,
    611,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  oe: [
    944,
    944,
    944,
    944,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  germandbls: [
    611,
    611,
    611,
    611,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Idieresis: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  eacute: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  abreve: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  uhungarumlaut: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ecaron: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Ydieresis: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  divide: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  Yacute: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  Acircumflex: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  aacute: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Ucircumflex: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  yacute: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  scommaaccent: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  ecircumflex: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Uring: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Udieresis: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  aogonek: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Uacute: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  uogonek: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Edieresis: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  Dcroat: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  commaaccent: [
    250,
    250,
    250,
    250,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  copyright: [
    737,
    737,
    737,
    737,
    747,
    747,
    760,
    760,
    600,
    600,
    600,
    600
  ],
  Emacron: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  ccaron: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  aring: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Ncommaaccent: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  lacute: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  agrave: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Tcommaaccent: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Cacute: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  atilde: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Edotaccent: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  scaron: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  scedilla: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  iacute: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  lozenge: [
    494,
    494,
    471,
    471,
    494,
    494,
    471,
    471,
    600,
    600,
    600,
    600
  ],
  Rcaron: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Gcommaaccent: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  ucircumflex: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  acircumflex: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Amacron: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  rcaron: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  ccedilla: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Zdotaccent: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Thorn: [
    667,
    667,
    667,
    667,
    611,
    611,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  Omacron: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Racute: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Sacute: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  dcaron: [
    743,
    743,
    643,
    643,
    672,
    608,
    544,
    588,
    600,
    600,
    600,
    600
  ],
  Umacron: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  uring: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  threesuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  Ograve: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Agrave: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Abreve: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  multiply: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  uacute: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Tcaron: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  partialdiff: [
    494,
    494,
    476,
    476,
    494,
    494,
    476,
    476,
    600,
    600,
    600,
    600
  ],
  ydieresis: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  Nacute: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  icircumflex: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Ecircumflex: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  adieresis: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  edieresis: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  cacute: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  nacute: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  umacron: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Ncaron: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  Iacute: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  plusminus: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  brokenbar: [
    280,
    280,
    260,
    260,
    220,
    220,
    275,
    200,
    600,
    600,
    600,
    600
  ],
  registered: [
    737,
    737,
    737,
    737,
    747,
    747,
    760,
    760,
    600,
    600,
    600,
    600
  ],
  Gbreve: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Idotaccent: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  summation: [
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600
  ],
  Egrave: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  racute: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  omacron: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Zacute: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Zcaron: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  greaterequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  Eth: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Ccedilla: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  lcommaaccent: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  tcaron: [
    389,
    389,
    317,
    317,
    416,
    366,
    300,
    326,
    600,
    600,
    600,
    600
  ],
  eogonek: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Uogonek: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Aacute: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Adieresis: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  egrave: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  zacute: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  iogonek: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Oacute: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  oacute: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  amacron: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  sacute: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  idieresis: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Ocircumflex: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Ugrave: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Delta: [
    612,
    612,
    612,
    612,
    612,
    612,
    612,
    612,
    600,
    600,
    600,
    600
  ],
  thorn: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  twosuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  Odieresis: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  mu: [
    611,
    611,
    556,
    556,
    556,
    576,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  igrave: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  ohungarumlaut: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Eogonek: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  dcroat: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  threequarters: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  Scedilla: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  lcaron: [
    400,
    400,
    299,
    299,
    394,
    382,
    300,
    344,
    600,
    600,
    600,
    600
  ],
  Kcommaaccent: [
    722,
    722,
    667,
    667,
    778,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  Lacute: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  trademark: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    980,
    980,
    600,
    600,
    600,
    600
  ],
  edotaccent: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Igrave: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  Imacron: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  Lcaron: [
    611,
    611,
    556,
    556,
    667,
    611,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  onehalf: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  lessequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  ocircumflex: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ntilde: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Uhungarumlaut: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Eacute: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  emacron: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  gbreve: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  onequarter: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  Scaron: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  Scommaaccent: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  Ohungarumlaut: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  degree: [
    400,
    400,
    400,
    400,
    400,
    400,
    400,
    400,
    600,
    600,
    600,
    600
  ],
  ograve: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Ccaron: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  ugrave: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  radical: [
    549,
    549,
    453,
    453,
    549,
    549,
    453,
    453,
    600,
    600,
    600,
    600
  ],
  Dcaron: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  rcommaaccent: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  Ntilde: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  otilde: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Rcommaaccent: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Lcommaaccent: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Atilde: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Aogonek: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Aring: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Otilde: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  zdotaccent: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  Ecaron: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  Iogonek: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  kcommaaccent: [
    556,
    556,
    500,
    500,
    556,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  minus: [
    584,
    584,
    584,
    584,
    570,
    606,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  Icircumflex: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ncaron: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  tcommaaccent: [
    333,
    333,
    278,
    278,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  logicalnot: [
    584,
    584,
    584,
    584,
    570,
    606,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  odieresis: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  udieresis: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  notequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  gcommaaccent: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  eth: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  zcaron: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  ncommaaccent: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  onesuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  imacron: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Euro: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ]
};
var kernPairs = {
  AC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  ATcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  ATcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Au: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Audieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Augrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Av: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Ay: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Ayacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AacuteC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AacuteT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AacuteW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AacuteY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AacuteYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AacuteYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aacuteu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacutev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aacutew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Aacutey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aacuteyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aacuteydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AbreveC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AbreveT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AbreveW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AbreveY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AbreveYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AbreveYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Abreveu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abrevev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Abrevew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Abrevey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Abreveyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Abreveydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AcircumflexC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AcircumflexT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AcircumflexW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AcircumflexY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AcircumflexYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AcircumflexYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Acircumflexu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Acircumflexw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Acircumflexy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Acircumflexyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Acircumflexydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AdieresisC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AdieresisT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AdieresisW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AdieresisY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AdieresisYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AdieresisYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Adieresisu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Adieresisw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Adieresisy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Adieresisyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Adieresisydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AgraveC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AgraveT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AgraveW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AgraveY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AgraveYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AgraveYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Agraveu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agravev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Agravew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Agravey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Agraveyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Agraveydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AmacronC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AmacronT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AmacronW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AmacronY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AmacronYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AmacronYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Amacronu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Amacronw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Amacrony: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Amacronyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Amacronydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AogonekC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AogonekT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AogonekW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AogonekY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AogonekYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AogonekYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aogoneku: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aogonekw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -52
  ],
  Aogoneky: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  Aogonekyacute: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  Aogonekydieresis: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  AringC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AringT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AringW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AringY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AringYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AringYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aringu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aringw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Aringy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aringyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aringydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AtildeC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AtildeT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AtildeW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AtildeY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AtildeYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AtildeYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Atildeu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Atildew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Atildey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Atildeyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Atildeydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  BA: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAacute: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAbreve: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAcircumflex: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAdieresis: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAgrave: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAmacron: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAogonek: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAring: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAtilde: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BU: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUacute: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUcircumflex: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUdieresis: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUgrave: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUhungarumlaut: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUmacron: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUogonek: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUring: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  DA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  DcaronA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DcaronW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DcaronY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcaronYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcaronYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcaroncomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dcaronperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  DcroatA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DcroatW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DcroatY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcroatYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcroatYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcroatcomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dcroatperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  FA: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAacute: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAbreve: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAcircumflex: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAdieresis: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAgrave: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAmacron: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAogonek: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAring: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAtilde: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  Fa: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faacute: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fabreve: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Facircumflex: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fadieresis: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fagrave: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Famacron: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faogonek: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faring: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fatilde: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fcomma: [
    -100,
    -100,
    -150,
    -150,
    -92,
    -129,
    -135,
    -80
  ],
  Fperiod: [
    -100,
    -100,
    -150,
    -150,
    -110,
    -129,
    -135,
    -80
  ],
  JA: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAbreve: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAogonek: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAring: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  Jcomma: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    -25
  ],
  Jperiod: [
    -20,
    -20,
    -30,
    -30,
    -20,
    -10,
    -25
  ],
  Ju: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juacute: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jucircumflex: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Judieresis: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jugrave: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jumacron: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juogonek: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juring: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  KO: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOacute: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOcircumflex: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOdieresis: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOgrave: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOhungarumlaut: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOmacron: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOslash: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOtilde: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  Ke: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Keacute: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kecaron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kecircumflex: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kedieresis: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kedotaccent: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kegrave: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kemacron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Keogonek: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Ko: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Koacute: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kocircumflex: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kodieresis: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kograve: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kohungarumlaut: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Komacron: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Koslash: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kotilde: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Ku: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuacute: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kudieresis: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kugrave: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kumacron: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuogonek: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuring: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Ky: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kyacute: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kydieresis: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  KcommaaccentO: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOacute: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOcircumflex: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOdieresis: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOgrave: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOhungarumlaut: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOmacron: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOslash: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOtilde: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  Kcommaaccente: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccenteacute: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentecaron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentecircumflex: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentedieresis: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentedotaccent: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentegrave: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentemacron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccenteogonek: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccento: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentoacute: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentocircumflex: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentodieresis: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentograve: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentohungarumlaut: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentomacron: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentoslash: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentotilde: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentu: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuacute: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentudieresis: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentugrave: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentumacron: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuogonek: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccenturing: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccenty: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kcommaaccentyacute: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kcommaaccentydieresis: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  LT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Ly: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LacuteT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LacuteW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LacuteY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LacuteYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LacuteYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lacutequotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lacutequoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lacutey: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lacuteyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lacuteydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LcommaaccentT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LcommaaccentW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LcommaaccentY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LcommaaccentYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LcommaaccentYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lcommaaccentquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lcommaaccentquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lcommaaccenty: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lcommaaccentyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lcommaaccentydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LslashT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LslashW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LslashY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LslashYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LslashYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lslashquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lslashquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lslashy: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lslashyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lslashydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  OA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ocomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Operiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OacuteA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OacuteX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Oacutecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Oacuteperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OcircumflexX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ocircumflexcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ocircumflexperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OdieresisX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Odieresiscomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Odieresisperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OgraveA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OgraveX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ogravecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ograveperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OhungarumlautX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ohungarumlautcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ohungarumlautperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OmacronA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OmacronX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Omacroncomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Omacronperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OslashA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OslashW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OslashX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OslashY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OslashYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OslashYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Oslashcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Oslashperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OtildeA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OtildeX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Otildecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Otildeperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  PA: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAacute: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAbreve: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAcircumflex: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAdieresis: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAgrave: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAmacron: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAogonek: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAring: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAtilde: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  Pa: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paacute: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pabreve: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pacircumflex: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Padieresis: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pagrave: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pamacron: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paogonek: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paring: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Patilde: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pcomma: [
    -120,
    -120,
    -180,
    -180,
    -92,
    -129,
    -135,
    -111
  ],
  Pe: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Peacute: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pecaron: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pecircumflex: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pedieresis: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pedotaccent: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pegrave: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pemacron: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Peogonek: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Po: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Poacute: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pocircumflex: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Podieresis: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pograve: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pohungarumlaut: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pomacron: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Poslash: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Potilde: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pperiod: [
    -120,
    -120,
    -180,
    -180,
    -110,
    -129,
    -135,
    -111
  ],
  QU: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUacute: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUcircumflex: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUdieresis: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUgrave: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUhungarumlaut: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUmacron: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUogonek: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUring: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  Qcomma: [
    20,
    20
  ],
  Qperiod: [
    20,
    20,
    0,
    0,
    -20
  ],
  RO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RacuteW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RacuteY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RcaronW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RcaronY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RcommaaccentW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RcommaaccentY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  TA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Ta: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Taacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Taogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Taring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Te: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Teacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -70
  ],
  Tedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Temacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Teogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Thyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  To: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Toacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Todieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Toslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Totilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Trcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Turing: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Ty: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  TcaronA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Tcarona: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronaacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tcaronacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tcaronadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronaogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronaring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaroncolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcaroncomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Tcarone: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaroneacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -30
  ],
  Tcaronedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tcaronedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Tcaronemacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Tcaroneogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronhyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  Tcarono: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronoacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronodieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronoslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronotilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tcaronr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronrcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tcaronu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuring: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Tcarony: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcaronyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcaronydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  TcommaaccentA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Tcommaaccenta: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentaacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tcommaaccentacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tcommaaccentadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentaogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentaring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentcolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcommaaccentcomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Tcommaaccente: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccenteacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -30
  ],
  Tcommaaccentedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tcommaaccentedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Tcommaaccentemacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Tcommaaccenteogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccenthyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  Tcommaaccento: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentoacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentodieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentoslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentotilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tcommaaccentr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentrcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tcommaaccentu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccenturing: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Tcommaaccenty: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcommaaccentyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcommaaccentydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  UA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ucomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UacuteA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uacutecomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uacuteperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UcircumflexA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ucircumflexcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Ucircumflexperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UdieresisA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Udieresiscomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Udieresisperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UgraveA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ugravecomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Ugraveperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UhungarumlautA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uhungarumlautcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uhungarumlautperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UmacronA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Umacroncomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Umacronperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UogonekA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uogonekcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uogonekperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UringA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uringcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uringperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  VA: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAacute: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAbreve: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAcircumflex: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAdieresis: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAgrave: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAmacron: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAogonek: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAring: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAtilde: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VG: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VGbreve: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VGcommaaccent: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VO: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOacute: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOdieresis: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOgrave: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOhungarumlaut: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOmacron: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOslash: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOtilde: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  Va: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vaacute: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vabreve: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vacircumflex: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vadieresis: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vagrave: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vamacron: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vaogonek: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Varing: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vatilde: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vcolon: [
    -40,
    -40,
    -40,
    -40,
    -92,
    -74,
    -65,
    -74
  ],
  Vcomma: [
    -120,
    -120,
    -125,
    -125,
    -129,
    -129,
    -129,
    -129
  ],
  Ve: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Veacute: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vecaron: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -71
  ],
  Vecircumflex: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -71
  ],
  Vedieresis: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Vedotaccent: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vegrave: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Vemacron: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Veogonek: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vhyphen: [
    -80,
    -80,
    -80,
    -80,
    -74,
    -70,
    -55,
    -100
  ],
  Vo: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Voacute: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vocircumflex: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vodieresis: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vograve: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vohungarumlaut: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vomacron: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Voslash: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Votilde: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vperiod: [
    -120,
    -120,
    -125,
    -125,
    -145,
    -129,
    -129,
    -129
  ],
  Vsemicolon: [
    -40,
    -40,
    -40,
    -40,
    -92,
    -74,
    -74,
    -74
  ],
  Vu: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuacute: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vucircumflex: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vudieresis: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vugrave: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuhungarumlaut: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vumacron: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuogonek: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuring: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  WA: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAacute: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAbreve: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAcircumflex: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAdieresis: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAgrave: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAmacron: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAogonek: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAring: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAtilde: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WO: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOacute: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOgrave: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOmacron: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOslash: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOtilde: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  Wa: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waacute: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wabreve: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wacircumflex: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wadieresis: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wagrave: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wamacron: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waogonek: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waring: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Watilde: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wcolon: [
    -10,
    -10,
    0,
    0,
    -55,
    -55,
    -65,
    -37
  ],
  Wcomma: [
    -80,
    -80,
    -80,
    -80,
    -92,
    -74,
    -92,
    -92
  ],
  We: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Weacute: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wecaron: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wecircumflex: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wedieresis: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Wedotaccent: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wegrave: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Wemacron: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Weogonek: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Whyphen: [
    -40,
    -40,
    -40,
    -40,
    -37,
    -50,
    -37,
    -65
  ],
  Wo: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Woacute: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wocircumflex: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wodieresis: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wograve: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wohungarumlaut: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Womacron: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Woslash: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wotilde: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wperiod: [
    -80,
    -80,
    -80,
    -80,
    -92,
    -74,
    -92,
    -92
  ],
  Wsemicolon: [
    -10,
    -10,
    0,
    0,
    -55,
    -55,
    -65,
    -37
  ],
  Wu: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuacute: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wucircumflex: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wudieresis: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wugrave: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuhungarumlaut: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wumacron: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuogonek: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuring: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wy: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  Wyacute: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  Wydieresis: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  YA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Ya: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Yacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yaring: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yatilde: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ycolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ycomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Ye: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yeacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Yedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Yeogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yo: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yomacron: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Ysemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  YacuteA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Yacutea: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacutearing: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteatilde: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yacutecolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yacutecomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Yacutee: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteeacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Yacuteedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteeogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteo: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteomacron: [
    -100,
    -100,
    -70,
    -70,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Yacutesemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yacuteu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  YdieresisA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Ydieresisa: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisaring: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisatilde: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresiscolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ydieresiscomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Ydieresise: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresiseacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Ydieresisedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresisedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresisemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresiseogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresiso: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisomacron: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Ydieresissemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ydieresisu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  ag: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  av: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  ay: [
    -20,
    -20,
    -30,
    -30
  ],
  ayacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aacutew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aacutey: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  abrevew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  abrevey: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  acircumflexw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  acircumflexy: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  adieresisw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  adieresisy: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  agravew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  agravey: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  amacrong: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacrongbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacrongcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacronv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  amacronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  amacrony: [
    -20,
    -20,
    -30,
    -30
  ],
  amacronyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  amacronydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aogonekw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aogoneky: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aringg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aringw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aringy: [
    -20,
    -20,
    -30,
    -30
  ],
  aringyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aringydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  atildew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  atildey: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  bl: [
    -10,
    -10,
    -20,
    -20
  ],
  blacute: [
    -10,
    -10,
    -20,
    -20
  ],
  blcommaaccent: [
    -10,
    -10,
    -20,
    -20
  ],
  blslash: [
    -10,
    -10,
    -20,
    -20
  ],
  bu: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buacute: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bucircumflex: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  budieresis: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bugrave: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bumacron: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buogonek: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buring: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bv: [
    -20,
    -20,
    -20,
    -20,
    -15,
    0,
    0,
    -15
  ],
  by: [
    -20,
    -20,
    -20,
    -20
  ],
  byacute: [
    -20,
    -20,
    -20,
    -20
  ],
  bydieresis: [
    -20,
    -20,
    -20,
    -20
  ],
  ch: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ck: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ckcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cl: [
    -20,
    -20
  ],
  clacute: [
    -20,
    -20
  ],
  clcommaaccent: [
    -20,
    -20
  ],
  clslash: [
    -20,
    -20
  ],
  cy: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteh: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  cacutek: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cacutekcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cacutel: [
    -20,
    -20
  ],
  cacutelacute: [
    -20,
    -20
  ],
  cacutelcommaaccent: [
    -20,
    -20
  ],
  cacutelslash: [
    -20,
    -20
  ],
  cacutey: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronh: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ccaronk: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccaronkcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccaronl: [
    -20,
    -20
  ],
  ccaronlacute: [
    -20,
    -20
  ],
  ccaronlcommaaccent: [
    -20,
    -20
  ],
  ccaronlslash: [
    -20,
    -20
  ],
  ccarony: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillah: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ccedillak: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccedillakcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccedillal: [
    -20,
    -20
  ],
  ccedillalacute: [
    -20,
    -20
  ],
  ccedillalcommaaccent: [
    -20,
    -20
  ],
  ccedillalslash: [
    -20,
    -20
  ],
  ccedillay: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillayacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillaydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  colonspace: [
    -40,
    -40,
    -50,
    -50
  ],
  commaquotedblright: [
    -120,
    -120,
    -100,
    -100,
    -45,
    -95,
    -140,
    -70
  ],
  commaquoteright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  commaspace: [
    -40,
    -40
  ],
  dd: [
    -10,
    -10
  ],
  ddcroat: [
    -10,
    -10
  ],
  dv: [
    -15,
    -15
  ],
  dw: [
    -15,
    -15,
    0,
    0,
    -15
  ],
  dy: [
    -15,
    -15
  ],
  dyacute: [
    -15,
    -15
  ],
  dydieresis: [
    -15,
    -15
  ],
  dcroatd: [
    -10,
    -10
  ],
  dcroatdcroat: [
    -10,
    -10
  ],
  dcroatv: [
    -15,
    -15
  ],
  dcroatw: [
    -15,
    -15,
    0,
    0,
    -15
  ],
  dcroaty: [
    -15,
    -15
  ],
  dcroatyacute: [
    -15,
    -15
  ],
  dcroatydieresis: [
    -15,
    -15
  ],
  ecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacutecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eacuteperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  eacutev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  eacutew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  eacutex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  eacutey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacuteyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacuteydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaroncomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  ecaronperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ecaronv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ecaronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ecaronx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ecarony: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaronyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaronydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  ecircumflexperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ecircumflexv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ecircumflexw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ecircumflexx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ecircumflexy: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresiscomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  edieresisperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  edieresisv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  edieresisw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  edieresisx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  edieresisy: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresisyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresisydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  edotaccentperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  edotaccentv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  edotaccentw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  edotaccentx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  edotaccenty: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egravecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  egraveperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  egravev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  egravew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  egravex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  egravey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egraveyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egraveydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacroncomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  emacronperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  emacronv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  emacronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  emacronx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  emacrony: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacronyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacronydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eogonekperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  eogonekv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  eogonekw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  eogonekx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  eogoneky: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  fcomma: [
    -10,
    -10,
    -30,
    -30,
    -15,
    -10,
    -10
  ],
  fe: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  feacute: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fecaron: [
    -10,
    -10,
    -30,
    -30
  ],
  fecircumflex: [
    -10,
    -10,
    -30,
    -30
  ],
  fedieresis: [
    -10,
    -10,
    -30,
    -30
  ],
  fedotaccent: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fegrave: [
    -10,
    -10,
    -30,
    -30
  ],
  femacron: [
    -10,
    -10,
    -30,
    -30
  ],
  feogonek: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fo: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  foacute: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  focircumflex: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fodieresis: [
    -20,
    -20,
    -30,
    -30,
    -25
  ],
  fograve: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fohungarumlaut: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fomacron: [
    -20,
    -20,
    -30,
    -30,
    -25
  ],
  foslash: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fotilde: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fperiod: [
    -10,
    -10,
    -30,
    -30,
    -15,
    -10,
    -15
  ],
  fquotedblright: [
    30,
    30,
    60,
    60,
    50
  ],
  fquoteright: [
    30,
    30,
    50,
    50,
    55,
    55,
    92,
    55
  ],
  ge: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  geacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  geogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  ggbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  ggcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevee: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveeacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveeogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccente: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccenteacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccenteogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  hy: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  hyacute: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  hydieresis: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  ko: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  koacute: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kocircumflex: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kodieresis: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kograve: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kohungarumlaut: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  komacron: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  koslash: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kotilde: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccento: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentoacute: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentocircumflex: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentodieresis: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentograve: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentohungarumlaut: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentomacron: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentoslash: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentotilde: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  lw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ly: [
    -15,
    -15
  ],
  lyacute: [
    -15,
    -15
  ],
  lydieresis: [
    -15,
    -15
  ],
  lacutew: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lacutey: [
    -15,
    -15
  ],
  lacuteyacute: [
    -15,
    -15
  ],
  lacuteydieresis: [
    -15,
    -15
  ],
  lcommaaccentw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lcommaaccenty: [
    -15,
    -15
  ],
  lcommaaccentyacute: [
    -15,
    -15
  ],
  lcommaaccentydieresis: [
    -15,
    -15
  ],
  lslashw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lslashy: [
    -15,
    -15
  ],
  lslashyacute: [
    -15,
    -15
  ],
  lslashydieresis: [
    -15,
    -15
  ],
  mu: [
    -20,
    -20,
    -10,
    -10
  ],
  muacute: [
    -20,
    -20,
    -10,
    -10
  ],
  mucircumflex: [
    -20,
    -20,
    -10,
    -10
  ],
  mudieresis: [
    -20,
    -20,
    -10,
    -10
  ],
  mugrave: [
    -20,
    -20,
    -10,
    -10
  ],
  muhungarumlaut: [
    -20,
    -20,
    -10,
    -10
  ],
  mumacron: [
    -20,
    -20,
    -10,
    -10
  ],
  muogonek: [
    -20,
    -20,
    -10,
    -10
  ],
  muring: [
    -20,
    -20,
    -10,
    -10
  ],
  my: [
    -30,
    -30,
    -15,
    -15
  ],
  myacute: [
    -30,
    -30,
    -15,
    -15
  ],
  mydieresis: [
    -30,
    -30,
    -15,
    -15
  ],
  nu: [
    -10,
    -10,
    -10,
    -10
  ],
  nuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  nucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  nudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  nugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  nuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  numacron: [
    -10,
    -10,
    -10,
    -10
  ],
  nuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  nuring: [
    -10,
    -10,
    -10,
    -10
  ],
  nv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ny: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteu: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuring: [
    -10,
    -10,
    -10,
    -10
  ],
  nacutev: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  nacutey: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronu: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuring: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ncarony: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentu: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccenturing: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ncommaaccenty: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeu: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuring: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildev: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ntildey: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ov: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ow: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ox: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  oy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacutev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  oacutew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  oacutex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  oacutey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacuteyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacuteydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ocircumflexw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ocircumflexx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ocircumflexy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  odieresisw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  odieresisx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  odieresisy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ogravev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ogravew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ogravex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ogravey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ograveyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ograveydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ohungarumlautw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ohungarumlautx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ohungarumlauty: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  omacronw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  omacronx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  omacrony: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oslashv: [
    -20,
    -20,
    -70,
    -70,
    -10,
    -15,
    -10,
    -15
  ],
  oslashw: [
    -15,
    -15,
    -70,
    -70,
    -10,
    -25,
    0,
    -25
  ],
  oslashx: [
    -30,
    -30,
    -85,
    -85,
    0,
    -10
  ],
  oslashy: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  oslashyacute: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  oslashydieresis: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  otildev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  otildew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  otildex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  otildey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  otildeyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  otildeydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  py: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  pyacute: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  pydieresis: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  periodquotedblright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  periodquoteright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  periodspace: [
    -40,
    -40,
    -60,
    -60
  ],
  quotedblrightspace: [
    -80,
    -80,
    -40,
    -40
  ],
  quoteleftquoteleft: [
    -46,
    -46,
    -57,
    -57,
    -63,
    -74,
    -111,
    -74
  ],
  quoterightd: [
    -80,
    -80,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightdcroat: [
    -80,
    -80,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightl: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlacute: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlcommaaccent: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlslash: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightquoteright: [
    -46,
    -46,
    -57,
    -57,
    -63,
    -74,
    -111,
    -74
  ],
  quoterightr: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightracute: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightrcaron: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightrcommaaccent: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterights: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightsacute: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscaron: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscedilla: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscommaaccent: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightspace: [
    -80,
    -80,
    -70,
    -70,
    -74,
    -74,
    -111,
    -74
  ],
  quoterightv: [
    -20,
    -20,
    0,
    0,
    -20,
    -15,
    -10,
    -50
  ],
  rc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rd: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rdcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rgbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rgcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rhyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  ro: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  roacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  romacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  roslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rs: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rt: [
    20,
    20,
    40,
    40
  ],
  rtcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rv: [
    10,
    10,
    30,
    30,
    -10
  ],
  ry: [
    10,
    10,
    30,
    30
  ],
  ryacute: [
    10,
    10,
    30,
    30
  ],
  rydieresis: [
    10,
    10,
    30,
    30
  ],
  racutec: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutecacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutecomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  racuted: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  racutedcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  racuteg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutegbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutegcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutehyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  racuteo: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  racuteq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutes: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutesacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutet: [
    20,
    20,
    40,
    40
  ],
  racutetcommaaccent: [
    20,
    20,
    40,
    40
  ],
  racutev: [
    10,
    10,
    30,
    30,
    -10
  ],
  racutey: [
    10,
    10,
    30,
    30
  ],
  racuteyacute: [
    10,
    10,
    30,
    30
  ],
  racuteydieresis: [
    10,
    10,
    30,
    30
  ],
  rcaronc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroncacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroncomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rcarond: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcarondcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcarong: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcarongbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcarongcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcaronhyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  rcarono: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rcaronq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcarons: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaront: [
    20,
    20,
    40,
    40
  ],
  rcarontcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rcaronv: [
    10,
    10,
    30,
    30,
    -10
  ],
  rcarony: [
    10,
    10,
    30,
    30
  ],
  rcaronyacute: [
    10,
    10,
    30,
    30
  ],
  rcaronydieresis: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentcacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentcomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rcommaaccentd: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcommaaccentdcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcommaaccentg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccentgbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccentgcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccenthyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  rcommaaccento: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rcommaaccentq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccents: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentt: [
    20,
    20,
    40,
    40
  ],
  rcommaaccenttcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rcommaaccentv: [
    10,
    10,
    30,
    30,
    -10
  ],
  rcommaaccenty: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentyacute: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentydieresis: [
    10,
    10,
    30,
    30
  ],
  sw: [
    -15,
    -15,
    -30,
    -30
  ],
  sacutew: [
    -15,
    -15,
    -30,
    -30
  ],
  scaronw: [
    -15,
    -15,
    -30,
    -30
  ],
  scedillaw: [
    -15,
    -15,
    -30,
    -30
  ],
  scommaaccentw: [
    -15,
    -15,
    -30,
    -30
  ],
  semicolonspace: [
    -40,
    -40,
    -50,
    -50
  ],
  spaceT: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceTcaron: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceTcommaaccent: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceV: [
    -80,
    -80,
    -50,
    -50,
    -45,
    -70,
    -35,
    -50
  ],
  spaceW: [
    -80,
    -80,
    -40,
    -40,
    -30,
    -70,
    -40,
    -30
  ],
  spaceY: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spaceYacute: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spaceYdieresis: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spacequotedblleft: [
    -80,
    -80,
    -30,
    -30
  ],
  spacequoteleft: [
    -60,
    -60,
    -60,
    -60
  ],
  va: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vaacute: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vabreve: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vacircumflex: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vadieresis: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vagrave: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vamacron: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vaogonek: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  varing: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vatilde: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vcomma: [
    -80,
    -80,
    -80,
    -80,
    -55,
    -37,
    -74,
    -65
  ],
  vo: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  voacute: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vocircumflex: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vodieresis: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vograve: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vohungarumlaut: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vomacron: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  voslash: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  votilde: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vperiod: [
    -80,
    -80,
    -80,
    -80,
    -70,
    -37,
    -74,
    -65
  ],
  wcomma: [
    -40,
    -40,
    -60,
    -60,
    -55,
    -37,
    -74,
    -65
  ],
  wo: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  woacute: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wocircumflex: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wodieresis: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wograve: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wohungarumlaut: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  womacron: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  woslash: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wotilde: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wperiod: [
    -40,
    -40,
    -60,
    -60,
    -70,
    -37,
    -74,
    -65
  ],
  xe: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xeacute: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xecaron: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xecircumflex: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xedieresis: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xedotaccent: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xegrave: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xemacron: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xeogonek: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  ya: [
    -30,
    -30,
    -20,
    -20
  ],
  yaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  yabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  yacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  yadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  yagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  yamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  yaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  yaring: [
    -30,
    -30,
    -20,
    -20
  ],
  yatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  ycomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  ye: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yeacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yeogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yo: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  yacutea: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  yacutearing: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  yacutecomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  yacutee: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteeacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteeogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteo: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  ydieresisa: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaring: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresiscomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  ydieresise: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiseacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiseogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiso: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  ze: [
    10,
    10,
    -15,
    -15
  ],
  zeacute: [
    10,
    10,
    -15,
    -15
  ],
  zecaron: [
    10,
    10,
    -15,
    -15
  ],
  zecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zegrave: [
    10,
    10,
    -15,
    -15
  ],
  zemacron: [
    10,
    10,
    -15,
    -15
  ],
  zeogonek: [
    10,
    10,
    -15,
    -15
  ],
  zacutee: [
    10,
    10,
    -15,
    -15
  ],
  zacuteeacute: [
    10,
    10,
    -15,
    -15
  ],
  zacuteecaron: [
    10,
    10,
    -15,
    -15
  ],
  zacuteecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zacuteedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zacuteedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zacuteegrave: [
    10,
    10,
    -15,
    -15
  ],
  zacuteemacron: [
    10,
    10,
    -15,
    -15
  ],
  zacuteeogonek: [
    10,
    10,
    -15,
    -15
  ],
  zcarone: [
    10,
    10,
    -15,
    -15
  ],
  zcaroneacute: [
    10,
    10,
    -15,
    -15
  ],
  zcaronecaron: [
    10,
    10,
    -15,
    -15
  ],
  zcaronecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zcaronedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zcaronedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zcaronegrave: [
    10,
    10,
    -15,
    -15
  ],
  zcaronemacron: [
    10,
    10,
    -15,
    -15
  ],
  zcaroneogonek: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccente: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccenteacute: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentecaron: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentegrave: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentemacron: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccenteogonek: [
    10,
    10,
    -15,
    -15
  ],
  Bcomma: [
    0,
    0,
    -20,
    -20
  ],
  Bperiod: [
    0,
    0,
    -20,
    -20
  ],
  Ccomma: [
    0,
    0,
    -30,
    -30
  ],
  Cperiod: [
    0,
    0,
    -30,
    -30
  ],
  Cacutecomma: [
    0,
    0,
    -30,
    -30
  ],
  Cacuteperiod: [
    0,
    0,
    -30,
    -30
  ],
  Ccaroncomma: [
    0,
    0,
    -30,
    -30
  ],
  Ccaronperiod: [
    0,
    0,
    -30,
    -30
  ],
  Ccedillacomma: [
    0,
    0,
    -30,
    -30
  ],
  Ccedillaperiod: [
    0,
    0,
    -30,
    -30
  ],
  Fe: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Feacute: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fecaron: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fecircumflex: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fedieresis: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fedotaccent: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fegrave: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Femacron: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Feogonek: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fo: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Foacute: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Focircumflex: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fodieresis: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fograve: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fohungarumlaut: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fomacron: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Foslash: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fotilde: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fr: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Fracute: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Frcaron: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Frcommaaccent: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Ja: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaacute: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jabreve: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jacircumflex: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jadieresis: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jagrave: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jamacron: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaogonek: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaring: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jatilde: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  LcaronT: [
    0,
    0,
    -110,
    -110
  ],
  LcaronTcaron: [
    0,
    0,
    -110,
    -110
  ],
  LcaronTcommaaccent: [
    0,
    0,
    -110,
    -110
  ],
  LcaronV: [
    0,
    0,
    -110,
    -110
  ],
  LcaronW: [
    0,
    0,
    -70,
    -70
  ],
  LcaronY: [
    0,
    0,
    -140,
    -140
  ],
  LcaronYacute: [
    0,
    0,
    -140,
    -140
  ],
  LcaronYdieresis: [
    0,
    0,
    -140,
    -140
  ],
  Lcaronquotedblright: [
    0,
    0,
    -140,
    -140
  ],
  Lcaronquoteright: [
    0,
    0,
    -160,
    -160,
    0,
    0,
    0,
    -92
  ],
  Lcarony: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Lcaronyacute: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Lcaronydieresis: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Scomma: [
    0,
    0,
    -20,
    -20
  ],
  Speriod: [
    0,
    0,
    -20,
    -20
  ],
  Sacutecomma: [
    0,
    0,
    -20,
    -20
  ],
  Sacuteperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scaroncomma: [
    0,
    0,
    -20,
    -20
  ],
  Scaronperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scedillacomma: [
    0,
    0,
    -20,
    -20
  ],
  Scedillaperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scommaaccentcomma: [
    0,
    0,
    -20,
    -20
  ],
  Scommaaccentperiod: [
    0,
    0,
    -20,
    -20
  ],
  Trcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronrcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentrcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Yhyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Yi: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacutehyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Yacutei: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacuteiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacuteiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresishyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Ydieresisi: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresisiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresisiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  bb: [
    0,
    0,
    -10,
    -10,
    -10,
    -10
  ],
  bcomma: [
    0,
    0,
    -40,
    -40
  ],
  bperiod: [
    0,
    0,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  ccomma: [
    0,
    0,
    -15,
    -15
  ],
  cacutecomma: [
    0,
    0,
    -15,
    -15
  ],
  ccaroncomma: [
    0,
    0,
    -15,
    -15
  ],
  ccedillacomma: [
    0,
    0,
    -15,
    -15
  ],
  fa: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faacute: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fabreve: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  facircumflex: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fadieresis: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fagrave: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  famacron: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faogonek: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faring: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fatilde: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fdotlessi: [
    0,
    0,
    -28,
    -28,
    -35,
    -30,
    -60,
    -50
  ],
  gr: [
    0,
    0,
    -10,
    -10
  ],
  gracute: [
    0,
    0,
    -10,
    -10
  ],
  grcaron: [
    0,
    0,
    -10,
    -10
  ],
  grcommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  gbrever: [
    0,
    0,
    -10,
    -10
  ],
  gbreveracute: [
    0,
    0,
    -10,
    -10
  ],
  gbrevercaron: [
    0,
    0,
    -10,
    -10
  ],
  gbrevercommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentr: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentracute: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentrcaron: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentrcommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  ke: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  keacute: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kecaron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kecircumflex: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kedieresis: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kedotaccent: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kegrave: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kemacron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  keogonek: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccente: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccenteacute: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentecaron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentecircumflex: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentedieresis: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentedotaccent: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentegrave: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentemacron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccenteogonek: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  ocomma: [
    0,
    0,
    -40,
    -40
  ],
  operiod: [
    0,
    0,
    -40,
    -40
  ],
  oacutecomma: [
    0,
    0,
    -40,
    -40
  ],
  oacuteperiod: [
    0,
    0,
    -40,
    -40
  ],
  ocircumflexcomma: [
    0,
    0,
    -40,
    -40
  ],
  ocircumflexperiod: [
    0,
    0,
    -40,
    -40
  ],
  odieresiscomma: [
    0,
    0,
    -40,
    -40
  ],
  odieresisperiod: [
    0,
    0,
    -40,
    -40
  ],
  ogravecomma: [
    0,
    0,
    -40,
    -40
  ],
  ograveperiod: [
    0,
    0,
    -40,
    -40
  ],
  ohungarumlautcomma: [
    0,
    0,
    -40,
    -40
  ],
  ohungarumlautperiod: [
    0,
    0,
    -40,
    -40
  ],
  omacroncomma: [
    0,
    0,
    -40,
    -40
  ],
  omacronperiod: [
    0,
    0,
    -40,
    -40
  ],
  oslasha: [
    0,
    0,
    -55,
    -55
  ],
  oslashaacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashabreve: [
    0,
    0,
    -55,
    -55
  ],
  oslashacircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashadieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashagrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashamacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashaogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslasharing: [
    0,
    0,
    -55,
    -55
  ],
  oslashatilde: [
    0,
    0,
    -55,
    -55
  ],
  oslashb: [
    0,
    0,
    -55,
    -55
  ],
  oslashc: [
    0,
    0,
    -55,
    -55
  ],
  oslashcacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashccaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashccedilla: [
    0,
    0,
    -55,
    -55
  ],
  oslashcomma: [
    0,
    0,
    -95,
    -95
  ],
  oslashd: [
    0,
    0,
    -55,
    -55
  ],
  oslashdcroat: [
    0,
    0,
    -55,
    -55
  ],
  oslashe: [
    0,
    0,
    -55,
    -55
  ],
  oslasheacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashecaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashecircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashedieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashedotaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashegrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashemacron: [
    0,
    0,
    -55,
    -55
  ],
  oslasheogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashf: [
    0,
    0,
    -55,
    -55
  ],
  oslashg: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashgbreve: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashgcommaaccent: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashh: [
    0,
    0,
    -55,
    -55
  ],
  oslashi: [
    0,
    0,
    -55,
    -55
  ],
  oslashiacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashicircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashidieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashigrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashimacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashiogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashj: [
    0,
    0,
    -55,
    -55
  ],
  oslashk: [
    0,
    0,
    -55,
    -55
  ],
  oslashkcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashl: [
    0,
    0,
    -55,
    -55
  ],
  oslashlacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashlcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashlslash: [
    0,
    0,
    -55,
    -55
  ],
  oslashm: [
    0,
    0,
    -55,
    -55
  ],
  oslashn: [
    0,
    0,
    -55,
    -55
  ],
  oslashnacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashncaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashncommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashntilde: [
    0,
    0,
    -55,
    -55
  ],
  oslasho: [
    0,
    0,
    -55,
    -55
  ],
  oslashoacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashocircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashodieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashograve: [
    0,
    0,
    -55,
    -55
  ],
  oslashohungarumlaut: [
    0,
    0,
    -55,
    -55
  ],
  oslashomacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashoslash: [
    0,
    0,
    -55,
    -55
  ],
  oslashotilde: [
    0,
    0,
    -55,
    -55
  ],
  oslashp: [
    0,
    0,
    -55,
    -55
  ],
  oslashperiod: [
    0,
    0,
    -95,
    -95
  ],
  oslashq: [
    0,
    0,
    -55,
    -55
  ],
  oslashr: [
    0,
    0,
    -55,
    -55
  ],
  oslashracute: [
    0,
    0,
    -55,
    -55
  ],
  oslashrcaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashrcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashs: [
    0,
    0,
    -55,
    -55
  ],
  oslashsacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashscaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashscedilla: [
    0,
    0,
    -55,
    -55
  ],
  oslashscommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslasht: [
    0,
    0,
    -55,
    -55
  ],
  oslashtcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashu: [
    0,
    0,
    -55,
    -55
  ],
  oslashuacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashucircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashudieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashugrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashuhungarumlaut: [
    0,
    0,
    -55,
    -55
  ],
  oslashumacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashuogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashuring: [
    0,
    0,
    -55,
    -55
  ],
  oslashz: [
    0,
    0,
    -55,
    -55
  ],
  oslashzacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashzcaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashzdotaccent: [
    0,
    0,
    -55,
    -55
  ],
  otildecomma: [
    0,
    0,
    -40,
    -40
  ],
  otildeperiod: [
    0,
    0,
    -40,
    -40
  ],
  pcomma: [
    0,
    0,
    -35,
    -35
  ],
  pperiod: [
    0,
    0,
    -35,
    -35
  ],
  ra: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  radieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ragrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ramacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ratilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcolon: [
    0,
    0,
    30,
    30
  ],
  ri: [
    0,
    0,
    15,
    15
  ],
  riacute: [
    0,
    0,
    15,
    15
  ],
  ricircumflex: [
    0,
    0,
    15,
    15
  ],
  ridieresis: [
    0,
    0,
    15,
    15
  ],
  rigrave: [
    0,
    0,
    15,
    15
  ],
  rimacron: [
    0,
    0,
    15,
    15
  ],
  riogonek: [
    0,
    0,
    15,
    15
  ],
  rk: [
    0,
    0,
    15,
    15
  ],
  rkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rl: [
    0,
    0,
    15,
    15
  ],
  rlacute: [
    0,
    0,
    15,
    15
  ],
  rlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rlslash: [
    0,
    0,
    15,
    15
  ],
  rm: [
    0,
    0,
    25,
    25
  ],
  rn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rsemicolon: [
    0,
    0,
    30,
    30
  ],
  ru: [
    0,
    0,
    15,
    15
  ],
  ruacute: [
    0,
    0,
    15,
    15
  ],
  rucircumflex: [
    0,
    0,
    15,
    15
  ],
  rudieresis: [
    0,
    0,
    15,
    15
  ],
  rugrave: [
    0,
    0,
    15,
    15
  ],
  ruhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rumacron: [
    0,
    0,
    15,
    15
  ],
  ruogonek: [
    0,
    0,
    15,
    15
  ],
  ruring: [
    0,
    0,
    15,
    15
  ],
  racutea: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racutearing: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racutecolon: [
    0,
    0,
    30,
    30
  ],
  racutei: [
    0,
    0,
    15,
    15
  ],
  racuteiacute: [
    0,
    0,
    15,
    15
  ],
  racuteicircumflex: [
    0,
    0,
    15,
    15
  ],
  racuteidieresis: [
    0,
    0,
    15,
    15
  ],
  racuteigrave: [
    0,
    0,
    15,
    15
  ],
  racuteimacron: [
    0,
    0,
    15,
    15
  ],
  racuteiogonek: [
    0,
    0,
    15,
    15
  ],
  racutek: [
    0,
    0,
    15,
    15
  ],
  racutekcommaaccent: [
    0,
    0,
    15,
    15
  ],
  racutel: [
    0,
    0,
    15,
    15
  ],
  racutelacute: [
    0,
    0,
    15,
    15
  ],
  racutelcommaaccent: [
    0,
    0,
    15,
    15
  ],
  racutelslash: [
    0,
    0,
    15,
    15
  ],
  racutem: [
    0,
    0,
    25,
    25
  ],
  racuten: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutenacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutencaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutencommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutentilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutep: [
    0,
    0,
    30,
    30,
    -10
  ],
  racutesemicolon: [
    0,
    0,
    30,
    30
  ],
  racuteu: [
    0,
    0,
    15,
    15
  ],
  racuteuacute: [
    0,
    0,
    15,
    15
  ],
  racuteucircumflex: [
    0,
    0,
    15,
    15
  ],
  racuteudieresis: [
    0,
    0,
    15,
    15
  ],
  racuteugrave: [
    0,
    0,
    15,
    15
  ],
  racuteuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  racuteumacron: [
    0,
    0,
    15,
    15
  ],
  racuteuogonek: [
    0,
    0,
    15,
    15
  ],
  racuteuring: [
    0,
    0,
    15,
    15
  ],
  rcarona: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaroncolon: [
    0,
    0,
    30,
    30
  ],
  rcaroni: [
    0,
    0,
    15,
    15
  ],
  rcaroniacute: [
    0,
    0,
    15,
    15
  ],
  rcaronicircumflex: [
    0,
    0,
    15,
    15
  ],
  rcaronidieresis: [
    0,
    0,
    15,
    15
  ],
  rcaronigrave: [
    0,
    0,
    15,
    15
  ],
  rcaronimacron: [
    0,
    0,
    15,
    15
  ],
  rcaroniogonek: [
    0,
    0,
    15,
    15
  ],
  rcaronk: [
    0,
    0,
    15,
    15
  ],
  rcaronkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcaronl: [
    0,
    0,
    15,
    15
  ],
  rcaronlacute: [
    0,
    0,
    15,
    15
  ],
  rcaronlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcaronlslash: [
    0,
    0,
    15,
    15
  ],
  rcaronm: [
    0,
    0,
    25,
    25
  ],
  rcaronn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rcaronsemicolon: [
    0,
    0,
    30,
    30
  ],
  rcaronu: [
    0,
    0,
    15,
    15
  ],
  rcaronuacute: [
    0,
    0,
    15,
    15
  ],
  rcaronucircumflex: [
    0,
    0,
    15,
    15
  ],
  rcaronudieresis: [
    0,
    0,
    15,
    15
  ],
  rcaronugrave: [
    0,
    0,
    15,
    15
  ],
  rcaronuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rcaronumacron: [
    0,
    0,
    15,
    15
  ],
  rcaronuogonek: [
    0,
    0,
    15,
    15
  ],
  rcaronuring: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenta: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentcolon: [
    0,
    0,
    30,
    30
  ],
  rcommaaccenti: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentiacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenticircumflex: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentidieresis: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentigrave: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentimacron: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentiogonek: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentk: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentl: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlslash: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentm: [
    0,
    0,
    25,
    25
  ],
  rcommaaccentn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rcommaaccentsemicolon: [
    0,
    0,
    30,
    30
  ],
  rcommaaccentu: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentucircumflex: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentudieresis: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentugrave: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentumacron: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuogonek: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenturing: [
    0,
    0,
    15,
    15
  ],
  scomma: [
    0,
    0,
    -15,
    -15
  ],
  speriod: [
    0,
    0,
    -15,
    -15
  ],
  sacutecomma: [
    0,
    0,
    -15,
    -15
  ],
  sacuteperiod: [
    0,
    0,
    -15,
    -15
  ],
  scaroncomma: [
    0,
    0,
    -15,
    -15
  ],
  scaronperiod: [
    0,
    0,
    -15,
    -15
  ],
  scedillacomma: [
    0,
    0,
    -15,
    -15
  ],
  scedillaperiod: [
    0,
    0,
    -15,
    -15
  ],
  scommaaccentcomma: [
    0,
    0,
    -15,
    -15
  ],
  scommaaccentperiod: [
    0,
    0,
    -15,
    -15
  ],
  ve: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  veacute: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vecaron: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vecircumflex: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vedieresis: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vedotaccent: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vegrave: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vemacron: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  veogonek: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  wa: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waacute: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wabreve: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wacircumflex: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wadieresis: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wagrave: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wamacron: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waogonek: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waring: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  watilde: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  we: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  weacute: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wecaron: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wecircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wedieresis: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wedotaccent: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wegrave: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wemacron: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  weogonek: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  zo: [
    0,
    0,
    -15,
    -15
  ],
  zoacute: [
    0,
    0,
    -15,
    -15
  ],
  zocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zograve: [
    0,
    0,
    -15,
    -15
  ],
  zohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zomacron: [
    0,
    0,
    -15,
    -15
  ],
  zoslash: [
    0,
    0,
    -15,
    -15
  ],
  zotilde: [
    0,
    0,
    -15,
    -15
  ],
  zacuteo: [
    0,
    0,
    -15,
    -15
  ],
  zacuteoacute: [
    0,
    0,
    -15,
    -15
  ],
  zacuteocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zacuteodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zacuteograve: [
    0,
    0,
    -15,
    -15
  ],
  zacuteohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zacuteomacron: [
    0,
    0,
    -15,
    -15
  ],
  zacuteoslash: [
    0,
    0,
    -15,
    -15
  ],
  zacuteotilde: [
    0,
    0,
    -15,
    -15
  ],
  zcarono: [
    0,
    0,
    -15,
    -15
  ],
  zcaronoacute: [
    0,
    0,
    -15,
    -15
  ],
  zcaronocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zcaronodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zcaronograve: [
    0,
    0,
    -15,
    -15
  ],
  zcaronohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zcaronomacron: [
    0,
    0,
    -15,
    -15
  ],
  zcaronoslash: [
    0,
    0,
    -15,
    -15
  ],
  zcaronotilde: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccento: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentoacute: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentograve: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentomacron: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentoslash: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentotilde: [
    0,
    0,
    -15,
    -15
  ],
  Ap: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aacutep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aacutequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Abrevep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Abrevequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Acircumflexp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Acircumflexquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Adieresisp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Adieresisquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Agravep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Agravequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Amacronp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Amacronquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aogonekp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aogonekquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aringp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aringquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Atildep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Atildequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Je: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jeacute: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jecaron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jecircumflex: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jedieresis: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jedotaccent: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jegrave: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jemacron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jeogonek: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jo: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Joacute: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jocircumflex: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jodieresis: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jograve: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Johungarumlaut: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jomacron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Joslash: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jotilde: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  NA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  Ti: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroni: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroniacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroniogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccenti: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccentiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccentiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Vi: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Viacute: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Vicircumflex: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vidieresis: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vigrave: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vimacron: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Viogonek: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Wi: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  Wiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  Wiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  fi: [
    0,
    0,
    0,
    0,
    -25,
    0,
    -20,
    -20
  ],
  gperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  gbreveperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  gcommaaccentperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  iv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  iacutev: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  icircumflexv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  idieresisv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  igravev: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  imacronv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  iogonekv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  ky: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kyacute: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kydieresis: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccenty: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccentyacute: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccentydieresis: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  quotedblleftA: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAacute: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAbreve: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAcircumflex: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAdieresis: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAgrave: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAmacron: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAogonek: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAring: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAtilde: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftA: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAacute: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAbreve: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAcircumflex: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAdieresis: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAgrave: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAmacron: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAogonek: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAring: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAtilde: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  re: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  reacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  recaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  recircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  redieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  redotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  regrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  remacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  reogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutee: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteeacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteeogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcarone: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroneacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroneogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccente: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccenteacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccenteogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  spaceA: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAacute: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAbreve: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAcircumflex: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAdieresis: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAgrave: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAmacron: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAogonek: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAring: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAtilde: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  Fi: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fiacute: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Ficircumflex: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fidieresis: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Figrave: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fimacron: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fiogonek: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  eb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  eacuteb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ecaronb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ecircumflexb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  edieresisb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  edotaccentb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  egraveb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  emacronb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  eogonekb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ff: [
    0,
    0,
    0,
    0,
    0,
    -18,
    -18,
    -25
  ],
  quoterightt: [
    0,
    0,
    0,
    0,
    0,
    -37,
    -30,
    -18
  ],
  quoterighttcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    -37,
    -30,
    -18
  ],
  Yicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  eg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacuteg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacutegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacutegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egraveg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egravegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egravegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  fiogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    -20
  ],
  gcomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevecomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentcomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  og: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacuteg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacutegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacutegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ograveg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogravegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogravegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildeg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  fiacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -20
  ],
  ga: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  garing: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbrevea: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbrevearing: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccenta: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaring: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ]
};
var data = {
  attributes,
  glyphWidths,
  kernPairs
};
var initFont = function initFont2(font2) {
  return [font2.FontName, {
    attributes: font2,
    glyphWidths: {},
    kernPairs: {}
  }];
};
var expandData = function expandData2(data2) {
  var attributes2 = data2.attributes, glyphWidths2 = data2.glyphWidths, kernPairs2 = data2.kernPairs;
  var fonts = attributes2.map(initFont);
  Object.keys(glyphWidths2).forEach(function(key) {
    glyphWidths2[key].forEach(function(value2, index2) {
      if (value2) fonts[index2][1].glyphWidths[key] = value2;
    });
  });
  Object.keys(kernPairs2).forEach(function(key) {
    kernPairs2[key].forEach(function(value2, index2) {
      if (value2) fonts[index2][1].kernPairs[key] = value2;
    });
  });
  return Object.fromEntries(fonts);
};
var STANDARD_FONTS = expandData(data);
var createStandardFont = function createStandardFont2(PDFFont2) {
  return function(_PDFFont) {
    _inheritsLoose(StandardFont3, _PDFFont);
    function StandardFont3(document2, name2, id) {
      var _this;
      _this = _PDFFont.call(this) || this;
      _this.document = document2;
      _this.name = name2;
      _this.id = id;
      _this.font = AFMFont.fromJson(STANDARD_FONTS[_this.name]);
      _this.ascender = _this.font.ascender;
      _this.descender = _this.font.descender;
      _this.bbox = _this.font.bbox;
      _this.lineGap = _this.font.lineGap;
      return _this;
    }
    var _proto = StandardFont3.prototype;
    _proto.embed = function embed() {
      this.dictionary.data = {
        Type: "Font",
        BaseFont: this.name,
        Subtype: "Type1",
        Encoding: "WinAnsiEncoding"
      };
      return this.dictionary.end();
    };
    _proto.encode = function encode(text2) {
      var encoded = this.font.encodeText(text2);
      var glyphs = this.font.glyphsForString("" + text2);
      var advances = this.font.advancesForGlyphs(glyphs);
      var positions = [];
      for (var i = 0; i < glyphs.length; i++) {
        var glyph = glyphs[i];
        positions.push({
          xAdvance: advances[i],
          yAdvance: 0,
          xOffset: 0,
          yOffset: 0,
          advanceWidth: this.font.widthOfGlyph(glyph)
        });
      }
      return [encoded, positions];
    };
    _proto.encodeGlyphs = function encodeGlyphs(glyphs) {
      var res = [];
      for (var _i = 0, _Array$from = Array.from(glyphs); _i < _Array$from.length; _i++) {
        var glyph = _Array$from[_i];
        res.push(("00" + glyph.id.toString(16)).slice(-2));
      }
      return res;
    };
    _proto.widthOfString = function widthOfString2(string, size) {
      var glyphs = this.font.glyphsForString("" + string);
      var advances = this.font.advancesForGlyphs(glyphs);
      var width = 0;
      for (var _i2 = 0, _Array$from2 = Array.from(advances); _i2 < _Array$from2.length; _i2++) {
        var advance = _Array$from2[_i2];
        width += advance;
      }
      var scale4 = size / 1e3;
      return width * scale4;
    };
    StandardFont3.isStandardFont = function isStandardFont(name2) {
      return name2 in STANDARD_FONTS;
    };
    return StandardFont3;
  }(PDFFont2);
};
var toHex2 = function toHex3() {
  for (var _len = arguments.length, codePoints = new Array(_len), _key = 0; _key < _len; _key++) {
    codePoints[_key] = arguments[_key];
  }
  var codes2 = Array.from(codePoints).map(function(code) {
    return ("0000" + code.toString(16)).slice(-4);
  });
  return codes2.join("");
};
var createEmbeddedFont = function createEmbeddedFont2(PDFFont2) {
  return function(_PDFFont) {
    _inheritsLoose(EmbeddedFont2, _PDFFont);
    function EmbeddedFont2(document2, font2, id) {
      var _this;
      _this = _PDFFont.call(this) || this;
      _this.document = document2;
      _this.font = font2;
      _this.id = id;
      _this.subset = _this.font.createSubset();
      _this.unicode = [[0]];
      _this.widths = [_this.font.getGlyph(0).advanceWidth];
      _this.name = _this.font.postscriptName;
      _this.scale = 1e3 / _this.font.unitsPerEm;
      _this.ascender = _this.font.ascent * _this.scale;
      _this.descender = _this.font.descent * _this.scale;
      _this.xHeight = _this.font.xHeight * _this.scale;
      _this.capHeight = _this.font.capHeight * _this.scale;
      _this.lineGap = _this.font.lineGap * _this.scale;
      _this.bbox = _this.font.bbox;
      _this.layoutCache = /* @__PURE__ */ Object.create(null);
      return _this;
    }
    var _proto = EmbeddedFont2.prototype;
    _proto.layoutRun = function layoutRun3(text2, features) {
      var run = this.font.layout(text2, features, void 0, void 0, "ltr");
      for (var i = 0; i < run.positions.length; i++) {
        var position = run.positions[i];
        for (var key in position) {
          position[key] *= this.scale;
        }
        position.advanceWidth = run.glyphs[i].advanceWidth * this.scale;
      }
      return run;
    };
    _proto.layoutCached = function layoutCached(text2) {
      var cached;
      if (cached = this.layoutCache[text2]) {
        return cached;
      }
      var run = this.layoutRun(text2);
      this.layoutCache[text2] = run;
      return run;
    };
    _proto.layout = function layout2(text2, features, onlyWidth) {
      if (onlyWidth == null) {
        onlyWidth = false;
      }
      if (features) {
        return this.layoutRun(text2, features);
      }
      var glyphs = onlyWidth ? null : [];
      var positions = onlyWidth ? null : [];
      var advanceWidth5 = 0;
      var last3 = 0;
      var index2 = 0;
      while (index2 <= text2.length) {
        var needle = void 0;
        if (index2 === text2.length && last3 < index2 || (needle = text2.charAt(index2), [" ", "	"].includes(needle))) {
          var run = this.layoutCached(text2.slice(last3, ++index2));
          if (!onlyWidth) {
            glyphs.push.apply(glyphs, Array.from(run.glyphs || []));
            positions.push.apply(positions, Array.from(run.positions || []));
          }
          advanceWidth5 += run.advanceWidth;
          last3 = index2;
        } else {
          index2++;
        }
      }
      return {
        glyphs,
        positions,
        advanceWidth: advanceWidth5
      };
    };
    _proto.encode = function encode(text2, features) {
      var _this$layout = this.layout(text2, features), glyphs = _this$layout.glyphs, positions = _this$layout.positions;
      var res = [];
      for (var i = 0; i < glyphs.length; i++) {
        var glyph = glyphs[i];
        var gid = this.subset.includeGlyph(glyph.id);
        res.push(("0000" + gid.toString(16)).slice(-4));
        if (this.widths[gid] == null) {
          this.widths[gid] = glyph.advanceWidth * this.scale;
        }
        if (this.unicode[gid] == null) {
          this.unicode[gid] = glyph.codePoints;
        }
      }
      return [res, positions];
    };
    _proto.encodeGlyphs = function encodeGlyphs(glyphs) {
      var res = [];
      for (var i = 0; i < glyphs.length; i++) {
        var glyph = glyphs[i];
        var gid = this.subset.includeGlyph(glyph.id);
        res.push(("0000" + gid.toString(16)).slice(-4));
        if (this.widths[gid] == null) {
          this.widths[gid] = glyph.advanceWidth * this.scale;
        }
        if (this.unicode[gid] == null) {
          this.unicode[gid] = glyph.codePoints;
        }
      }
      return res;
    };
    _proto.widthOfString = function widthOfString2(string, size, features) {
      var width = this.layout(string, features, true).advanceWidth;
      var scale4 = size / 1e3;
      return width * scale4;
    };
    _proto.embed = function embed() {
      var isCFF = this.subset.cff != null;
      var fontFile = this.document.ref();
      if (isCFF) {
        fontFile.data.Subtype = "CIDFontType0C";
      }
      fontFile.end(this.subset.encode());
      var familyClass = ((this.font["OS/2"] != null ? this.font["OS/2"].sFamilyClass : void 0) || 0) >> 8;
      var flags = 0;
      if (this.font.post.isFixedPitch) {
        flags |= 1 << 0;
      }
      if (1 <= familyClass && familyClass <= 7) {
        flags |= 1 << 1;
      }
      flags |= 1 << 2;
      if (familyClass === 10) {
        flags |= 1 << 3;
      }
      if (this.font.head.macStyle.italic) {
        flags |= 1 << 6;
      }
      var tag = [0, 1, 2, 3, 4, 5].map(function() {
        return String.fromCharCode(Math.random() * 26 + 65);
      }).join("");
      var name2 = tag + "+" + this.font.postscriptName;
      var bbox = this.font.bbox;
      var descriptor = this.document.ref({
        Type: "FontDescriptor",
        FontName: name2,
        Flags: flags,
        FontBBox: [bbox.minX * this.scale, bbox.minY * this.scale, bbox.maxX * this.scale, bbox.maxY * this.scale],
        ItalicAngle: this.font.italicAngle,
        Ascent: this.ascender,
        Descent: this.descender,
        CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,
        XHeight: (this.font.xHeight || 0) * this.scale,
        StemV: 0
      });
      if (isCFF) {
        descriptor.data.FontFile3 = fontFile;
      } else {
        descriptor.data.FontFile2 = fontFile;
      }
      descriptor.end();
      var descendantFontData = {
        Type: "Font",
        Subtype: "CIDFontType0",
        BaseFont: name2,
        CIDSystemInfo: {
          Registry: new String("Adobe"),
          Ordering: new String("Identity"),
          Supplement: 0
        },
        FontDescriptor: descriptor,
        W: [0, this.widths]
      };
      if (!isCFF) {
        descendantFontData.Subtype = "CIDFontType2";
        descendantFontData.CIDToGIDMap = "Identity";
      }
      var descendantFont = this.document.ref(descendantFontData);
      descendantFont.end();
      this.dictionary.data = {
        Type: "Font",
        Subtype: "Type0",
        BaseFont: name2,
        Encoding: "Identity-H",
        DescendantFonts: [descendantFont],
        ToUnicode: this.toUnicodeCmap()
      };
      return this.dictionary.end();
    };
    _proto.toUnicodeCmap = function toUnicodeCmap() {
      var cmap = this.document.ref();
      var entries = [];
      var unicodeMap = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange";
      for (var _iterator = _createForOfIteratorHelperLoose(this.unicode.entries()), _step; !(_step = _iterator()).done; ) {
        var _step$value = _step.value, index2 = _step$value[0], codePoints = _step$value[1];
        var encoded = [];
        if (entries.length >= 100) {
          unicodeMap += "\n" + entries.length + " beginbfchar\n" + entries.join("\n") + "\nendbfchar";
          entries = [];
        }
        for (var _iterator2 = _createForOfIteratorHelperLoose(codePoints), _step2; !(_step2 = _iterator2()).done; ) {
          var value2 = _step2.value;
          if (value2 > 65535) {
            value2 -= 65536;
            encoded.push(toHex2(value2 >>> 10 & 1023 | 55296));
            value2 = 56320 | value2 & 1023;
          }
          encoded.push(toHex2(value2));
        }
        entries.push("<" + toHex2(index2) + "><" + encoded.join(" ") + ">");
      }
      if (entries.length) {
        unicodeMap += "\n" + entries.length + " beginbfchar\n" + entries.join("\n") + "\nendbfchar\n";
      }
      unicodeMap += "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
      cmap.end(unicodeMap);
      return cmap;
    };
    return EmbeddedFont2;
  }(PDFFont2);
};
var PDFFont = function() {
  function PDFFont2() {
  }
  PDFFont2.open = function open(document2, src, family, id) {
    var font2;
    if (typeof src === "string") {
      if (StandardFont.isStandardFont(src)) {
        return new StandardFont(document2, src, id);
      }
      {
        throw new Error("Can't open " + src + " in browser build");
      }
    } else if (src instanceof Uint8Array) {
      font2 = $d636bc798e7178db$export$185802fd694ee1f5(src, family);
    } else if (src instanceof ArrayBuffer) {
      font2 = $d636bc798e7178db$export$185802fd694ee1f5(new Uint8Array(src), family);
    } else if (typeof src === "object") {
      font2 = src;
    }
    if (font2 == null) {
      throw new Error("Not a supported font format or standard PDF font.");
    }
    return new EmbeddedFont(document2, font2, id);
  };
  var _proto = PDFFont2.prototype;
  _proto.encode = function encode() {
    throw new Error("Must be implemented by subclasses");
  };
  _proto.widthOfString = function widthOfString2() {
    throw new Error("Must be implemented by subclasses");
  };
  _proto.ref = function ref() {
    return this.dictionary != null ? this.dictionary : this.dictionary = this.document.ref();
  };
  _proto.finalize = function finalize() {
    if (this.embedded || this.dictionary == null) {
      return;
    }
    this.embed();
    return this.embedded = true;
  };
  _proto.embed = function embed() {
    throw new Error("Must be implemented by subclasses");
  };
  _proto.lineHeight = function lineHeight(size, includeGap) {
    if (includeGap == null) {
      includeGap = false;
    }
    var gap = includeGap ? this.lineGap : 0;
    return (this.ascender + gap - this.descender) / 1e3 * size;
  };
  return PDFFont2;
}();
var StandardFont = createStandardFont(PDFFont);
var EmbeddedFont = createEmbeddedFont(PDFFont);
var FontsMixin = {
  initFonts: function initFonts() {
    this._fontFamilies = {};
    this._fontCount = 0;
    this._fontSize = 12;
    this._font = null;
    this._registeredFonts = {};
    return this.font("Helvetica");
  },
  font: function font(src, family, size) {
    var cacheKey;
    var font2;
    if (typeof family === "number") {
      size = family;
      family = null;
    }
    if (typeof src === "string" && this._registeredFonts[src]) {
      cacheKey = src;
      var _this$_registeredFont = this._registeredFonts[src];
      src = _this$_registeredFont.src;
      family = _this$_registeredFont.family;
    } else {
      cacheKey = family || src;
      if (typeof cacheKey !== "string") {
        cacheKey = null;
      }
    }
    if (size != null) {
      this.fontSize(size);
    }
    if (font2 = this._fontFamilies[cacheKey]) {
      this._font = font2;
      return this;
    }
    var id = "F" + ++this._fontCount;
    this._font = PDFFont.open(this, src, family, id);
    if (font2 = this._fontFamilies[this._font.name]) {
      this._font = font2;
      return this;
    }
    if (cacheKey) {
      this._fontFamilies[cacheKey] = this._font;
    }
    if (this._font.name) {
      this._fontFamilies[this._font.name] = this._font;
    }
    return this;
  },
  fontSize: function fontSize(_fontSize) {
    this._fontSize = _fontSize;
    return this;
  },
  currentLineHeight: function currentLineHeight(includeGap) {
    if (includeGap == null) {
      includeGap = false;
    }
    return this._font.lineHeight(this._fontSize, includeGap);
  },
  registerFont: function registerFont(name2, src, family) {
    this._registeredFonts[name2] = {
      src,
      family
    };
    return this;
  }
};
var number = PDFObject$1.number;
var TextMixin = {
  initText: function initText() {
    this._line = this._line.bind(this);
    this.x = 0;
    this.y = 0;
    return this._lineGap = 0;
  },
  _text: function _text(text2, x, y, options, lineCallback) {
    var _this = this;
    options = this._initOptions(x, y, options);
    text2 = text2 == null ? "" : "" + text2;
    if (options.wordSpacing) {
      text2 = text2.replace(/\s{2,}/g, " ");
    }
    var addStructure2 = function addStructure3() {
      if (options.structParent) {
        options.structParent.add(_this.struct(options.structType || "P", [_this.markStructureContent(options.structType || "P")]));
      }
    };
    for (var _iterator = _createForOfIteratorHelperLoose(text2.split("\n")), _step; !(_step = _iterator()).done; ) {
      var line2 = _step.value;
      addStructure2();
      lineCallback(line2, options);
    }
    return this;
  },
  text: function text(_text2, x, y, options) {
    return this._text(_text2, x, y, options, this._line);
  },
  widthOfString: function widthOfString(string, options) {
    if (options === void 0) {
      options = {};
    }
    return this._font.widthOfString(string, this._fontSize, options.features) + (options.characterSpacing || 0) * (string.length - 1);
  },
  _initOptions: function _initOptions(x, y, options) {
    if (x === void 0) {
      x = {};
    }
    if (options === void 0) {
      options = {};
    }
    if (typeof x === "object") {
      options = x;
      x = null;
    }
    var result = Object.assign({}, options);
    if (this._textOptions) {
      for (var key in this._textOptions) {
        var val = this._textOptions[key];
        if (key !== "continued") {
          if (result[key] === void 0) {
            result[key] = val;
          }
        }
      }
    }
    if (x != null) {
      this.x = x;
    }
    if (y != null) {
      this.y = y;
    }
    if (result.lineBreak !== false) {
      if (result.width == null) {
        result.width = this.page.width - this.x - this.page.margins.right;
      }
      result.width = Math.max(result.width, 0);
    }
    if (!result.columns) {
      result.columns = 0;
    }
    if (result.columnGap == null) {
      result.columnGap = 18;
    }
    return result;
  },
  _line: function _line(text2, options) {
    if (options === void 0) {
      options = {};
    }
    this._fragment(text2, this.x, this.y, options);
    return this.x += this.widthOfString(text2);
  },
  _fragment: function _fragment(text2, x, y, options) {
    text2 = ("" + text2).replace(/\n/g, "");
    if (text2.length === 0) return;
    var _this$_font$encode = this._font.encode(text2, options.features), encoded = _this$_font$encode[0], positions = _this$_font$encode[1];
    var dy = this._font.ascender / 1e3 * this._fontSize;
    this._glyphs(encoded, positions, x, y + dy, options);
  },
  _glyphs: function _glyphs(encoded, positions, x, y, options) {
    var _this2 = this;
    var commands = [];
    var scale4 = this._fontSize / 1e3;
    var i;
    var last3 = 0;
    var hadOffset = false;
    this.save();
    this.transform(1, 0, 0, -1, 0, this.page.height);
    y = this.page.height - y;
    if (this.page.fonts[this._font.id] == null) {
      this.page.fonts[this._font.id] = this._font.ref();
    }
    this.addContent("BT");
    this.addContent("1 0 0 1 " + number(x) + " " + number(y) + " Tm");
    this.addContent("/" + this._font.id + " " + number(this._fontSize) + " Tf");
    var mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;
    if (mode) {
      this.addContent(mode + " Tr");
    }
    var addSegment = function addSegment2(cur) {
      if (last3 < cur) {
        var hex = encoded.slice(last3, cur).join("");
        var advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;
        commands.push("<" + hex + "> " + number(-advance));
      }
      return last3 = cur;
    };
    var flush = function flush2(i2) {
      addSegment(i2);
      if (commands.length > 0) {
        _this2.addContent("[" + commands.join(" ") + "] TJ");
        return commands.length = 0;
      }
    };
    for (i = 0; i < positions.length; i++) {
      var pos = positions[i];
      if (pos.xOffset || pos.yOffset) {
        flush(i);
        this.addContent("1 0 0 1 " + number(x + pos.xOffset * scale4) + " " + number(y + pos.yOffset * scale4) + " Tm");
        flush(i + 1);
        hadOffset = true;
      } else {
        if (hadOffset) {
          this.addContent("1 0 0 1 " + number(x) + " " + number(y) + " Tm");
          hadOffset = false;
        }
        if (pos.xAdvance - pos.advanceWidth !== 0) {
          addSegment(i + 1);
        }
      }
      x += pos.xAdvance * scale4;
    }
    flush(i);
    this.addContent("ET");
    return this.restore();
  }
};
var COLOR_SPACE_MAP = {
  1: "DeviceGray",
  3: "DeviceRGB",
  4: "DeviceCMYK"
};
var JPEG2 = function() {
  function JPEG5(data2, label) {
    this.data = data2;
    this.label = label;
    this.orientation = 1;
    if (this.data.readUInt16BE(0) !== 65496) {
      throw "SOI not found in JPEG";
    }
    var markers = src_default.decode(this.data);
    for (var i = 0; i < markers.length; i += 1) {
      var marker = markers[i];
      if (marker.name === "EXIF" && marker.entries.orientation) {
        this.orientation = marker.entries.orientation;
      }
      if (marker.name === "SOF") {
        this.bits || (this.bits = marker.precision);
        this.width || (this.width = marker.width);
        this.height || (this.height = marker.height);
        this.colorSpace || (this.colorSpace = COLOR_SPACE_MAP[marker.numberOfComponents]);
      }
    }
    this.obj = null;
  }
  var _proto = JPEG5.prototype;
  _proto.embed = function embed(document2) {
    if (this.obj) {
      return;
    }
    this.obj = document2.ref({
      Type: "XObject",
      Subtype: "Image",
      BitsPerComponent: this.bits,
      Width: this.width,
      Height: this.height,
      ColorSpace: this.colorSpace,
      Filter: "DCTDecode"
    });
    if (this.colorSpace === "DeviceCMYK") {
      this.obj.data["Decode"] = [1, 0, 1, 0, 1, 0, 1, 0];
    }
    this.obj.end(this.data);
    return this.data = null;
  };
  return JPEG5;
}();
var PNGImage = function() {
  function PNGImage2(data2, label) {
    this.label = label;
    this.image = new PNG(data2);
    this.width = this.image.width;
    this.height = this.image.height;
    this.imgData = this.image.imgData;
    this.obj = null;
  }
  var _proto = PNGImage2.prototype;
  _proto.embed = function embed(document2) {
    var dataDecoded = false;
    this.document = document2;
    if (this.obj) {
      return;
    }
    var hasAlphaChannel = this.image.hasAlphaChannel;
    var isInterlaced = this.image.interlaceMethod === 1;
    this.obj = this.document.ref({
      Type: "XObject",
      Subtype: "Image",
      BitsPerComponent: hasAlphaChannel ? 8 : this.image.bits,
      Width: this.width,
      Height: this.height,
      Filter: "FlateDecode"
    });
    if (!hasAlphaChannel) {
      var params = this.document.ref({
        Predictor: isInterlaced ? 1 : 15,
        Colors: this.image.colors,
        BitsPerComponent: this.image.bits,
        Columns: this.width
      });
      this.obj.data.DecodeParms = params;
      params.end();
    }
    if (this.image.palette.length === 0) {
      this.obj.data.ColorSpace = this.image.colorSpace;
    } else {
      var palette = this.document.ref();
      palette.end(Buffer$2.from(this.image.palette));
      this.obj.data.ColorSpace = ["Indexed", "DeviceRGB", this.image.palette.length / 3 - 1, palette];
    }
    if (this.image.transparency.grayscale != null) {
      var val = this.image.transparency.grayscale;
      this.obj.data.Mask = [val, val];
    } else if (this.image.transparency.rgb) {
      var rgb = this.image.transparency.rgb;
      var mask = [];
      for (var _iterator = _createForOfIteratorHelperLoose(rgb), _step; !(_step = _iterator()).done; ) {
        var x = _step.value;
        mask.push(x, x);
      }
      this.obj.data.Mask = mask;
    } else if (this.image.transparency.indexed) {
      dataDecoded = true;
      return this.loadIndexedAlphaChannel();
    } else if (hasAlphaChannel) {
      dataDecoded = true;
      return this.splitAlphaChannel();
    }
    if (isInterlaced && !dataDecoded) {
      return this.decodeData();
    }
    this.finalize();
  };
  _proto.finalize = function finalize() {
    if (this.alphaChannel) {
      var sMask = this.document.ref({
        Type: "XObject",
        Subtype: "Image",
        Height: this.height,
        Width: this.width,
        BitsPerComponent: 8,
        Filter: "FlateDecode",
        ColorSpace: "DeviceGray",
        Decode: [0, 1]
      });
      sMask.end(this.alphaChannel);
      this.obj.data.SMask = sMask;
    }
    this.obj.end(this.imgData);
    this.image = null;
    return this.imgData = null;
  };
  _proto.splitAlphaChannel = function splitAlphaChannel() {
    var _this = this;
    return this.image.decodePixels(function(pixels) {
      var a2;
      var p;
      var colorCount = _this.image.colors;
      var pixelCount = _this.width * _this.height;
      var imgData = Buffer$2.alloc(pixelCount * colorCount);
      var alphaChannel = Buffer$2.alloc(pixelCount);
      var i = p = a2 = 0;
      var len = pixels.length;
      var skipByteCount = _this.image.bits === 16 ? 1 : 0;
      while (i < len) {
        for (var colorIndex = 0; colorIndex < colorCount; colorIndex++) {
          imgData[p++] = pixels[i++];
          i += skipByteCount;
        }
        alphaChannel[a2++] = pixels[i++];
        i += skipByteCount;
      }
      _this.imgData = zlib2.deflateSync(imgData);
      _this.alphaChannel = zlib2.deflateSync(alphaChannel);
      return _this.finalize();
    });
  };
  _proto.loadIndexedAlphaChannel = function loadIndexedAlphaChannel() {
    var _this2 = this;
    var transparency = this.image.transparency.indexed;
    return this.image.decodePixels(function(pixels) {
      var alphaChannel = Buffer$2.alloc(_this2.width * _this2.height);
      var i = 0;
      for (var j = 0, end3 = pixels.length; j < end3; j++) {
        alphaChannel[i++] = transparency[pixels[j]];
      }
      _this2.alphaChannel = zlib2.deflateSync(alphaChannel);
      return _this2.finalize();
    });
  };
  _proto.decodeData = function decodeData() {
    var _this3 = this;
    this.image.decodePixels(function(pixels) {
      _this3.imgData = zlib2.deflateSync(pixels);
      _this3.finalize();
    });
  };
  return PNGImage2;
}();
var PDFImage = function() {
  function PDFImage2() {
  }
  PDFImage2.open = function open(src, label) {
    var data2;
    if (Buffer$2.isBuffer(src)) {
      data2 = src;
    } else if (src instanceof ArrayBuffer) {
      data2 = Buffer$2.from(new Uint8Array(src));
    } else {
      var match;
      if (match = /^data:.+?;base64,(.*)$/.exec(src)) {
        data2 = Buffer$2.from(match[1], "base64");
      } else {
        data2 = fs.readFileSync(src);
        if (!data2) {
          return;
        }
      }
    }
    if (data2[0] === 255 && data2[1] === 216) {
      return new JPEG2(data2, label);
    } else if (data2[0] === 137 && data2.toString("ascii", 1, 4) === "PNG") {
      return new PNGImage(data2, label);
    } else {
      throw new Error("Unknown image format.");
    }
  };
  return PDFImage2;
}();
var ImagesMixin = {
  initImages: function initImages() {
    this._imageRegistry = {};
    return this._imageCount = 0;
  },
  embedImage: function embedImage(src) {
    var image2;
    if (typeof src === "string") {
      image2 = this._imageRegistry[src];
    }
    if (!image2) {
      if (src.width && src.height) {
        image2 = src;
      } else {
        image2 = this.openImage(src);
      }
    }
    if (!image2.obj) {
      image2.embed(this);
    }
    return image2;
  },
  image: function image(src, x, y, options) {
    if (options === void 0) {
      options = {};
    }
    var bh;
    var bp;
    var bw;
    var image2;
    var ip;
    var left;
    var left1;
    var rotateAngle;
    var originX;
    var originY;
    if (typeof x === "object") {
      options = x;
      x = null;
    }
    var ignoreOrientation = options.ignoreOrientation || options.ignoreOrientation !== false && this.options.ignoreOrientation;
    x = (left = x != null ? x : options.x) != null ? left : this.x;
    y = (left1 = y != null ? y : options.y) != null ? left1 : this.y;
    if (typeof src === "string") {
      image2 = this._imageRegistry[src];
    }
    if (!image2) {
      if (src.width && src.height) {
        image2 = src;
      } else {
        image2 = this.openImage(src);
      }
    }
    if (!image2.obj) {
      image2.embed(this);
    }
    if (this.page.xobjects[image2.label] == null) {
      this.page.xobjects[image2.label] = image2.obj;
    }
    var _image = image2, width = _image.width, height5 = _image.height;
    if (!ignoreOrientation && image2.orientation > 4) {
      var _ref = [height5, width];
      width = _ref[0];
      height5 = _ref[1];
    }
    var w = options.width || width;
    var h2 = options.height || height5;
    if (options.width && !options.height) {
      var wp = w / width;
      w = width * wp;
      h2 = height5 * wp;
    } else if (options.height && !options.width) {
      var hp = h2 / height5;
      w = width * hp;
      h2 = height5 * hp;
    } else if (options.scale) {
      w = width * options.scale;
      h2 = height5 * options.scale;
    } else if (options.fit) {
      var _options$fit = options.fit;
      bw = _options$fit[0];
      bh = _options$fit[1];
      bp = bw / bh;
      ip = width / height5;
      if (ip > bp) {
        w = bw;
        h2 = bw / ip;
      } else {
        h2 = bh;
        w = bh * ip;
      }
    } else if (options.cover) {
      var _options$cover = options.cover;
      bw = _options$cover[0];
      bh = _options$cover[1];
      bp = bw / bh;
      ip = width / height5;
      if (ip > bp) {
        h2 = bh;
        w = bh * ip;
      } else {
        w = bw;
        h2 = bw / ip;
      }
    }
    if (options.fit || options.cover) {
      if (options.align === "center") {
        x = x + bw / 2 - w / 2;
      } else if (options.align === "right") {
        x = x + bw - w;
      }
      if (options.valign === "center") {
        y = y + bh / 2 - h2 / 2;
      } else if (options.valign === "bottom") {
        y = y + bh - h2;
      }
    }
    if (!ignoreOrientation) {
      switch (image2.orientation) {
        default:
        case 1:
          h2 = -h2;
          y -= h2;
          rotateAngle = 0;
          break;
        case 2:
          w = -w;
          h2 = -h2;
          x -= w;
          y -= h2;
          rotateAngle = 0;
          break;
        case 3:
          originX = x;
          originY = y;
          h2 = -h2;
          x -= w;
          rotateAngle = 180;
          break;
        case 4:
          break;
        case 5:
          originX = x;
          originY = y;
          var _ref2 = [h2, w];
          w = _ref2[0];
          h2 = _ref2[1];
          y -= h2;
          rotateAngle = 90;
          break;
        case 6:
          originX = x;
          originY = y;
          var _ref3 = [h2, w];
          w = _ref3[0];
          h2 = _ref3[1];
          h2 = -h2;
          rotateAngle = 90;
          break;
        case 7:
          originX = x;
          originY = y;
          var _ref4 = [h2, w];
          w = _ref4[0];
          h2 = _ref4[1];
          h2 = -h2;
          w = -w;
          x -= w;
          rotateAngle = 90;
          break;
        case 8:
          originX = x;
          originY = y;
          var _ref5 = [h2, w];
          w = _ref5[0];
          h2 = _ref5[1];
          h2 = -h2;
          x -= w;
          y -= h2;
          rotateAngle = -90;
          break;
      }
    } else {
      h2 = -h2;
      y -= h2;
      rotateAngle = 0;
    }
    if (this.y === y) {
      this.y += h2;
    }
    this.save();
    if (rotateAngle) {
      this.rotate(rotateAngle, {
        origin: [originX, originY]
      });
    }
    this.transform(w, 0, 0, h2, x, y);
    this.addContent("/" + image2.label + " Do");
    this.restore();
    return this;
  },
  openImage: function openImage(src) {
    var image2;
    if (typeof src === "string") {
      image2 = this._imageRegistry[src];
    }
    if (!image2) {
      image2 = PDFImage.open(src, "I" + ++this._imageCount);
      if (typeof src === "string") {
        this._imageRegistry[src] = image2;
      }
    }
    return image2;
  }
};
var AnnotationsMixin = {
  annotate: function annotate(x, y, w, h2, options) {
    options.Type = "Annot";
    options.Rect = this._convertRect(x, y, w, h2);
    options.Border = [0, 0, 0];
    if (options.Subtype === "Link" && typeof options.F === "undefined") {
      options.F = 1 << 2;
    }
    if (options.Subtype !== "Link") {
      if (options.C == null) {
        options.C = this._normalizeColor(options.color || [0, 0, 0]);
      }
    }
    delete options.color;
    if (typeof options.Dest === "string") {
      options.Dest = new String(options.Dest);
    }
    for (var key in options) {
      var val = options[key];
      options[key[0].toUpperCase() + key.slice(1)] = val;
    }
    var ref = this.ref(options);
    this.page.annotations.push(ref);
    ref.end();
    return this;
  },
  note: function note(x, y, w, h2, contents, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Text";
    options.Contents = new String(contents);
    options.Name = "Comment";
    if (options.color == null) {
      options.color = [243, 223, 92];
    }
    return this.annotate(x, y, w, h2, options);
  },
  goTo: function goTo(x, y, w, h2, name2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Link";
    options.A = this.ref({
      S: "GoTo",
      D: new String(name2)
    });
    options.A.end();
    return this.annotate(x, y, w, h2, options);
  },
  link: function link(x, y, w, h2, url, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Link";
    if (typeof url === "number") {
      var pages = this._root.data.Pages.data;
      if (url >= 0 && url < pages.Kids.length) {
        options.A = this.ref({
          S: "GoTo",
          D: [pages.Kids[url], "XYZ", null, null, null]
        });
        options.A.end();
      } else {
        throw new Error("The document has no page " + url);
      }
    } else {
      options.A = this.ref({
        S: "URI",
        URI: new String(url)
      });
      options.A.end();
    }
    return this.annotate(x, y, w, h2, options);
  },
  _markup: function _markup(x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    var _this$_convertRect = this._convertRect(x, y, w, h2), x1 = _this$_convertRect[0], y1 = _this$_convertRect[1], x2 = _this$_convertRect[2], y2 = _this$_convertRect[3];
    options.QuadPoints = [x1, y2, x2, y2, x1, y1, x2, y1];
    options.Contents = new String();
    return this.annotate(x, y, w, h2, options);
  },
  highlight: function highlight(x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Highlight";
    if (options.color == null) {
      options.color = [241, 238, 148];
    }
    return this._markup(x, y, w, h2, options);
  },
  underline: function underline(x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Underline";
    return this._markup(x, y, w, h2, options);
  },
  strike: function strike(x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "StrikeOut";
    return this._markup(x, y, w, h2, options);
  },
  lineAnnotation: function lineAnnotation(x1, y1, x2, y2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Line";
    options.Contents = new String();
    options.L = [x1, this.page.height - y1, x2, this.page.height - y2];
    return this.annotate(x1, y1, x2, y2, options);
  },
  rectAnnotation: function rectAnnotation(x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Square";
    options.Contents = new String();
    return this.annotate(x, y, w, h2, options);
  },
  ellipseAnnotation: function ellipseAnnotation(x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Circle";
    options.Contents = new String();
    return this.annotate(x, y, w, h2, options);
  },
  textAnnotation: function textAnnotation(x, y, w, h2, text2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "FreeText";
    options.Contents = new String(text2);
    options.DA = new String();
    return this.annotate(x, y, w, h2, options);
  },
  fileAnnotation: function fileAnnotation(x, y, w, h2, file2, options) {
    if (file2 === void 0) {
      file2 = {};
    }
    if (options === void 0) {
      options = {};
    }
    var filespec = this.file(file2.src, Object.assign({
      hidden: true
    }, file2));
    options.Subtype = "FileAttachment";
    options.FS = filespec;
    if (options.Contents) {
      options.Contents = new String(options.Contents);
    } else if (filespec.data.Desc) {
      options.Contents = filespec.data.Desc;
    }
    return this.annotate(x, y, w, h2, options);
  },
  _convertRect: function _convertRect(x1, y1, w, h2) {
    var y2 = y1;
    y1 += h2;
    var x2 = x1 + w;
    var _this$_ctm = this._ctm, m0 = _this$_ctm[0], m1 = _this$_ctm[1], m2 = _this$_ctm[2], m3 = _this$_ctm[3], m4 = _this$_ctm[4], m5 = _this$_ctm[5];
    x1 = m0 * x1 + m2 * y1 + m4;
    y1 = m1 * x1 + m3 * y1 + m5;
    x2 = m0 * x2 + m2 * y2 + m4;
    y2 = m1 * x2 + m3 * y2 + m5;
    return [x1, y1, x2, y2];
  }
};
var PDFOutline = function() {
  function PDFOutline2(document2, parent, title3, dest, options) {
    if (options === void 0) {
      options = {
        expanded: false
      };
    }
    this.document = document2;
    this.options = options;
    this.outlineData = {};
    if (dest !== null) {
      this.outlineData["Dest"] = [dest.dictionary, "Fit"];
    }
    if (parent !== null) {
      this.outlineData["Parent"] = parent;
    }
    if (title3 !== null) {
      this.outlineData["Title"] = new String(title3);
    }
    this.dictionary = this.document.ref(this.outlineData);
    this.children = [];
  }
  var _proto = PDFOutline2.prototype;
  _proto.addItem = function addItem(title3, options) {
    if (options === void 0) {
      options = {
        expanded: false
      };
    }
    var result = new PDFOutline2(this.document, this.dictionary, title3, this.document.page, options);
    this.children.push(result);
    return result;
  };
  _proto.endOutline = function endOutline2() {
    if (this.children.length > 0) {
      if (this.options.expanded) {
        this.outlineData.Count = this.children.length;
      }
      var first = this.children[0], last3 = this.children[this.children.length - 1];
      this.outlineData.First = first.dictionary;
      this.outlineData.Last = last3.dictionary;
      for (var i = 0, len = this.children.length; i < len; i++) {
        var child = this.children[i];
        if (i > 0) {
          child.outlineData.Prev = this.children[i - 1].dictionary;
        }
        if (i < this.children.length - 1) {
          child.outlineData.Next = this.children[i + 1].dictionary;
        }
        child.endOutline();
      }
    }
    return this.dictionary.end();
  };
  return PDFOutline2;
}();
var OutlineMixin = {
  initOutline: function initOutline() {
    return this.outline = new PDFOutline(this, null, null, null);
  },
  endOutline: function endOutline() {
    this.outline.endOutline();
    if (this.outline.children.length > 0) {
      this._root.data.Outlines = this.outline.dictionary;
      return this._root.data.PageMode = "UseOutlines";
    }
  }
};
var PDFStructureContent = function() {
  function PDFStructureContent2(pageRef, mcid) {
    this.refs = [{
      pageRef,
      mcid
    }];
  }
  var _proto = PDFStructureContent2.prototype;
  _proto.push = function push(structContent) {
    var _this = this;
    structContent.refs.forEach(function(ref) {
      return _this.refs.push(ref);
    });
  };
  return PDFStructureContent2;
}();
var PDFStructureElement = function() {
  function PDFStructureElement2(document2, type2, options, children) {
    var _this = this;
    if (options === void 0) {
      options = {};
    }
    if (children === void 0) {
      children = null;
    }
    this.document = document2;
    this._attached = false;
    this._ended = false;
    this._flushed = false;
    this.dictionary = document2.ref({
      // Type: "StructElem",
      S: type2
    });
    var data2 = this.dictionary.data;
    if (Array.isArray(options) || this._isValidChild(options)) {
      children = options;
      options = {};
    }
    if (typeof options.title !== "undefined") {
      data2.T = new String(options.title);
    }
    if (typeof options.lang !== "undefined") {
      data2.Lang = new String(options.lang);
    }
    if (typeof options.alt !== "undefined") {
      data2.Alt = new String(options.alt);
    }
    if (typeof options.expanded !== "undefined") {
      data2.E = new String(options.expanded);
    }
    if (typeof options.actual !== "undefined") {
      data2.ActualText = new String(options.actual);
    }
    this._children = [];
    if (children) {
      if (!Array.isArray(children)) {
        children = [children];
      }
      children.forEach(function(child) {
        return _this.add(child);
      });
      this.end();
    }
  }
  var _proto = PDFStructureElement2.prototype;
  _proto.add = function add3(child) {
    if (this._ended) {
      throw new Error("Cannot add child to already-ended structure element");
    }
    if (!this._isValidChild(child)) {
      throw new Error("Invalid structure element child");
    }
    if (child instanceof PDFStructureElement2) {
      child.setParent(this.dictionary);
      if (this._attached) {
        child.setAttached();
      }
    }
    if (child instanceof PDFStructureContent) {
      this._addContentToParentTree(child);
    }
    if (typeof child === "function" && this._attached) {
      child = this._contentForClosure(child);
    }
    this._children.push(child);
    return this;
  };
  _proto._addContentToParentTree = function _addContentToParentTree(content) {
    var _this2 = this;
    content.refs.forEach(function(_ref) {
      var pageRef = _ref.pageRef, mcid = _ref.mcid;
      var pageStructParents = _this2.document.getStructParentTree().get(pageRef.data.StructParents);
      pageStructParents[mcid] = _this2.dictionary;
    });
  };
  _proto.setParent = function setParent(parentRef) {
    if (this.dictionary.data.P) {
      throw new Error("Structure element added to more than one parent");
    }
    this.dictionary.data.P = parentRef;
    this._flush();
  };
  _proto.setAttached = function setAttached() {
    var _this3 = this;
    if (this._attached) {
      return;
    }
    this._children.forEach(function(child, index2) {
      if (child instanceof PDFStructureElement2) {
        child.setAttached();
      }
      if (typeof child === "function") {
        _this3._children[index2] = _this3._contentForClosure(child);
      }
    });
    this._attached = true;
    this._flush();
  };
  _proto.end = function end3() {
    if (this._ended) {
      return;
    }
    this._children.filter(function(child) {
      return child instanceof PDFStructureElement2;
    }).forEach(function(child) {
      return child.end();
    });
    this._ended = true;
    this._flush();
  };
  _proto._isValidChild = function _isValidChild(child) {
    return child instanceof PDFStructureElement2 || child instanceof PDFStructureContent || typeof child === "function";
  };
  _proto._contentForClosure = function _contentForClosure(closure) {
    var content = this.document.markStructureContent(this.dictionary.data.S);
    closure();
    this.document.endMarkedContent();
    this._addContentToParentTree(content);
    return content;
  };
  _proto._isFlushable = function _isFlushable() {
    if (!this.dictionary.data.P || !this._ended) {
      return false;
    }
    return this._children.every(function(child) {
      if (typeof child === "function") {
        return false;
      }
      if (child instanceof PDFStructureElement2) {
        return child._isFlushable();
      }
      return true;
    });
  };
  _proto._flush = function _flush() {
    var _this4 = this;
    if (this._flushed || !this._isFlushable()) {
      return;
    }
    this.dictionary.data.K = [];
    this._children.forEach(function(child) {
      return _this4._flushChild(child);
    });
    this.dictionary.end();
    this._children = [];
    this.dictionary.data.K = null;
    this._flushed = true;
  };
  _proto._flushChild = function _flushChild(child) {
    var _this5 = this;
    if (child instanceof PDFStructureElement2) {
      this.dictionary.data.K.push(child.dictionary);
    }
    if (child instanceof PDFStructureContent) {
      child.refs.forEach(function(_ref2) {
        var pageRef = _ref2.pageRef, mcid = _ref2.mcid;
        if (!_this5.dictionary.data.Pg) {
          _this5.dictionary.data.Pg = pageRef;
        }
        if (_this5.dictionary.data.Pg === pageRef) {
          _this5.dictionary.data.K.push(mcid);
        } else {
          _this5.dictionary.data.K.push({
            Type: "MCR",
            Pg: pageRef,
            MCID: mcid
          });
        }
      });
    }
  };
  return PDFStructureElement2;
}();
var PDFNumberTree = function(_PDFTree) {
  _inheritsLoose(PDFNumberTree2, _PDFTree);
  function PDFNumberTree2() {
    return _PDFTree.apply(this, arguments) || this;
  }
  var _proto = PDFNumberTree2.prototype;
  _proto._compareKeys = function _compareKeys(a2, b) {
    return parseInt(a2) - parseInt(b);
  };
  _proto._keysName = function _keysName() {
    return "Nums";
  };
  _proto._dataForKey = function _dataForKey(k) {
    return parseInt(k);
  };
  return PDFNumberTree2;
}(PDFTree);
var MarkingsMixin = {
  initMarkings: function initMarkings(options) {
    this.structChildren = [];
    if (options.tagged) {
      this.getMarkInfoDictionary().data.Marked = true;
      this.getStructTreeRoot();
    }
  },
  markContent: function markContent(tag, options) {
    if (options === void 0) {
      options = null;
    }
    if (tag === "Artifact" || options && options.mcid) {
      var toClose = 0;
      this.page.markings.forEach(function(marking) {
        if (toClose || marking.structContent || marking.tag === "Artifact") {
          toClose++;
        }
      });
      while (toClose--) {
        this.endMarkedContent();
      }
    }
    if (!options) {
      this.page.markings.push({
        tag
      });
      this.addContent("/" + tag + " BMC");
      return this;
    }
    this.page.markings.push({
      tag,
      options
    });
    var dictionary = {};
    if (typeof options.mcid !== "undefined") {
      dictionary.MCID = options.mcid;
    }
    if (tag === "Artifact") {
      if (typeof options.type === "string") {
        dictionary.Type = options.type;
      }
      if (Array.isArray(options.bbox)) {
        dictionary.BBox = [options.bbox[0], this.page.height - options.bbox[3], options.bbox[2], this.page.height - options.bbox[1]];
      }
      if (Array.isArray(options.attached) && options.attached.every(function(val) {
        return typeof val === "string";
      })) {
        dictionary.Attached = options.attached;
      }
    }
    if (tag === "Span") {
      if (options.lang) {
        dictionary.Lang = new String(options.lang);
      }
      if (options.alt) {
        dictionary.Alt = new String(options.alt);
      }
      if (options.expanded) {
        dictionary.E = new String(options.expanded);
      }
      if (options.actual) {
        dictionary.ActualText = new String(options.actual);
      }
    }
    this.addContent("/" + tag + " " + PDFObject$1.convert(dictionary) + " BDC");
    return this;
  },
  markStructureContent: function markStructureContent(tag, options) {
    if (options === void 0) {
      options = {};
    }
    var pageStructParents = this.getStructParentTree().get(this.page.structParentTreeKey);
    var mcid = pageStructParents.length;
    pageStructParents.push(null);
    this.markContent(tag, _extends({}, options, {
      mcid
    }));
    var structContent = new PDFStructureContent(this.page.dictionary, mcid);
    this.page.markings.slice(-1)[0].structContent = structContent;
    return structContent;
  },
  endMarkedContent: function endMarkedContent() {
    this.page.markings.pop();
    this.addContent("EMC");
    return this;
  },
  struct: function struct(type2, options, children) {
    if (options === void 0) {
      options = {};
    }
    if (children === void 0) {
      children = null;
    }
    return new PDFStructureElement(this, type2, options, children);
  },
  addStructure: function addStructure(structElem) {
    var structTreeRoot = this.getStructTreeRoot();
    structElem.setParent(structTreeRoot);
    structElem.setAttached();
    this.structChildren.push(structElem);
    if (!structTreeRoot.data.K) {
      structTreeRoot.data.K = [];
    }
    structTreeRoot.data.K.push(structElem.dictionary);
    return this;
  },
  initPageMarkings: function initPageMarkings(pageMarkings) {
    var _this = this;
    pageMarkings.forEach(function(marking) {
      if (marking.structContent) {
        var structContent = marking.structContent;
        var newStructContent = _this.markStructureContent(marking.tag, marking.options);
        structContent.push(newStructContent);
        _this.page.markings.slice(-1)[0].structContent = structContent;
      } else {
        _this.markContent(marking.tag, marking.options);
      }
    });
  },
  endPageMarkings: function endPageMarkings(page) {
    var pageMarkings = page.markings;
    pageMarkings.forEach(function() {
      return page.write("EMC");
    });
    page.markings = [];
    return pageMarkings;
  },
  getMarkInfoDictionary: function getMarkInfoDictionary() {
    if (!this._root.data.MarkInfo) {
      this._root.data.MarkInfo = this.ref({});
    }
    return this._root.data.MarkInfo;
  },
  getStructTreeRoot: function getStructTreeRoot() {
    if (!this._root.data.StructTreeRoot) {
      this._root.data.StructTreeRoot = this.ref({
        Type: "StructTreeRoot",
        ParentTree: new PDFNumberTree(),
        ParentTreeNextKey: 0
      });
    }
    return this._root.data.StructTreeRoot;
  },
  getStructParentTree: function getStructParentTree() {
    return this.getStructTreeRoot().data.ParentTree;
  },
  createStructParentTreeNextKey: function createStructParentTreeNextKey() {
    this.getMarkInfoDictionary();
    var structTreeRoot = this.getStructTreeRoot();
    var key = structTreeRoot.data.ParentTreeNextKey++;
    structTreeRoot.data.ParentTree.add(key, []);
    return key;
  },
  endMarkings: function endMarkings() {
    var structTreeRoot = this._root.data.StructTreeRoot;
    if (structTreeRoot) {
      structTreeRoot.end();
      this.structChildren.forEach(function(structElem) {
        return structElem.end();
      });
    }
    if (this._root.data.MarkInfo) {
      this._root.data.MarkInfo.end();
    }
  }
};
var FIELD_FLAGS = {
  readOnly: 1,
  required: 2,
  noExport: 4,
  multiline: 4096,
  password: 8192,
  toggleToOffButton: 16384,
  radioButton: 32768,
  pushButton: 65536,
  combo: 131072,
  edit: 262144,
  sort: 524288,
  multiSelect: 2097152,
  noSpell: 4194304
};
var FIELD_JUSTIFY = {
  left: 0,
  center: 1,
  right: 2
};
var VALUE_MAP = {
  value: "V",
  defaultValue: "DV"
};
var FORMAT_SPECIAL = {
  zip: "0",
  zipPlus4: "1",
  zip4: "1",
  phone: "2",
  ssn: "3"
};
var FORMAT_DEFAULT = {
  number: {
    nDec: 0,
    sepComma: false,
    negStyle: "MinusBlack",
    currency: "",
    currencyPrepend: true
  },
  percent: {
    nDec: 0,
    sepComma: false
  }
};
var AcroFormMixin = {
  /**
   * Must call if adding AcroForms to a document. Must also call font() before
   * this method to set the default font.
   */
  initForm: function initForm() {
    if (!this._font) {
      throw new Error("Must set a font before calling initForm method");
    }
    this._acroform = {
      fonts: {},
      defaultFont: this._font.name
    };
    this._acroform.fonts[this._font.id] = this._font.ref();
    var data2 = {
      Fields: [],
      NeedAppearances: true,
      DA: new String("/" + this._font.id + " 0 Tf 0 g"),
      DR: {
        Font: {}
      }
    };
    data2.DR.Font[this._font.id] = this._font.ref();
    var AcroForm = this.ref(data2);
    this._root.data.AcroForm = AcroForm;
    return this;
  },
  /**
   * Called automatically by document.js
   */
  endAcroForm: function endAcroForm() {
    var _this = this;
    if (this._root.data.AcroForm) {
      if (!Object.keys(this._acroform.fonts).length && !this._acroform.defaultFont) {
        throw new Error("No fonts specified for PDF form");
      }
      var fontDict = this._root.data.AcroForm.data.DR.Font;
      Object.keys(this._acroform.fonts).forEach(function(name2) {
        fontDict[name2] = _this._acroform.fonts[name2];
      });
      this._root.data.AcroForm.data.Fields.forEach(function(fieldRef) {
        _this._endChild(fieldRef);
      });
      this._root.data.AcroForm.end();
    }
    return this;
  },
  _endChild: function _endChild(ref) {
    var _this2 = this;
    if (Array.isArray(ref.data.Kids)) {
      ref.data.Kids.forEach(function(childRef) {
        _this2._endChild(childRef);
      });
      ref.end();
    }
    return this;
  },
  /**
   * Creates and adds a form field to the document. Form fields are intermediate
   * nodes in a PDF form that are used to specify form name heirarchy and form
   * value defaults.
   * @param {string} name - field name (T attribute in field dictionary)
   * @param {object} options  - other attributes to include in field dictionary
   */
  formField: function formField(name2, options) {
    if (options === void 0) {
      options = {};
    }
    var fieldDict = this._fieldDict(name2, null, options);
    var fieldRef = this.ref(fieldDict);
    this._addToParent(fieldRef);
    return fieldRef;
  },
  /**
   * Creates and adds a Form Annotation to the document. Form annotations are
   * called Widget annotations internally within a PDF file.
   * @param {string} name - form field name (T attribute of widget annotation
   * dictionary)
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @param {object} options
   */
  formAnnotation: function formAnnotation(name2, type2, x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    var fieldDict = this._fieldDict(name2, type2, options);
    fieldDict.Subtype = "Widget";
    if (fieldDict.F === void 0) {
      fieldDict.F = 4;
    }
    this.annotate(x, y, w, h2, fieldDict);
    var annotRef = this.page.annotations[this.page.annotations.length - 1];
    return this._addToParent(annotRef);
  },
  formText: function formText(name2, x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name2, "text", x, y, w, h2, options);
  },
  formPushButton: function formPushButton(name2, x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name2, "pushButton", x, y, w, h2, options);
  },
  formCombo: function formCombo(name2, x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name2, "combo", x, y, w, h2, options);
  },
  formList: function formList(name2, x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name2, "list", x, y, w, h2, options);
  },
  formRadioButton: function formRadioButton(name2, x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name2, "radioButton", x, y, w, h2, options);
  },
  formCheckbox: function formCheckbox(name2, x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name2, "checkbox", x, y, w, h2, options);
  },
  _addToParent: function _addToParent(fieldRef) {
    var parent = fieldRef.data.Parent;
    if (parent) {
      if (!parent.data.Kids) {
        parent.data.Kids = [];
      }
      parent.data.Kids.push(fieldRef);
    } else {
      this._root.data.AcroForm.data.Fields.push(fieldRef);
    }
    return this;
  },
  _fieldDict: function _fieldDict(name2, type2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!this._acroform) {
      throw new Error("Call document.initForms() method before adding form elements to document");
    }
    var opts2 = Object.assign({}, options);
    if (type2 !== null) {
      opts2 = this._resolveType(type2, options);
    }
    opts2 = this._resolveFlags(opts2);
    opts2 = this._resolveJustify(opts2);
    opts2 = this._resolveFont(opts2);
    opts2 = this._resolveStrings(opts2);
    opts2 = this._resolveColors(opts2);
    opts2 = this._resolveFormat(opts2);
    opts2.T = new String(name2);
    if (opts2.parent) {
      opts2.Parent = opts2.parent;
      delete opts2.parent;
    }
    return opts2;
  },
  _resolveType: function _resolveType(type2, opts2) {
    if (type2 === "text") {
      opts2.FT = "Tx";
    } else if (type2 === "pushButton") {
      opts2.FT = "Btn";
      opts2.pushButton = true;
    } else if (type2 === "radioButton") {
      opts2.FT = "Btn";
      opts2.radioButton = true;
    } else if (type2 === "checkbox") {
      opts2.FT = "Btn";
    } else if (type2 === "combo") {
      opts2.FT = "Ch";
      opts2.combo = true;
    } else if (type2 === "list") {
      opts2.FT = "Ch";
    } else {
      throw new Error("Invalid form annotation type '" + type2 + "'");
    }
    return opts2;
  },
  _resolveFormat: function _resolveFormat(opts2) {
    var f = opts2.format;
    if (f && f.type) {
      var fnKeystroke;
      var fnFormat;
      var params = "";
      if (FORMAT_SPECIAL[f.type] !== void 0) {
        fnKeystroke = "AFSpecial_Keystroke";
        fnFormat = "AFSpecial_Format";
        params = FORMAT_SPECIAL[f.type];
      } else {
        var format3 = f.type.charAt(0).toUpperCase() + f.type.slice(1);
        fnKeystroke = "AF" + format3 + "_Keystroke";
        fnFormat = "AF" + format3 + "_Format";
        if (f.type === "date") {
          fnKeystroke += "Ex";
          params = String(f.param);
        } else if (f.type === "time") {
          params = String(f.param);
        } else if (f.type === "number") {
          var p = Object.assign({}, FORMAT_DEFAULT.number, f);
          params = String([String(p.nDec), p.sepComma ? "0" : "1", '"' + p.negStyle + '"', "null", '"' + p.currency + '"', String(p.currencyPrepend)].join(","));
        } else if (f.type === "percent") {
          var _p = Object.assign({}, FORMAT_DEFAULT.percent, f);
          params = String([String(_p.nDec), _p.sepComma ? "0" : "1"].join(","));
        }
      }
      opts2.AA = opts2.AA ? opts2.AA : {};
      opts2.AA.K = {
        S: "JavaScript",
        JS: new String(fnKeystroke + "(" + params + ");")
      };
      opts2.AA.F = {
        S: "JavaScript",
        JS: new String(fnFormat + "(" + params + ");")
      };
    }
    delete opts2.format;
    return opts2;
  },
  _resolveColors: function _resolveColors(opts2) {
    var color = this._normalizeColor(opts2.backgroundColor);
    if (color) {
      if (!opts2.MK) {
        opts2.MK = {};
      }
      opts2.MK.BG = color;
    }
    color = this._normalizeColor(opts2.borderColor);
    if (color) {
      if (!opts2.MK) {
        opts2.MK = {};
      }
      opts2.MK.BC = color;
    }
    delete opts2.backgroundColor;
    delete opts2.borderColor;
    return opts2;
  },
  _resolveFlags: function _resolveFlags(options) {
    var result = 0;
    Object.keys(options).forEach(function(key) {
      if (FIELD_FLAGS[key]) {
        result |= FIELD_FLAGS[key];
        delete options[key];
      }
    });
    if (result !== 0) {
      options.Ff = options.Ff ? options.Ff : 0;
      options.Ff |= result;
    }
    return options;
  },
  _resolveJustify: function _resolveJustify(options) {
    var result = 0;
    if (options.align !== void 0) {
      if (typeof FIELD_JUSTIFY[options.align] === "number") {
        result = FIELD_JUSTIFY[options.align];
      }
      delete options.align;
    }
    if (result !== 0) {
      options.Q = result;
    }
    return options;
  },
  _resolveFont: function _resolveFont(options) {
    if (this._acroform.fonts[this._font.id] === null) {
      this._acroform.fonts[this._font.id] = this._font.ref();
    }
    if (this._acroform.defaultFont !== this._font.name) {
      options.DR = {
        Font: {}
      };
      var fontSize2 = options.fontSize || 0;
      options.DR.Font[this._font.id] = this._font.ref();
      options.DA = new String("/" + this._font.id + " " + fontSize2 + " Tf 0 g");
    }
    return options;
  },
  _resolveStrings: function _resolveStrings(options) {
    var select = [];
    function appendChoices(a2) {
      if (Array.isArray(a2)) {
        for (var idx = 0; idx < a2.length; idx++) {
          if (typeof a2[idx] === "string") {
            select.push(new String(a2[idx]));
          } else {
            select.push(a2[idx]);
          }
        }
      }
    }
    appendChoices(options.Opt);
    if (options.select) {
      appendChoices(options.select);
      delete options.select;
    }
    if (select.length) {
      options.Opt = select;
    }
    Object.keys(VALUE_MAP).forEach(function(key) {
      if (options[key] !== void 0) {
        options[VALUE_MAP[key]] = options[key];
        delete options[key];
      }
    });
    ["V", "DV"].forEach(function(key) {
      if (typeof options[key] === "string") {
        options[key] = new String(options[key]);
      }
    });
    if (options.MK && options.MK.CA) {
      options.MK.CA = new String(options.MK.CA);
    }
    if (options.label) {
      options.MK = options.MK ? options.MK : {};
      options.MK.CA = new String(options.label);
      delete options.label;
    }
    return options;
  }
};
var AttachmentsMixin = {
  /**
   * Embed contents of `src` in PDF
   * @param {Buffer | ArrayBuffer | string} src input Buffer, ArrayBuffer, base64 encoded string or path to file
   * @param {object} options
   *  * options.name: filename to be shown in PDF, will use `src` if none set
   *  * options.type: filetype to be shown in PDF
   *  * options.description: description to be shown in PDF
   *  * options.hidden: if true, do not add attachment to EmbeddedFiles dictionary. Useful for file attachment annotations
   *  * options.creationDate: override creation date
   *  * options.modifiedDate: override modified date
   * @returns filespec reference
   */
  file: function file(src, options) {
    if (options === void 0) {
      options = {};
    }
    options.name = options.name || src;
    var refBody = {
      Type: "EmbeddedFile",
      Params: {}
    };
    var data2;
    if (!src) {
      throw new Error("No src specified");
    }
    if (Buffer$2.isBuffer(src)) {
      data2 = src;
    } else if (src instanceof ArrayBuffer) {
      data2 = Buffer$2.from(new Uint8Array(src));
    } else {
      var match;
      if (match = /^data:(.*);base64,(.*)$/.exec(src)) {
        if (match[1]) {
          refBody.Subtype = match[1].replace("/", "#2F");
        }
        data2 = Buffer$2.from(match[2], "base64");
      } else {
        throw new Error("Could not find file " + src);
      }
    }
    if (options.creationDate instanceof Date) {
      refBody.Params.CreationDate = options.creationDate;
    }
    if (options.modifiedDate instanceof Date) {
      refBody.Params.ModDate = options.modifiedDate;
    }
    if (options.type) {
      refBody.Subtype = options.type.replace("/", "#2F");
    }
    var checksum = (0, import_md5.default)(CryptoJS.lib.WordArray.create(new Uint8Array(data2)));
    refBody.Params.CheckSum = new String(checksum);
    refBody.Params.Size = data2.byteLength;
    var ref;
    if (!this._fileRegistry) this._fileRegistry = {};
    var file2 = this._fileRegistry[options.name];
    if (file2 && isEqual(refBody, file2)) {
      ref = file2.ref;
    } else {
      ref = this.ref(refBody);
      ref.end(data2);
      this._fileRegistry[options.name] = _extends({}, refBody, {
        ref
      });
    }
    var fileSpecBody = {
      Type: "Filespec",
      F: new String(options.name),
      EF: {
        F: ref
      },
      UF: new String(options.name)
    };
    if (options.description) {
      fileSpecBody.Desc = new String(options.description);
    }
    var filespec = this.ref(fileSpecBody);
    filespec.end();
    if (!options.hidden) {
      this.addNamedEmbeddedFile(options.name, filespec);
    }
    return filespec;
  }
};
function isEqual(a2, b) {
  return a2.Subtype === b.Subtype && a2.Params.CheckSum.toString() === b.Params.CheckSum.toString() && a2.Params.Size === b.Params.Size && a2.Params.CreationDate === b.Params.CreationDate && a2.Params.ModDate === b.Params.ModDate;
}
var PDFMetadata = function() {
  function PDFMetadata2() {
    this._metadata = '\n        <?xpacket begin="\uFEFF" id="W5M0MpCehiHzreSzNTczkc9d"?>\n            <x:xmpmeta xmlns:x="adobe:ns:meta/">\n                <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">\n        ';
  }
  var _proto = PDFMetadata2.prototype;
  _proto._closeTags = function _closeTags() {
    this._metadata = this._metadata.concat('\n                </rdf:RDF>\n            </x:xmpmeta>\n        <?xpacket end="w"?>\n        ');
  };
  _proto.append = function append4(xml, newline) {
    if (newline === void 0) {
      newline = true;
    }
    this._metadata = this._metadata.concat(xml);
    if (newline) this._metadata = this._metadata.concat("\n");
  };
  _proto.getXML = function getXML() {
    return this._metadata;
  };
  _proto.getLength = function getLength() {
    return this._metadata.length;
  };
  _proto.end = function end3() {
    this._closeTags();
    this._metadata = this._metadata.trim();
  };
  return PDFMetadata2;
}();
var MetadataMixin = {
  initMetadata: function initMetadata() {
    this.metadata = new PDFMetadata();
  },
  appendXML: function appendXML(xml, newline) {
    if (newline === void 0) {
      newline = true;
    }
    this.metadata.append(xml, newline);
  },
  _addInfo: function _addInfo() {
    this.appendXML('\n        <rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/">\n            <xmp:CreateDate>' + (this.info.CreationDate.toISOString().split(".")[0] + "Z") + "</xmp:CreateDate>\n            <xmp:CreatorTool>" + this.info.Creator + "</xmp:CreatorTool>\n        </rdf:Description>\n        ");
    if (this.info.Title || this.info.Author || this.info.Subject) {
      this.appendXML('\n            <rdf:Description rdf:about="" xmlns:dc="http://purl.org/dc/elements/1.1/">\n            ');
      if (this.info.Title) {
        this.appendXML('\n                <dc:title>\n                    <rdf:Alt>\n                        <rdf:li xml:lang="x-default">' + this.info.Title + "</rdf:li>\n                    </rdf:Alt>\n                </dc:title>\n                ");
      }
      if (this.info.Author) {
        this.appendXML("\n                <dc:creator>\n                    <rdf:Seq>\n                        <rdf:li>" + this.info.Author + "</rdf:li>\n                    </rdf:Seq>\n                </dc:creator>\n                ");
      }
      if (this.info.Subject) {
        this.appendXML('\n                <dc:description>\n                    <rdf:Alt>\n                        <rdf:li xml:lang="x-default">' + this.info.Subject + "</rdf:li>\n                    </rdf:Alt>\n                </dc:description>\n                ");
      }
      this.appendXML("\n            </rdf:Description>\n            ");
    }
    this.appendXML('\n        <rdf:Description rdf:about="" xmlns:pdf="http://ns.adobe.com/pdf/1.3/">\n            <pdf:Producer>' + this.info.Creator + "</pdf:Producer>", false);
    if (this.info.Keywords) {
      this.appendXML("\n            <pdf:Keywords>" + this.info.Keywords + "</pdf:Keywords>", false);
    }
    this.appendXML("\n        </rdf:Description>\n        ");
  },
  endMetadata: function endMetadata() {
    this._addInfo();
    this.metadata.end();
    if (this.version != 1.3) {
      this.metadataRef = this.ref({
        length: this.metadata.getLength(),
        Type: "Metadata",
        Subtype: "XML"
      });
      this.metadataRef.compress = false;
      this.metadataRef.write(Buffer$2.from(this.metadata.getXML(), "utf-8"));
      this.metadataRef.end();
      this._root.data.Metadata = this.metadataRef;
    }
  }
};
var capitalize3 = function capitalize4(v2) {
  return v2[0].toUpperCase() + v2.slice(1);
};
var PDFDocument = function(_stream$Readable) {
  _inheritsLoose(PDFDocument2, _stream$Readable);
  function PDFDocument2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _stream$Readable.call(this) || this;
    _this.options = options;
    switch (options.pdfVersion) {
      case "1.4":
        _this.version = 1.4;
        break;
      case "1.5":
        _this.version = 1.5;
        break;
      case "1.6":
        _this.version = 1.6;
        break;
      case "1.7":
      case "1.7ext3":
        _this.version = 1.7;
        break;
      default:
        _this.version = 1.3;
        break;
    }
    _this.compress = _this.options.compress != null ? _this.options.compress : true;
    _this._pageBuffer = [];
    _this._pageBufferStart = 0;
    _this._offsets = [];
    _this._waiting = 0;
    _this._ended = false;
    _this._offset = 0;
    var Pages = _this.ref({
      Type: "Pages",
      Count: 0,
      Kids: []
    });
    var Names = _this.ref({
      Dests: new PDFNameTree()
    });
    _this._root = _this.ref({
      Type: "Catalog",
      Pages,
      Names
    });
    if (_this.options.lang) {
      _this._root.data.Lang = new String(_this.options.lang);
    }
    if (_this.options.pageLayout) {
      _this._root.data.PageLayout = capitalize3(_this.options.pageLayout);
    }
    if (_this.options.pageMode) {
      _this._root.data.PageMode = capitalize3(_this.options.pageMode);
    }
    _this.page = null;
    _this.initColor();
    _this.initVector();
    _this.initFonts();
    _this.initText();
    _this.initImages();
    _this.initOutline();
    _this.info = {
      Producer: "PDFKit",
      Creator: "PDFKit",
      CreationDate: /* @__PURE__ */ new Date()
    };
    if (_this.options.info) {
      for (var key in _this.options.info) {
        var val = _this.options.info[key];
        _this.info[key] = val;
      }
    }
    if (_this.options.displayTitle) {
      _this._root.data.ViewerPreferences = _this.ref({
        DisplayDocTitle: true
      });
    }
    _this._id = PDFSecurity.generateFileID(_this.info);
    _this._write("%PDF-" + _this.version);
    _this._write("%");
    if (_this.options.autoFirstPage !== false) {
      _this.addPage();
    }
    return _this;
  }
  var _proto = PDFDocument2.prototype;
  _proto.addPage = function addPage(options) {
    if (options == null) {
      options = this.options;
    }
    if (!this.options.bufferPages) {
      this.flushPages();
    }
    this.page = new PDFPage(this, options);
    this._pageBuffer.push(this.page);
    var pages = this._root.data.Pages.data;
    pages.Kids.push(this.page.dictionary);
    pages.Count++;
    this._ctm = [1, 0, 0, 1, 0, 0];
    this.transform(1, 0, 0, -1, 0, this.page.height);
    return this;
  };
  _proto.flushPages = function flushPages() {
    var pages = this._pageBuffer;
    this._pageBuffer = [];
    this._pageBufferStart += pages.length;
    for (var _i = 0, _Array$from = Array.from(pages); _i < _Array$from.length; _i++) {
      var page = _Array$from[_i];
      page.end();
    }
  };
  _proto.addNamedDestination = function addNamedDestination(name2) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (args.length === 0) {
      args = ["XYZ", null, null, null];
    }
    if (args[0] === "XYZ" && args[2] !== null) {
      args[2] = this.page.height - args[2];
    }
    args.unshift(this.page.dictionary);
    this._root.data.Names.data.Dests.add(name2, args);
  };
  _proto.addNamedEmbeddedFile = function addNamedEmbeddedFile(name2, ref) {
    if (!this._root.data.Names.data.EmbeddedFiles) {
      this._root.data.Names.data.EmbeddedFiles = new PDFNameTree({
        limits: false
      });
    }
    this._root.data.Names.data.EmbeddedFiles.add(name2, ref);
  };
  _proto.addNamedJavaScript = function addNamedJavaScript(name2, js) {
    if (!this._root.data.Names.data.JavaScript) {
      this._root.data.Names.data.JavaScript = new PDFNameTree();
    }
    var data2 = {
      JS: new String(js),
      S: "JavaScript"
    };
    this._root.data.Names.data.JavaScript.add(name2, data2);
  };
  _proto.ref = function ref(data2) {
    var ref2 = new PDFReference(this, this._offsets.length + 1, data2);
    this._offsets.push(null);
    this._waiting++;
    return ref2;
  };
  _proto._read = function _read() {
  };
  _proto._write = function _write(data2) {
    if (!Buffer$2.isBuffer(data2)) {
      data2 = Buffer$2.from(data2 + "\n", "binary");
    }
    this.push(data2);
    return this._offset += data2.length;
  };
  _proto.addContent = function addContent(data2) {
    this.page.write(data2);
    return this;
  };
  _proto._refEnd = function _refEnd(ref) {
    this._offsets[ref.id - 1] = ref.offset;
    if (--this._waiting === 0 && this._ended) {
      this._finalize();
      return this._ended = false;
    }
  };
  _proto.end = function end3() {
    this.flushPages();
    this._info = this.ref();
    for (var key in this.info) {
      var val = this.info[key];
      if (typeof val === "string") {
        val = new String(val);
      }
      var entry = this.ref(val);
      entry.end();
      this._info.data[key] = entry;
    }
    this._info.end();
    for (var name2 in this._fontFamilies) {
      var font2 = this._fontFamilies[name2];
      font2.finalize();
    }
    this.endOutline();
    this._root.end();
    this._root.data.Pages.end();
    this._root.data.Names.end();
    this.endAcroForm();
    if (this._root.data.ViewerPreferences) {
      this._root.data.ViewerPreferences.end();
    }
    if (this._waiting === 0) {
      return this._finalize();
    }
    this._ended = true;
  };
  _proto._finalize = function _finalize() {
    var xRefOffset = this._offset;
    this._write("xref");
    this._write("0 " + (this._offsets.length + 1));
    this._write("0000000000 65535 f ");
    for (var _i2 = 0, _Array$from2 = Array.from(this._offsets); _i2 < _Array$from2.length; _i2++) {
      var offset3 = _Array$from2[_i2];
      offset3 = ("0000000000" + offset3).slice(-10);
      this._write(offset3 + " 00000 n ");
    }
    var trailer = {
      Size: this._offsets.length + 1,
      Root: this._root,
      Info: this._info,
      ID: [this._id, this._id]
    };
    this._write("trailer");
    this._write(PDFObject$1.convert(trailer));
    this._write("startxref");
    this._write("" + xRefOffset);
    this._write("%%EOF");
    return this.push(null);
  };
  _proto.toString = function toString7() {
    return "[object PDFDocument]";
  };
  _proto.initColor = function initColor2() {
  };
  _proto.initVector = function initVector2() {
  };
  _proto.initFonts = function initFonts2() {
  };
  _proto.initText = function initText2() {
  };
  _proto.initImages = function initImages2() {
  };
  _proto.initOutline = function initOutline2() {
  };
  _proto.transform = function transform4(m11, m12, m21, m22, dx, dy) {
  };
  _proto.endOutline = function endOutline2() {
  };
  _proto.endAcroForm = function endAcroForm2() {
  };
  return PDFDocument2;
}(stream.Readable);
var mixin = function mixin2(methods) {
  Object.assign(PDFDocument.prototype, methods);
};
mixin(MetadataMixin);
mixin(ColorMixin);
mixin(VectorMixin);
mixin(FontsMixin);
mixin(TextMixin);
mixin(ImagesMixin);
mixin(AnnotationsMixin);
mixin(OutlineMixin);
mixin(MarkingsMixin);
mixin(AcroFormMixin);
mixin(AttachmentsMixin);

// ../../.yarn/cache/@react-pdf-stylesheet-npm-4.2.5-021f0b4958-9e8939444e.zip/node_modules/@react-pdf/stylesheet/lib/index.js
var import_parse = __toESM(require_parse());
var import_unit = __toESM(require_unit());
var import_hsl_to_hex = __toESM(require_hsl_to_hex());
var import_color_string2 = __toESM(require_color_string());
var import_media_engine = __toESM(require_src());
var flexDefaults = [1, 1, 0];
var flexAuto = [1, 1, "auto"];
var expandFlex = function expandFlex2(key, value2) {
  var defaults = flexDefaults;
  var matches = [];
  if (value2 === "auto") {
    defaults = flexAuto;
  } else {
    matches = ("" + value2).split(" ");
  }
  var flexGrow = matches[0] || defaults[0];
  var flexShrink = matches[1] || defaults[1];
  var flexBasis = matches[2] || defaults[2];
  return {
    flexGrow,
    flexShrink,
    flexBasis
  };
};
var BOX_MODEL_UNITS = "px,in,mm,cm,pt,%,vw,vh";
var logError = function logError2(style, value2) {
  console.error("\n    @react-pdf/stylesheet parsing error:\n\n    " + style + ": " + value2 + ",\n    " + " ".repeat(style.length + 2) + "^\n    Unsupported " + style + " value format\n  ");
};
var expandBoxModel = function expandBoxModel2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, expandsTo7 = _ref.expandsTo, _ref$maxValues = _ref.maxValues, maxValues = _ref$maxValues === void 0 ? 1 : _ref$maxValues, _ref$autoSupported = _ref.autoSupported, autoSupported = _ref$autoSupported === void 0 ? false : _ref$autoSupported;
  return function(model, value2) {
    var _ref2;
    var nodes = (0, import_parse.default)("" + value2);
    var parts = [];
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (node.type === "function" || node.type === "string" || node.type === "div") {
        logError(model, value2);
        return {};
      }
      if (node.type === "word") {
        if (node.value === "auto" && autoSupported) {
          parts.push(node.value);
        } else {
          var result = (0, import_unit.default)(node.value);
          if (result && BOX_MODEL_UNITS.includes(result.unit)) {
            parts.push(node.value);
          } else {
            logError(model, value2);
            return {};
          }
        }
      }
    }
    if (parts.length > maxValues) {
      logError(model, value2);
      return {};
    }
    var first = parts[0];
    if (expandsTo7) {
      var second = parts[1] || parts[0];
      var third = parts[2] || parts[0];
      var fourth = parts[3] || parts[1] || parts[0];
      return expandsTo7({
        first,
        second,
        third,
        fourth
      });
    }
    return _ref2 = {}, _ref2[model] = first, _ref2;
  };
};
var processMargin = expandBoxModel({
  expandsTo: function expandsTo(_ref) {
    var first = _ref.first, second = _ref.second, third = _ref.third, fourth = _ref.fourth;
    return {
      marginTop: first,
      marginRight: second,
      marginBottom: third,
      marginLeft: fourth
    };
  },
  maxValues: 4,
  autoSupported: true
});
var processMarginVertical = expandBoxModel({
  expandsTo: function expandsTo2(_ref2) {
    var first = _ref2.first, second = _ref2.second;
    return {
      marginTop: first,
      marginBottom: second
    };
  },
  maxValues: 2,
  autoSupported: true
});
var processMarginHorizontal = expandBoxModel({
  expandsTo: function expandsTo3(_ref3) {
    var first = _ref3.first, second = _ref3.second;
    return {
      marginRight: first,
      marginLeft: second
    };
  },
  maxValues: 2,
  autoSupported: true
});
var processMarginSingle = expandBoxModel({
  autoSupported: true
});
var BORDER_SHORTHAND_REGEX = /(-?\d+(\.\d+)?(px|in|mm|cm|pt|vw|vh|px)?)\s(\S+)\s(.+)/;
var matchBorderShorthand = function matchBorderShorthand2(value2) {
  return value2.match(BORDER_SHORTHAND_REGEX) || [];
};
var expandBorders = function expandBorders2(key, value2) {
  var match = matchBorderShorthand("" + value2);
  if (match) {
    var color = match[5] || value2;
    var style = match[4] || value2;
    var width = match[1] || value2;
    if (key.match(/(Top|Right|Bottom|Left)$/)) {
      var _ref;
      return _ref = {}, _ref[key + "Color"] = color, _ref[key + "Style"] = style, _ref[key + "Width"] = width, _ref;
    }
    if (key.match(/Color$/)) {
      return {
        borderTopColor: color,
        borderRightColor: color,
        borderBottomColor: color,
        borderLeftColor: color
      };
    }
    if (key.match(/Style$/)) {
      return {
        borderTopStyle: style,
        borderRightStyle: style,
        borderBottomStyle: style,
        borderLeftStyle: style
      };
    }
    if (key.match(/Width$/)) {
      return {
        borderTopWidth: width,
        borderRightWidth: width,
        borderBottomWidth: width,
        borderLeftWidth: width
      };
    }
    if (key.match(/Radius$/)) {
      return {
        borderTopLeftRadius: value2,
        borderTopRightRadius: value2,
        borderBottomRightRadius: value2,
        borderBottomLeftRadius: value2
      };
    }
    return {
      borderTopColor: color,
      borderTopStyle: style,
      borderTopWidth: width,
      borderRightColor: color,
      borderRightStyle: style,
      borderRightWidth: width,
      borderBottomColor: color,
      borderBottomStyle: style,
      borderBottomWidth: width,
      borderLeftColor: color,
      borderLeftStyle: style,
      borderLeftWidth: width
    };
  }
  return value2;
};
var processPadding = expandBoxModel({
  expandsTo: function expandsTo4(_ref) {
    var first = _ref.first, second = _ref.second, third = _ref.third, fourth = _ref.fourth;
    return {
      paddingTop: first,
      paddingRight: second,
      paddingBottom: third,
      paddingLeft: fourth
    };
  },
  maxValues: 4
});
var processPaddingVertical = expandBoxModel({
  expandsTo: function expandsTo5(_ref2) {
    var first = _ref2.first, second = _ref2.second;
    return {
      paddingTop: first,
      paddingBottom: second
    };
  },
  maxValues: 2
});
var processPaddingHorizontal = expandBoxModel({
  expandsTo: function expandsTo6(_ref3) {
    var first = _ref3.first, second = _ref3.second;
    return {
      paddingRight: first,
      paddingLeft: second
    };
  },
  maxValues: 2
});
var processPaddingSingle = expandBoxModel();
var expandObjectPosition = function expandObjectPosition2(key, value2) {
  var match = ("" + value2).split(" ");
  return {
    objectPositionX: (match === null || match === void 0 ? void 0 : match[0]) || value2,
    objectPositionY: (match === null || match === void 0 ? void 0 : match[1]) || value2
  };
};
var Y_AXIS_SHORTHANDS = {
  top: true,
  bottom: true
};
var sortTransformOriginPair = function sortTransformOriginPair2(a2, b) {
  if (Y_AXIS_SHORTHANDS[a2]) return 1;
  if (Y_AXIS_SHORTHANDS[b]) return -1;
  return 0;
};
var getTransformOriginPair = function getTransformOriginPair2(values) {
  if (!values || values.length === 0) return ["center", "center"];
  var pair = values.length === 1 ? [values[0], "center"] : values;
  return pair.sort(sortTransformOriginPair);
};
var expandTransformOrigin = function expandTransformOrigin2(key, value2) {
  var match = ("" + value2).split(" ");
  var pair = getTransformOriginPair(match);
  return {
    transformOriginX: pair[0],
    transformOriginY: pair[1]
  };
};
var expandGap = function expandGap2(key, value2) {
  var match = ("" + value2).split(" ");
  return {
    rowGap: (match === null || match === void 0 ? void 0 : match[0]) || value2,
    columnGap: (match === null || match === void 0 ? void 0 : match[1]) || value2
  };
};
var shorthands = {
  flex: expandFlex,
  gap: expandGap,
  margin: processMargin,
  marginHorizontal: processMarginHorizontal,
  marginVertical: processMarginVertical,
  marginTop: processMarginSingle,
  marginRight: processMarginSingle,
  marginBottom: processMarginSingle,
  marginLeft: processMarginSingle,
  padding: processPadding,
  paddingHorizontal: processPaddingHorizontal,
  paddingVertical: processPaddingVertical,
  paddingTop: processPaddingSingle,
  paddingRight: processPaddingSingle,
  paddingBottom: processPaddingSingle,
  paddingLeft: processPaddingSingle,
  border: expandBorders,
  borderTop: expandBorders,
  borderRight: expandBorders,
  borderBottom: expandBorders,
  borderLeft: expandBorders,
  borderColor: expandBorders,
  borderRadius: expandBorders,
  borderStyle: expandBorders,
  borderWidth: expandBorders,
  objectPosition: expandObjectPosition,
  transformOrigin: expandTransformOrigin
};
var expandStyle = function expandStyle2(key, value2) {
  var _ref;
  return shorthands[key] ? shorthands[key](key, value2) : (_ref = {}, _ref[key] = value2, _ref);
};
var expand = function expand2(style) {
  if (!style) return style;
  var propsArray = Object.keys(style);
  var resolvedStyle = {};
  for (var i = 0; i < propsArray.length; i += 1) {
    var key = propsArray[i];
    var value2 = style[key];
    var extended = expandStyle(key, value2);
    var keys2 = Object.keys(extended);
    for (var j = 0; j < keys2.length; j += 1) {
      var propName = keys2[j];
      var propValue = extended[propName];
      resolvedStyle[propName] = propValue;
    }
  }
  return resolvedStyle;
};
var compact = function compact2(array) {
  return array.filter(Boolean);
};
var mergeStyles = function mergeStyles2(styles) {
  return styles.reduce(function(acc, style) {
    var s2 = Array.isArray(style) ? flatten(style) : style;
    Object.keys(s2).forEach(function(key) {
      if (s2[key] !== null && s2[key] !== void 0) {
        acc[key] = s2[key];
      }
    });
    return acc;
  }, {});
};
var flatten = compose(mergeStyles, compact, castArray);
var parseValue = function parseValue2(value2) {
  var match = /^(-?\d*\.?\d+)(in|mm|cm|pt|vh|vw|px)?$/g.exec(value2);
  return match ? {
    value: parseFloat(match[1]),
    unit: match[2] || "pt"
  } : {
    value: value2,
    unit: void 0
  };
};
var transformUnit = function transformUnit2(container, value2) {
  var scalar = parseValue(value2);
  var dpi = container.dpi || 72;
  var mmFactor = 1 / 25.4 * dpi;
  var cmFactor = 1 / 2.54 * dpi;
  switch (scalar.unit) {
    case "in":
      return scalar.value * dpi;
    case "mm":
      return scalar.value * mmFactor;
    case "cm":
      return scalar.value * cmFactor;
    case "vh":
      return scalar.value * (container.height / 100);
    case "vw":
      return scalar.value * (container.width / 100);
    default:
      return scalar.value;
  }
};
var isRgb = function isRgb2(value2) {
  return /rgba?/g.test(value2);
};
var isHsl = function isHsl2(value2) {
  return /hsla?/g.test(value2);
};
var parseRgb = function parseRgb2(value2) {
  var rgb = import_color_string2.default.get.rgb(value2);
  return import_color_string2.default.to.hex(rgb);
};
var parseHsl = function parseHsl2(value2) {
  var hsl = import_color_string2.default.get.hsl(value2).map(Math.round);
  var hex = import_hsl_to_hex.default.apply(void 0, hsl);
  return hex.toUpperCase();
};
var transformColor = function transformColor2(value2) {
  if (isRgb(value2)) return parseRgb(value2);
  if (isHsl(value2)) return parseHsl(value2);
  return value2;
};
var parse = function parse2(transformString) {
  var transforms = transformString.trim().split(/\) |\)/);
  if (transforms.length === 1) {
    return [[transforms[0], true]];
  }
  var parsed = [];
  for (var i = 0; i < transforms.length; i += 1) {
    var transform4 = transforms[i];
    if (transform4) {
      var _transform$split = transform4.split("("), name2 = _transform$split[0], rawValue = _transform$split[1];
      var splitChar = rawValue.indexOf(",") >= 0 ? "," : " ";
      var value2 = rawValue.split(splitChar).map(function(val) {
        return val.trim();
      });
      parsed.push({
        operation: name2,
        value: value2
      });
    }
  }
  return parsed;
};
var parseAngle = function parseAngle2(value2) {
  var unitsRegexp = /(-?\d*\.?\d*)(\w*)?/i;
  var _unitsRegexp$exec = unitsRegexp.exec(value2), angle = _unitsRegexp$exec[1], unit = _unitsRegexp$exec[2];
  var number2 = Number.parseFloat(angle);
  return unit === "rad" ? number2 * 180 / Math.PI : number2;
};
var normalizeTransformOperation = function normalizeTransformOperation2(_ref) {
  var operation = _ref.operation, value2 = _ref.value;
  switch (operation) {
    case "scale": {
      var _value$map = value2.map(function(num) {
        return Number.parseFloat(num);
      }), scaleX = _value$map[0], _value$map$ = _value$map[1], scaleY = _value$map$ === void 0 ? scaleX : _value$map$;
      return {
        operation: "scale",
        value: [scaleX, scaleY]
      };
    }
    case "scaleX": {
      return {
        operation: "scale",
        value: [Number.parseFloat(value2), 1]
      };
    }
    case "scaleY": {
      return {
        operation: "scale",
        value: [1, Number.parseFloat(value2)]
      };
    }
    case "rotate": {
      return {
        operation: "rotate",
        value: [parseAngle(value2)]
      };
    }
    case "translate": {
      return {
        operation: "translate",
        value: value2.map(function(num) {
          return Number.parseFloat(num);
        })
      };
    }
    case "translateX": {
      return {
        operation: "translate",
        value: [Number.parseFloat(value2), 0]
      };
    }
    case "translateY": {
      return {
        operation: "translate",
        value: [0, Number.parseFloat(value2)]
      };
    }
    case "skew": {
      return {
        operation: "skew",
        value: value2.map(parseAngle)
      };
    }
    case "skewX": {
      return {
        operation: "skew",
        value: [parseAngle(value2), 0]
      };
    }
    case "skewY": {
      return {
        operation: "skew",
        value: [0, parseAngle(value2)]
      };
    }
    default: {
      return {
        operation,
        value: value2.map(function(num) {
          return Number.parseFloat(num);
        })
      };
    }
  }
};
var normalize2 = function normalize3(operations) {
  return operations.map(function(operation) {
    return normalizeTransformOperation(operation);
  });
};
var processTransform = function processTransform2(value2) {
  if (typeof value2 !== "string") return value2;
  return normalize2(parse(value2));
};
var FONT_WEIGHTS2 = {
  thin: 100,
  hairline: 100,
  ultralight: 200,
  extralight: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  demibold: 600,
  bold: 700,
  ultrabold: 800,
  extrabold: 800,
  heavy: 900,
  black: 900
};
var processFontWeight = function processFontWeight2(value2) {
  if (!value2) return FONT_WEIGHTS2.normal;
  if (typeof value2 === "number") return value2;
  var lv = value2.toLowerCase();
  if (FONT_WEIGHTS2[lv]) return FONT_WEIGHTS2[lv];
  return value2;
};
var matchNumber = function matchNumber2(value2) {
  return typeof value2 === "string" && /^-?\d*\.?\d*$/.test(value2);
};
var castFloat = function castFloat2(value2) {
  if (typeof value2 !== "string") return value2;
  if (matchNumber(value2)) return parseFloat(value2);
  return value2;
};
var offsetKeyword = function offsetKeyword2(value2) {
  switch (value2) {
    case "top":
    case "left":
      return "0%";
    case "right":
    case "bottom":
      return "100%";
    case "center":
      return "50%";
    default:
      return null;
  }
};
var transformObjectPosition = function transformObjectPosition2(value2) {
  return offsetKeyword(value2) || castFloat(value2);
};
var transformTransformOrigin = function transformTransformOrigin2(value2) {
  return offsetKeyword(value2) || castFloat(value2);
};
var handlers = {
  transform: processTransform,
  fontWeight: processFontWeight,
  objectPositionX: transformObjectPosition,
  objectPositionY: transformObjectPosition,
  transformOriginX: transformTransformOrigin,
  transformOriginY: transformTransformOrigin
};
var transformStyle = function transformStyle2(key, value2, container) {
  var result = handlers[key] ? handlers[key](value2) : value2;
  return transformColor(transformUnit(container, castFloat(result)));
};
var transform2 = function transform3(container) {
  return function(style) {
    if (!style) return style;
    var propsArray = Object.keys(style);
    var resolvedStyle = {};
    for (var i = 0; i < propsArray.length; i += 1) {
      var key = propsArray[i];
      var value2 = style[key];
      var transformed = transformStyle(key, value2, container);
      resolvedStyle[key] = transformed;
    }
    return resolvedStyle;
  };
};
var resolveMediaQueries = function resolveMediaQueries2(container, styles) {
  return Object.keys(styles).reduce(function(acc, key) {
    var _extends2;
    if (/@media/.test(key)) {
      var _matchMedia;
      return _extends({}, acc, (0, import_media_engine.default)((_matchMedia = {}, _matchMedia[key] = styles[key], _matchMedia), container));
    }
    return _extends({}, acc, (_extends2 = {}, _extends2[key] = styles[key], _extends2));
  }, {});
};
var resolveStyles = function resolveStyles2(container, style) {
  var computeMediaQueries = function computeMediaQueries2(value2) {
    return resolveMediaQueries(container, value2);
  };
  return compose(transform2(container), expand, computeMediaQueries, flatten)(style);
};

// ../../.yarn/cache/bidi-js-npm-1.0.3-0035393a88-fdddea4aa4.zip/node_modules/bidi-js/dist/bidi.mjs
function bidiFactory() {
  var bidi2 = function(exports2) {
    var DATA = {
      "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      "B": "a,3,f+2,2v,690",
      "S": "9,2,k",
      "WS": "c,k,4f4,1vk+a,u,1j,335",
      "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      "LRO": "6ct",
      "RLO": "6cu",
      "LRE": "6cq",
      "RLE": "6cr",
      "PDF": "6cs",
      "LRI": "6ee",
      "RLI": "6ef",
      "FSI": "6eg",
      "PDI": "6eh"
    };
    var TYPES = {};
    var TYPES_TO_NAMES = {};
    TYPES.L = 1;
    TYPES_TO_NAMES[1] = "L";
    Object.keys(DATA).forEach(function(type2, i) {
      TYPES[type2] = 1 << i + 1;
      TYPES_TO_NAMES[TYPES[type2]] = type2;
    });
    Object.freeze(TYPES);
    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;
    var map = null;
    function parseData() {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        var loop = function(type3) {
          if (DATA.hasOwnProperty(type3)) {
            var lastCode = 0;
            DATA[type3].split(",").forEach(function(range3) {
              var ref = range3.split("+");
              var skip = ref[0];
              var step = ref[1];
              skip = parseInt(skip, 36);
              step = step ? parseInt(step, 36) : 0;
              map.set(lastCode += skip, TYPES[type3]);
              for (var i = 0; i < step; i++) {
                map.set(++lastCode, TYPES[type3]);
              }
            });
          }
        };
        for (var type2 in DATA) loop(type2);
      }
    }
    function getBidiCharType(char) {
      parseData();
      return map.get(char.codePointAt(0)) || TYPES.L;
    }
    function getBidiCharTypeName(char) {
      return TYPES_TO_NAMES[getBidiCharType(char)];
    }
    var data$1 = {
      "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function parseCharacterMap(encodedString, includeReverse) {
      var radix = 36;
      var lastCode = 0;
      var map2 = /* @__PURE__ */ new Map();
      var reverseMap = includeReverse && /* @__PURE__ */ new Map();
      var prevPair;
      encodedString.split(",").forEach(function visit(entry) {
        if (entry.indexOf("+") !== -1) {
          for (var i = +entry; i--; ) {
            visit(prevPair);
          }
        } else {
          prevPair = entry;
          var ref = entry.split(">");
          var a2 = ref[0];
          var b = ref[1];
          a2 = String.fromCodePoint(lastCode += parseInt(a2, radix));
          b = String.fromCodePoint(lastCode += parseInt(b, radix));
          map2.set(a2, b);
          includeReverse && reverseMap.set(b, a2);
        }
      });
      return { map: map2, reverseMap };
    }
    var openToClose, closeToOpen, canonical;
    function parse$12() {
      if (!openToClose) {
        var ref = parseCharacterMap(data$1.pairs, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        openToClose = map2;
        closeToOpen = reverseMap;
        canonical = parseCharacterMap(data$1.canonical, false).map;
      }
    }
    function openingToClosingBracket(char) {
      parse$12();
      return openToClose.get(char) || null;
    }
    function closingToOpeningBracket(char) {
      parse$12();
      return closeToOpen.get(char) || null;
    }
    function getCanonicalBracket(char) {
      parse$12();
      return canonical.get(char) || null;
    }
    var TYPE_L = TYPES.L;
    var TYPE_R = TYPES.R;
    var TYPE_EN = TYPES.EN;
    var TYPE_ES = TYPES.ES;
    var TYPE_ET = TYPES.ET;
    var TYPE_AN = TYPES.AN;
    var TYPE_CS = TYPES.CS;
    var TYPE_B = TYPES.B;
    var TYPE_S = TYPES.S;
    var TYPE_ON = TYPES.ON;
    var TYPE_BN = TYPES.BN;
    var TYPE_NSM = TYPES.NSM;
    var TYPE_AL = TYPES.AL;
    var TYPE_LRO = TYPES.LRO;
    var TYPE_RLO = TYPES.RLO;
    var TYPE_LRE = TYPES.LRE;
    var TYPE_RLE = TYPES.RLE;
    var TYPE_PDF = TYPES.PDF;
    var TYPE_LRI = TYPES.LRI;
    var TYPE_RLI = TYPES.RLI;
    var TYPE_FSI = TYPES.FSI;
    var TYPE_PDI = TYPES.PDI;
    function getEmbeddingLevels(string, baseDirection) {
      var MAX_DEPTH = 125;
      var charTypes = new Uint32Array(string.length);
      for (var i = 0; i < string.length; i++) {
        charTypes[i] = getBidiCharType(string[i]);
      }
      var charTypeCounts = /* @__PURE__ */ new Map();
      function changeCharType(i2, type3) {
        var oldType = charTypes[i2];
        charTypes[i2] = type3;
        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
        if (oldType & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
        }
        charTypeCounts.set(type3, (charTypeCounts.get(type3) || 0) + 1);
        if (type3 & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
        }
      }
      var embedLevels = new Uint8Array(string.length);
      var isolationPairs = /* @__PURE__ */ new Map();
      var paragraphs = [];
      var paragraph = null;
      for (var i$1 = 0; i$1 < string.length; i$1++) {
        if (!paragraph) {
          paragraphs.push(paragraph = {
            start: i$1,
            end: string.length - 1,
            // 3.3.1 P2-P3: Determine the paragraph level
            level: baseDirection === "rtl" ? 1 : baseDirection === "ltr" ? 0 : determineAutoEmbedLevel(i$1, false)
          });
        }
        if (charTypes[i$1] & TYPE_B) {
          paragraph.end = i$1;
          paragraph = null;
        }
      }
      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
      var nextEven = function(n) {
        return n + (n & 1 ? 1 : 2);
      };
      var nextOdd = function(n) {
        return n + (n & 1 ? 2 : 1);
      };
      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
        paragraph = paragraphs[paraIdx];
        var statusStack = [{
          _level: paragraph.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }];
        var stackTop = void 0;
        var overflowIsolateCount = 0;
        var overflowEmbeddingCount = 0;
        var validIsolateCount = 0;
        charTypeCounts.clear();
        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
          var charType = charTypes[i$2];
          stackTop = statusStack[statusStack.length - 1];
          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
          if (charType & NEUTRAL_ISOLATE_TYPES) {
            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
          }
          if (charType & FORMATTING_TYPES) {
            if (charType & (TYPE_RLE | TYPE_LRE)) {
              embedLevels[i$2] = stackTop._level;
              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level,
                  _override: 0,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & (TYPE_RLO | TYPE_LRO)) {
              embedLevels[i$2] = stackTop._level;
              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level$1,
                  _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & ISOLATE_INIT_TYPES) {
              if (charType & TYPE_FSI) {
                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
              }
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
                validIsolateCount++;
                statusStack.push({
                  _level: level$2,
                  _override: 0,
                  _isolate: 1,
                  _isolInitIndex: i$2
                });
              } else {
                overflowIsolateCount++;
              }
            } else if (charType & TYPE_PDI) {
              if (overflowIsolateCount > 0) {
                overflowIsolateCount--;
              } else if (validIsolateCount > 0) {
                overflowEmbeddingCount = 0;
                while (!statusStack[statusStack.length - 1]._isolate) {
                  statusStack.pop();
                }
                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
                if (isolInitIndex != null) {
                  isolationPairs.set(isolInitIndex, i$2);
                  isolationPairs.set(i$2, isolInitIndex);
                }
                statusStack.pop();
                validIsolateCount--;
              }
              stackTop = statusStack[statusStack.length - 1];
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
            } else if (charType & TYPE_PDF) {
              if (overflowIsolateCount === 0) {
                if (overflowEmbeddingCount > 0) {
                  overflowEmbeddingCount--;
                } else if (!stackTop._isolate && statusStack.length > 1) {
                  statusStack.pop();
                  stackTop = statusStack[statusStack.length - 1];
                }
              }
              embedLevels[i$2] = stackTop._level;
            } else if (charType & TYPE_B) {
              embedLevels[i$2] = paragraph.level;
            }
          } else {
            embedLevels[i$2] = stackTop._level;
            if (stackTop._override && charType !== TYPE_BN) {
              changeCharType(i$2, stackTop._override);
            }
          }
        }
        var levelRuns = [];
        var currentRun = null;
        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
          var charType$1 = charTypes[i$3];
          if (!(charType$1 & BN_LIKE_TYPES)) {
            var lvl = embedLevels[i$3];
            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
            var isPDI = charType$1 === TYPE_PDI;
            if (currentRun && lvl === currentRun._level) {
              currentRun._end = i$3;
              currentRun._endsWithIsolInit = isIsolInit;
            } else {
              levelRuns.push(currentRun = {
                _start: i$3,
                _end: i$3,
                _level: lvl,
                _startsWithPDI: isPDI,
                _endsWithIsolInit: isIsolInit
              });
            }
          }
        }
        var isolatingRunSeqs = [];
        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
          var run = levelRuns[runIdx];
          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {
            var seqRuns = [currentRun = run];
            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null; ) {
              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
                if (levelRuns[i$4]._start === pdiIndex) {
                  seqRuns.push(currentRun = levelRuns[i$4]);
                  break;
                }
              }
            }
            var seqIndices = [];
            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
              var run$1 = seqRuns[i$5];
              for (var j = run$1._start; j <= run$1._end; j++) {
                seqIndices.push(j);
              }
            }
            var firstLevel = embedLevels[seqIndices[0]];
            var prevLevel = paragraph.level;
            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {
                prevLevel = embedLevels[i$6];
                break;
              }
            }
            var lastIndex = seqIndices[seqIndices.length - 1];
            var lastLevel = embedLevels[lastIndex];
            var nextLevel = paragraph.level;
            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {
                  nextLevel = embedLevels[i$7];
                  break;
                }
              }
            }
            isolatingRunSeqs.push({
              _seqIndices: seqIndices,
              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
            });
          }
        }
        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
          var ref = isolatingRunSeqs[seqIdx];
          var seqIndices$1 = ref._seqIndices;
          var sosType = ref._sosType;
          var eosType = ref._eosType;
          var embedDirection = embedLevels[seqIndices$1[0]] & 1 ? TYPE_R : TYPE_L;
          if (charTypeCounts.get(TYPE_NSM)) {
            for (var si = 0; si < seqIndices$1.length; si++) {
              var i$8 = seqIndices$1[si];
              if (charTypes[i$8] & TYPE_NSM) {
                var prevType = sosType;
                for (var sj = si - 1; sj >= 0; sj--) {
                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {
                    prevType = charTypes[seqIndices$1[sj]];
                    break;
                  }
                }
                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
              var i$9 = seqIndices$1[si$1];
              if (charTypes[i$9] & TYPE_EN) {
                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
                  if (prevCharType & STRONG_TYPES) {
                    if (prevCharType === TYPE_AL) {
                      changeCharType(i$9, TYPE_AN);
                    }
                    break;
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_AL)) {
            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
              var i$10 = seqIndices$1[si$2];
              if (charTypes[i$10] & TYPE_AL) {
                changeCharType(i$10, TYPE_R);
              }
            }
          }
          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
              var i$11 = seqIndices$1[si$3];
              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
                var prevType$1 = 0, nextType = 0;
                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
                  prevType$1 = charTypes[seqIndices$1[sj$2]];
                  if (!(prevType$1 & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
                  nextType = charTypes[seqIndices$1[sj$3]];
                  if (!(nextType & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {
                  changeCharType(i$11, prevType$1);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
              var i$12 = seqIndices$1[si$4];
              if (charTypes[i$12] & TYPE_EN) {
                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {
                  changeCharType(seqIndices$1[sj$4], TYPE_EN);
                }
                for (si$4++; si$4 < seqIndices$1.length && charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN); si$4++) {
                  if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {
                    changeCharType(seqIndices$1[si$4], TYPE_EN);
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
              var i$13 = seqIndices$1[si$5];
              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
                changeCharType(i$13, TYPE_ON);
                for (var sj$5 = si$5 - 1; sj$5 >= 0 && charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES; sj$5--) {
                  changeCharType(seqIndices$1[sj$5], TYPE_ON);
                }
                for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6++) {
                  changeCharType(seqIndices$1[sj$6], TYPE_ON);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
              var i$14 = seqIndices$1[si$6];
              var type2 = charTypes[i$14];
              if (type2 & TYPE_EN) {
                if (prevStrongType === TYPE_L) {
                  changeCharType(i$14, TYPE_L);
                }
              } else if (type2 & STRONG_TYPES) {
                prevStrongType = type2;
              }
            }
          }
          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;
            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;
            var bracketPairs = [];
            {
              var openerStack = [];
              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
                  var char = string[seqIndices$1[si$7]];
                  var oppositeBracket = void 0;
                  if (openingToClosingBracket(char) !== null) {
                    if (openerStack.length < 63) {
                      openerStack.push({ char, seqIndex: si$7 });
                    } else {
                      break;
                    }
                  } else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
                      var stackChar = openerStack[stackIdx].char;
                      if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {
                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
                        openerStack.length = stackIdx;
                        break;
                      }
                    }
                  }
                }
              }
              bracketPairs.sort(function(a2, b) {
                return a2[0] - b[0];
              });
            }
            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
              var ref$1 = bracketPairs[pairIdx];
              var openSeqIdx = ref$1[0];
              var closeSeqIdx = ref$1[1];
              var foundStrongType = false;
              var useStrongType = 0;
              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
                var i$15 = seqIndices$1[si$8];
                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
                  foundStrongType = true;
                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                  if (lr === embedDirection) {
                    useStrongType = lr;
                    break;
                  }
                }
              }
              if (foundStrongType && !useStrongType) {
                useStrongType = sosType;
                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
                  var i$16 = seqIndices$1[si$9];
                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    if (lr$1 !== embedDirection) {
                      useStrongType = lr$1;
                    } else {
                      useStrongType = embedDirection;
                    }
                    break;
                  }
                }
              }
              if (useStrongType) {
                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
                if (useStrongType !== embedDirection) {
                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$10]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
                if (useStrongType !== embedDirection) {
                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$11]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
              }
            }
            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
                var niRunStart = si$12, niRunEnd = si$12;
                var prevType$2 = sosType;
                for (var si2 = si$12 - 1; si2 >= 0; si2--) {
                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
                    niRunStart = si2;
                  } else {
                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                var nextType$1 = eosType;
                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                    niRunEnd = si2$1;
                  } else {
                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {
                  charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;
                }
                si$12 = niRunEnd;
              }
            }
          }
        }
        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
          var level$3 = embedLevels[i$17];
          var type$1 = charTypes[i$17];
          if (level$3 & 1) {
            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
              embedLevels[i$17]++;
            }
          } else {
            if (type$1 & TYPE_R) {
              embedLevels[i$17]++;
            } else if (type$1 & (TYPE_AN | TYPE_EN)) {
              embedLevels[i$17] += 2;
            }
          }
          if (type$1 & BN_LIKE_TYPES) {
            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
          }
          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {
              embedLevels[j$1] = paragraph.level;
            }
          }
        }
      }
      return {
        levels: embedLevels,
        paragraphs
      };
      function determineAutoEmbedLevel(start3, isFSI) {
        for (var i2 = start3; i2 < string.length; i2++) {
          var charType2 = charTypes[i2];
          if (charType2 & (TYPE_R | TYPE_AL)) {
            return 1;
          }
          if (charType2 & (TYPE_B | TYPE_L) || isFSI && charType2 === TYPE_PDI) {
            return 0;
          }
          if (charType2 & ISOLATE_INIT_TYPES) {
            var pdi = indexOfMatchingPDI(i2);
            i2 = pdi === -1 ? string.length : pdi;
          }
        }
        return 0;
      }
      function indexOfMatchingPDI(isolateStart) {
        var isolationLevel = 1;
        for (var i2 = isolateStart + 1; i2 < string.length; i2++) {
          var charType2 = charTypes[i2];
          if (charType2 & TYPE_B) {
            break;
          }
          if (charType2 & TYPE_PDI) {
            if (--isolationLevel === 0) {
              return i2;
            }
          } else if (charType2 & ISOLATE_INIT_TYPES) {
            isolationLevel++;
          }
        }
        return -1;
      }
    }
    var data2 = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";
    var mirrorMap;
    function parse3() {
      if (!mirrorMap) {
        var ref = parseCharacterMap(data2, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        reverseMap.forEach(function(value2, key) {
          map2.set(key, value2);
        });
        mirrorMap = map2;
      }
    }
    function getMirroredCharacter(char) {
      parse3();
      return mirrorMap.get(char) || null;
    }
    function getMirroredCharactersMap(string, embeddingLevels, start3, end3) {
      var strLen = string.length;
      start3 = Math.max(0, start3 == null ? 0 : +start3);
      end3 = Math.min(strLen - 1, end3 == null ? strLen - 1 : +end3);
      var map2 = /* @__PURE__ */ new Map();
      for (var i = start3; i <= end3; i++) {
        if (embeddingLevels[i] & 1) {
          var mirror = getMirroredCharacter(string[i]);
          if (mirror !== null) {
            map2.set(i, mirror);
          }
        }
      }
      return map2;
    }
    function getReorderSegments(string, embeddingLevelsResult, start3, end3) {
      var strLen = string.length;
      start3 = Math.max(0, start3 == null ? 0 : +start3);
      end3 = Math.min(strLen - 1, end3 == null ? strLen - 1 : +end3);
      var segments = [];
      embeddingLevelsResult.paragraphs.forEach(function(paragraph) {
        var lineStart = Math.max(start3, paragraph.start);
        var lineEnd = Math.min(end3, paragraph.end);
        if (lineStart < lineEnd) {
          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);
          for (var i = lineEnd; i >= lineStart && getBidiCharType(string[i]) & TRAILING_TYPES; i--) {
            lineLevels[i] = paragraph.level;
          }
          var maxLevel = paragraph.level;
          var minOddLevel = Infinity;
          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
            var level = lineLevels[i$1];
            if (level > maxLevel) {
              maxLevel = level;
            }
            if (level < minOddLevel) {
              minOddLevel = level | 1;
            }
          }
          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
              if (lineLevels[i$2] >= lvl) {
                var segStart = i$2;
                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
                  i$2++;
                }
                if (i$2 > segStart) {
                  segments.push([segStart + lineStart, i$2 + lineStart]);
                }
              }
            }
          }
        }
      });
      return segments;
    }
    function getReorderedString(string, embedLevelsResult, start3, end3) {
      var indices = getReorderedIndices3(string, embedLevelsResult, start3, end3);
      var chars = [].concat(string);
      indices.forEach(function(charIndex, i) {
        chars[i] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];
      });
      return chars.join("");
    }
    function getReorderedIndices3(string, embedLevelsResult, start3, end3) {
      var segments = getReorderSegments(string, embedLevelsResult, start3, end3);
      var indices = [];
      for (var i = 0; i < string.length; i++) {
        indices[i] = i;
      }
      segments.forEach(function(ref) {
        var start4 = ref[0];
        var end4 = ref[1];
        var slice8 = indices.slice(start4, end4 + 1);
        for (var i2 = slice8.length; i2--; ) {
          indices[end4 - i2] = slice8[i2];
        }
      });
      return indices;
    }
    exports2.closingToOpeningBracket = closingToOpeningBracket;
    exports2.getBidiCharType = getBidiCharType;
    exports2.getBidiCharTypeName = getBidiCharTypeName;
    exports2.getCanonicalBracket = getCanonicalBracket;
    exports2.getEmbeddingLevels = getEmbeddingLevels;
    exports2.getMirroredCharacter = getMirroredCharacter;
    exports2.getMirroredCharactersMap = getMirroredCharactersMap;
    exports2.getReorderSegments = getReorderSegments;
    exports2.getReorderedIndices = getReorderedIndices3;
    exports2.getReorderedString = getReorderedString;
    exports2.openingToClosingBracket = openingToClosingBracket;
    Object.defineProperty(exports2, "__esModule", { value: true });
    return exports2;
  }({});
  return bidi2;
}
var bidi_default = bidiFactory;

// ../../.yarn/cache/@react-pdf-textkit-npm-4.4.1-46021e9afd-261c9130c8.zip/node_modules/@react-pdf/textkit/lib/textkit.js
var import_hyphen = __toESM(require_hyphen());
var import_en_us = __toESM(require_en_us());
var fromFragments = function fromFragments2(fragments) {
  var offset3 = 0;
  var string = "";
  var runs = [];
  fragments.forEach(function(fragment) {
    string += fragment.string;
    runs.push(_extends({}, fragment, {
      start: offset3,
      end: offset3 + fragment.string.length,
      attributes: fragment.attributes || {}
    }));
    offset3 += fragment.string.length;
  });
  return {
    string,
    runs
  };
};
var defaultHyphenationEngine = function defaultHyphenationEngine2(word) {
  return [word];
};
var wrapWords = function wrapWords2(engines2, options) {
  if (engines2 === void 0) {
    engines2 = {};
  }
  if (options === void 0) {
    options = {};
  }
  return function(attributedString) {
    var _engines$wordHyphenat, _engines;
    var syllables = [];
    var fragments = [];
    var hyphenateWord = options.hyphenationCallback || ((_engines$wordHyphenat = (_engines = engines2).wordHyphenation) === null || _engines$wordHyphenat === void 0 ? void 0 : _engines$wordHyphenat.call(_engines, options)) || defaultHyphenationEngine;
    for (var i = 0; i < attributedString.runs.length; i += 1) {
      var string = "";
      var run = attributedString.runs[i];
      var words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);
      for (var j = 0; j < words.length; j += 1) {
        var word = words[j];
        var parts = hyphenateWord(word);
        syllables.push.apply(syllables, parts);
        string += parts.join("");
      }
      fragments.push(_extends({}, run, {
        string
      }));
    }
    return _extends({}, fromFragments(fragments), {
      syllables
    });
  };
};
var copy3 = function copy4(rect2) {
  return Object.assign({}, rect2);
};
var partition = function partition2(rect2, height5) {
  var a2 = Object.assign({}, rect2, {
    height: height5
  });
  var b = Object.assign({}, rect2, {
    y: rect2.y + height5,
    height: rect2.height - height5
  });
  return [a2, b];
};
var crop = function crop2(height5, rect2) {
  var _partition = partition(rect2, height5), result = _partition[1];
  return result;
};
var height$2 = function height(paragraph) {
  return paragraph.reduce(function(acc, block) {
    return acc + block.box.height;
  }, 0);
};
var calculateScale = function calculateScale2(run) {
  var _attributes$font;
  var attributes2 = run.attributes || {};
  var fontSize2 = attributes2.fontSize || 12;
  var unitsPerEm = (_attributes$font = attributes2.font) === null || _attributes$font === void 0 ? void 0 : _attributes$font.unitsPerEm;
  return unitsPerEm ? fontSize2 / unitsPerEm : 0;
};
var scale2 = function scale3(run) {
  var _run$attributes;
  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.scale) || calculateScale(run);
};
var offset = function offset2(index2, run) {
  if (!run) return 0;
  var glyphIndices = run.glyphIndices || [];
  var value2 = glyphIndices[index2];
  return glyphIndices.slice(0, index2).filter(function(i) {
    return i === value2;
  }).length;
};
var getFont = function getFont2(run) {
  var _run$attributes;
  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.font) || null;
};
var slice$2 = function slice3(start3, end3, font2, glyph) {
  if (!glyph) return [];
  if (start3 === end3) return [];
  if (start3 === 0 && end3 === glyph.codePoints.length) return [glyph];
  var codePoints = glyph.codePoints.slice(start3, end3);
  var string = String.fromCodePoint.apply(String, codePoints);
  return font2 ? font2.layout(string, void 0, void 0, void 0, "ltr").glyphs : [glyph];
};
var glyphIndexAt = function glyphIndexAt2(index2, run) {
  var _run$glyphIndices;
  var result = run === null || run === void 0 ? void 0 : (_run$glyphIndices = run.glyphIndices) === null || _run$glyphIndices === void 0 ? void 0 : _run$glyphIndices[index2];
  return isNil(result) ? index2 : result;
};
var normalize4 = function normalize5(array) {
  var head = array[0];
  return array.map(function(value2) {
    return value2 - head;
  });
};
var slice$1 = function slice4(start3, end3, run) {
  var _run$glyphs, _run$glyphs2;
  var runScale = scale2(run);
  var font2 = getFont(run);
  var startIndex = glyphIndexAt(start3, run);
  var endIndex = glyphIndexAt(end3, run);
  var startGlyph = (_run$glyphs = run.glyphs) === null || _run$glyphs === void 0 ? void 0 : _run$glyphs[startIndex];
  var endGlyph = (_run$glyphs2 = run.glyphs) === null || _run$glyphs2 === void 0 ? void 0 : _run$glyphs2[endIndex];
  var startOffset = offset(start3, run);
  var startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font2, startGlyph) : [];
  var endOffset = offset(end3, run);
  var endGlyphs = slice$2(0, endOffset, font2, endGlyph);
  var sliceStart = startIndex + Math.min(1, startOffset);
  var glyphs = (run.glyphs || []).slice(sliceStart, endIndex);
  var glyphPosition = function glyphPosition2(g) {
    return {
      xAdvance: g.advanceWidth * runScale
    };
  };
  var startPositions = startGlyphs.map(glyphPosition);
  var positions = (run.positions || []).slice(sliceStart, endIndex);
  var endPositions = endGlyphs.map(glyphPosition);
  return Object.assign({}, run, {
    start: run.start + start3,
    end: Math.min(run.end, run.start + end3),
    glyphIndices: normalize4((run.glyphIndices || []).slice(start3, end3)),
    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),
    positions: [startPositions, positions, endPositions].flat()
  });
};
var runIndexAt$1 = function runIndexAt(n, runs) {
  if (!runs) return -1;
  return runs.findIndex(function(run) {
    return run.start <= n && n < run.end;
  });
};
var filter = function filter2(start3, end3, runs) {
  var startIndex = runIndexAt$1(start3, runs);
  var endIndex = Math.max(runIndexAt$1(end3 - 1, runs), startIndex);
  return runs.slice(startIndex, endIndex + 1);
};
var subtract = function subtract2(n, run) {
  var start3 = run.start - n;
  var end3 = run.end - n;
  return Object.assign({}, run, {
    start: start3,
    end: end3
  });
};
var sliceRuns = function sliceRuns2(start3, end3, runs) {
  var sliceFirstRun = function sliceFirstRun2(a2) {
    return slice$1(start3 - a2.start, end3 - a2.start, a2);
  };
  var sliceLastRun = function sliceLastRun2(a2) {
    return slice$1(0, end3 - a2.start, a2);
  };
  return runs.map(function(run, i) {
    var result = run;
    var isFirst = i === 0;
    var isLast = !isFirst && i === runs.length - 1;
    if (isFirst) result = sliceFirstRun(run);
    if (isLast) result = sliceLastRun(run);
    return subtract(start3, result);
  });
};
var slice5 = function slice6(start3, end3, attributedString) {
  if (attributedString.string.length === 0) return attributedString;
  var string = attributedString.string.slice(start3, end3);
  var filteredRuns = filter(start3, end3, attributedString.runs);
  var slicedRuns = sliceRuns(start3, end3, filteredRuns);
  return Object.assign({}, attributedString, {
    string,
    runs: slicedRuns
  });
};
var findCharIndex = function findCharIndex2(string) {
  return string.search(/\S/g);
};
var findLastCharIndex = function findLastCharIndex2(string) {
  var match = string.match(/\S/g);
  return match ? string.lastIndexOf(match[match.length - 1]) : -1;
};
var trim = function trim2(attributedString) {
  var start3 = findCharIndex(attributedString.string);
  var end3 = findLastCharIndex(attributedString.string);
  return slice5(start3, end3 + 1, attributedString);
};
var empty$1 = function empty() {
  return {
    start: 0,
    end: 0,
    glyphIndices: [],
    glyphs: [],
    positions: [],
    attributes: {}
  };
};
var isNumber3 = function isNumber4(value2) {
  return typeof value2 === "number";
};
var appendIndices = function appendIndices2(length4, indices) {
  var lastIndex = last(indices);
  var value2 = isNil(lastIndex) ? 0 : lastIndex + 1;
  var newIndices = Array(length4).fill(value2);
  return indices.concat(newIndices);
};
var fromCodePoint = function fromCodePoint2(value2, font2) {
  return font2 && value2 ? font2.glyphForCodePoint(value2) : null;
};
var appendGlyph = function appendGlyph2(glyph, run) {
  var _glyph$codePoints;
  var glyphLength = ((_glyph$codePoints = glyph.codePoints) === null || _glyph$codePoints === void 0 ? void 0 : _glyph$codePoints.length) || 0;
  var end3 = run.end + glyphLength;
  var glyphs = run.glyphs.concat(glyph);
  var glyphIndices = appendIndices(glyphLength, run.glyphIndices);
  if (!run.positions) return Object.assign({}, run, {
    end: end3,
    glyphs,
    glyphIndices
  });
  var positions = run.positions.concat({
    xAdvance: glyph.advanceWidth * scale2(run)
  });
  return Object.assign({}, run, {
    end: end3,
    glyphs,
    glyphIndices,
    positions
  });
};
var append$1 = function append(value2, run) {
  if (!value2) return run;
  var font2 = getFont(run);
  var glyph = isNumber3(value2) ? fromCodePoint(value2, font2) : value2;
  return appendGlyph(glyph, run);
};
var stringFromCodePoints = function stringFromCodePoints2(codePoints) {
  return String.fromCodePoint.apply(String, codePoints || []);
};
var append2 = function append3(glyph, attributedString) {
  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];
  var codePointsString = stringFromCodePoints(codePoints);
  var string = attributedString.string + codePointsString;
  var firstRuns = attributedString.runs.slice(0, -1);
  var lastRun = last(attributedString.runs) || empty$1();
  var runs = firstRuns.concat(append$1(glyph, lastRun));
  return Object.assign({}, attributedString, {
    string,
    runs
  });
};
var ELLIPSIS_UNICODE = 8230;
var ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);
var getEllipsisCodePoint = function getEllipsisCodePoint2(font2) {
  if (!font2.encode) return ELLIPSIS_UNICODE;
  var _font$encode = font2.encode(ELLIPSIS_STRING), codePoints = _font$encode[0];
  return parseInt(codePoints[0], 16);
};
var truncate3 = function truncate4(block) {
  var _last, _last2, _last2$attributes;
  var runs = ((_last = last(block)) === null || _last === void 0 ? void 0 : _last.runs) || [];
  var font2 = (_last2 = last(runs)) === null || _last2 === void 0 ? void 0 : (_last2$attributes = _last2.attributes) === null || _last2$attributes === void 0 ? void 0 : _last2$attributes.font;
  if (font2) {
    var _Object$assign;
    var index2 = block.length - 1;
    var codePoint = getEllipsisCodePoint(font2);
    var glyph = font2.glyphForCodePoint(codePoint);
    var lastBlock = append2(glyph, trim(block[index2]));
    return Object.assign([], block, (_Object$assign = {}, _Object$assign[index2] = lastBlock, _Object$assign));
  }
  return block;
};
var omit3 = function omit4(value2, run) {
  var attributes2 = Object.assign({}, run.attributes);
  delete attributes2[value2];
  return Object.assign({}, run, {
    attributes: attributes2
  });
};
var ascent$1 = function ascent(run) {
  var _run$attributes, _run$attributes$attac, _run$attributes2, _run$attributes2$font;
  var attachmentHeight = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$attac = _run$attributes.attachment) === null || _run$attributes$attac === void 0 ? void 0 : _run$attributes$attac.height) || 0;
  var fontAscent = ((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : (_run$attributes2$font = _run$attributes2.font) === null || _run$attributes2$font === void 0 ? void 0 : _run$attributes2$font.ascent) || 0;
  return Math.max(attachmentHeight, fontAscent * scale2(run));
};
var descent = function descent2(run) {
  var _run$attributes, _run$attributes$font;
  var fontDescent = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.descent) || 0;
  return scale2(run) * fontDescent;
};
var lineGap = function lineGap2(run) {
  var _run$attributes, _run$attributes$font;
  return (((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.lineGap) || 0) * scale2(run);
};
var height$1 = function height2(run) {
  var _run$attributes;
  var lineHeight = (_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.lineHeight;
  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);
};
var height3 = function height4(attributedString) {
  var reducer = function reducer2(acc, run) {
    return Math.max(acc, height$1(run));
  };
  return attributedString.runs.reduce(reducer, 0);
};
var intersects = function intersects2(a2, b) {
  var x = Math.max(a2.x, b.x);
  var num1 = Math.min(a2.x + a2.width, b.x + b.width);
  var y = Math.max(a2.y, b.y);
  var num2 = Math.min(a2.y + a2.height, b.y + b.height);
  return num1 >= x && num2 >= y;
};
var _excluded2 = ["excludeRects"];
var getLineFragment = function getLineFragment2(lineRect, excludeRect) {
  if (!intersects(excludeRect, lineRect)) return [lineRect];
  var eStart = excludeRect.x;
  var eEnd = excludeRect.x + excludeRect.width;
  var lStart = lineRect.x;
  var lEnd = lineRect.x + lineRect.width;
  var a2 = Object.assign({}, lineRect, {
    width: eStart - lStart
  });
  var b = Object.assign({}, lineRect, {
    x: eEnd,
    width: lEnd - eEnd
  });
  return [a2, b].filter(function(r) {
    return r.width > 0;
  });
};
var getLineFragments = function getLineFragments2(rect2, excludeRects) {
  var fragments = [rect2];
  var _loop = function _loop2() {
    var excludeRect = excludeRects[i];
    fragments = fragments.reduce(function(acc, fragment) {
      var pieces = getLineFragment(fragment, excludeRect);
      return acc.concat(pieces);
    }, []);
  };
  for (var i = 0; i < excludeRects.length; i += 1) {
    _loop();
  }
  return fragments;
};
var generateLineRects = function generateLineRects2(container, height5) {
  var excludeRects = container.excludeRects, rect2 = _objectWithoutPropertiesLoose(container, _excluded2);
  if (!excludeRects) return [rect2];
  var lineRects = [];
  var maxY = Math.max.apply(Math, excludeRects.map(function(r) {
    return r.y + r.height;
  }));
  var currentRect = rect2;
  while (currentRect.y < maxY) {
    var _partition = partition(currentRect, height5), lineRect = _partition[0], rest = _partition[1];
    var lineRectFragments = getLineFragments(lineRect, excludeRects);
    currentRect = rest;
    lineRects.push.apply(lineRects, lineRectFragments);
  }
  return [].concat(lineRects, [currentRect]);
};
var ATTACHMENT_CODE$1 = "";
var purgeAttachments = function purgeAttachments2(attributedString) {
  var shouldPurge = !attributedString.string.includes(ATTACHMENT_CODE$1);
  if (!shouldPurge) return attributedString;
  var runs = attributedString.runs.map(function(run) {
    return omit3("attachment", run);
  });
  return Object.assign({}, attributedString, {
    runs
  });
};
var layoutLines = function layoutLines2(rects, lines, indent) {
  var rect2 = rects.shift();
  var currentY = rect2.y;
  return lines.map(function(line2, i) {
    var _line$runs, _line$runs$;
    var lineIndent = i === 0 ? indent : 0;
    var style = ((_line$runs = line2.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};
    var height$12 = Math.max(height3(line2), style.lineHeight);
    if (currentY + height$12 > rect2.y + rect2.height && rects.length > 0) {
      rect2 = rects.shift();
      currentY = rect2.y;
    }
    var newLine = Object.assign({}, line2);
    delete newLine.syllables;
    newLine.box = {
      x: rect2.x + lineIndent,
      y: currentY,
      width: rect2.width - lineIndent,
      height: height$12
    };
    currentY += height$12;
    return purgeAttachments(newLine);
  });
};
var layoutParagraph = function layoutParagraph2(engines2, options) {
  return function(container, paragraph) {
    var _paragraph$runs, _paragraph$runs$, _paragraph$runs$$attr;
    var height$12 = height3(paragraph);
    var indent = ((_paragraph$runs = paragraph.runs) === null || _paragraph$runs === void 0 ? void 0 : (_paragraph$runs$ = _paragraph$runs[0]) === null || _paragraph$runs$ === void 0 ? void 0 : (_paragraph$runs$$attr = _paragraph$runs$.attributes) === null || _paragraph$runs$$attr === void 0 ? void 0 : _paragraph$runs$$attr.indent) || 0;
    var rects = generateLineRects(container, height$12);
    var availableWidths = rects.map(function(r) {
      return r.width;
    });
    availableWidths[0] -= indent;
    var lines = engines2.linebreaker(options)(paragraph, availableWidths);
    return layoutLines(rects, lines, indent);
  };
};
var sliceAtHeight = function sliceAtHeight2(height5, block) {
  var newBlock = [];
  var counter = 0;
  for (var i = 0; i < block.length; i += 1) {
    var line2 = block[i];
    counter += line2.box.height;
    if (counter < height5) {
      newBlock.push(line2);
    } else {
      break;
    }
  }
  return newBlock;
};
var typesetter = function typesetter2(engines2, options, container) {
  return function(attributedStrings) {
    var blocks = [];
    var paragraphs = [].concat(attributedStrings);
    var layoutBlock = layoutParagraph(engines2, options);
    var maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;
    var truncateEllipsis = container.truncateMode === "ellipsis";
    var linesCount = maxLines;
    var paragraphRect = copy3(container);
    var nextParagraph = paragraphs.shift();
    while (linesCount > 0 && nextParagraph) {
      var block = layoutBlock(paragraphRect, nextParagraph);
      var slicedBlock = block.slice(0, linesCount);
      var linesHeight3 = height$2(slicedBlock);
      var shouldTruncate = truncateEllipsis && block.length !== slicedBlock.length;
      linesCount -= slicedBlock.length;
      if (paragraphRect.height >= linesHeight3) {
        blocks.push(shouldTruncate ? truncate3(slicedBlock) : slicedBlock);
        paragraphRect = crop(linesHeight3, paragraphRect);
        nextParagraph = paragraphs.shift();
      } else {
        blocks.push(truncate3(sliceAtHeight(paragraphRect.height, slicedBlock)));
        break;
      }
    }
    return blocks;
  };
};
var start = function start2(attributedString) {
  var runs = attributedString.runs;
  return runs.length === 0 ? 0 : runs[0].start;
};
var end = function end2(attributedString) {
  var runs = attributedString.runs;
  return runs.length === 0 ? 0 : last(runs).end;
};
var length$1 = function length(attributedString) {
  return end(attributedString) - start(attributedString);
};
var bidi$2 = bidi_default();
var getBidiLevels$1 = function getBidiLevels(runs) {
  return runs.reduce(function(acc, run) {
    var length4 = run.end - run.start;
    var levels = repeat(run.attributes.bidiLevel, length4);
    return acc.concat(levels);
  }, []);
};
var getReorderedIndices = function getReorderedIndices2(string, segments) {
  var indices = [];
  for (var i = 0; i < string.length; i += 1) {
    indices[i] = i;
  }
  segments.forEach(function(_ref) {
    var start3 = _ref[0], end3 = _ref[1];
    var slice8 = indices.slice(start3, end3 + 1);
    for (var _i = slice8.length - 1; _i >= 0; _i -= 1) {
      indices[end3 - _i] = slice8[_i];
    }
  });
  return indices;
};
var getItemAtIndex = function getItemAtIndex2(runs, objectName, index2) {
  for (var i = 0; i < runs.length; i += 1) {
    var run = runs[i];
    var updatedIndex = run.glyphIndices[index2 - run.start];
    if (index2 >= run.start && index2 < run.end) {
      return run[objectName][updatedIndex];
    }
  }
  throw new Error("index " + index2 + " out of range");
};
var reorderLine = function reorderLine2(attributedString) {
  var _attributedString$run;
  var levels = getBidiLevels$1(attributedString.runs);
  var direction = (_attributedString$run = attributedString.runs[0]) === null || _attributedString$run === void 0 ? void 0 : _attributedString$run.attributes.direction;
  var level = direction === "rtl" ? 1 : 0;
  var end3 = length$1(attributedString) - 1;
  var paragraphs = [{
    start: 0,
    end: end3,
    level
  }];
  var embeddingLevels = {
    paragraphs,
    levels
  };
  var segments = bidi$2.getReorderSegments(attributedString.string, embeddingLevels);
  if (segments.length === 0) return attributedString;
  var indices = getReorderedIndices(attributedString.string, segments);
  var updatedString = bidi$2.getReorderedString(attributedString.string, embeddingLevels);
  var updatedRuns = attributedString.runs.map(function(run) {
    var selectedIndices = indices.slice(run.start, run.end);
    var updatedGlyphs = [];
    var updatedPositions = [];
    var addedGlyphs = /* @__PURE__ */ new Set();
    for (var i = 0; i < selectedIndices.length; i += 1) {
      var index2 = selectedIndices[i];
      var glyph = getItemAtIndex(attributedString.runs, "glyphs", index2);
      if (addedGlyphs.has(glyph.id)) continue;
      updatedGlyphs.push(glyph);
      updatedPositions.push(getItemAtIndex(attributedString.runs, "positions", index2));
      if (glyph.isLigature) {
        addedGlyphs.add(glyph.id);
      }
    }
    return _extends({}, run, {
      glyphs: updatedGlyphs,
      positions: updatedPositions
    });
  });
  return _extends({}, attributedString, {
    runs: updatedRuns,
    string: updatedString
  });
};
var reorderParagraph = function reorderParagraph2(lines) {
  return lines.map(reorderLine);
};
var bidiReordering = function bidiReordering2() {
  return function(paragraphs) {
    return paragraphs.map(reorderParagraph);
  };
};
var DUMMY_CODEPOINT = 123;
var resolve = function resolve2(glyphs) {
  if (glyphs === void 0) {
    glyphs = [];
  }
  return glyphs.reduce(function(acc, glyph) {
    var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];
    if (acc.length === 0) return codePoints.map(function() {
      return 0;
    });
    var last3 = acc[acc.length - 1];
    var next = codePoints.map(function() {
      return last3 + 1;
    });
    return [].concat(acc, next);
  }, []);
};
var getCharacterSpacing = function getCharacterSpacing2(run) {
  var _run$attributes;
  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.characterSpacing) || 0;
};
var scalePositions = function scalePositions2(run, positions) {
  var runScale = scale2(run);
  var characterSpacing = getCharacterSpacing(run);
  return positions.map(function(position, i) {
    var isLast = i === positions.length;
    var xSpacing = isLast ? 0 : characterSpacing;
    return Object.assign({}, position, {
      xAdvance: position.xAdvance * runScale + xSpacing,
      yAdvance: position.yAdvance * runScale,
      xOffset: position.xOffset * runScale,
      yOffset: position.yOffset * runScale
    });
  });
};
var layoutRun = function layoutRun2(string) {
  return function(run) {
    var start3 = run.start, end3 = run.end, _run$attributes2 = run.attributes, attributes2 = _run$attributes2 === void 0 ? {} : _run$attributes2;
    var font2 = attributes2.font;
    if (!font2) return _extends({}, run, {
      glyphs: [],
      glyphIndices: [],
      positions: []
    });
    var runString = string.slice(start3, end3);
    var glyphRun = font2.layout(runString, void 0, void 0, void 0, "ltr");
    var positions = scalePositions(run, glyphRun.positions);
    var glyphIndices = resolve(glyphRun.glyphs);
    return _extends({}, run, {
      positions,
      glyphIndices,
      glyphs: glyphRun.glyphs
    });
  };
};
var generateGlyphs = function generateGlyphs2() {
  return function(attributedString) {
    var runs = attributedString.runs.map(layoutRun(attributedString.string));
    return Object.assign({}, attributedString, {
      runs
    });
  };
};
var resolveRunYOffset = function resolveRunYOffset2(run) {
  var _run$attributes, _run$attributes$font, _run$attributes2;
  if (!run.positions) return run;
  var unitsPerEm = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.unitsPerEm) || 0;
  var yOffset = (((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : _run$attributes2.yOffset) || 0) * unitsPerEm;
  var positions = run.positions.map(function(p) {
    return Object.assign({}, p, {
      yOffset
    });
  });
  return Object.assign({}, run, {
    positions
  });
};
var resolveYOffset = function resolveYOffset2() {
  return function(attributedString) {
    var runs = attributedString.runs.map(resolveRunYOffset);
    return Object.assign({}, attributedString, {
      runs
    });
  };
};
var sort = function sort2(runs) {
  return runs.sort(function(a2, b) {
    return a2.start - b.start || a2.end - b.end;
  });
};
var isEmpty = function isEmpty2(run) {
  return run.start === run.end;
};
var sortPoints = function sortPoints2(a2, b) {
  return a2[1] - b[1] || a2[3] - b[3];
};
var generatePoints = function generatePoints2(runs) {
  var result = runs.reduce(function(acc, run, i) {
    return acc.concat([["start", run.start, run.attributes, i], ["end", run.end, run.attributes, i]]);
  }, []);
  return result.sort(sortPoints);
};
var mergeRuns = function mergeRuns2(runs) {
  return runs.reduce(function(acc, run) {
    var attributes2 = Object.assign({}, acc.attributes, run.attributes);
    return Object.assign({}, run, {
      attributes: attributes2
    });
  }, {});
};
var groupEmptyRuns = function groupEmptyRuns2(runs) {
  var groups = runs.reduce(function(acc, run) {
    if (!acc[run.start]) acc[run.start] = [];
    acc[run.start].push(run);
    return acc;
  }, []);
  return Object.values(groups);
};
var flattenEmptyRuns = function flattenEmptyRuns2(runs) {
  return groupEmptyRuns(runs).map(mergeRuns);
};
var flattenRegularRuns = function flattenRegularRuns2(runs) {
  var res = [];
  var points = generatePoints(runs);
  var start3 = -1;
  var attrs = {};
  var stack = [];
  for (var i = 0; i < points.length; i += 1) {
    var _points$i = points[i], type2 = _points$i[0], offset3 = _points$i[1], attributes2 = _points$i[2];
    if (start3 !== -1 && start3 < offset3) {
      res.push({
        start: start3,
        end: offset3,
        attributes: attrs
      });
    }
    if (type2 === "start") {
      stack.push(attributes2);
      attrs = Object.assign({}, attrs, attributes2);
    } else {
      attrs = {};
      for (var j = 0; j < stack.length; j += 1) {
        if (stack[j] === attributes2) {
          stack.splice(j--, 1);
        } else {
          attrs = Object.assign({}, attrs, stack[j]);
        }
      }
    }
    start3 = offset3;
  }
  return res;
};
var flatten2 = function flatten3(runs) {
  if (runs === void 0) {
    runs = [];
  }
  var emptyRuns = flattenEmptyRuns(runs.filter(function(run) {
    return isEmpty(run);
  }));
  var regularRuns = flattenRegularRuns(runs.filter(function(run) {
    return !isEmpty(run);
  }));
  return sort(emptyRuns.concat(regularRuns));
};
var empty2 = function empty3() {
  return {
    string: "",
    runs: []
  };
};
var omitFont = function omitFont2(attributedString) {
  var runs = attributedString.runs.map(function(run) {
    return omit3("font", run);
  });
  return Object.assign({}, attributedString, {
    runs
  });
};
var preprocessRuns = function preprocessRuns2(engines2, options) {
  return function(attributedString) {
    if (isNil(attributedString)) return empty2();
    var string = attributedString.string;
    var fontSubstitution3 = engines2.fontSubstitution, scriptItemizer3 = engines2.scriptItemizer, bidi2 = engines2.bidi;
    var _omitFont = omitFont(attributedString), omittedFontRuns = _omitFont.runs;
    var _scriptItemizer = scriptItemizer3(options)(attributedString), itemizationRuns = _scriptItemizer.runs;
    var _fontSubstitution = fontSubstitution3(options)(attributedString), substitutedRuns = _fontSubstitution.runs;
    var _bidi = bidi2(options)(attributedString), bidiRuns = _bidi.runs;
    var runs = bidiRuns.concat(substitutedRuns).concat(itemizationRuns).concat(omittedFontRuns);
    return {
      string,
      runs: flatten2(runs)
    };
  };
};
var splitParagraphs = function splitParagraphs2() {
  return function(attributedString) {
    var res = [];
    var start3 = 0;
    var breakPoint = attributedString.string.indexOf("\n") + 1;
    while (breakPoint > 0) {
      res.push(slice5(start3, breakPoint, attributedString));
      start3 = breakPoint;
      breakPoint = attributedString.string.indexOf("\n", breakPoint) + 1;
    }
    if (start3 === 0) {
      res.push(attributedString);
    } else if (start3 < attributedString.string.length) {
      res.push(slice5(start3, length$1(attributedString), attributedString));
    }
    return res;
  };
};
var advanceWidth$2 = function advanceWidth(positions) {
  return positions.reduce(function(acc, pos) {
    return acc + (pos.xAdvance || 0);
  }, 0);
};
var advanceWidth$1 = function advanceWidth2(run) {
  return advanceWidth$2(run.positions || []);
};
var advanceWidth3 = function advanceWidth4(attributedString) {
  var reducer = function reducer2(acc, run) {
    return acc + advanceWidth$1(run);
  };
  return attributedString.runs.reduce(reducer, 0);
};
var WHITE_SPACES_CODE = 32;
var isWhiteSpace = function isWhiteSpace2(glyph) {
  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];
  return codePoints.includes(WHITE_SPACES_CODE);
};
var leadingPositions = function leadingPositions2(run) {
  var glyphs = run.glyphs || [];
  var positions = run.positions || [];
  var leadingWhitespaces = glyphs.findIndex(function(g) {
    return !isWhiteSpace(g);
  });
  return positions.slice(0, leadingWhitespaces);
};
var leadingOffset$1 = function leadingOffset(run) {
  var positions = leadingPositions(run);
  return positions.reduce(function(acc, pos) {
    return acc + (pos.xAdvance || 0);
  }, 0);
};
var leadingOffset2 = function leadingOffset3(attributedString) {
  var runs = attributedString.runs || [];
  return leadingOffset$1(runs[0]);
};
var reverse3 = function reverse4(array) {
  return [].concat(array).reverse();
};
var trailingPositions = function trailingPositions2(run) {
  var glyphs = reverse3(run.glyphs || []);
  var positions = reverse3(run.positions || []);
  var leadingWhitespaces = glyphs.findIndex(function(g) {
    return !isWhiteSpace(g);
  });
  return positions.slice(0, leadingWhitespaces);
};
var trailingOffset$1 = function trailingOffset(run) {
  var positions = trailingPositions(run);
  return positions.reduce(function(acc, pos) {
    return acc + (pos.xAdvance || 0);
  }, 0);
};
var trailingOffset2 = function trailingOffset3(attributedString) {
  var runs = attributedString.runs || [];
  return trailingOffset$1(last(runs));
};
var dropLast$1 = function dropLast3(run) {
  return slice$1(0, run.end - run.start - 1, run);
};
var dropLast4 = function dropLast5(attributedString) {
  var string = dropLast(attributedString.string);
  var runs = adjust(-1, dropLast$1, attributedString.runs);
  return Object.assign({}, attributedString, {
    string,
    runs
  });
};
var ALIGNMENT_FACTORS = {
  center: 0.5,
  right: 1
};
var removeNewLine = function removeNewLine2(line2) {
  return last(line2.string) === "\n" ? dropLast4(line2) : line2;
};
var getOverflowLeft = function getOverflowLeft2(line2) {
  return leadingOffset2(line2) + (line2.overflowLeft || 0);
};
var getOverflowRight = function getOverflowRight2(line2) {
  return trailingOffset2(line2) + (line2.overflowRight || 0);
};
var adjustOverflow = function adjustOverflow2(line2) {
  var overflowLeft = getOverflowLeft(line2);
  var overflowRight = getOverflowRight(line2);
  var x = line2.box.x - overflowLeft;
  var width = line2.box.width + overflowLeft + overflowRight;
  var box = Object.assign({}, line2.box, {
    x,
    width
  });
  return Object.assign({}, line2, {
    box,
    overflowLeft,
    overflowRight
  });
};
var justifyLine$1 = function justifyLine(engines2, options, align) {
  return function(line2) {
    var lineWidth2 = advanceWidth3(line2);
    var alignFactor = ALIGNMENT_FACTORS[align] || 0;
    var remainingWidth = Math.max(0, line2.box.width - lineWidth2);
    var shouldJustify = align === "justify" || lineWidth2 > line2.box.width;
    var x = line2.box.x + remainingWidth * alignFactor;
    var box = Object.assign({}, line2.box, {
      x
    });
    var newLine = Object.assign({}, line2, {
      box
    });
    return shouldJustify ? engines2.justification(options)(newLine) : newLine;
  };
};
var finalizeLine = function finalizeLine2(line2) {
  var lineAscent = 0;
  var lineDescent = 0;
  var lineHeight = 0;
  var lineXAdvance = 0;
  var runs = line2.runs.map(function(run) {
    var height5 = height$1(run);
    var ascent4 = ascent$1(run);
    var descent$1 = descent(run);
    var xAdvance = advanceWidth$1(run);
    lineHeight = Math.max(lineHeight, height5);
    lineAscent = Math.max(lineAscent, ascent4);
    lineDescent = Math.max(lineDescent, descent$1);
    lineXAdvance += xAdvance;
    return Object.assign({}, run, {
      height: height5,
      ascent: ascent4,
      descent: descent$1,
      xAdvance
    });
  });
  return Object.assign({}, line2, {
    runs,
    height: lineHeight,
    ascent: lineAscent,
    descent: lineDescent,
    xAdvance: lineXAdvance
  });
};
var finalizeBlock = function finalizeBlock2(engines2, options) {
  if (engines2 === void 0) {
    engines2 = {};
  }
  return function(line2, i, lines) {
    var _line$runs, _line$runs$;
    var isLastFragment = i === lines.length - 1;
    var style = ((_line$runs = line2.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};
    var align = isLastFragment ? style.alignLastLine : style.align;
    return compose(finalizeLine, engines2.textDecoration(options), justifyLine$1(engines2, options, align), adjustOverflow, removeNewLine)(line2);
  };
};
var finalizeFragments = function finalizeFragments2(engines2, options) {
  return function(blocks) {
    var blockFinalizer = finalizeBlock(engines2, options);
    return blocks.map(function(block) {
      return block.map(blockFinalizer);
    });
  };
};
var ATTACHMENT_CODE = 65532;
var isReplaceGlyph = function isReplaceGlyph2(glyph) {
  return glyph.codePoints.includes(ATTACHMENT_CODE);
};
var resolveRunAttachments = function resolveRunAttachments2(run) {
  var _run$attributes;
  if (!run.positions) return run;
  var glyphs = run.glyphs || [];
  var attachment = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.attachment) || {};
  var positions = run.positions.map(function(position, i) {
    var glyph = glyphs[i];
    if (attachment && attachment.width && isReplaceGlyph(glyph)) {
      return Object.assign({}, position, {
        xAdvance: attachment.width
      });
    }
    return Object.assign({}, position);
  });
  return Object.assign({}, run, {
    positions
  });
};
var resolveAttachments = function resolveAttachments2() {
  return function(attributedString) {
    var runs = attributedString.runs.map(resolveRunAttachments);
    return Object.assign({}, attributedString, {
      runs
    });
  };
};
var applyAttributes = function applyAttributes2(a2) {
  return {
    align: a2.align || (a2.direction === "rtl" ? "right" : "left"),
    alignLastLine: a2.alignLastLine || (a2.align === "justify" ? "left" : a2.align || "left"),
    attachment: a2.attachment || null,
    backgroundColor: a2.backgroundColor || null,
    bullet: a2.bullet || null,
    characterSpacing: a2.characterSpacing || 0,
    color: a2.color || "black",
    direction: a2.direction || "ltr",
    features: a2.features || [],
    fill: a2.fill !== false,
    font: a2.font || null,
    fontSize: a2.fontSize || 12,
    hangingPunctuation: a2.hangingPunctuation || false,
    hyphenationFactor: a2.hyphenationFactor || 0,
    indent: a2.indent || 0,
    justificationFactor: a2.justificationFactor || 1,
    lineHeight: a2.lineHeight || null,
    lineSpacing: a2.lineSpacing || 0,
    link: a2.link || null,
    marginLeft: a2.marginLeft || a2.margin || 0,
    marginRight: a2.marginRight || a2.margin || 0,
    opacity: a2.opacity,
    paddingTop: a2.paddingTop || a2.padding || 0,
    paragraphSpacing: a2.paragraphSpacing || 0,
    script: a2.script || null,
    shrinkFactor: a2.shrinkFactor || 0,
    strike: a2.strike || false,
    strikeColor: a2.strikeColor || a2.color || "black",
    strikeStyle: a2.strikeStyle || "solid",
    stroke: a2.stroke || false,
    underline: a2.underline || false,
    underlineColor: a2.underlineColor || a2.color || "black",
    underlineStyle: a2.underlineStyle || "solid",
    verticalAlign: a2.verticalAlign || null,
    wordSpacing: a2.wordSpacing || 0,
    yOffset: a2.yOffset || 0
  };
};
var applyRunStyles = function applyRunStyles2(run) {
  var attributes2 = applyAttributes(run.attributes);
  return Object.assign({}, run, {
    attributes: attributes2
  });
};
var applyDefaultStyles = function applyDefaultStyles2() {
  return function(attributedString) {
    var string = attributedString.string || "";
    var runs = (attributedString.runs || []).map(applyRunStyles);
    return {
      string,
      runs
    };
  };
};
var verticalAlignment = function verticalAlignment2() {
  return function(attributedString) {
    attributedString.runs.forEach(function(run) {
      var attributes2 = run.attributes;
      var verticalAlign = attributes2.verticalAlign;
      if (verticalAlign === "sub") {
        attributes2.yOffset = -0.2;
      } else if (verticalAlign === "super") {
        attributes2.yOffset = 0.4;
      }
    });
    return attributedString;
  };
};
var bidi$1 = bidi_default();
var getBidiLevels2 = function getBidiLevels3(runs) {
  return runs.reduce(function(acc, run) {
    var length4 = run.end - run.start;
    var levels = repeat(run.attributes.bidiLevel, length4);
    return acc.concat(levels);
  }, []);
};
var mirrorString = function mirrorString2() {
  return function(attributedString) {
    var levels = getBidiLevels2(attributedString.runs);
    var updatedString = "";
    attributedString.string.split("").forEach(function(char, index2) {
      var isRTL = levels[index2] % 2 === 1;
      var mirroredChar = isRTL ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index2)) : null;
      updatedString += mirroredChar || char;
    });
    return _extends({}, attributedString, {
      string: updatedString,
      levels
    });
  };
};
var layoutEngine = function layoutEngine2(engines2) {
  return function(attributedString, container, options) {
    if (options === void 0) {
      options = {};
    }
    var processParagraph = compose(resolveYOffset(), resolveAttachments(), verticalAlignment(), wrapWords(engines2, options), generateGlyphs(), mirrorString(), preprocessRuns(engines2, options));
    var processParagraphs = function processParagraphs2(paragraphs) {
      return paragraphs.map(processParagraph);
    };
    return compose(finalizeFragments(engines2, options), bidiReordering(), typesetter(engines2, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);
  };
};
var bidi = bidi_default();
var bidiEngine = function bidiEngine2() {
  return function(attributedString) {
    var _attributedString$run;
    var string = attributedString.string;
    var direction = (_attributedString$run = attributedString.runs[0]) === null || _attributedString$run === void 0 ? void 0 : _attributedString$run.attributes.direction;
    var _bidi$getEmbeddingLev = bidi.getEmbeddingLevels(string, direction), levels = _bidi$getEmbeddingLev.levels;
    var lastLevel = null;
    var lastIndex = 0;
    var index2 = 0;
    var res = [];
    for (var i = 0; i < levels.length; i += 1) {
      var level = levels[i];
      if (level !== lastLevel) {
        if (lastLevel !== null) {
          res.push({
            start: lastIndex,
            end: index2,
            attributes: {
              bidiLevel: lastLevel
            }
          });
        }
        lastIndex = index2;
        lastLevel = level;
      }
      index2 += 1;
    }
    if (lastIndex < string.length) {
      res.push({
        start: lastIndex,
        end: string.length,
        attributes: {
          bidiLevel: lastLevel
        }
      });
    }
    return {
      string,
      runs: res
    };
  };
};
var INFINITY = 1e4;
var getNextBreakpoint = function getNextBreakpoint2(subnodes, widths, lineNumber) {
  var position = null;
  var minimumBadness = Infinity;
  var sum = {
    width: 0,
    stretch: 0,
    shrink: 0
  };
  var lineLength = widths[Math.min(lineNumber, widths.length - 1)];
  var calculateRatio = function calculateRatio2(node2) {
    if (sum.width < lineLength) {
      return sum.stretch - node2.stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;
    }
    if (sum.width > lineLength) {
      return sum.shrink - node2.shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;
    }
    return 0;
  };
  for (var i = 0; i < subnodes.length; i += 1) {
    var node = subnodes[i];
    if (node.type === "box") {
      sum.width += node.width;
    } else if (node.type === "glue") {
      sum.width += node.width;
      sum.stretch += node.stretch;
      sum.shrink += node.shrink;
    }
    if (sum.width - sum.shrink > lineLength) {
      if (position === null) {
        var j = i === 0 ? i + 1 : i;
        while (j < subnodes.length && (subnodes[j].type === "glue" || subnodes[j].type === "penalty")) {
          j++;
        }
        position = j - 1;
      }
      break;
    }
    if (node.type === "penalty" || node.type === "glue") {
      var ratio = calculateRatio(node);
      var penalty = node.type === "penalty" ? node.penalty : 0;
      var badness = 100 * Math.pow(Math.abs(ratio), 3) + penalty;
      if (minimumBadness >= badness) {
        position = i;
        minimumBadness = badness;
      }
    }
  }
  return sum.width - sum.shrink > lineLength ? position : null;
};
var applyBestFit = function applyBestFit2(nodes, widths) {
  var count = 0;
  var lineNumber = 0;
  var subnodes = nodes;
  var breakpoints = [{
    position: 0
  }];
  while (subnodes.length > 0) {
    var breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);
    if (breakpoint !== null) {
      count += breakpoint;
      breakpoints.push({
        position: count
      });
      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);
      count++;
      lineNumber++;
    } else {
      subnodes = [];
    }
  }
  return breakpoints;
};
var Node = function() {
  function Node2(data2) {
    this.prev = null;
    this.next = null;
    this.data = data2;
  }
  var _proto = Node2.prototype;
  _proto.toString = function toString7() {
    return this.data.toString();
  };
  return Node2;
}();
var LinkedList = function() {
  function LinkedList2() {
    this.head = null;
    this.tail = null;
    this.listSize = 0;
    this.listLength = 0;
  }
  var _proto2 = LinkedList2.prototype;
  _proto2.isLinked = function isLinked(node) {
    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());
  };
  _proto2.size = function size() {
    return this.listSize;
  };
  _proto2.isEmpty = function isEmpty3() {
    return this.listSize === 0;
  };
  _proto2.first = function first() {
    return this.head;
  };
  _proto2.last = function last3() {
    return this.last;
  };
  _proto2.toString = function toString7() {
    return this.toArray().toString();
  };
  _proto2.toArray = function toArray() {
    var node = this.head;
    var result = [];
    while (node !== null) {
      result.push(node);
      node = node.next;
    }
    return result;
  };
  _proto2.forEach = function forEach2(fun) {
    var node = this.head;
    while (node !== null) {
      fun(node);
      node = node.next;
    }
  };
  _proto2.contains = function contains(n) {
    var node = this.head;
    if (!this.isLinked(n)) {
      return false;
    }
    while (node !== null) {
      if (node === n) {
        return true;
      }
      node = node.next;
    }
    return false;
  };
  _proto2.at = function at(i) {
    var node = this.head;
    var index2 = 0;
    if (i >= this.listLength || i < 0) {
      return null;
    }
    while (node !== null) {
      if (i === index2) {
        return node;
      }
      node = node.next;
      index2 += 1;
    }
    return null;
  };
  _proto2.insertAfter = function insertAfter(node, newNode) {
    if (!this.isLinked(node)) {
      return this;
    }
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next === null) {
      this.tail = newNode;
    } else {
      node.next.prev = newNode;
    }
    node.next = newNode;
    this.listSize += 1;
    return this;
  };
  _proto2.insertBefore = function insertBefore(node, newNode) {
    if (!this.isLinked(node)) {
      return this;
    }
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev === null) {
      this.head = newNode;
    } else {
      node.prev.next = newNode;
    }
    node.prev = newNode;
    this.listSize += 1;
    return this;
  };
  _proto2.push = function push(node) {
    if (this.head === null) {
      this.unshift(node);
    } else {
      this.insertAfter(this.tail, node);
    }
    return this;
  };
  _proto2.unshift = function unshift(node) {
    if (this.head === null) {
      this.head = node;
      this.tail = node;
      node.prev = null;
      node.next = null;
      this.listSize += 1;
    } else {
      this.insertBefore(this.head, node);
    }
    return this;
  };
  _proto2.remove = function remove(node) {
    if (!this.isLinked(node)) {
      return this;
    }
    if (node.prev === null) {
      this.head = node.next;
    } else {
      node.prev.next = node.next;
    }
    if (node.next === null) {
      this.tail = node.prev;
    } else {
      node.next.prev = node.prev;
    }
    this.listSize -= 1;
    return this;
  };
  _proto2.pop = function pop() {
    var node = this.tail;
    this.tail.prev.next = null;
    this.tail = this.tail.prev;
    this.listSize -= 1;
    node.prev = null;
    node.next = null;
    return node;
  };
  _proto2.shift = function shift() {
    var node = this.head;
    this.head.next.prev = null;
    this.head = this.head.next;
    this.listSize -= 1;
    node.prev = null;
    node.next = null;
    return node;
  };
  return LinkedList2;
}();
LinkedList.Node = Node;
var linebreak = function linebreak2(nodes, lines, settings) {
  var options = {
    demerits: {
      line: settings && settings.demerits && settings.demerits.line || 10,
      flagged: settings && settings.demerits && settings.demerits.flagged || 100,
      fitness: settings && settings.demerits && settings.demerits.fitness || 3e3
    },
    tolerance: settings && settings.tolerance || 3
  };
  var activeNodes = new LinkedList();
  var sum = {
    width: 0,
    stretch: 0,
    shrink: 0
  };
  var lineLengths = lines;
  var breaks = [];
  var tmp = {
    data: {
      demerits: Infinity
    }
  };
  function breakpoint(position, demerits, ratio, line2, fitnessClass, totals, previous) {
    return {
      position,
      demerits,
      ratio,
      line: line2,
      fitnessClass,
      totals: totals || {
        width: 0,
        stretch: 0,
        shrink: 0
      },
      previous
    };
  }
  function computeCost(start3, end3, active, currentLine) {
    var width = sum.width - active.totals.width;
    var stretch = 0;
    var shrink = 0;
    var lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];
    if (nodes[end3].type === "penalty") {
      width += nodes[end3].width;
    }
    if (width < lineLength) {
      stretch = sum.stretch - active.totals.stretch;
      if (stretch > 0) {
        return (lineLength - width) / stretch;
      }
      return linebreak2.infinity;
    }
    if (width > lineLength) {
      shrink = sum.shrink - active.totals.shrink;
      if (shrink > 0) {
        return (lineLength - width) / shrink;
      }
      return linebreak2.infinity;
    }
    return 0;
  }
  function computeSum(breakPointIndex) {
    var result = {
      width: sum.width,
      stretch: sum.stretch,
      shrink: sum.shrink
    };
    for (var i = breakPointIndex; i < nodes.length; i += 1) {
      if (nodes[i].type === "glue") {
        result.width += nodes[i].width;
        result.stretch += nodes[i].stretch;
        result.shrink += nodes[i].shrink;
      } else if (nodes[i].type === "box" || nodes[i].type === "penalty" && nodes[i].penalty === -linebreak2.infinity && i > breakPointIndex) {
        break;
      }
    }
    return result;
  }
  function mainLoop(node, index2, nodes2) {
    var active = activeNodes.first();
    var next = null;
    var ratio = 0;
    var demerits = 0;
    var candidates = [];
    var badness;
    var currentLine = 0;
    var tmpSum;
    var currentClass = 0;
    var fitnessClass;
    var candidate;
    var newNode;
    while (active !== null) {
      candidates = [{
        demerits: Infinity
      }, {
        demerits: Infinity
      }, {
        demerits: Infinity
      }, {
        demerits: Infinity
      }];
      while (active !== null) {
        next = active.next;
        currentLine = active.data.line + 1;
        ratio = computeCost(active.data.position, index2, active.data, currentLine);
        if (ratio < -1 || node.type === "penalty" && node.penalty === -linebreak2.infinity) {
          activeNodes.remove(active);
        }
        if (ratio >= -1 && ratio <= options.tolerance) {
          badness = 100 * Math.pow(Math.abs(ratio), 3);
          if (node.type === "penalty" && node.penalty >= 0) {
            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2);
          } else if (node.type === "penalty" && node.penalty !== -linebreak2.infinity) {
            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2);
          } else {
            demerits = Math.pow(options.demerits.line + badness, 2);
          }
          if (node.type === "penalty" && nodes2[active.data.position].type === "penalty") {
            demerits += options.demerits.flagged * node.flagged * nodes2[active.data.position].flagged;
          }
          if (ratio < -0.5) {
            currentClass = 0;
          } else if (ratio <= 0.5) {
            currentClass = 1;
          } else if (ratio <= 1) {
            currentClass = 2;
          } else {
            currentClass = 3;
          }
          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {
            demerits += options.demerits.fitness;
          }
          demerits += active.data.demerits;
          if (demerits < candidates[currentClass].demerits) {
            candidates[currentClass] = {
              active,
              demerits,
              ratio
            };
          }
        }
        active = next;
        if (active !== null && active.data.line >= currentLine) {
          break;
        }
      }
      tmpSum = computeSum(index2);
      for (fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {
        candidate = candidates[fitnessClass];
        if (candidate.demerits < Infinity) {
          newNode = new LinkedList.Node(breakpoint(index2, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));
          if (active !== null) {
            activeNodes.insertBefore(active, newNode);
          } else {
            activeNodes.push(newNode);
          }
        }
      }
    }
  }
  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, 0, void 0, null)));
  nodes.forEach(function(node, index2, nodes2) {
    if (node.type === "box") {
      sum.width += node.width;
    } else if (node.type === "glue") {
      if (index2 > 0 && nodes2[index2 - 1].type === "box") {
        mainLoop(node, index2, nodes2);
      }
      sum.width += node.width;
      sum.stretch += node.stretch;
      sum.shrink += node.shrink;
    } else if (node.type === "penalty" && node.penalty !== linebreak2.infinity) {
      mainLoop(node, index2, nodes2);
    }
  });
  if (activeNodes.size() !== 0) {
    activeNodes.forEach(function(node) {
      if (node.data.demerits < tmp.data.demerits) {
        tmp = node;
      }
    });
    while (tmp !== null) {
      breaks.push({
        position: tmp.data.position,
        ratio: tmp.data.ratio
      });
      tmp = tmp.data.previous;
    }
    return breaks.reverse();
  }
  return [];
};
linebreak.infinity = 1e4;
linebreak.glue = function(width, value2, stretch, shrink) {
  return {
    type: "glue",
    value: value2,
    width,
    stretch,
    shrink
  };
};
linebreak.box = function(width, value2, hyphenated) {
  if (hyphenated === void 0) {
    hyphenated = false;
  }
  return {
    type: "box",
    width,
    value: value2,
    hyphenated
  };
};
linebreak.penalty = function(width, penalty, flagged) {
  return {
    type: "penalty",
    width,
    penalty,
    flagged
  };
};
var add = function add2(n, run) {
  var start3 = run.start + n;
  var end3 = run.end + n;
  return Object.assign({}, run, {
    start: start3,
    end: end3
  });
};
var length2 = function length3(run) {
  return run.end - run.start;
};
var concat3 = function concat4(runA, runB) {
  var end3 = runA.end + length2(runB);
  var glyphs = (runA.glyphs || []).concat(runB.glyphs || []);
  var positions = (runA.positions || []).concat(runB.positions || []);
  var attributes2 = Object.assign({}, runA.attributes, runB.attributes);
  var runAIndices = runA.glyphIndices || [];
  var runALastIndex = last(runAIndices) || 0;
  var runBIndices = (runB.glyphIndices || []).map(function(i) {
    return i + runALastIndex + 1;
  });
  var glyphIndices = normalize4(runAIndices.concat(runBIndices));
  return Object.assign({}, runA, {
    end: end3,
    glyphs,
    positions,
    attributes: attributes2,
    glyphIndices
  });
};
var insertGlyph$1 = function insertGlyph(index2, glyph, run) {
  if (!glyph) return run;
  var leadingRun = slice$1(0, index2, run);
  var trailingRun = slice$1(index2, Infinity, run);
  return concat3(append$1(glyph, leadingRun), trailingRun);
};
var insert = function insert2(index2, value2, run) {
  var font2 = getFont(run);
  var glyph = isNumber3(value2) ? fromCodePoint(value2, font2) : value2;
  return insertGlyph$1(index2, glyph, run);
};
var runIndexAt2 = function runIndexAt3(n, string) {
  return runIndexAt$1(n, string.runs);
};
var insertGlyph2 = function insertGlyph3(index2, glyph, attributedString) {
  var runIndex = runIndexAt2(index2, attributedString);
  if (runIndex === -1) return append2(glyph, attributedString);
  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];
  var string = attributedString.string.slice(0, index2) + stringFromCodePoints(codePoints) + attributedString.string.slice(index2);
  var runs = attributedString.runs.map(function(run, i) {
    if (i === runIndex) return insert(index2 - run.start, glyph, run);
    if (i > runIndex) return add(codePoints.length, run);
    return run;
  });
  return Object.assign({}, attributedString, {
    string,
    runs
  });
};
var advanceWidthBetween$1 = function advanceWidthBetween(start3, end3, run) {
  var runStart = run.start || 0;
  var glyphStartIndex = Math.max(0, glyphIndexAt(start3 - runStart, run));
  var glyphEndIndex = Math.max(0, glyphIndexAt(end3 - runStart, run));
  var positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);
  return advanceWidth$2(positions);
};
var advanceWidthBetween2 = function advanceWidthBetween3(start3, end3, attributedString) {
  var runs = filter(start3, end3, attributedString.runs);
  return runs.reduce(function(acc, run) {
    return acc + advanceWidthBetween$1(start3, end3, run);
  }, 0);
};
var HYPHEN = 45;
var TOLERANCE_STEPS = 5;
var TOLERANCE_LIMIT = 50;
var opts = {
  width: 3,
  stretch: 6,
  shrink: 9
};
var breakLines = function breakLines2(string, nodes, breaks) {
  var start3 = 0;
  var end3 = null;
  var lines = breaks.reduce(function(acc, breakPoint) {
    var node = nodes[breakPoint.position];
    var prevNode = nodes[breakPoint.position - 1];
    if (breakPoint.position === nodes.length - 1) return acc;
    var line2;
    if (node.type === "penalty") {
      end3 = prevNode.value.end;
      line2 = slice5(start3, end3, string);
      line2 = insertGlyph2(line2.length, HYPHEN, line2);
    } else {
      end3 = node.value.end;
      line2 = slice5(start3, end3, string);
    }
    start3 = end3;
    return [].concat(acc, [line2]);
  }, []);
  lines.push(slice5(start3, string.string.length, string));
  return lines;
};
var getNodes = function getNodes2(attributedString, _ref, options) {
  var align = _ref.align;
  var start3 = 0;
  var hyphenWidth = 5;
  var syllables = attributedString.syllables;
  var hyphenPenalty = options.hyphenationPenalty || (align === "justify" ? 100 : 600);
  var result = syllables.reduce(function(acc, s2, index2) {
    var width = advanceWidthBetween2(start3, start3 + s2.length, attributedString);
    if (s2.trim() === "") {
      var stretch = width * opts.width / opts.stretch;
      var shrink = width * opts.width / opts.shrink;
      var value2 = {
        start: start3,
        end: start3 + s2.length
      };
      acc.push(linebreak.glue(width, value2, stretch, shrink));
    } else {
      var hyphenated = syllables[index2 + 1] !== " ";
      var _value = {
        start: start3,
        end: start3 + s2.length
      };
      acc.push(linebreak.box(width, _value, hyphenated));
      if (syllables[index2 + 1] && hyphenated) {
        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));
      }
    }
    start3 += s2.length;
    return acc;
  }, []);
  result.push(linebreak.glue(0, null, linebreak.infinity, 0));
  result.push(linebreak.penalty(0, -linebreak.infinity, 1));
  return result;
};
var getStyles = function getStyles2(attributedString) {
  var _attributedString$run, _attributedString$run2;
  return ((_attributedString$run = attributedString.runs) === null || _attributedString$run === void 0 ? void 0 : (_attributedString$run2 = _attributedString$run[0]) === null || _attributedString$run2 === void 0 ? void 0 : _attributedString$run2.attributes) || {};
};
var linebreaker = function linebreaker2(options) {
  return function(attributedString, availableWidths) {
    var tolerance = options.tolerance || 4;
    var style = getStyles(attributedString);
    var nodes = getNodes(attributedString, style, options);
    var breaks = linebreak(nodes, availableWidths, {
      tolerance
    });
    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {
      tolerance += TOLERANCE_STEPS;
      breaks = linebreak(nodes, availableWidths, {
        tolerance
      });
    }
    if (breaks.length === 0 || breaks.length === 1 && breaks[0].position === 0) {
      breaks = applyBestFit(nodes, availableWidths);
    }
    return breakLines(attributedString, nodes, breaks.slice(1));
  };
};
var WHITESPACE_PRIORITY = 1;
var LETTER_PRIORITY = 2;
var EXPAND_WHITESPACE_FACTOR = {
  before: 0.5,
  after: 0.5,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};
var EXPAND_CHAR_FACTOR = {
  before: 0.14453125,
  // 37/256
  after: 0.14453125,
  priority: LETTER_PRIORITY,
  unconstrained: false
};
var SHRINK_WHITESPACE_FACTOR = {
  before: -0.04296875,
  // -11/256
  after: -0.04296875,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};
var SHRINK_CHAR_FACTOR = {
  before: -0.04296875,
  after: -0.04296875,
  priority: LETTER_PRIORITY,
  unconstrained: false
};
var getCharFactor = function getCharFactor2(direction, options) {
  var expandCharFactor = options.expandCharFactor || {};
  var shrinkCharFactor = options.shrinkCharFactor || {};
  return direction === "GROW" ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);
};
var getWhitespaceFactor = function getWhitespaceFactor2(direction, options) {
  var expandWhitespaceFactor = options.expandWhitespaceFactor || {};
  var shrinkWhitespaceFactor2 = options.shrinkWhitespaceFactor || {};
  return direction === "GROW" ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor2);
};
var factor = function factor2(direction, options) {
  return function(glyphs) {
    var charFactor = getCharFactor(direction, options);
    var whitespaceFactor = getWhitespaceFactor(direction, options);
    var factors = [];
    for (var index2 = 0; index2 < glyphs.length; index2 += 1) {
      var f = void 0;
      var glyph = glyphs[index2];
      if (isWhiteSpace(glyph)) {
        f = Object.assign({}, whitespaceFactor);
        if (index2 === glyphs.length - 1) {
          f.before = 0;
          if (index2 > 0) {
            factors[index2 - 1].after = 0;
          }
        }
      } else if (glyph.isMark && index2 > 0) {
        f = Object.assign({}, factors[index2 - 1]);
        f.before = 0;
        factors[index2 - 1].after = 0;
      } else {
        f = Object.assign({}, charFactor);
      }
      factors.push(f);
    }
    return factors;
  };
};
var getFactors = function getFactors2(gap, line2, options) {
  var direction = gap > 0 ? "GROW" : "SHRINK";
  var getFactor = factor(direction, options);
  var factors = line2.runs.reduce(function(acc, run) {
    return acc.concat(getFactor(run.glyphs));
  }, []);
  factors[0].before = 0;
  factors[factors.length - 1].after = 0;
  return factors;
};
var KASHIDA_PRIORITY = 0;
var NULL_PRIORITY = 3;
var getDistances = function getDistances2(gap, factors) {
  var total = 0;
  var priorities = [];
  var unconstrained = [];
  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority += 1) {
    priorities[_priority] = unconstrained[_priority] = 0;
  }
  for (var j = 0; j < factors.length; j += 1) {
    var f = factors[j];
    var sum = f.before + f.after;
    total += sum;
    priorities[f.priority] += sum;
    if (f.unconstrained) {
      unconstrained[f.priority] += sum;
    }
  }
  var highestPriority = -1;
  var highestPrioritySum = 0;
  var remainingGap = gap;
  var priority;
  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {
    var prioritySum = priorities[priority];
    if (prioritySum !== 0) {
      if (highestPriority === -1) {
        highestPriority = priority;
        highestPrioritySum = prioritySum;
      }
      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {
        priorities[priority] = remainingGap / prioritySum;
        unconstrained[priority] = 0;
        remainingGap = 0;
        break;
      }
      priorities[priority] = 1;
      remainingGap -= prioritySum;
      if (unconstrained[priority] !== 0) {
        unconstrained[priority] = remainingGap / unconstrained[priority];
        remainingGap = 0;
        break;
      }
    }
  }
  for (var p = priority + 1; p <= NULL_PRIORITY; p += 1) {
    priorities[p] = 0;
    unconstrained[p] = 0;
  }
  if (remainingGap > 0 && highestPriority > -1) {
    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;
  }
  var distances = [];
  for (var index2 = 0; index2 < factors.length; index2 += 1) {
    var _f = factors[index2];
    var next = factors[index2 + 1];
    var dist = _f.after * priorities[_f.priority];
    if (next) {
      dist += next.before * priorities[next.priority];
    }
    if (_f.unconstrained) {
      dist += _f.after * unconstrained[_f.priority];
      if (next) {
        dist += next.before * unconstrained[next.priority];
      }
    }
    distances.push(dist);
  }
  return distances;
};
var justifyLine2 = function justifyLine3(distances, line2) {
  var index2 = 0;
  for (var _iterator = _createForOfIteratorHelperLoose(line2.runs), _step; !(_step = _iterator()).done; ) {
    var run = _step.value;
    for (var _iterator2 = _createForOfIteratorHelperLoose(run.positions), _step2; !(_step2 = _iterator2()).done; ) {
      var position = _step2.value;
      position.xAdvance += distances[index2++];
    }
  }
  return line2;
};
var justification = function justification2(options) {
  return function(line2) {
    var gap = line2.box.width - advanceWidth3(line2);
    if (gap === 0) return;
    var factors = getFactors(gap, line2, options);
    var distances = getDistances(gap, factors);
    return justifyLine2(distances, line2);
  };
};
var ascent2 = function ascent3(attributedString) {
  var reducer = function reducer2(acc, run) {
    return Math.max(acc, ascent$1(run));
  };
  return attributedString.runs.reduce(reducer, 0);
};
var BASE_FONT_SIZE = 12;
var textDecoration = function textDecoration2() {
  return function(lineFragment) {
    var x = lineFragment.overflowLeft || 0;
    var overflowRight = lineFragment.overflowRight || 0;
    var maxX = advanceWidth3(lineFragment) - overflowRight;
    lineFragment.decorationLines = [];
    for (var i = 0; i < lineFragment.runs.length; i += 1) {
      var run = lineFragment.runs[i];
      var width = Math.min(maxX - x, advanceWidth$1(run));
      var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));
      if (run.attributes.underline) {
        var rect2 = {
          x,
          y: ascent2(lineFragment) + thickness * 2,
          width,
          height: thickness
        };
        var line2 = {
          rect: rect2,
          opacity: run.attributes.opacity,
          color: run.attributes.underlineColor || "black",
          style: run.attributes.underlineStyle || "solid"
        };
        lineFragment.decorationLines.push(line2);
      }
      if (run.attributes.strike) {
        var y = ascent2(lineFragment) - ascent$1(run) / 3;
        var _rect = {
          x,
          y,
          width,
          height: thickness
        };
        var _line2 = {
          rect: _rect,
          opacity: run.attributes.opacity,
          color: run.attributes.strikeColor || "black",
          style: run.attributes.strikeStyle || "solid"
        };
        lineFragment.decorationLines.push(_line2);
      }
      x += width;
    }
    return lineFragment;
  };
};
var ignoredScripts = ["Common", "Inherited", "Unknown"];
var scriptItemizer = function scriptItemizer2() {
  return function(attributedString) {
    var string = attributedString.string;
    var lastScript = "Unknown";
    var lastIndex = 0;
    var index2 = 0;
    var res = [];
    if (!string) return empty2();
    for (var i = 0; i < string.length; i += 1) {
      var char = string[i];
      var codePoint = char.codePointAt();
      var script = $747425b437e121da$export$2e2bcd8739ae039.getScript(codePoint);
      if (script !== lastScript && !ignoredScripts.includes(script)) {
        if (lastScript !== "Unknown") {
          res.push({
            start: lastIndex,
            end: index2,
            attributes: {
              script: lastScript
            }
          });
        }
        lastIndex = index2;
        lastScript = script;
      }
      index2 += char.length;
    }
    if (lastIndex < string.length) {
      res.push({
        start: lastIndex,
        end: string.length,
        attributes: {
          script: lastScript
        }
      });
    }
    return {
      string,
      runs: res
    };
  };
};
var SOFT_HYPHEN = "";
var hyphenator = (0, import_hyphen.default)(import_en_us.default);
var splitHyphen = function splitHyphen2(word) {
  return word.split(SOFT_HYPHEN);
};
var cache = {};
var getParts = function getParts2(word) {
  var base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);
  return splitHyphen(base);
};
var wordHyphenation = function wordHyphenation2() {
  return function(word) {
    var cacheKey = "_" + word;
    if (isNil(word)) return [];
    if (cache[cacheKey]) return cache[cacheKey];
    cache[cacheKey] = getParts(word);
    return cache[cacheKey];
  };
};

// ../../.yarn/cache/@react-pdf-layout-npm-3.12.1-67178ab492-9dce683d17.zip/node_modules/@react-pdf/layout/lib/index.js
var Yoga = __toESM(require_wasm_async_web2());

// ../../.yarn/cache/emoji-regex-npm-10.3.0-0c9fc2ef7f-b4838e8dcd.zip/node_modules/emoji-regex/index.mjs
var emoji_regex_default = () => {
  return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};

// ../../.yarn/cache/@react-pdf-image-npm-2.3.6-69cfa0d486-7ff4994f53.zip/node_modules/@react-pdf/image/lib/index.browser.js
var import_cross_fetch2 = __toESM(require_browser_ponyfill());
var global$13 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup3 = [];
var revLookup3 = [];
var Arr3 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited3 = false;
function init3() {
  inited3 = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup3[i] = code[i];
    revLookup3[code.charCodeAt(i)] = i;
  }
  revLookup3["-".charCodeAt(0)] = 62;
  revLookup3["_".charCodeAt(0)] = 63;
}
function toByteArray3(b64) {
  if (!inited3) {
    init3();
  }
  var i, j, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr3(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L2 = 0;
  for (i = 0, j = 0; i < l2; i += 4, j += 3) {
    tmp = revLookup3[b64.charCodeAt(i)] << 18 | revLookup3[b64.charCodeAt(i + 1)] << 12 | revLookup3[b64.charCodeAt(i + 2)] << 6 | revLookup3[b64.charCodeAt(i + 3)];
    arr[L2++] = tmp >> 16 & 255;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup3[b64.charCodeAt(i)] << 2 | revLookup3[b64.charCodeAt(i + 1)] >> 4;
    arr[L2++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup3[b64.charCodeAt(i)] << 10 | revLookup3[b64.charCodeAt(i + 1)] << 4 | revLookup3[b64.charCodeAt(i + 2)] >> 2;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  return arr;
}
function tripletToBase643(num) {
  return lookup3[num >> 18 & 63] + lookup3[num >> 12 & 63] + lookup3[num >> 6 & 63] + lookup3[num & 63];
}
function encodeChunk3(uint82, start3, end3) {
  var tmp;
  var output = [];
  for (var i = start3; i < end3; i += 3) {
    tmp = (uint82[i] << 16) + (uint82[i + 1] << 8) + uint82[i + 2];
    output.push(tripletToBase643(tmp));
  }
  return output.join("");
}
function fromByteArray3(uint82) {
  if (!inited3) {
    init3();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk3(uint82, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup3[tmp >> 2];
    output += lookup3[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup3[tmp >> 10];
    output += lookup3[tmp >> 4 & 63];
    output += lookup3[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read3(buffer, offset3, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s2 = buffer[offset3 + i];
  i += d;
  e = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset3 + i], i += d, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer[offset3 + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
}
function write5(buffer, value2, offset3, isLE, mLen, nBytes) {
  var e, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e)) < 1) {
      e--;
      c2 *= 2;
    }
    if (e + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e++;
      c2 /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset3 + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer[offset3 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset3 + i - d] |= s2 * 128;
}
var toString5 = {}.toString;
var isArray3 = Array.isArray || function(arr) {
  return toString5.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES3 = 50;
Buffer4.TYPED_ARRAY_SUPPORT = global$13.TYPED_ARRAY_SUPPORT !== void 0 ? global$13.TYPED_ARRAY_SUPPORT : true;
kMaxLength3();
function kMaxLength3() {
  return Buffer4.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer3(that, length4) {
  if (kMaxLength3() < length4) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length4);
    that.__proto__ = Buffer4.prototype;
  } else {
    if (that === null) {
      that = new Buffer4(length4);
    }
    that.length = length4;
  }
  return that;
}
function Buffer4(arg, encodingOrOffset, length4) {
  if (!Buffer4.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer4)) {
    return new Buffer4(arg, encodingOrOffset, length4);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe3(this, arg);
  }
  return from3(this, arg, encodingOrOffset, length4);
}
Buffer4.poolSize = 8192;
Buffer4._augment = function(arr) {
  arr.__proto__ = Buffer4.prototype;
  return arr;
};
function from3(that, value2, encodingOrOffset, length4) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer3(that, value2, encodingOrOffset, length4);
  }
  if (typeof value2 === "string") {
    return fromString3(that, value2, encodingOrOffset);
  }
  return fromObject3(that, value2);
}
Buffer4.from = function(value2, encodingOrOffset, length4) {
  return from3(null, value2, encodingOrOffset, length4);
};
if (Buffer4.TYPED_ARRAY_SUPPORT) {
  Buffer4.prototype.__proto__ = Uint8Array.prototype;
  Buffer4.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer4[Symbol.species] === Buffer4) ;
}
function assertSize3(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc3(that, size, fill5, encoding) {
  assertSize3(size);
  if (size <= 0) {
    return createBuffer3(that, size);
  }
  if (fill5 !== void 0) {
    return typeof encoding === "string" ? createBuffer3(that, size).fill(fill5, encoding) : createBuffer3(that, size).fill(fill5);
  }
  return createBuffer3(that, size);
}
Buffer4.alloc = function(size, fill5, encoding) {
  return alloc3(null, size, fill5, encoding);
};
function allocUnsafe3(that, size) {
  assertSize3(size);
  that = createBuffer3(that, size < 0 ? 0 : checked3(size) | 0);
  if (!Buffer4.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
Buffer4.allocUnsafe = function(size) {
  return allocUnsafe3(null, size);
};
Buffer4.allocUnsafeSlow = function(size) {
  return allocUnsafe3(null, size);
};
function fromString3(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer4.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length4 = byteLength4(string, encoding) | 0;
  that = createBuffer3(that, length4);
  var actual = that.write(string, encoding);
  if (actual !== length4) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike3(that, array) {
  var length4 = array.length < 0 ? 0 : checked3(array.length) | 0;
  that = createBuffer3(that, length4);
  for (var i = 0; i < length4; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer3(that, array, byteOffset, length4) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length4 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length4 === void 0) {
    array = new Uint8Array(array);
  } else if (length4 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length4);
  }
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer4.prototype;
  } else {
    that = fromArrayLike3(that, array);
  }
  return that;
}
function fromObject3(that, obj) {
  if (internalIsBuffer3(obj)) {
    var len = checked3(obj.length) | 0;
    that = createBuffer3(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan3(obj.length)) {
        return createBuffer3(that, 0);
      }
      return fromArrayLike3(that, obj);
    }
    if (obj.type === "Buffer" && isArray3(obj.data)) {
      return fromArrayLike3(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked3(length4) {
  if (length4 >= kMaxLength3()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength3().toString(16) + " bytes");
  }
  return length4 | 0;
}
Buffer4.isBuffer = isBuffer3;
function internalIsBuffer3(b) {
  return !!(b != null && b._isBuffer);
}
Buffer4.compare = function compare7(a2, b) {
  if (!internalIsBuffer3(a2) || !internalIsBuffer3(b)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a2 === b) return 0;
  var x = a2.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a2[i] !== b[i]) {
      x = a2[i];
      y = b[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer4.isEncoding = function isEncoding3(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer4.concat = function concat5(list, length4) {
  if (!isArray3(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer4.alloc(0);
  }
  var i;
  if (length4 === void 0) {
    length4 = 0;
    for (i = 0; i < list.length; ++i) {
      length4 += list[i].length;
    }
  }
  var buffer = Buffer4.allocUnsafe(length4);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer3(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength4(string, encoding) {
  if (internalIsBuffer3(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0) return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes3(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes3(string).length;
      default:
        if (loweredCase) return utf8ToBytes3(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer4.byteLength = byteLength4;
function slowToString3(encoding, start3, end3) {
  var loweredCase = false;
  if (start3 === void 0 || start3 < 0) {
    start3 = 0;
  }
  if (start3 > this.length) {
    return "";
  }
  if (end3 === void 0 || end3 > this.length) {
    end3 = this.length;
  }
  if (end3 <= 0) {
    return "";
  }
  end3 >>>= 0;
  start3 >>>= 0;
  if (end3 <= start3) {
    return "";
  }
  if (!encoding) encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice3(this, start3, end3);
      case "utf8":
      case "utf-8":
        return utf8Slice3(this, start3, end3);
      case "ascii":
        return asciiSlice3(this, start3, end3);
      case "latin1":
      case "binary":
        return latin1Slice3(this, start3, end3);
      case "base64":
        return base64Slice3(this, start3, end3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice3(this, start3, end3);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer4.prototype._isBuffer = true;
function swap3(b, n, m2) {
  var i = b[n];
  b[n] = b[m2];
  b[m2] = i;
}
Buffer4.prototype.swap16 = function swap163() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i = 0; i < len; i += 2) {
    swap3(this, i, i + 1);
  }
  return this;
};
Buffer4.prototype.swap32 = function swap323() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i = 0; i < len; i += 4) {
    swap3(this, i, i + 3);
    swap3(this, i + 1, i + 2);
  }
  return this;
};
Buffer4.prototype.swap64 = function swap643() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i = 0; i < len; i += 8) {
    swap3(this, i, i + 7);
    swap3(this, i + 1, i + 6);
    swap3(this, i + 2, i + 5);
    swap3(this, i + 3, i + 4);
  }
  return this;
};
Buffer4.prototype.toString = function toString6() {
  var length4 = this.length | 0;
  if (length4 === 0) return "";
  if (arguments.length === 0) return utf8Slice3(this, 0, length4);
  return slowToString3.apply(this, arguments);
};
Buffer4.prototype.equals = function equals3(b) {
  if (!internalIsBuffer3(b)) throw new TypeError("Argument must be a Buffer");
  if (this === b) return true;
  return Buffer4.compare(this, b) === 0;
};
Buffer4.prototype.inspect = function inspect5() {
  var str = "";
  var max3 = INSPECT_MAX_BYTES3;
  if (this.length > 0) {
    str = this.toString("hex", 0, max3).match(/.{2}/g).join(" ");
    if (this.length > max3) str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer4.prototype.compare = function compare8(target, start3, end3, thisStart, thisEnd) {
  if (!internalIsBuffer3(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start3 === void 0) {
    start3 = 0;
  }
  if (end3 === void 0) {
    end3 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start3 < 0 || end3 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start3 >= end3) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start3 >= end3) {
    return 1;
  }
  start3 >>>= 0;
  end3 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end3 - start3;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start3, end3);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
function bidirectionalIndexOf3(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1;
  }
  if (typeof val === "string") {
    val = Buffer4.from(val, encoding);
  }
  if (internalIsBuffer3(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf3(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer4.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf3(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf3(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read4(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read4(arr, i) === read4(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read4(arr, i + j) !== read4(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer4.prototype.includes = function includes4(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer4.prototype.indexOf = function indexOf5(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, true);
};
Buffer4.prototype.lastIndexOf = function lastIndexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, false);
};
function hexWrite3(buf, string, offset3, length4) {
  offset3 = Number(offset3) || 0;
  var remaining = buf.length - offset3;
  if (!length4) {
    length4 = remaining;
  } else {
    length4 = Number(length4);
    if (length4 > remaining) {
      length4 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
  if (length4 > strLen / 2) {
    length4 = strLen / 2;
  }
  for (var i = 0; i < length4; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset3 + i] = parsed;
  }
  return i;
}
function utf8Write3(buf, string, offset3, length4) {
  return blitBuffer3(utf8ToBytes3(string, buf.length - offset3), buf, offset3, length4);
}
function asciiWrite3(buf, string, offset3, length4) {
  return blitBuffer3(asciiToBytes3(string), buf, offset3, length4);
}
function latin1Write3(buf, string, offset3, length4) {
  return asciiWrite3(buf, string, offset3, length4);
}
function base64Write3(buf, string, offset3, length4) {
  return blitBuffer3(base64ToBytes3(string), buf, offset3, length4);
}
function ucs2Write3(buf, string, offset3, length4) {
  return blitBuffer3(utf16leToBytes3(string, buf.length - offset3), buf, offset3, length4);
}
Buffer4.prototype.write = function write6(string, offset3, length4, encoding) {
  if (offset3 === void 0) {
    encoding = "utf8";
    length4 = this.length;
    offset3 = 0;
  } else if (length4 === void 0 && typeof offset3 === "string") {
    encoding = offset3;
    length4 = this.length;
    offset3 = 0;
  } else if (isFinite(offset3)) {
    offset3 = offset3 | 0;
    if (isFinite(length4)) {
      length4 = length4 | 0;
      if (encoding === void 0) encoding = "utf8";
    } else {
      encoding = length4;
      length4 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset3;
  if (length4 === void 0 || length4 > remaining) length4 = remaining;
  if (string.length > 0 && (length4 < 0 || offset3 < 0) || offset3 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding) encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite3(this, string, offset3, length4);
      case "utf8":
      case "utf-8":
        return utf8Write3(this, string, offset3, length4);
      case "ascii":
        return asciiWrite3(this, string, offset3, length4);
      case "latin1":
      case "binary":
        return latin1Write3(this, string, offset3, length4);
      case "base64":
        return base64Write3(this, string, offset3, length4);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write3(this, string, offset3, length4);
      default:
        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer4.prototype.toJSON = function toJSON3() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice3(buf, start3, end3) {
  if (start3 === 0 && end3 === buf.length) {
    return fromByteArray3(buf);
  } else {
    return fromByteArray3(buf.slice(start3, end3));
  }
}
function utf8Slice3(buf, start3, end3) {
  end3 = Math.min(buf.length, end3);
  var res = [];
  var i = start3;
  while (i < end3) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end3) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray3(res);
}
var MAX_ARGUMENTS_LENGTH3 = 4096;
function decodeCodePointsArray3(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH3) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH3)
    );
  }
  return res;
}
function asciiSlice3(buf, start3, end3) {
  var ret = "";
  end3 = Math.min(buf.length, end3);
  for (var i = start3; i < end3; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice3(buf, start3, end3) {
  var ret = "";
  end3 = Math.min(buf.length, end3);
  for (var i = start3; i < end3; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice3(buf, start3, end3) {
  var len = buf.length;
  if (!start3 || start3 < 0) start3 = 0;
  if (!end3 || end3 < 0 || end3 > len) end3 = len;
  var out = "";
  for (var i = start3; i < end3; ++i) {
    out += toHex4(buf[i]);
  }
  return out;
}
function utf16leSlice3(buf, start3, end3) {
  var bytes = buf.slice(start3, end3);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer4.prototype.slice = function slice7(start3, end3) {
  var len = this.length;
  start3 = ~~start3;
  end3 = end3 === void 0 ? len : ~~end3;
  if (start3 < 0) {
    start3 += len;
    if (start3 < 0) start3 = 0;
  } else if (start3 > len) {
    start3 = len;
  }
  if (end3 < 0) {
    end3 += len;
    if (end3 < 0) end3 = 0;
  } else if (end3 > len) {
    end3 = len;
  }
  if (end3 < start3) end3 = start3;
  var newBuf;
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start3, end3);
    newBuf.__proto__ = Buffer4.prototype;
  } else {
    var sliceLen = end3 - start3;
    newBuf = new Buffer4(sliceLen, void 0);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start3];
    }
  }
  return newBuf;
};
function checkOffset3(offset3, ext, length4) {
  if (offset3 % 1 !== 0 || offset3 < 0) throw new RangeError("offset is not uint");
  if (offset3 + ext > length4) throw new RangeError("Trying to access beyond buffer length");
}
Buffer4.prototype.readUIntLE = function readUIntLE3(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset3(offset3, byteLength5, this.length);
  var val = this[offset3];
  var mul = 1;
  var i = 0;
  while (++i < byteLength5 && (mul *= 256)) {
    val += this[offset3 + i] * mul;
  }
  return val;
};
Buffer4.prototype.readUIntBE = function readUIntBE3(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset3(offset3, byteLength5, this.length);
  }
  var val = this[offset3 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset3 + --byteLength5] * mul;
  }
  return val;
};
Buffer4.prototype.readUInt8 = function readUInt84(offset3, noAssert) {
  if (!noAssert) checkOffset3(offset3, 1, this.length);
  return this[offset3];
};
Buffer4.prototype.readUInt16LE = function readUInt16LE4(offset3, noAssert) {
  if (!noAssert) checkOffset3(offset3, 2, this.length);
  return this[offset3] | this[offset3 + 1] << 8;
};
Buffer4.prototype.readUInt16BE = function readUInt16BE4(offset3, noAssert) {
  if (!noAssert) checkOffset3(offset3, 2, this.length);
  return this[offset3] << 8 | this[offset3 + 1];
};
Buffer4.prototype.readUInt32LE = function readUInt32LE4(offset3, noAssert) {
  if (!noAssert) checkOffset3(offset3, 4, this.length);
  return (this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16) + this[offset3 + 3] * 16777216;
};
Buffer4.prototype.readUInt32BE = function readUInt32BE4(offset3, noAssert) {
  if (!noAssert) checkOffset3(offset3, 4, this.length);
  return this[offset3] * 16777216 + (this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3]);
};
Buffer4.prototype.readIntLE = function readIntLE3(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset3(offset3, byteLength5, this.length);
  var val = this[offset3];
  var mul = 1;
  var i = 0;
  while (++i < byteLength5 && (mul *= 256)) {
    val += this[offset3 + i] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer4.prototype.readIntBE = function readIntBE3(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) checkOffset3(offset3, byteLength5, this.length);
  var i = byteLength5;
  var mul = 1;
  var val = this[offset3 + --i];
  while (i > 0 && (mul *= 256)) {
    val += this[offset3 + --i] * mul;
  }
  mul *= 128;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer4.prototype.readInt8 = function readInt83(offset3, noAssert) {
  if (!noAssert) checkOffset3(offset3, 1, this.length);
  if (!(this[offset3] & 128)) return this[offset3];
  return (255 - this[offset3] + 1) * -1;
};
Buffer4.prototype.readInt16LE = function readInt16LE3(offset3, noAssert) {
  if (!noAssert) checkOffset3(offset3, 2, this.length);
  var val = this[offset3] | this[offset3 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer4.prototype.readInt16BE = function readInt16BE3(offset3, noAssert) {
  if (!noAssert) checkOffset3(offset3, 2, this.length);
  var val = this[offset3 + 1] | this[offset3] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer4.prototype.readInt32LE = function readInt32LE3(offset3, noAssert) {
  if (!noAssert) checkOffset3(offset3, 4, this.length);
  return this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16 | this[offset3 + 3] << 24;
};
Buffer4.prototype.readInt32BE = function readInt32BE3(offset3, noAssert) {
  if (!noAssert) checkOffset3(offset3, 4, this.length);
  return this[offset3] << 24 | this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3];
};
Buffer4.prototype.readFloatLE = function readFloatLE3(offset3, noAssert) {
  if (!noAssert) checkOffset3(offset3, 4, this.length);
  return read3(this, offset3, true, 23, 4);
};
Buffer4.prototype.readFloatBE = function readFloatBE3(offset3, noAssert) {
  if (!noAssert) checkOffset3(offset3, 4, this.length);
  return read3(this, offset3, false, 23, 4);
};
Buffer4.prototype.readDoubleLE = function readDoubleLE3(offset3, noAssert) {
  if (!noAssert) checkOffset3(offset3, 8, this.length);
  return read3(this, offset3, true, 52, 8);
};
Buffer4.prototype.readDoubleBE = function readDoubleBE3(offset3, noAssert) {
  if (!noAssert) checkOffset3(offset3, 8, this.length);
  return read3(this, offset3, false, 52, 8);
};
function checkInt3(buf, value2, offset3, ext, max3, min3) {
  if (!internalIsBuffer3(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max3 || value2 < min3) throw new RangeError('"value" argument is out of bounds');
  if (offset3 + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer4.prototype.writeUIntLE = function writeUIntLE3(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt3(this, value2, offset3, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset3] = value2 & 255;
  while (++i < byteLength5 && (mul *= 256)) {
    this[offset3 + i] = value2 / mul & 255;
  }
  return offset3 + byteLength5;
};
Buffer4.prototype.writeUIntBE = function writeUIntBE3(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt3(this, value2, offset3, byteLength5, maxBytes, 0);
  }
  var i = byteLength5 - 1;
  var mul = 1;
  this[offset3 + i] = value2 & 255;
  while (--i >= 0 && (mul *= 256)) {
    this[offset3 + i] = value2 / mul & 255;
  }
  return offset3 + byteLength5;
};
Buffer4.prototype.writeUInt8 = function writeUInt83(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt3(this, value2, offset3, 1, 255, 0);
  if (!Buffer4.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  this[offset3] = value2 & 255;
  return offset3 + 1;
};
function objectWriteUInt163(buf, value2, offset3, littleEndian) {
  if (value2 < 0) value2 = 65535 + value2 + 1;
  for (var i = 0, j = Math.min(buf.length - offset3, 2); i < j; ++i) {
    buf[offset3 + i] = (value2 & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer4.prototype.writeUInt16LE = function writeUInt16LE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt3(this, value2, offset3, 2, 65535, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt163(this, value2, offset3, true);
  }
  return offset3 + 2;
};
Buffer4.prototype.writeUInt16BE = function writeUInt16BE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt3(this, value2, offset3, 2, 65535, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
  } else {
    objectWriteUInt163(this, value2, offset3, false);
  }
  return offset3 + 2;
};
function objectWriteUInt323(buf, value2, offset3, littleEndian) {
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  for (var i = 0, j = Math.min(buf.length - offset3, 4); i < j; ++i) {
    buf[offset3 + i] = value2 >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
Buffer4.prototype.writeUInt32LE = function writeUInt32LE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt3(this, value2, offset3, 4, 4294967295, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3 + 3] = value2 >>> 24;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset3, true);
  }
  return offset3 + 4;
};
Buffer4.prototype.writeUInt32BE = function writeUInt32BE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt3(this, value2, offset3, 4, 4294967295, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset3, false);
  }
  return offset3 + 4;
};
Buffer4.prototype.writeIntLE = function writeIntLE3(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt3(this, value2, offset3, byteLength5, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset3] = value2 & 255;
  while (++i < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset3 + i - 1] !== 0) {
      sub = 1;
    }
    this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
  }
  return offset3 + byteLength5;
};
Buffer4.prototype.writeIntBE = function writeIntBE3(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt3(this, value2, offset3, byteLength5, limit - 1, -limit);
  }
  var i = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset3 + i] = value2 & 255;
  while (--i >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset3 + i + 1] !== 0) {
      sub = 1;
    }
    this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
  }
  return offset3 + byteLength5;
};
Buffer4.prototype.writeInt8 = function writeInt83(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt3(this, value2, offset3, 1, 127, -128);
  if (!Buffer4.TYPED_ARRAY_SUPPORT) value2 = Math.floor(value2);
  if (value2 < 0) value2 = 255 + value2 + 1;
  this[offset3] = value2 & 255;
  return offset3 + 1;
};
Buffer4.prototype.writeInt16LE = function writeInt16LE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt3(this, value2, offset3, 2, 32767, -32768);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt163(this, value2, offset3, true);
  }
  return offset3 + 2;
};
Buffer4.prototype.writeInt16BE = function writeInt16BE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt3(this, value2, offset3, 2, 32767, -32768);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
  } else {
    objectWriteUInt163(this, value2, offset3, false);
  }
  return offset3 + 2;
};
Buffer4.prototype.writeInt32LE = function writeInt32LE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt3(this, value2, offset3, 4, 2147483647, -2147483648);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt323(this, value2, offset3, true);
  }
  return offset3 + 4;
};
Buffer4.prototype.writeInt32BE = function writeInt32BE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) checkInt3(this, value2, offset3, 4, 2147483647, -2147483648);
  if (value2 < 0) value2 = 4294967295 + value2 + 1;
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset3, false);
  }
  return offset3 + 4;
};
function checkIEEE7543(buf, value2, offset3, ext, max3, min3) {
  if (offset3 + ext > buf.length) throw new RangeError("Index out of range");
  if (offset3 < 0) throw new RangeError("Index out of range");
}
function writeFloat3(buf, value2, offset3, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7543(buf, value2, offset3, 4);
  }
  write5(buf, value2, offset3, littleEndian, 23, 4);
  return offset3 + 4;
}
Buffer4.prototype.writeFloatLE = function writeFloatLE3(value2, offset3, noAssert) {
  return writeFloat3(this, value2, offset3, true, noAssert);
};
Buffer4.prototype.writeFloatBE = function writeFloatBE3(value2, offset3, noAssert) {
  return writeFloat3(this, value2, offset3, false, noAssert);
};
function writeDouble3(buf, value2, offset3, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7543(buf, value2, offset3, 8);
  }
  write5(buf, value2, offset3, littleEndian, 52, 8);
  return offset3 + 8;
}
Buffer4.prototype.writeDoubleLE = function writeDoubleLE3(value2, offset3, noAssert) {
  return writeDouble3(this, value2, offset3, true, noAssert);
};
Buffer4.prototype.writeDoubleBE = function writeDoubleBE3(value2, offset3, noAssert) {
  return writeDouble3(this, value2, offset3, false, noAssert);
};
Buffer4.prototype.copy = function copy5(target, targetStart, start3, end3) {
  if (!start3) start3 = 0;
  if (!end3 && end3 !== 0) end3 = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end3 > 0 && end3 < start3) end3 = start3;
  if (end3 === start3) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start3 < 0 || start3 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (end3 < 0) throw new RangeError("sourceEnd out of bounds");
  if (end3 > this.length) end3 = this.length;
  if (target.length - targetStart < end3 - start3) {
    end3 = target.length - targetStart + start3;
  }
  var len = end3 - start3;
  var i;
  if (this === target && start3 < targetStart && targetStart < end3) {
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start3];
    }
  } else if (len < 1e3 || !Buffer4.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start3];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start3, start3 + len),
      targetStart
    );
  }
  return len;
};
Buffer4.prototype.fill = function fill4(val, start3, end3, encoding) {
  if (typeof val === "string") {
    if (typeof start3 === "string") {
      encoding = start3;
      start3 = 0;
      end3 = this.length;
    } else if (typeof end3 === "string") {
      encoding = end3;
      end3 = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start3 < 0 || this.length < start3 || this.length < end3) {
    throw new RangeError("Out of range index");
  }
  if (end3 <= start3) {
    return this;
  }
  start3 = start3 >>> 0;
  end3 = end3 === void 0 ? this.length : end3 >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === "number") {
    for (i = start3; i < end3; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer3(val) ? val : utf8ToBytes3(new Buffer4(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end3 - start3; ++i) {
      this[i + start3] = bytes[i % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE3 = /[^+\/0-9A-Za-z-_]/g;
function base64clean3(str) {
  str = stringtrim3(str).replace(INVALID_BASE64_RE3, "");
  if (str.length < 2) return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim3(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex4(n) {
  if (n < 16) return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes3(string, units) {
  units = units || Infinity;
  var codePoint;
  var length4 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length4; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length4) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0) break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0) break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0) break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes3(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes3(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c2 = str.charCodeAt(i);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes3(str) {
  return toByteArray3(base64clean3(str));
}
function blitBuffer3(src, dst, offset3, length4) {
  for (var i = 0; i < length4; ++i) {
    if (i + offset3 >= dst.length || i >= src.length) break;
    dst[i + offset3] = src[i];
  }
  return i;
}
function isnan3(val) {
  return val !== val;
}
function isBuffer3(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer3(obj) || isSlowBuffer3(obj));
}
function isFastBuffer3(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer3(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer3(obj.slice(0, 0));
}
PNG.isValid = function isValid(data2) {
  try {
    return !!new PNG(data2);
  } catch (e) {
    return false;
  }
};
var JPEG3 = function JPEG4(data2) {
  this.data = null;
  this.width = null;
  this.height = null;
  this.data = data2;
  if (data2.readUInt16BE(0) !== 65496) {
    throw new Error("SOI not found in JPEG");
  }
  var markers = src_default.decode(this.data);
  for (var i = 0; i < markers.length; i += 1) {
    var marker = markers[i];
    if (marker.name === "EXIF" && marker.entries.orientation) {
      this.orientation = marker.entries.orientation;
    }
    if (marker.name === "SOF") {
      this.width || (this.width = marker.width);
      this.height || (this.height = marker.height);
    }
  }
  if (this.orientation > 4) {
    var _ref = [this.height, this.width];
    this.width = _ref[0];
    this.height = _ref[1];
  }
};
JPEG3.isValid = function(data2) {
  return data2 && Buffer4.isBuffer(data2) && data2.readUInt16BE(0) === 65496;
};
var createCache = function createCache2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$limit = _ref.limit, limit = _ref$limit === void 0 ? 100 : _ref$limit;
  var cache2 = {};
  var keys2 = [];
  return {
    get: function get16(key) {
      return cache2[key];
    },
    set: function set5(key, value2) {
      keys2.push(key);
      if (keys2.length > limit) {
        delete cache2[keys2.shift()];
      }
      cache2[key] = value2;
    },
    reset: function reset() {
      cache2 = {};
      keys2 = [];
    },
    length: function length4() {
      return keys2.length;
    }
  };
};
var IMAGE_CACHE = createCache({
  limit: 30
});
var fetchRemoteFile = function() {
  var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(uri, options) {
    var response, buffer;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return (0, import_cross_fetch2.default)(uri, options);
        case 2:
          response = _context.sent;
          _context.next = 5;
          return response.buffer ? response.buffer() : response.arrayBuffer();
        case 5:
          buffer = _context.sent;
          return _context.abrupt("return", buffer.constructor.name === "Buffer" ? buffer : Buffer4.from(buffer));
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function fetchRemoteFile2(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var isValidFormat = function isValidFormat2(format3) {
  var lower = format3.toLowerCase();
  return lower === "jpg" || lower === "jpeg" || lower === "png";
};
var guessFormat = function guessFormat2(buffer) {
  var format3;
  if (JPEG3.isValid(buffer)) {
    format3 = "jpg";
  } else if (PNG.isValid(buffer)) {
    format3 = "png";
  }
  return format3;
};
var isCompatibleBase64 = function isCompatibleBase642(_ref2) {
  var uri = _ref2.uri;
  return /^data:image\/[a-zA-Z]*;base64,[^"]*/g.test(uri);
};
function getImage(body, extension) {
  switch (extension.toLowerCase()) {
    case "jpg":
    case "jpeg":
      return new JPEG3(body);
    case "png":
      return new PNG(body);
    default:
      return null;
  }
}
var resolveBase64Image = function resolveBase64Image2(_ref3) {
  var uri = _ref3.uri;
  var match = /^data:image\/([a-zA-Z]*);base64,([^"]*)/g.exec(uri);
  var format3 = match[1];
  var data2 = match[2];
  if (!isValidFormat(format3)) {
    throw new Error("Base64 image invalid format: " + format3);
  }
  return new Promise(function(resolve3) {
    return resolve3(getImage(Buffer4.from(data2, "base64"), format3));
  });
};
var resolveImageFromData = function resolveImageFromData2(src) {
  if (src.data && src.format) {
    return new Promise(function(resolve3) {
      return resolve3(getImage(src.data, src.format));
    });
  }
  throw new Error("Invalid data given for local file: " + JSON.stringify(src));
};
var resolveBufferImage = function resolveBufferImage2(buffer) {
  var format3 = guessFormat(buffer);
  if (format3) {
    return new Promise(function(resolve3) {
      return resolve3(getImage(buffer, format3));
    });
  }
  return Promise.resolve();
};
var resolveBlobImage = function() {
  var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(blob) {
    var type2, arrayBuffer, _buffer, format3, buffer;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          type2 = blob.type;
          if (!(!type2 || type2 === "application/octet-stream")) {
            _context2.next = 7;
            break;
          }
          _context2.next = 4;
          return blob.arrayBuffer();
        case 4:
          arrayBuffer = _context2.sent;
          _buffer = Buffer4.from(arrayBuffer);
          return _context2.abrupt("return", resolveBufferImage(_buffer));
        case 7:
          if (type2.startsWith("image/")) {
            _context2.next = 9;
            break;
          }
          throw new Error("Invalid blob type: " + type2);
        case 9:
          format3 = type2.replace("image/", "");
          if (isValidFormat(format3)) {
            _context2.next = 12;
            break;
          }
          throw new Error("Invalid blob type: " + type2);
        case 12:
          _context2.next = 14;
          return blob.arrayBuffer();
        case 14:
          buffer = _context2.sent;
          return _context2.abrupt("return", getImage(Buffer4.from(buffer), format3));
        case 16:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function resolveBlobImage2(_x3) {
    return _ref4.apply(this, arguments);
  };
}();
var getImageFormat = function getImageFormat2(body) {
  var isPng = body[0] === 137 && body[1] === 80 && body[2] === 78 && body[3] === 71 && body[4] === 13 && body[5] === 10 && body[6] === 26 && body[7] === 10;
  var isJpg = body[0] === 255 && body[1] === 216 && body[2] === 255;
  var extension = "";
  if (isPng) {
    extension = "png";
  } else if (isJpg) {
    extension = "jpg";
  } else {
    throw new Error("Not valid image extension");
  }
  return extension;
};
var resolveImageFromUrl = function() {
  var _ref5 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(src) {
    var uri, body, headers, _src$method, method, credentials, data2, extension;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          uri = src.uri, body = src.body, headers = src.headers, _src$method = src.method, method = _src$method === void 0 ? "GET" : _src$method, credentials = src.credentials;
          {
            _context3.next = 7;
            break;
          }
        case 4:
          _context3.t0 = _context3.sent;
          _context3.next = 10;
          break;
        case 7:
          _context3.next = 9;
          return fetchRemoteFile(uri, {
            body,
            headers,
            method,
            credentials
          });
        case 9:
          _context3.t0 = _context3.sent;
        case 10:
          data2 = _context3.t0;
          extension = getImageFormat(data2);
          return _context3.abrupt("return", getImage(data2, extension));
        case 13:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function resolveImageFromUrl2(_x4) {
    return _ref5.apply(this, arguments);
  };
}();
var resolveImage = function resolveImage2(src, _temp) {
  var _ref6 = _temp === void 0 ? {} : _temp, _ref6$cache = _ref6.cache, cache2 = _ref6$cache === void 0 ? true : _ref6$cache;
  var image2;
  var cacheKey = src.data ? src.data.toString() : src.uri;
  if (typeof Blob !== "undefined" && src instanceof Blob) {
    image2 = resolveBlobImage(src);
  } else if (Buffer4.isBuffer(src)) {
    image2 = resolveBufferImage(src);
  } else if (cache2 && IMAGE_CACHE.get(cacheKey)) {
    return IMAGE_CACHE.get(cacheKey);
  } else if (isCompatibleBase64(src)) {
    image2 = resolveBase64Image(src);
  } else if (typeof src === "object" && src.data) {
    image2 = resolveImageFromData(src);
  } else {
    image2 = resolveImageFromUrl(src);
  }
  if (!image2) {
    throw new Error("Cannot resolve image");
  }
  if (cache2) {
    IMAGE_CACHE.set(cacheKey, image2);
  }
  return image2;
};

// ../../.yarn/cache/@react-pdf-layout-npm-3.12.1-67178ab492-9dce683d17.zip/node_modules/@react-pdf/layout/lib/index.js
var fromFragments3 = function fromFragments4(fragments) {
  var offset3 = 0;
  var string = "";
  var runs = [];
  fragments.forEach(function(fragment) {
    string += fragment.string;
    runs.push({
      start: offset3,
      end: offset3 + fragment.string.length,
      attributes: fragment.attributes || {}
    });
    offset3 += fragment.string.length;
  });
  return {
    string,
    runs
  };
};
var transformText = function transformText2(text2, transformation) {
  switch (transformation) {
    case "uppercase":
      return text2.toUpperCase();
    case "lowercase":
      return text2.toLowerCase();
    case "capitalize":
      return capitalize(text2);
    case "upperfirst":
      return upperFirst(text2);
    default:
      return text2;
  }
};
var StandardFont2 = function() {
  function StandardFont3(src) {
    this.name = src;
    this.src = PDFFont.open(null, src);
  }
  var _proto = StandardFont3.prototype;
  _proto.encode = function encode(str) {
    return this.src.encode(str);
  };
  _proto.layout = function layout2(str) {
    var _this = this;
    var _this$encode = this.encode(str), encoded = _this$encode[0], positions = _this$encode[1];
    return {
      positions,
      stringIndices: positions.map(function(_, i) {
        return i;
      }),
      glyphs: encoded.map(function(g, i) {
        var glyph = _this.getGlyph(parseInt(g, 16));
        glyph.advanceWidth = positions[i].advanceWidth;
        return glyph;
      })
    };
  };
  _proto.glyphForCodePoint = function glyphForCodePoint(codePoint) {
    var glyph = this.getGlyph(codePoint);
    glyph.advanceWidth = 400;
    return glyph;
  };
  _proto.getGlyph = function getGlyph(id) {
    return {
      id,
      _font: this.src,
      codePoints: [id],
      isLigature: false,
      name: this.src.font.characterToGlyph(id)
    };
  };
  _proto.hasGlyphForCodePoint = function hasGlyphForCodePoint(codePoint) {
    return this.src.font.characterToGlyph(codePoint) !== ".notdef";
  };
  _createClass(StandardFont3, [{
    key: "ascent",
    get: function get16() {
      return 900;
    }
    // Based on empirical observation
  }, {
    key: "capHeight",
    get: function get16() {
      switch (this.name) {
        case "Times-Roman":
        case "Times-Bold":
        case "Times-Italic":
        case "Times-BoldItalic":
          return 650;
        case "Courier":
        case "Courier-Bold":
        case "Courier-Oblique":
        case "Courier-BoldOblique":
          return 550;
        default:
          return 690;
      }
    }
    // Based on empirical observation
  }, {
    key: "xHeight",
    get: function get16() {
      switch (this.name) {
        case "Times-Roman":
        case "Times-Bold":
        case "Times-Italic":
        case "Times-BoldItalic":
          return 440;
        case "Courier":
        case "Courier-Bold":
        case "Courier-Oblique":
        case "Courier-BoldOblique":
          return 390;
        default:
          return 490;
      }
    }
    // Based on empirical observation
  }, {
    key: "descent",
    get: function get16() {
      switch (this.name) {
        case "Times-Roman":
        case "Times-Bold":
        case "Times-Italic":
        case "Times-BoldItalic":
          return -220;
        case "Courier":
        case "Courier-Bold":
        case "Courier-Oblique":
        case "Courier-BoldOblique":
          return -230;
        default:
          return -200;
      }
    }
  }, {
    key: "lineGap",
    get: function get16() {
      return 0;
    }
  }, {
    key: "unitsPerEm",
    get: function get16() {
      return 1e3;
    }
  }]);
  return StandardFont3;
}();
var fontCache = {};
var IGNORED_CODE_POINTS = [173];
var getFontSize = function getFontSize2(node) {
  return node.attributes.fontSize || 12;
};
var getOrCreateFont = function getOrCreateFont2(name2) {
  if (fontCache[name2]) return fontCache[name2];
  var font2 = new StandardFont2(name2);
  fontCache[name2] = font2;
  return font2;
};
var getFallbackFont = function getFallbackFont2() {
  return getOrCreateFont("Helvetica");
};
var pickFontFromFontStack = function pickFontFromFontStack2(codePoint, fontStack, lastFont) {
  var fontStackWithFallback = [].concat(fontStack, [getFallbackFont()]);
  if (lastFont) {
    fontStackWithFallback.unshift(lastFont);
  }
  for (var i = 0; i < fontStackWithFallback.length; i += 1) {
    var font2 = fontStackWithFallback[i];
    if (!IGNORED_CODE_POINTS.includes(codePoint) && font2 && font2.hasGlyphForCodePoint && font2.hasGlyphForCodePoint(codePoint)) {
      return font2;
    }
  }
  return getFallbackFont();
};
var fontSubstitution = function fontSubstitution2() {
  return function(_ref) {
    var string = _ref.string, runs = _ref.runs;
    var lastFont = null;
    var lastFontSize = null;
    var lastIndex = 0;
    var index2 = 0;
    var res = [];
    for (var i = 0; i < runs.length; i += 1) {
      var run = runs[i];
      var defaultFont = typeof run.attributes.font === "string" ? getOrCreateFont(run.attributes.font) : run.attributes.font;
      if (string.length === 0) {
        res.push({
          start: 0,
          end: 0,
          attributes: {
            font: defaultFont
          }
        });
        break;
      }
      var chars = string.slice(run.start, run.end);
      for (var j = 0; j < chars.length; j += 1) {
        var char = chars[j];
        var codePoint = char.codePointAt();
        var font2 = pickFontFromFontStack(codePoint, run.attributes.font, lastFont);
        var fontSize2 = getFontSize(run);
        if (font2 !== lastFont || fontSize2 !== lastFontSize || font2.unitsPerEm !== lastFont.unitsPerEm) {
          if (lastFont) {
            res.push({
              start: lastIndex,
              end: index2,
              attributes: {
                font: lastFont,
                scale: lastFontSize / lastFont.unitsPerEm
              }
            });
          }
          lastFont = font2;
          lastFontSize = fontSize2;
          lastIndex = index2;
        }
        index2 += char.length;
      }
    }
    if (lastIndex < string.length) {
      var _fontSize = getFontSize(last(runs));
      res.push({
        start: lastIndex,
        end: string.length,
        attributes: {
          font: lastFont,
          scale: _fontSize / lastFont.unitsPerEm
        }
      });
    }
    return {
      string,
      runs: res
    };
  };
};
var isTextInstance$4 = function isTextInstance(node) {
  return node.type === TextInstance;
};
var engines$1 = {
  bidi: bidiEngine,
  linebreaker,
  justification,
  textDecoration,
  scriptItemizer,
  wordHyphenation,
  fontSubstitution
};
var engine$1 = layoutEngine(engines$1);
var getFragments$1 = function getFragments(fontStore2, instance) {
  if (!instance) return [{
    string: ""
  }];
  var fragments = [];
  var _instance$props = instance.props, _instance$props$fill = _instance$props.fill, fill5 = _instance$props$fill === void 0 ? "black" : _instance$props$fill, _instance$props$fontF = _instance$props.fontFamily, fontFamily = _instance$props$fontF === void 0 ? "Helvetica" : _instance$props$fontF, fontWeight = _instance$props.fontWeight, fontStyle = _instance$props.fontStyle, _instance$props$fontS = _instance$props.fontSize, fontSize2 = _instance$props$fontS === void 0 ? 18 : _instance$props$fontS, textDecorationColor = _instance$props.textDecorationColor, textDecorationStyle = _instance$props.textDecorationStyle, textTransform = _instance$props.textTransform, opacity2 = _instance$props.opacity;
  var _textDecoration = instance.props.textDecoration;
  var obj = fontStore2 ? fontStore2.getFont({
    fontFamily,
    fontWeight,
    fontStyle
  }) : null;
  var font2 = obj ? obj.data : fontFamily;
  var attributes2 = {
    font: font2,
    opacity: opacity2,
    fontSize: fontSize2,
    color: fill5,
    underlineStyle: textDecorationStyle,
    underline: _textDecoration === "underline" || _textDecoration === "underline line-through" || _textDecoration === "line-through underline",
    underlineColor: textDecorationColor || fill5,
    strike: _textDecoration === "line-through" || _textDecoration === "underline line-through" || _textDecoration === "line-through underline",
    strikeStyle: textDecorationStyle,
    strikeColor: textDecorationColor || fill5
  };
  for (var i = 0; i < instance.children.length; i += 1) {
    var child = instance.children[i];
    if (isTextInstance$4(child)) {
      fragments.push({
        string: transformText(child.value, textTransform),
        attributes: attributes2
      });
    } else if (child) {
      fragments.push.apply(fragments, getFragments(child));
    }
  }
  return fragments;
};
var getAttributedString$1 = function getAttributedString(fontStore2, instance) {
  return fromFragments3(getFragments$1(fontStore2, instance));
};
var AlmostInfinity = 999999999999;
var shrinkWhitespaceFactor = {
  before: -0.5,
  after: -0.5
};
var layoutTspan = function layoutTspan2(fontStore2) {
  return function(node) {
    var _node$props, _node$props2;
    var attributedString = getAttributedString$1(fontStore2, node);
    var x = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.x) || 0;
    var y = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.y) || 0;
    var container = {
      x,
      y,
      width: AlmostInfinity,
      height: AlmostInfinity
    };
    var hyphenationCallback = node.props.hyphenationCallback || (fontStore2 === null || fontStore2 === void 0 ? void 0 : fontStore2.getHyphenationCallback()) || null;
    var layoutOptions = {
      hyphenationCallback,
      shrinkWhitespaceFactor
    };
    var lines = engine$1(attributedString, container, layoutOptions).flat();
    return Object.assign({}, node, {
      lines
    });
  };
};
var layoutText$1 = function layoutText(fontStore2, node) {
  if (!node.children) return node;
  var children = node.children.map(layoutTspan(fontStore2));
  return Object.assign({}, node, {
    children
  });
};
var isDefs = function isDefs2(node) {
  return node.type === Defs;
};
var getDefs = function getDefs2(node) {
  var children = node.children || [];
  var defs = children.find(isDefs) || {};
  var values = defs.children || [];
  return values.reduce(function(acc, value2) {
    var _value$props;
    var id = (_value$props = value2.props) === null || _value$props === void 0 ? void 0 : _value$props.id;
    if (id) acc[id] = value2;
    return acc;
  }, {});
};
var isNotDefs = function isNotDefs2(node) {
  return node.type !== Defs;
};
var detachDefs = function detachDefs2(node) {
  if (!node.children) return node;
  var children = node.children.filter(isNotDefs);
  return Object.assign({}, node, {
    children
  });
};
var URL_REGEX = /url\(['"]?#([^'"]+)['"]?\)/;
var replaceDef = function replaceDef2(defs, value2) {
  if (!value2) return void 0;
  if (!URL_REGEX.test(value2)) return value2;
  var match = value2.match(URL_REGEX);
  return defs[match[1]];
};
var parseNodeDefs = function parseNodeDefs2(defs) {
  return function(node) {
    var _node$props, _node$props2;
    var fill5 = replaceDef(defs, (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.fill);
    var clipPath3 = replaceDef(defs, (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.clipPath);
    var props = Object.assign({}, node.props, {
      fill: fill5,
      clipPath: clipPath3
    });
    var children = node.children ? node.children.map(parseNodeDefs2(defs)) : void 0;
    return Object.assign({}, node, {
      props,
      children
    });
  };
};
var parseDefs = function parseDefs2(root) {
  if (!root.children) return root;
  var defs = getDefs(root);
  var children = root.children.map(parseNodeDefs(defs));
  return Object.assign({}, root, {
    children
  });
};
var replaceDefs = function replaceDefs2(node) {
  return detachDefs(parseDefs(node));
};
var parseViewbox = function parseViewbox2(value2) {
  if (!value2) return null;
  var values = value2.split(/[,\s]+/).map(parseFloat);
  if (values.length !== 4) return null;
  return {
    minX: values[0],
    minY: values[1],
    maxX: values[2],
    maxY: values[3]
  };
};
var getContainer$1 = function getContainer(node) {
  var viewbox = parseViewbox(node.props.viewBox);
  if (viewbox) {
    return {
      width: viewbox.maxX,
      height: viewbox.maxY
    };
  }
  if (node.props.width && node.props.height) {
    return {
      width: parseFloat(node.props.width),
      height: parseFloat(node.props.height)
    };
  }
  return {
    width: 0,
    height: 0
  };
};
var SVG_INHERITED_PROPS = ["x", "y", "clipPath", "clipRule", "opacity", "fill", "fillOpacity", "fillRule", "stroke", "strokeLinecap", "strokeLinejoin", "strokeOpacity", "strokeWidth", "textAnchor", "dominantBaseline", "color", "fontFamily", "fontSize", "fontStyle", "fontWeight", "letterSpacing", "opacity", "textDecoration", "lineHeight", "textAlign", "visibility", "wordSpacing"];
var getInheritProps = function getInheritProps2(node) {
  var props = node.props || {};
  return pick(SVG_INHERITED_PROPS, props);
};
var inheritProps = function inheritProps2(node) {
  if (!node.children) return node;
  var inheritedProps = getInheritProps(node);
  var children = node.children.map(function(child) {
    var props = Object.assign({}, inheritedProps, child.props || {});
    var newChild = Object.assign({}, child, {
      props
    });
    return inheritProps2(newChild);
  });
  return Object.assign({}, node, {
    children
  });
};
var parseAspectRatio = function parseAspectRatio2(value2) {
  var match = value2.replace(/[\s\r\t\n]+/gm, " ").replace(/^defer\s/, "").split(" ");
  var align = match[0] || "xMidYMid";
  var meetOrSlice = match[1] || "meet";
  return {
    align,
    meetOrSlice
  };
};
var STYLE_PROPS = ["width", "height", "color", "stroke", "strokeWidth", "opacity", "fillOpacity", "strokeOpacity", "fill", "fillRule", "clipPath", "offset", "transform", "strokeLinejoin", "strokeLinecap", "strokeDasharray"];
var VERTICAL_PROPS = ["y", "y1", "y2", "height", "cy", "ry"];
var HORIZONTAL_PROPS = ["x", "x1", "x2", "width", "cx", "rx"];
var isType$3 = function isType(type2) {
  return function(node) {
    return node.type === type2;
  };
};
var isSvg$3 = isType$3(Svg);
var isText$5 = isType$3(Text);
var isTextInstance$3 = isType$3(TextInstance);
var transformPercent = function transformPercent2(container) {
  return function(props) {
    return mapValues(props, function(value2, key) {
      var match = matchPercent(value2);
      if (match && VERTICAL_PROPS.includes(key)) {
        return match.percent * container.height;
      }
      if (match && HORIZONTAL_PROPS.includes(key)) {
        return match.percent * container.width;
      }
      return value2;
    });
  };
};
var parsePercent = function parsePercent2(value2) {
  var match = matchPercent(value2);
  return match ? match.percent : parseFloat(value2);
};
var parseProps = function parseProps2(container) {
  return function(node) {
    var props = transformPercent(container)(node.props);
    props = evolve({
      x: parseFloat,
      x1: parseFloat,
      x2: parseFloat,
      y: parseFloat,
      y1: parseFloat,
      y2: parseFloat,
      r: parseFloat,
      rx: parseFloat,
      ry: parseFloat,
      cx: parseFloat,
      cy: parseFloat,
      width: parseFloat,
      height: parseFloat,
      offset: parsePercent,
      fill: transformColor,
      opacity: parsePercent,
      stroke: transformColor,
      stopOpacity: parsePercent,
      stopColor: transformColor,
      transform: processTransform
    }, props);
    return Object.assign({}, node, {
      props
    });
  };
};
var mergeStyles$1 = function mergeStyles3(node) {
  var style = node.style || {};
  var props = Object.assign({}, style, node.props);
  return Object.assign({}, node, {
    props
  });
};
var removeNoneValues = function removeNoneValues2(node) {
  var removeNone = function removeNone2(value2) {
    return value2 === "none" ? null : value2;
  };
  var props = mapValues(node.props, removeNone);
  return Object.assign({}, node, {
    props
  });
};
var pickStyleProps = function pickStyleProps2(node) {
  var props = node.props || {};
  var styleProps = pick(STYLE_PROPS, props);
  var style = Object.assign({}, styleProps, node.style || {});
  return Object.assign({}, node, {
    style
  });
};
var parseSvgProps = function parseSvgProps2(node) {
  var props = evolve({
    width: parseFloat,
    height: parseFloat,
    viewBox: parseViewbox,
    preserveAspectRatio: parseAspectRatio
  }, node.props);
  return Object.assign({}, node, {
    props
  });
};
var wrapBetweenTspan = function wrapBetweenTspan2(node) {
  return {
    type: Tspan,
    props: {},
    children: [node]
  };
};
var addMissingTspan = function addMissingTspan2(node) {
  if (!isText$5(node)) return node;
  if (!node.children) return node;
  var resolveChild = function resolveChild2(child) {
    return isTextInstance$3(child) ? wrapBetweenTspan(child) : child;
  };
  var children = node.children.map(resolveChild);
  return Object.assign({}, node, {
    children
  });
};
var parseText = function parseText2(fontStore2) {
  return function(node) {
    if (isText$5(node)) return layoutText$1(fontStore2, node);
    if (!node.children) return node;
    var children = node.children.map(parseText2(fontStore2));
    return Object.assign({}, node, {
      children
    });
  };
};
var resolveSvgNode = function resolveSvgNode2(container) {
  return compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1);
};
var resolveChildren = function resolveChildren2(container) {
  return function(node) {
    if (!node.children) return node;
    var resolveChild = compose(resolveChildren2(container), resolveSvgNode(container));
    var children = node.children.map(resolveChild);
    return Object.assign({}, node, {
      children
    });
  };
};
var resolveSvgRoot = function resolveSvgRoot2(node, fontStore2) {
  var container = getContainer$1(node);
  return compose(replaceDefs, parseText(fontStore2), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container))(node);
};
var resolveSvg = function resolveSvg2(node, fontStore2) {
  if (!node.children) return node;
  var resolveChild = function resolveChild2(child) {
    return resolveSvg2(child, fontStore2);
  };
  var root = isSvg$3(node) ? resolveSvgRoot(node, fontStore2) : node;
  var children = root.children.map(resolveChild);
  return Object.assign({}, root, {
    children
  });
};
var loadYoga2 = function() {
  var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
    var instance, config3, node;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return Yoga.loadYoga();
        case 2:
          instance = _context.sent;
          config3 = instance.Config.create();
          config3.setPointScaleFactor(0);
          node = {
            create: function create2() {
              return instance.Node.createWithConfig(config3);
            }
          };
          return _context.abrupt("return", {
            node
          });
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function loadYoga3() {
    return _ref.apply(this, arguments);
  };
}();
var resolveYoga = function() {
  var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(root) {
    var yoga;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return loadYoga2();
        case 2:
          yoga = _context.sent;
          return _context.abrupt("return", Object.assign({}, root, {
            yoga
          }));
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function resolveYoga2(_x) {
    return _ref.apply(this, arguments);
  };
}();
var getZIndex = function getZIndex2(node) {
  return node.style.zIndex;
};
var shouldSort = function shouldSort2(node) {
  return node.type !== Document && node.type !== Svg;
};
var sortZIndex = function sortZIndex2(a2, b) {
  var za = getZIndex(a2);
  var zb = getZIndex(b);
  if (!za && !zb) return 0;
  if (!za) return 1;
  if (!zb) return -1;
  return zb - za;
};
var resolveZIndex = function resolveZIndex2(node) {
  if (!node.children) return node;
  var sortedChildren = shouldSort(node) ? node.children.sort(sortZIndex) : node.children;
  var children = sortedChildren.map(resolveZIndex2);
  return Object.assign({}, node, {
    children
  });
};
var emojis = {};
var regex3 = emoji_regex_default();
var reflect = function reflect2(promise) {
  return function() {
    return promise.apply(void 0, arguments).then(function(v2) {
      return v2;
    }, function(e) {
      return e;
    });
  };
};
var makeFetchEmojiImage = function makeFetchEmojiImage2() {
  return reflect(resolveImage);
};
var _removeVariationSelectors = function _removeVariationSelectors2(x) {
  return x !== "";
};
var getCodePoints = function getCodePoints2(string, withVariationSelectors) {
  return Array.from(string).filter(withVariationSelectors ? function() {
    return true;
  } : _removeVariationSelectors).map(function(char) {
    return char.codePointAt(0).toString(16);
  }).join("-");
};
var buildEmojiUrl = function buildEmojiUrl2(emoji, source) {
  var url = source.url, format3 = source.format, builder = source.builder, withVariationSelectors = source.withVariationSelectors;
  if (typeof builder === "function") {
    return builder(getCodePoints(emoji, withVariationSelectors));
  }
  return "" + url + getCodePoints(emoji, withVariationSelectors) + "." + format3;
};
var fetchEmojis = function fetchEmojis2(string, source) {
  if (!source || !source.url && !source.builder) return [];
  var promises = [];
  Array.from(string.matchAll(regex3)).forEach(function(match) {
    var emoji = match[0];
    if (!emojis[emoji] || emojis[emoji].loading) {
      var emojiUrl = buildEmojiUrl(emoji, source);
      emojis[emoji] = {
        loading: true
      };
      var fetchEmojiImage = makeFetchEmojiImage();
      promises.push(fetchEmojiImage({
        uri: emojiUrl
      }).then(function(image2) {
        emojis[emoji].loading = false;
        emojis[emoji].data = image2.data;
      }));
    }
  });
  return promises;
};
var specialCases = ["", "", ""];
var embedEmojis = function embedEmojis2(fragments) {
  var result = [];
  var _loop = function _loop2() {
    var fragment = fragments[i];
    var lastIndex = 0;
    Array.from(fragment.string.matchAll(regex3)).forEach(function(match) {
      var index2 = match.index;
      var emoji = match[0];
      var isSpecialCase = specialCases.includes(emoji);
      var emojiSize = fragment.attributes.fontSize;
      var chunk = fragment.string.slice(lastIndex, index2 + match[0].length);
      if (emojis[emoji] && emojis[emoji].data) {
        result.push({
          string: chunk.replace(match, String.fromCharCode(65532)),
          attributes: _extends({}, fragment.attributes, {
            attachment: {
              width: emojiSize,
              height: emojiSize,
              yOffset: Math.floor(emojiSize * 0.1),
              image: emojis[emoji].data
            }
          })
        });
      } else if (isSpecialCase) {
        result.push({
          string: chunk,
          attributes: fragment.attributes
        });
      } else {
        result.push({
          string: chunk.replace(match, String.fromCharCode(0)),
          attributes: fragment.attributes
        });
      }
      lastIndex = index2 + emoji.length;
    });
    if (lastIndex < fragment.string.length) {
      result.push({
        string: fragment.string.slice(lastIndex),
        attributes: fragment.attributes
      });
    }
  };
  for (var i = 0; i < fragments.length; i += 1) {
    _loop();
  }
  return result;
};
var getSource = function getSource2(node) {
  var _node$props, _node$props2, _node$props3;
  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.src) || ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.source) || ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.href);
};
var resolveSource = function() {
  var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(src) {
    var source;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!(typeof src === "function")) {
            _context.next = 6;
            break;
          }
          _context.next = 3;
          return src();
        case 3:
          _context.t0 = _context.sent;
          _context.next = 9;
          break;
        case 6:
          _context.next = 8;
          return src;
        case 8:
          _context.t0 = _context.sent;
        case 9:
          source = _context.t0;
          return _context.abrupt("return", typeof source === "string" ? {
            uri: source
          } : source);
        case 11:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function resolveSource2(_x) {
    return _ref.apply(this, arguments);
  };
}();
var fetchImage = function() {
  var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(node) {
    var src, cache2, source;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          src = getSource(node);
          cache2 = node.props.cache;
          if (src) {
            _context.next = 5;
            break;
          }
          console.warn(false, 'Image should receive either a "src" or "source" prop');
          return _context.abrupt("return");
        case 5:
          _context.prev = 5;
          _context.next = 8;
          return resolveSource(src);
        case 8:
          source = _context.sent;
          if (source) {
            _context.next = 11;
            break;
          }
          throw new Error(`Image's "src" or "source" prop returned ` + source);
        case 11:
          _context.next = 13;
          return resolveImage(source, {
            cache: cache2
          });
        case 13:
          node.image = _context.sent;
          node.image.key = source.data ? source.data.toString() : source.uri;
          _context.next = 21;
          break;
        case 17:
          _context.prev = 17;
          _context.t0 = _context["catch"](5);
          node.image = {
            width: 0,
            height: 0,
            key: null
          };
          console.warn(_context.t0.message);
        case 21:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[5, 17]]);
  }));
  return function fetchImage2(_x) {
    return _ref.apply(this, arguments);
  };
}();
var isImage$2 = function isImage(node) {
  return node.type === Image;
};
var fetchAssets = function fetchAssets2(fontStore2, node) {
  var _node$children;
  var promises = [];
  var listToExplore = ((_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children.slice(0)) || [];
  var emojiSource = fontStore2 ? fontStore2.getEmojiSource() : null;
  while (listToExplore.length > 0) {
    var _n$style;
    var n = listToExplore.shift();
    if (isImage$2(n)) {
      promises.push(fetchImage(n));
    }
    if (fontStore2 && (_n$style = n.style) !== null && _n$style !== void 0 && _n$style.fontFamily) {
      promises.push(fontStore2.load(n.style));
    }
    if (typeof n === "string") {
      promises.push.apply(promises, fetchEmojis(n, emojiSource));
    }
    if (typeof n.value === "string") {
      promises.push.apply(promises, fetchEmojis(n.value, emojiSource));
    }
    if (n.children) {
      n.children.forEach(function(childNode) {
        listToExplore.push(childNode);
      });
    }
  }
  return promises;
};
var resolveAssets = function() {
  var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(node, fontStore2) {
    var promises;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          promises = fetchAssets(fontStore2, node);
          _context.next = 3;
          return Promise.all(promises);
        case 3:
          return _context.abrupt("return", node);
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function resolveAssets2(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var isLink$1 = function isLink(node) {
  return node.type === Link;
};
var DEFAULT_LINK_STYLES = {
  color: "blue",
  textDecoration: "underline"
};
var computeStyle = function computeStyle2(container, node) {
  var baseStyle = node.style;
  if (isLink$1(node)) {
    baseStyle = Array.isArray(node.style) ? [DEFAULT_LINK_STYLES].concat(node.style) : [DEFAULT_LINK_STYLES, node.style];
  }
  return resolveStyles(container, baseStyle);
};
var resolveNodeStyles = function resolveNodeStyles2(container) {
  return function(node) {
    var style = computeStyle(container, node);
    if (!node.children) return Object.assign({}, node, {
      style
    });
    var children = node.children.map(resolveNodeStyles2(container));
    return Object.assign({}, node, {
      style,
      children
    });
  };
};
var resolvePageStyles = function resolvePageStyles2(page) {
  var _page$props, _page$box, _page$box2, _page$props2;
  var dpi = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.dpi) || 72;
  var width = ((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.width) || page.style.width;
  var height5 = ((_page$box2 = page.box) === null || _page$box2 === void 0 ? void 0 : _page$box2.height) || page.style.height;
  var orientation = ((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.orientation) || "portrait";
  var container = {
    width,
    height: height5,
    orientation,
    dpi
  };
  return resolveNodeStyles(container)(page);
};
var resolveStyles3 = function resolveStyles4(root) {
  if (!root.children) return root;
  var children = root.children.map(resolvePageStyles);
  return Object.assign({}, root, {
    children
  });
};
var getTransformStyle = function getTransformStyle2(s2) {
  return function(node) {
    var _node$style, _node$style2;
    return isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style[s2]) ? "50%" : (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2[s2];
  };
};
var getOrigin = function getOrigin2(node) {
  if (!node.box) return {};
  var _node$box = node.box, left = _node$box.left, top = _node$box.top, width = _node$box.width, height5 = _node$box.height;
  var transformOriginX = getTransformStyle("transformOriginX")(node);
  var transformOriginY = getTransformStyle("transformOriginY")(node);
  var percentX = matchPercent(transformOriginX);
  var percentY = matchPercent(transformOriginY);
  var offsetX = percentX ? width * percentX.percent : transformOriginX;
  var offsetY = percentY ? height5 * percentY.percent : transformOriginY;
  return {
    left: left + offsetX,
    top: top + offsetY
  };
};
var resolveNodeOrigin = function resolveNodeOrigin2(node) {
  var origin = getOrigin(node);
  var newNode = Object.assign({}, node, {
    origin
  });
  if (!node.children) return newNode;
  var children = node.children.map(resolveNodeOrigin2);
  return Object.assign({}, newNode, {
    children
  });
};
var resolveOrigin = function resolveOrigin2(root) {
  if (!root.children) return root;
  var children = root.children.map(resolveNodeOrigin);
  return Object.assign({}, root, {
    children
  });
};
var getBookmarkValue = function getBookmarkValue2(title3) {
  return typeof title3 === "string" ? {
    title: title3,
    fit: false,
    expanded: false
  } : title3;
};
var resolveBookmarks = function resolveBookmarks2(node) {
  var refs = 0;
  var children = (node.children || []).slice(0);
  var listToExplore = children.map(function(value2) {
    return {
      value: value2,
      parent: null
    };
  });
  var _loop = function _loop2() {
    var _child$props;
    var element = listToExplore.shift();
    var child = element.value;
    var parent = element.parent;
    if ((_child$props = child.props) !== null && _child$props !== void 0 && _child$props.bookmark) {
      var _parent;
      var bookmark = getBookmarkValue(child.props.bookmark);
      var ref = refs++;
      var newHierarchy = _extends({
        ref,
        parent: (_parent = parent) === null || _parent === void 0 ? void 0 : _parent.ref
      }, bookmark);
      child.props.bookmark = newHierarchy;
      parent = newHierarchy;
    }
    if (child.children) {
      child.children.forEach(function(childNode) {
        listToExplore.push({
          value: childNode,
          parent
        });
      });
    }
  };
  while (listToExplore.length > 0) {
    _loop();
  }
  return node;
};
var VALID_ORIENTATIONS = ["portrait", "landscape"];
var getOrientation = function getOrientation2(page) {
  var _page$props;
  var value2 = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.orientation) || "portrait";
  return VALID_ORIENTATIONS.includes(value2) ? value2 : "portrait";
};
var isLandscape = function isLandscape2(page) {
  return getOrientation(page) === "landscape";
};
var PAGE_SIZES = {
  "4A0": [4767.87, 6740.79],
  "2A0": [3370.39, 4767.87],
  A0: [2383.94, 3370.39],
  A1: [1683.78, 2383.94],
  A2: [1190.55, 1683.78],
  A3: [841.89, 1190.55],
  A4: [595.28, 841.89],
  A5: [419.53, 595.28],
  A6: [297.64, 419.53],
  A7: [209.76, 297.64],
  A8: [147.4, 209.76],
  A9: [104.88, 147.4],
  A10: [73.7, 104.88],
  B0: [2834.65, 4008.19],
  B1: [2004.09, 2834.65],
  B2: [1417.32, 2004.09],
  B3: [1000.63, 1417.32],
  B4: [708.66, 1000.63],
  B5: [498.9, 708.66],
  B6: [354.33, 498.9],
  B7: [249.45, 354.33],
  B8: [175.75, 249.45],
  B9: [124.72, 175.75],
  B10: [87.87, 124.72],
  C0: [2599.37, 3676.54],
  C1: [1836.85, 2599.37],
  C2: [1298.27, 1836.85],
  C3: [918.43, 1298.27],
  C4: [649.13, 918.43],
  C5: [459.21, 649.13],
  C6: [323.15, 459.21],
  C7: [229.61, 323.15],
  C8: [161.57, 229.61],
  C9: [113.39, 161.57],
  C10: [79.37, 113.39],
  RA0: [2437.8, 3458.27],
  RA1: [1729.13, 2437.8],
  RA2: [1218.9, 1729.13],
  RA3: [864.57, 1218.9],
  RA4: [609.45, 864.57],
  SRA0: [2551.18, 3628.35],
  SRA1: [1814.17, 2551.18],
  SRA2: [1275.59, 1814.17],
  SRA3: [907.09, 1275.59],
  SRA4: [637.8, 907.09],
  EXECUTIVE: [521.86, 756],
  FOLIO: [612, 936],
  LEGAL: [612, 1008],
  LETTER: [612, 792],
  TABLOID: [792, 1224],
  ID1: [153, 243]
};
var toSizeObject = function toSizeObject2(v2) {
  return {
    width: v2[0],
    height: v2[1]
  };
};
var flipSizeObject = function flipSizeObject2(v2) {
  return {
    width: v2.height,
    height: v2.width
  };
};
var adjustDpi = function adjustDpi2(v2, dpi) {
  return {
    width: v2.width ? v2.width * dpi : v2.width,
    height: v2.height ? v2.height * dpi : v2.height
  };
};
var getStringSize = function getStringSize2(v2) {
  return toSizeObject(PAGE_SIZES[v2.toUpperCase()]);
};
var getNumberSize = function getNumberSize2(n) {
  return toSizeObject([n]);
};
var getSize = function getSize2(page) {
  var _page$props, _page$props2;
  var value2 = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.size) || "A4";
  var dpi = parseFloat(((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.dpi) || 72);
  var type2 = typeof value2;
  var size;
  if (type2 === "string") {
    size = getStringSize(value2);
  } else if (Array.isArray(value2)) {
    size = toSizeObject(value2);
  } else if (type2 === "number") {
    size = getNumberSize(value2);
  } else {
    size = value2;
  }
  size = adjustDpi(size, dpi / 72);
  return isLandscape(page) ? flipSizeObject(size) : size;
};
var resolvePageSize = function resolvePageSize2(page) {
  var size = getSize(page);
  var style = flatten(page.style || {});
  return _extends({}, page, {
    style: _extends({}, style, size)
  });
};
var resolvePageSizes = function resolvePageSizes2(root) {
  if (!root.children) return root;
  var children = root.children.map(resolvePageSize);
  return Object.assign({}, root, {
    children
  });
};
var isFixed = function isFixed2(node) {
  var _node$props;
  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.fixed) === true;
};
var lineIndexAtHeight = function lineIndexAtHeight2(node, height5) {
  var y = 0;
  if (!node.lines) return 0;
  for (var i = 0; i < node.lines.length; i += 1) {
    var line2 = node.lines[i];
    if (y + line2.box.height > height5) return i;
    y += line2.box.height;
  }
  return node.lines.length;
};
var heightAtLineIndex = function heightAtLineIndex2(node, index2) {
  var counter = 0;
  if (!node.lines) return counter;
  for (var i = 0; i < index2; i += 1) {
    var line2 = node.lines[i];
    if (!line2) break;
    counter += line2.box.height;
  }
  return counter;
};
var getLineBreak = function getLineBreak2(node, height5) {
  var top = get(node, ["box", "top"], 0);
  var widows = get(node, ["props", "widows"], 2);
  var orphans = get(node, ["props", "orphans"], 2);
  var linesQuantity = node.lines.length;
  var slicedLine = lineIndexAtHeight(node, height5 - top);
  if (slicedLine === 0) {
    return 0;
  }
  if (linesQuantity < orphans) {
    return linesQuantity;
  }
  if (slicedLine < orphans || linesQuantity < orphans + widows) {
    return 0;
  }
  if (linesQuantity === orphans + widows) {
    return orphans;
  }
  if (linesQuantity - slicedLine < widows) {
    return linesQuantity - widows;
  }
  return slicedLine;
};
var splitText = function splitText2(node, height5) {
  var slicedLineIndex = getLineBreak(node, height5);
  var currentHeight = heightAtLineIndex(node, slicedLineIndex);
  var nextHeight = node.box.height - currentHeight;
  var current = Object.assign({}, node, {
    box: _extends({}, node.box, {
      height: currentHeight,
      borderBottomWidth: 0
    }),
    style: _extends({}, node.style, {
      marginBottom: 0,
      paddingBottom: 0,
      borderBottomWidth: 0,
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    }),
    lines: node.lines.slice(0, slicedLineIndex)
  });
  var next = Object.assign({}, node, {
    box: _extends({}, node.box, {
      top: 0,
      height: nextHeight,
      borderTopWidth: 0
    }),
    style: _extends({}, node.style, {
      marginTop: 0,
      paddingTop: 0,
      borderTopWidth: 0,
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    }),
    lines: node.lines.slice(slicedLineIndex)
  });
  return [current, next];
};
var getTop$1 = function getTop(node) {
  var _node$box;
  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;
};
var hasFixedHeight = function hasFixedHeight2(node) {
  var _node$style;
  return !isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.height);
};
var splitNode = function splitNode2(node, height5) {
  if (!node) return [null, null];
  var nodeTop = getTop$1(node);
  var current = Object.assign({}, node, {
    box: _extends({}, node.box, {
      borderBottomWidth: 0
    }),
    style: _extends({}, node.style, {
      marginBottom: 0,
      paddingBottom: 0,
      borderBottomWidth: 0,
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    })
  });
  current.style.height = height5 - nodeTop;
  var nextHeight = hasFixedHeight(node) ? node.box.height - (height5 - nodeTop) : null;
  var next = Object.assign({}, node, {
    box: _extends({}, node.box, {
      top: 0,
      borderTopWidth: 0
    }),
    style: _extends({}, node.style, {
      marginTop: 0,
      paddingTop: 0,
      borderTopWidth: 0,
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    })
  });
  if (nextHeight) {
    next.style.height = nextHeight;
  }
  return [current, next];
};
var NON_WRAP_TYPES = [Svg, Note, Image, Canvas];
var getWrap = function getWrap2(node) {
  var _node$props;
  if (NON_WRAP_TYPES.includes(node.type)) return false;
  return isNil((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.wrap) ? true : node.props.wrap;
};
var getComputedPadding = function getComputedPadding2(node, edge) {
  var yogaNode = node.yogaNode;
  return yogaNode ? yogaNode.getComputedPadding(edge) : null;
};
var getPadding = function getPadding2(node) {
  var style = node.style, box = node.box;
  var paddingTop = getComputedPadding(node, Yoga.Edge.Top) || (box === null || box === void 0 ? void 0 : box.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingVertical) || (style === null || style === void 0 ? void 0 : style.padding) || 0;
  var paddingRight = getComputedPadding(node, Yoga.Edge.Right) || (box === null || box === void 0 ? void 0 : box.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingHorizontal) || (style === null || style === void 0 ? void 0 : style.padding) || 0;
  var paddingBottom = getComputedPadding(node, Yoga.Edge.Bottom) || (box === null || box === void 0 ? void 0 : box.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingVertical) || (style === null || style === void 0 ? void 0 : style.padding) || 0;
  var paddingLeft = getComputedPadding(node, Yoga.Edge.Left) || (box === null || box === void 0 ? void 0 : box.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingHorizontal) || (style === null || style === void 0 ? void 0 : style.padding) || 0;
  return {
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft
  };
};
var getWrapArea = function getWrapArea2(page) {
  var _page$style;
  var _getPadding = getPadding(page), paddingBottom = _getPadding.paddingBottom;
  var height5 = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;
  return height5 - paddingBottom;
};
var getContentArea = function getContentArea2(page) {
  var _page$style;
  var height5 = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;
  var _getPadding = getPadding(page), paddingTop = _getPadding.paddingTop, paddingBottom = _getPadding.paddingBottom;
  return height5 - paddingBottom - paddingTop;
};
var _excluded3 = ["style", "children"];
var isString3 = function isString4(value2) {
  return typeof value2 === "string";
};
var isNumber5 = function isNumber6(value2) {
  return typeof value2 === "number";
};
var isFragment = function isFragment2(value2) {
  return value2 && value2.type === Symbol.for("react.fragment");
};
var createInstances = function createInstances2(element) {
  if (!element) return [];
  if (isString3(element) || isNumber5(element)) {
    return [{
      type: TextInstance,
      value: "" + element
    }];
  }
  if (isFragment(element)) {
    return createInstances2(element.props.children);
  }
  if (Array.isArray(element)) {
    return element.reduce(function(acc, el) {
      return acc.concat(createInstances2(el));
    }, []);
  }
  if (!isString3(element.type)) {
    return createInstances2(element.type(element.props));
  }
  var type2 = element.type, _element$props = element.props, _element$props$style = _element$props.style, style = _element$props$style === void 0 ? {} : _element$props$style, _element$props$childr = _element$props.children, children = _element$props$childr === void 0 ? [] : _element$props$childr, props = _objectWithoutPropertiesLoose(_element$props, _excluded3);
  var nextChildren = castArray(children).reduce(function(acc, child) {
    return acc.concat(createInstances2(child));
  }, []);
  return [{
    type: type2,
    style,
    props,
    box: {},
    children: nextChildren
  }];
};
var getBreak = function getBreak2(node) {
  var _node$props;
  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.break) || false;
};
var getMinPresenceAhead = function getMinPresenceAhead2(node) {
  var _node$props2;
  return ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.minPresenceAhead) || 0;
};
var getFurthestEnd = function getFurthestEnd2(elements) {
  return Math.max.apply(Math, elements.map(function(node) {
    return node.box.top + node.box.height;
  }));
};
var getEndOfMinPresenceAhead = function getEndOfMinPresenceAhead2(child) {
  return child.box.top + child.box.height + child.box.marginBottom + getMinPresenceAhead(child);
};
var getEndOfPresence = function getEndOfPresence2(child, futureElements) {
  var afterMinPresenceAhead = getEndOfMinPresenceAhead(child);
  var endOfFurthestFutureElement = getFurthestEnd(futureElements.filter(function(node) {
    var _node$props3;
    return !((_node$props3 = node.props) !== null && _node$props3 !== void 0 && _node$props3.fixed);
  }));
  return Math.min(afterMinPresenceAhead, endOfFurthestFutureElement);
};
var shouldBreak = function shouldBreak2(child, futureElements, height5) {
  var _child$props;
  if ((_child$props = child.props) !== null && _child$props !== void 0 && _child$props.fixed) return false;
  var shouldSplit = height5 < child.box.top + child.box.height;
  var canWrap = getWrap(child);
  var endOfPresence = getEndOfPresence(child, futureElements);
  var breakingImprovesPresence = child.box.top > child.box.marginTop;
  return getBreak(child) || shouldSplit && !canWrap || !shouldSplit && endOfPresence > height5 && breakingImprovesPresence;
};
var IGNORABLE_CODEPOINTS = [
  8232,
  // LINE_SEPARATOR
  8233
  // PARAGRAPH_SEPARATOR
];
var buildSubsetForFont = function buildSubsetForFont2(font2) {
  return IGNORABLE_CODEPOINTS.reduce(function(acc, codePoint) {
    if (font2 && font2.hasGlyphForCodePoint && font2.hasGlyphForCodePoint(codePoint)) {
      return acc;
    }
    return [].concat(acc, [String.fromCharCode(codePoint)]);
  }, []);
};
var ignoreChars = function ignoreChars2(fragments) {
  return fragments.map(function(fragment) {
    var charSubset = buildSubsetForFont(fragment.attributes.font);
    var subsetRegex = new RegExp(charSubset.join("|"));
    return {
      string: fragment.string.replace(subsetRegex, ""),
      attributes: fragment.attributes
    };
  });
};
var PREPROCESSORS = [ignoreChars, embedEmojis];
var isImage$1 = function isImage2(node) {
  return node.type === Image;
};
var isTextInstance$2 = function isTextInstance2(node) {
  return node.type === TextInstance;
};
var getFragments2 = function getFragments3(fontStore2, instance, parentLink, level) {
  var _instance$props, _instance$props2;
  if (level === void 0) {
    level = 0;
  }
  if (!instance) return [{
    string: ""
  }];
  var fragments = [];
  var _instance$style = instance.style, _instance$style$color = _instance$style.color, color = _instance$style$color === void 0 ? "black" : _instance$style$color, _instance$style$direc = _instance$style.direction, direction = _instance$style$direc === void 0 ? "ltr" : _instance$style$direc, _instance$style$fontF = _instance$style.fontFamily, fontFamily = _instance$style$fontF === void 0 ? "Helvetica" : _instance$style$fontF, fontWeight = _instance$style.fontWeight, fontStyle = _instance$style.fontStyle, _instance$style$fontS = _instance$style.fontSize, fontSize2 = _instance$style$fontS === void 0 ? 18 : _instance$style$fontS, textAlign = _instance$style.textAlign, lineHeight = _instance$style.lineHeight, textDecoration3 = _instance$style.textDecoration, textDecorationColor = _instance$style.textDecorationColor, textDecorationStyle = _instance$style.textDecorationStyle, textTransform = _instance$style.textTransform, letterSpacing = _instance$style.letterSpacing, textIndent = _instance$style.textIndent, opacity2 = _instance$style.opacity, verticalAlign = _instance$style.verticalAlign;
  var fontFamilies = typeof fontFamily === "string" ? [fontFamily] : [].concat(fontFamily || []);
  var font2 = fontFamilies.map(function(fontFamilyName) {
    if (typeof fontFamilyName !== "string") return fontFamilyName;
    var opts2 = {
      fontFamily: fontFamilyName,
      fontWeight,
      fontStyle
    };
    var obj = fontStore2 ? fontStore2.getFont(opts2) : null;
    return obj ? obj.data : fontFamilyName;
  });
  var backgroundColor = level === 0 ? null : instance.style.backgroundColor;
  var attributes2 = {
    font: font2,
    color,
    opacity: opacity2,
    fontSize: fontSize2,
    direction,
    verticalAlign,
    backgroundColor,
    indent: textIndent,
    characterSpacing: letterSpacing,
    strikeStyle: textDecorationStyle,
    underlineStyle: textDecorationStyle,
    underline: textDecoration3 === "underline" || textDecoration3 === "underline line-through" || textDecoration3 === "line-through underline",
    strike: textDecoration3 === "line-through" || textDecoration3 === "underline line-through" || textDecoration3 === "line-through underline",
    strikeColor: textDecorationColor || color,
    underlineColor: textDecorationColor || color,
    link: parentLink || ((_instance$props = instance.props) === null || _instance$props === void 0 ? void 0 : _instance$props.src) || ((_instance$props2 = instance.props) === null || _instance$props2 === void 0 ? void 0 : _instance$props2.href),
    lineHeight: lineHeight ? lineHeight * fontSize2 : null,
    align: textAlign || (direction === "rtl" ? "right" : "left")
  };
  for (var i = 0; i < instance.children.length; i += 1) {
    var child = instance.children[i];
    if (isImage$1(child)) {
      fragments.push({
        string: String.fromCharCode(65532),
        attributes: _extends({}, attributes2, {
          attachment: {
            width: child.style.width || fontSize2,
            height: child.style.height || fontSize2,
            image: child.image.data
          }
        })
      });
    } else if (isTextInstance$2(child)) {
      fragments.push({
        string: transformText(child.value, textTransform),
        attributes: attributes2
      });
    } else if (child) {
      var _fragments;
      (_fragments = fragments).push.apply(_fragments, getFragments3(fontStore2, child, attributes2.link, level + 1));
    }
  }
  for (var _i = 0; _i < PREPROCESSORS.length; _i += 1) {
    var preprocessor = PREPROCESSORS[_i];
    fragments = preprocessor(fragments);
  }
  return fragments;
};
var getAttributedString2 = function getAttributedString3(fontStore2, instance) {
  var fragments = getFragments2(fontStore2, instance);
  return fromFragments3(fragments);
};
var engines = {
  bidi: bidiEngine,
  linebreaker,
  justification,
  textDecoration,
  scriptItemizer,
  wordHyphenation,
  fontSubstitution
};
var engine = layoutEngine(engines);
var getMaxLines = function getMaxLines2(node) {
  var _node$style;
  return (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.maxLines;
};
var getTextOverflow = function getTextOverflow2(node) {
  var _node$style2;
  return (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.textOverflow;
};
var getContainer2 = function getContainer3(width, height5, node) {
  var maxLines = getMaxLines(node);
  var textOverflow = getTextOverflow(node);
  return {
    x: 0,
    y: 0,
    width,
    maxLines,
    height: height5 || Infinity,
    truncateMode: textOverflow
  };
};
var getLayoutOptions = function getLayoutOptions2(fontStore2, node) {
  return {
    hyphenationPenalty: node.props.hyphenationPenalty,
    shrinkWhitespaceFactor: {
      before: -0.5,
      after: -0.5
    },
    hyphenationCallback: node.props.hyphenationCallback || (fontStore2 === null || fontStore2 === void 0 ? void 0 : fontStore2.getHyphenationCallback()) || null
  };
};
var layoutText2 = function layoutText3(node, width, height5, fontStore2) {
  var attributedString = getAttributedString2(fontStore2, node);
  var container = getContainer2(width, height5, node);
  var options = getLayoutOptions(fontStore2, node);
  var lines = engine(attributedString, container, options);
  return lines.reduce(function(acc, line2) {
    return [].concat(acc, line2);
  }, []);
};
var isType$2 = function isType2(type2) {
  return function(node) {
    return node.type === type2;
  };
};
var isSvg$2 = isType$2(Svg);
var isText$4 = isType$2(Text);
var shouldIterate = function shouldIterate2(node) {
  return !isSvg$2(node) && !isText$4(node);
};
var shouldLayoutText = function shouldLayoutText2(node) {
  return isText$4(node) && !node.lines;
};
var resolveTextLayout = function resolveTextLayout2(node, fontStore2) {
  if (shouldLayoutText(node)) {
    var width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);
    var height5 = node.box.height - (node.box.paddingTop + node.box.paddingBottom);
    node.lines = layoutText2(node, width, height5, fontStore2);
  }
  if (shouldIterate(node)) {
    if (!node.children) return node;
    var mapChild = function mapChild2(child) {
      return resolveTextLayout2(child, fontStore2);
    };
    var children = node.children.map(mapChild);
    return Object.assign({}, node, {
      children
    });
  }
  return node;
};
var BASE_INHERITABLE_PROPERTIES = ["color", "fontFamily", "fontSize", "fontStyle", "fontWeight", "letterSpacing", "opacity", "textDecoration", "textTransform", "lineHeight", "textAlign", "visibility", "wordSpacing"];
var TEXT_INHERITABLE_PROPERTIES = [].concat(BASE_INHERITABLE_PROPERTIES, ["backgroundColor"]);
var isSvg$1 = function isSvg(node) {
  return node.type === Svg;
};
var isText$3 = function isText(node) {
  return node.type === Text;
};
var mergeValues = function mergeValues2(styleName, value2, inheritedValue) {
  switch (styleName) {
    case "textDecoration": {
      return [inheritedValue, value2].filter(function(v2) {
        return v2 && v2 !== "none";
      }).join(" ");
    }
    default:
      return value2;
  }
};
var merge = function merge2(inheritedStyles, style) {
  var mergedStyles = _extends({}, inheritedStyles);
  Object.entries(style).forEach(function(_ref) {
    var styleName = _ref[0], value2 = _ref[1];
    mergedStyles[styleName] = mergeValues(styleName, value2, inheritedStyles[styleName]);
  });
  return mergedStyles;
};
var mergeStyles4 = function mergeStyles5(inheritedStyles) {
  return function(node) {
    var style = merge(inheritedStyles, node.style || {});
    return Object.assign({}, node, {
      style
    });
  };
};
var resolveInheritance = function resolveInheritance2(node) {
  if (isSvg$1(node)) return node;
  if (!node.children) return node;
  var inheritableProperties = isText$3(node) ? TEXT_INHERITABLE_PROPERTIES : BASE_INHERITABLE_PROPERTIES;
  var inheritStyles = pick(inheritableProperties, node.style || {});
  var resolveChild = compose(resolveInheritance2, mergeStyles4(inheritStyles));
  var children = node.children.map(resolveChild);
  return Object.assign({}, node, {
    children
  });
};
var getComputedMargin = function getComputedMargin2(node, edge) {
  var yogaNode = node.yogaNode;
  return yogaNode ? yogaNode.getComputedMargin(edge) : null;
};
var getMargin3 = function getMargin4(node) {
  var style = node.style, box = node.box;
  var marginTop = getComputedMargin(node, Yoga.Edge.Top) || (box === null || box === void 0 ? void 0 : box.marginTop) || (style === null || style === void 0 ? void 0 : style.marginTop) || (style === null || style === void 0 ? void 0 : style.marginVertical) || (style === null || style === void 0 ? void 0 : style.margin) || 0;
  var marginRight = getComputedMargin(node, Yoga.Edge.Right) || (box === null || box === void 0 ? void 0 : box.marginRight) || (style === null || style === void 0 ? void 0 : style.marginRight) || (style === null || style === void 0 ? void 0 : style.marginHorizontal) || (style === null || style === void 0 ? void 0 : style.margin) || 0;
  var marginBottom = getComputedMargin(node, Yoga.Edge.Bottom) || (box === null || box === void 0 ? void 0 : box.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginVertical) || (style === null || style === void 0 ? void 0 : style.margin) || 0;
  var marginLeft = getComputedMargin(node, Yoga.Edge.Left) || (box === null || box === void 0 ? void 0 : box.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginHorizontal) || (style === null || style === void 0 ? void 0 : style.margin) || 0;
  return {
    marginTop,
    marginRight,
    marginBottom,
    marginLeft
  };
};
var getPosition = function getPosition2(node) {
  var yogaNode = node.yogaNode;
  return {
    top: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedTop()) || 0,
    right: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedRight()) || 0,
    bottom: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedBottom()) || 0,
    left: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedLeft()) || 0
  };
};
var DEFAULT_DIMENSION = {
  width: 0,
  height: 0
};
var getDimension = function getDimension2(node) {
  var yogaNode = node.yogaNode;
  if (!yogaNode) return DEFAULT_DIMENSION;
  return {
    width: yogaNode.getComputedWidth(),
    height: yogaNode.getComputedHeight()
  };
};
var getComputedBorder = function getComputedBorder2(yogaNode, edge) {
  return yogaNode ? yogaNode.getComputedBorder(edge) : 0;
};
var getBorderWidth = function getBorderWidth2(node) {
  var yogaNode = node.yogaNode;
  return {
    borderTopWidth: getComputedBorder(yogaNode, Yoga.Edge.Top),
    borderRightWidth: getComputedBorder(yogaNode, Yoga.Edge.Right),
    borderBottomWidth: getComputedBorder(yogaNode, Yoga.Edge.Bottom),
    borderLeftWidth: getComputedBorder(yogaNode, Yoga.Edge.Left)
  };
};
var setDisplay = function setDisplay2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (yogaNode) {
      yogaNode.setDisplay(value2 === "none" ? Yoga.Display.None : Yoga.Display.Flex);
    }
    return node;
  };
};
var OVERFLOW = {
  hidden: Yoga.Overflow.Hidden,
  scroll: Yoga.Overflow.Scroll
};
var setOverflow = function setOverflow2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (!isNil(value2) && yogaNode) {
      var overflow = OVERFLOW[value2] || Yoga.Overflow.Visible;
      yogaNode.setOverflow(overflow);
    }
    return node;
  };
};
var FLEX_WRAP = {
  wrap: Yoga.Wrap.Wrap,
  "wrap-reverse": Yoga.Wrap.WrapReverse
};
var setFlexWrap = function setFlexWrap2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (yogaNode) {
      var flexWrap = FLEX_WRAP[value2] || Yoga.Wrap.NoWrap;
      yogaNode.setFlexWrap(flexWrap);
    }
    return node;
  };
};
var setYogaValue = function setYogaValue2(attr, edge) {
  return function(value2) {
    return function(node) {
      var yogaNode = node.yogaNode;
      if (!isNil(value2) && yogaNode) {
        var hasEdge = !isNil(edge);
        var fixedMethod = "set" + upperFirst(attr);
        var autoMethod = fixedMethod + "Auto";
        var percentMethod = fixedMethod + "Percent";
        var percent = matchPercent(value2);
        if (percent && !yogaNode[percentMethod]) {
          throw new Error("You can't pass percentage values to " + attr + " property");
        }
        if (percent) {
          if (hasEdge) {
            var _yogaNode$percentMeth;
            (_yogaNode$percentMeth = yogaNode[percentMethod]) === null || _yogaNode$percentMeth === void 0 ? void 0 : _yogaNode$percentMeth.call(yogaNode, edge, percent.value);
          } else {
            var _yogaNode$percentMeth2;
            (_yogaNode$percentMeth2 = yogaNode[percentMethod]) === null || _yogaNode$percentMeth2 === void 0 ? void 0 : _yogaNode$percentMeth2.call(yogaNode, percent.value);
          }
        } else if (value2 === "auto") {
          if (hasEdge) {
            var _yogaNode$autoMethod;
            (_yogaNode$autoMethod = yogaNode[autoMethod]) === null || _yogaNode$autoMethod === void 0 ? void 0 : _yogaNode$autoMethod.call(yogaNode, edge);
          } else {
            var _yogaNode$autoMethod2;
            (_yogaNode$autoMethod2 = yogaNode[autoMethod]) === null || _yogaNode$autoMethod2 === void 0 ? void 0 : _yogaNode$autoMethod2.call(yogaNode);
          }
        } else if (hasEdge) {
          var _yogaNode$fixedMethod;
          (_yogaNode$fixedMethod = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod === void 0 ? void 0 : _yogaNode$fixedMethod.call(yogaNode, edge, value2);
        } else {
          var _yogaNode$fixedMethod2;
          (_yogaNode$fixedMethod2 = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod2 === void 0 ? void 0 : _yogaNode$fixedMethod2.call(yogaNode, value2);
        }
      }
      return node;
    };
  };
};
var setFlexGrow = function setFlexGrow2(value2) {
  return function(node) {
    return setYogaValue("flexGrow")(value2 || 0)(node);
  };
};
var setFlexBasis = setYogaValue("flexBasis");
var ALIGN = {
  "flex-start": Yoga.Align.FlexStart,
  center: Yoga.Align.Center,
  "flex-end": Yoga.Align.FlexEnd,
  stretch: Yoga.Align.Stretch,
  baseline: Yoga.Align.Baseline,
  "space-between": Yoga.Align.SpaceBetween,
  "space-around": Yoga.Align.SpaceAround
};
var setAlign = function setAlign2(attr) {
  return function(value2) {
    return function(node) {
      var yogaNode = node.yogaNode;
      var defaultValue = attr === "items" ? Yoga.Align.Stretch : Yoga.Align.Auto;
      if (yogaNode) {
        var align = ALIGN[value2] || defaultValue;
        yogaNode["setAlign" + upperFirst(attr)](align);
      }
      return node;
    };
  };
};
var setAlignSelf = setAlign("self");
var setAlignItems = setAlign("items");
var setFlexShrink = function setFlexShrink2(value2) {
  return function(node) {
    return setYogaValue("flexShrink")(value2 || 1)(node);
  };
};
var setAspectRatio = function setAspectRatio2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (!isNil(value2) && yogaNode) {
      yogaNode.setAspectRatio(value2);
    }
    return node;
  };
};
var setAlignContent = setAlign("content");
var setPositionType = function setPositionType2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (!isNil(value2) && yogaNode) {
      yogaNode.setPositionType(value2 === "absolute" ? Yoga.PositionType.Absolute : Yoga.PositionType.Relative);
    }
    return node;
  };
};
var FLEX_DIRECTIONS = {
  row: Yoga.FlexDirection.Row,
  "row-reverse": Yoga.FlexDirection.RowReverse,
  "column-reverse": Yoga.FlexDirection.ColumnReverse
};
var setFlexDirection = function setFlexDirection2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (yogaNode) {
      var flexDirection = FLEX_DIRECTIONS[value2] || Yoga.FlexDirection.Column;
      yogaNode.setFlexDirection(flexDirection);
    }
    return node;
  };
};
var JUSTIFY_CONTENT = {
  center: Yoga.Justify.Center,
  "flex-end": Yoga.Justify.FlexEnd,
  "space-between": Yoga.Justify.SpaceBetween,
  "space-around": Yoga.Justify.SpaceAround,
  "space-evenly": Yoga.Justify.SpaceEvenly
};
var setJustifyContent = function setJustifyContent2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (!isNil(value2) && yogaNode) {
      var justifyContent = JUSTIFY_CONTENT[value2] || Yoga.Justify.FlexStart;
      yogaNode.setJustifyContent(justifyContent);
    }
    return node;
  };
};
var setMarginTop = setYogaValue("margin", Yoga.Edge.Top);
var setMarginRight = setYogaValue("margin", Yoga.Edge.Right);
var setMarginBottom = setYogaValue("margin", Yoga.Edge.Bottom);
var setMarginLeft = setYogaValue("margin", Yoga.Edge.Left);
var setPaddingTop = setYogaValue("padding", Yoga.Edge.Top);
var setPaddingRight = setYogaValue("padding", Yoga.Edge.Right);
var setPaddingBottom = setYogaValue("padding", Yoga.Edge.Bottom);
var setPaddingLeft = setYogaValue("padding", Yoga.Edge.Left);
var setBorderTop = setYogaValue("border", Yoga.Edge.Top);
var setBorderRight = setYogaValue("border", Yoga.Edge.Right);
var setBorderBottom = setYogaValue("border", Yoga.Edge.Bottom);
var setBorderLeft = setYogaValue("border", Yoga.Edge.Left);
var setPositionTop = setYogaValue("position", Yoga.Edge.Top);
var setPositionRight = setYogaValue("position", Yoga.Edge.Right);
var setPositionBottom = setYogaValue("position", Yoga.Edge.Bottom);
var setPositionLeft = setYogaValue("position", Yoga.Edge.Left);
var setWidth = setYogaValue("width");
var setMinWidth = setYogaValue("minWidth");
var setMaxWidth = setYogaValue("maxWidth");
var setHeight = setYogaValue("height");
var setMinHeight = setYogaValue("minHeight");
var setMaxHeight = setYogaValue("maxHeight");
var checkPercents = function checkPercents2(attr, value2) {
  var percent = matchPercent(value2);
  if (percent) {
    throw new Error("You can't pass percentage values to " + attr + " property");
  }
};
var setRowGap = function setRowGap2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (!isNil(value2) && yogaNode) {
      checkPercents("rowGap", value2);
      yogaNode.setGap(Yoga.Gutter.Row, value2);
    }
    return node;
  };
};
var setColumnGap = function setColumnGap2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (!isNil(value2) && yogaNode) {
      checkPercents("columnGap", value2);
      yogaNode.setGap(Yoga.Gutter.Column, value2);
    }
    return node;
  };
};
var getAspectRatio = function getAspectRatio2(viewbox) {
  if (!viewbox) return null;
  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);
};
var measureCanvas$1 = function measureCanvas(page, node) {
  return function(width, widthMode, height5, heightMode) {
    var aspectRatio = getAspectRatio(node.props.viewBox) || 1;
    if (widthMode === Yoga.MeasureMode.Exactly || widthMode === Yoga.MeasureMode.AtMost) {
      return {
        width,
        height: width / aspectRatio
      };
    }
    if (heightMode === Yoga.MeasureMode.Exactly) {
      return {
        width: height5 * aspectRatio
      };
    }
    return {};
  };
};
var linesWidth = function linesWidth2(node) {
  if (!node.lines) return 0;
  return Math.max.apply(Math, [0].concat(node.lines.map(function(line2) {
    return line2.xAdvance;
  })));
};
var linesHeight = function linesHeight2(node) {
  if (!node.lines) return -1;
  return node.lines.reduce(function(acc, line2) {
    return acc + line2.box.height;
  }, 0);
};
var ALIGNMENT_FACTORS2 = {
  center: 0.5,
  right: 1
};
var measureText = function measureText2(page, node, fontStore2) {
  return function(width, widthMode, height5) {
    if (widthMode === Yoga.MeasureMode.Exactly) {
      if (!node.lines) node.lines = layoutText2(node, width, height5, fontStore2);
      return {
        height: linesHeight(node)
      };
    }
    if (widthMode === Yoga.MeasureMode.AtMost) {
      var _node$style;
      var alignFactor = ALIGNMENT_FACTORS2[(_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.textAlign] || 0;
      if (!node.lines) {
        node.lines = layoutText2(node, width, height5, fontStore2);
        node.alignOffset = (width - linesWidth(node)) * alignFactor;
      }
      return {
        height: linesHeight(node),
        width: Math.min(width, linesWidth(node))
      };
    }
    return {};
  };
};
var getRatio = function getRatio2(node) {
  var _node$image;
  return (_node$image = node.image) !== null && _node$image !== void 0 && _node$image.data ? node.image.width / node.image.height : 1;
};
var isHeightAuto = function isHeightAuto2(page) {
  var _page$box;
  return isNil((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.height);
};
var SAFETY_HEIGHT$1 = 10;
var measureImage = function measureImage2(page, node) {
  return function(width, widthMode, height5, heightMode) {
    var imageRatio = getRatio(node);
    var imageMargin = getMargin3(node);
    var pagePadding = getPadding(page);
    var pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT$1;
    if (!node.image) return {
      width: 0,
      height: 0
    };
    if (widthMode === Yoga.MeasureMode.Exactly && heightMode === Yoga.MeasureMode.Undefined) {
      var scaledHeight = width / imageRatio;
      return {
        height: Math.min(pageArea, scaledHeight)
      };
    }
    if (heightMode === Yoga.MeasureMode.Exactly && (widthMode === Yoga.MeasureMode.AtMost || widthMode === Yoga.MeasureMode.Undefined)) {
      return {
        width: Math.min(height5 * imageRatio, width)
      };
    }
    if (widthMode === Yoga.MeasureMode.Exactly && heightMode === Yoga.MeasureMode.AtMost) {
      var _scaledHeight = width / imageRatio;
      return {
        height: Math.min(height5, pageArea, _scaledHeight)
      };
    }
    if (widthMode === Yoga.MeasureMode.AtMost && heightMode === Yoga.MeasureMode.AtMost) {
      if (imageRatio > 1) {
        return {
          width,
          height: Math.min(width / imageRatio, height5)
        };
      }
      return {
        height: height5,
        width: Math.min(height5 * imageRatio, width)
      };
    }
    return {
      height: height5,
      width
    };
  };
};
var SAFETY_HEIGHT = 10;
var getMax = function getMax2(values) {
  return Math.max.apply(Math, [-Infinity].concat(values));
};
var measureCtx = function measureCtx2() {
  var ctx = {};
  var points = [];
  var nil = function nil2() {
    return ctx;
  };
  var addPoint = function addPoint2(x, y) {
    return points.push([x, y]);
  };
  var moveTo2 = function moveTo3() {
    addPoint.apply(void 0, arguments);
    return ctx;
  };
  var rect2 = function rect3(x, y, w, h2) {
    addPoint(x, y);
    addPoint(x + w, y);
    addPoint(x, y + h2);
    addPoint(x + w, y + h2);
    return ctx;
  };
  var ellipse2 = function ellipse3(x, y, rx, ry) {
    ry = ry || rx;
    addPoint(x - rx, y - ry);
    addPoint(x + rx, y - ry);
    addPoint(x + rx, y + ry);
    addPoint(x - rx, y + ry);
    return ctx;
  };
  var polygon2 = function polygon3() {
    points.push.apply(points, arguments);
    return ctx;
  };
  ctx.rect = rect2;
  ctx.moveTo = moveTo2;
  ctx.lineTo = moveTo2;
  ctx.circle = ellipse2;
  ctx.polygon = polygon2;
  ctx.ellipse = ellipse2;
  ctx.roundedRect = rect2;
  ctx.text = nil;
  ctx.path = nil;
  ctx.lineWidth = nil;
  ctx.bezierCurveTo = nil;
  ctx.quadraticCurveTo = nil;
  ctx.scale = nil;
  ctx.rotate = nil;
  ctx.translate = nil;
  ctx.dash = nil;
  ctx.clip = nil;
  ctx.save = nil;
  ctx.fill = nil;
  ctx.font = nil;
  ctx.stroke = nil;
  ctx.lineCap = nil;
  ctx.opacity = nil;
  ctx.restore = nil;
  ctx.lineJoin = nil;
  ctx.fontSize = nil;
  ctx.fillColor = nil;
  ctx.miterLimit = nil;
  ctx.strokeColor = nil;
  ctx.fillOpacity = nil;
  ctx.strokeOpacity = nil;
  ctx.linearGradient = nil;
  ctx.radialGradient = nil;
  ctx.getWidth = function() {
    return getMax(points.map(function(p) {
      return p[0];
    }));
  };
  ctx.getHeight = function() {
    return getMax(points.map(function(p) {
      return p[1];
    }));
  };
  return ctx;
};
var measureCanvas2 = function measureCanvas3(page, node) {
  return function() {
    var imageMargin = getMargin3(node);
    var pagePadding = getPadding(page);
    var pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT;
    var ctx = measureCtx();
    node.props.paint(ctx);
    var width = ctx.getWidth();
    var height5 = Math.min(pageArea, ctx.getHeight());
    return {
      width,
      height: height5
    };
  };
};
var isType$1 = function isType3(type2) {
  return function(node) {
    return node.type === type2;
  };
};
var isSvg2 = isType$1(Svg);
var isText$2 = isType$1(Text);
var isNote = isType$1(Note);
var isPage = isType$1(Page);
var isImage3 = isType$1(Image);
var isCanvas = isType$1(Canvas);
var isTextInstance$1 = isType$1(TextInstance);
var setNodeHeight = function setNodeHeight2(node) {
  var value2 = isPage(node) ? node.box.height : node.style.height;
  return setHeight(value2);
};
var setYogaValues = function setYogaValues2(node) {
  compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);
};
var insertYogaNodes = function insertYogaNodes2(parent) {
  return function(child) {
    parent.insertChild(child.yogaNode, parent.getChildCount());
    return child;
  };
};
var setMeasureFunc = function setMeasureFunc2(node, page, fontStore2) {
  var yogaNode = node.yogaNode;
  if (isText$2(node)) {
    yogaNode.setMeasureFunc(measureText(page, node, fontStore2));
  }
  if (isImage3(node)) {
    yogaNode.setMeasureFunc(measureImage(page, node));
  }
  if (isCanvas(node)) {
    yogaNode.setMeasureFunc(measureCanvas2(page, node));
  }
  if (isSvg2(node)) {
    yogaNode.setMeasureFunc(measureCanvas$1(page, node));
  }
  return node;
};
var isLayoutElement = function isLayoutElement2(node) {
  return !isText$2(node) && !isNote(node) && !isSvg2(node);
};
var createYogaNodes = function createYogaNodes2(page, fontStore2, yoga) {
  return function(node) {
    var yogaNode = yoga.node.create();
    var result = Object.assign({}, node, {
      yogaNode
    });
    setYogaValues(result);
    if (isLayoutElement(node) && node.children) {
      var resolveChild = compose(insertYogaNodes(yogaNode), createYogaNodes2(page, fontStore2, yoga));
      result.children = node.children.map(resolveChild);
    }
    setMeasureFunc(result, page, fontStore2);
    return result;
  };
};
var calculateLayout = function calculateLayout2(page) {
  page.yogaNode.calculateLayout();
  return page;
};
var persistDimensions = function persistDimensions2(node) {
  if (isTextInstance$1(node)) return node;
  var box = Object.assign(getPadding(node), getMargin3(node), getBorderWidth(node), getPosition(node), getDimension(node));
  var newNode = Object.assign({}, node, {
    box
  });
  if (!node.children) return newNode;
  var children = node.children.map(persistDimensions2);
  return Object.assign({}, newNode, {
    children
  });
};
var destroyYogaNodes = function destroyYogaNodes2(node) {
  var newNode = Object.assign({}, node);
  delete newNode.yogaNode;
  if (!node.children) return newNode;
  var children = node.children.map(destroyYogaNodes2);
  return Object.assign({}, newNode, {
    children
  });
};
var freeYogaNodes = function freeYogaNodes2(node) {
  if (node.yogaNode) node.yogaNode.freeRecursive();
  return node;
};
var resolvePageDimensions = function resolvePageDimensions2(page, fontStore2, yoga) {
  if (isNil(page)) return null;
  return compose(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore2, yoga))(page);
};
var resolveDimensions = function resolveDimensions2(node, fontStore2) {
  if (!node.children) return node;
  var resolveChild = function resolveChild2(child) {
    return resolvePageDimensions(child, fontStore2, node.yoga);
  };
  var children = node.children.map(resolveChild);
  return Object.assign({}, node, {
    children
  });
};
var isText$1 = function isText2(node) {
  return node.type === Text;
};
var SAFETY_THRESHOLD = 1e-3;
var assingChildren = function assingChildren2(children, node) {
  return Object.assign({}, node, {
    children
  });
};
var getTop2 = function getTop3(node) {
  var _node$box;
  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;
};
var allFixed = function allFixed2(nodes) {
  return nodes.every(isFixed);
};
var isDynamic = function isDynamic2(node) {
  var _node$props;
  return !isNil((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.render);
};
var relayoutPage = compose(resolveTextLayout, resolvePageDimensions, resolveInheritance, resolvePageStyles);
var warnUnavailableSpace = function warnUnavailableSpace2(node) {
  console.warn("Node of type " + node.type + " can't wrap between pages and it's bigger than available page height");
};
var splitNodes = function splitNodes2(height5, contentArea, nodes) {
  var currentChildren = [];
  var nextChildren = [];
  for (var i = 0; i < nodes.length; i += 1) {
    var child = nodes[i];
    var futureNodes = nodes.slice(i + 1);
    var futureFixedNodes = futureNodes.filter(isFixed);
    var nodeTop = getTop2(child);
    var nodeHeight = child.box.height;
    var isOutside = height5 <= nodeTop;
    var shouldBreak$1 = shouldBreak(child, futureNodes, height5);
    var shouldSplit = height5 + SAFETY_THRESHOLD < nodeTop + nodeHeight;
    var canWrap = getWrap(child);
    var fitsInsidePage = nodeHeight <= contentArea;
    if (isFixed(child)) {
      nextChildren.push(child);
      currentChildren.push(child);
      continue;
    }
    if (isOutside) {
      var box = Object.assign({}, child.box, {
        top: child.box.top - height5
      });
      var next = Object.assign({}, child, {
        box
      });
      nextChildren.push(next);
      continue;
    }
    if (!fitsInsidePage && !canWrap) {
      currentChildren.push(child);
      nextChildren.push.apply(nextChildren, futureNodes);
      warnUnavailableSpace(child);
      break;
    }
    if (shouldBreak$1) {
      var _box = Object.assign({}, child.box, {
        top: child.box.top - height5
      });
      var props = Object.assign({}, child.props, {
        wrap: true,
        break: false
      });
      var _next = Object.assign({}, child, {
        box: _box,
        props
      });
      currentChildren.push.apply(currentChildren, futureFixedNodes);
      nextChildren.push.apply(nextChildren, [_next].concat(futureNodes));
      break;
    }
    if (shouldSplit) {
      var _split = split(child, height5, contentArea), currentChild = _split[0], nextChild = _split[1];
      if (child.children.length > 0 && currentChild.children.length === 0) {
        var _box2 = Object.assign({}, child.box, {
          top: child.box.top - height5
        });
        var _next2 = Object.assign({}, child, {
          box: _box2
        });
        currentChildren.push.apply(currentChildren, futureFixedNodes);
        nextChildren.push.apply(nextChildren, [_next2].concat(futureNodes));
        break;
      }
      if (currentChild) currentChildren.push(currentChild);
      if (nextChild) nextChildren.push(nextChild);
      continue;
    }
    currentChildren.push(child);
  }
  return [currentChildren, nextChildren];
};
var splitChildren = function splitChildren2(height5, contentArea, node) {
  var children = node.children || [];
  var availableHeight = height5 - getTop2(node);
  return splitNodes(availableHeight, contentArea, children);
};
var splitView = function splitView2(node, height5, contentArea) {
  var _splitNode = splitNode(node, height5), currentNode = _splitNode[0], nextNode = _splitNode[1];
  var _splitChildren = splitChildren(height5, contentArea, node), currentChilds = _splitChildren[0], nextChildren = _splitChildren[1];
  return [assingChildren(currentChilds, currentNode), assingChildren(nextChildren, nextNode)];
};
var split = function split2(node, height5, contentArea) {
  return isText$1(node) ? splitText(node, height5) : splitView(node, height5, contentArea);
};
var shouldResolveDynamicNodes = function shouldResolveDynamicNodes2(node) {
  var children = node.children || [];
  return isDynamic(node) || children.some(shouldResolveDynamicNodes2);
};
var resolveDynamicNodes = function resolveDynamicNodes2(props, node) {
  var isNodeDynamic = isDynamic(node);
  var resolveChildren3 = function resolveChildren4(children2) {
    if (children2 === void 0) {
      children2 = [];
    }
    if (isNodeDynamic) {
      var res = node.props.render(props);
      return createInstances(res).filter(Boolean).map(function(n) {
        return resolveDynamicNodes2(props, n);
      });
    }
    return children2.map(function(c2) {
      return resolveDynamicNodes2(props, c2);
    });
  };
  var resetHeight = isNodeDynamic && isText$1(node);
  var box = resetHeight ? _extends({}, node.box, {
    height: 0
  }) : node.box;
  var children = resolveChildren3(node.children);
  var lines = isNodeDynamic ? null : node.lines;
  return Object.assign({}, node, {
    box,
    lines,
    children
  });
};
var resolveDynamicPage = function resolveDynamicPage2(props, page, fontStore2, yoga) {
  if (shouldResolveDynamicNodes(page)) {
    var resolvedPage = resolveDynamicNodes(props, page);
    return relayoutPage(resolvedPage, fontStore2, yoga);
  }
  return page;
};
var splitPage = function splitPage2(page, pageNumber, fontStore2, yoga) {
  var wrapArea = getWrapArea(page);
  var contentArea = getContentArea(page);
  var dynamicPage = resolveDynamicPage({
    pageNumber
  }, page, fontStore2, yoga);
  var height5 = page.style.height;
  var _splitNodes = splitNodes(wrapArea, contentArea, dynamicPage.children), currentChilds = _splitNodes[0], nextChilds = _splitNodes[1];
  var relayout = function relayout2(node) {
    return relayoutPage(node, fontStore2, yoga);
  };
  var currentBox = _extends({}, page.box, {
    height: height5
  });
  var currentPage = relayout(Object.assign({}, page, {
    box: currentBox,
    children: currentChilds
  }));
  if (nextChilds.length === 0 || allFixed(nextChilds)) return [currentPage, null];
  var nextBox = omit("height", page.box);
  var nextProps = omit("bookmark", page.props);
  var nextPage = relayout(Object.assign({}, page, {
    props: nextProps,
    box: nextBox,
    children: nextChilds
  }));
  return [currentPage, nextPage];
};
var resolvePageIndices = function resolvePageIndices2(fontStore2, yoga, page, pageNumber, pages) {
  var totalPages = pages.length;
  var props = {
    totalPages,
    pageNumber: pageNumber + 1,
    subPageNumber: page.subPageNumber + 1,
    subPageTotalPages: page.subPageTotalPages
  };
  return resolveDynamicPage(props, page, fontStore2, yoga);
};
var assocSubPageData = function assocSubPageData2(subpages) {
  return subpages.map(function(page, i) {
    return _extends({}, page, {
      subPageNumber: i,
      subPageTotalPages: subpages.length
    });
  });
};
var dissocSubPageData = function dissocSubPageData2(page) {
  return omit(["subPageNumber", "subPageTotalPages"], page);
};
var paginate = function paginate2(page, pageNumber, fontStore2, yoga) {
  var _page$props;
  if (!page) return [];
  if (((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.wrap) === false) return [page];
  var splittedPage = splitPage(page, pageNumber, fontStore2, yoga);
  var pages = [splittedPage[0]];
  var nextPage = splittedPage[1];
  while (nextPage !== null) {
    splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore2, yoga);
    pages.push(splittedPage[0]);
    nextPage = splittedPage[1];
  }
  return pages;
};
var resolvePagination = function resolvePagination2(doc, fontStore2) {
  var pages = [];
  var pageNumber = 1;
  for (var i = 0; i < doc.children.length; i += 1) {
    var page = doc.children[i];
    var subpages = paginate(page, pageNumber, fontStore2, doc.yoga);
    subpages = assocSubPageData(subpages);
    pageNumber += subpages.length;
    pages = pages.concat(subpages);
  }
  pages = pages.map(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return dissocSubPageData(resolvePageIndices.apply(void 0, [fontStore2, doc.yoga].concat(args)));
  });
  return assingChildren(pages, doc);
};
var resolvePageHorizontalPadding = function resolvePageHorizontalPadding2(container) {
  return function(value2) {
    var match = matchPercent(value2);
    return match ? match.percent * container.width : value2;
  };
};
var resolvePageVerticalPadding = function resolvePageVerticalPadding2(container) {
  return function(value2) {
    var match = matchPercent(value2);
    return match ? match.percent * container.height : value2;
  };
};
var resolvePagePaddings = function resolvePagePaddings2(page) {
  var container = page.style;
  var style = evolve({
    paddingTop: resolvePageVerticalPadding(container),
    paddingLeft: resolvePageHorizontalPadding(container),
    paddingRight: resolvePageHorizontalPadding(container),
    paddingBottom: resolvePageVerticalPadding(container)
  }, page.style);
  return Object.assign({}, page, {
    style
  });
};
var resolvePagesPaddings = function resolvePagesPaddings2(root) {
  if (!root.children) return root;
  var children = root.children.map(resolvePagePaddings);
  return Object.assign({}, root, {
    children
  });
};
var resolveRadius = function resolveRadius2(container) {
  return function(value2) {
    if (!value2) return void 0;
    var match = matchPercent(value2);
    return match ? match.percent * Math.min(container.width, container.height) : value2;
  };
};
var resolvePercentRadius = function resolvePercentRadius2(node) {
  var style = evolve({
    borderTopLeftRadius: resolveRadius(node.box),
    borderTopRightRadius: resolveRadius(node.box),
    borderBottomRightRadius: resolveRadius(node.box),
    borderBottomLeftRadius: resolveRadius(node.box)
  }, node.style || {});
  var newNode = Object.assign({}, node, {
    style
  });
  if (!node.children) return newNode;
  var children = node.children.map(resolvePercentRadius2);
  return Object.assign({}, newNode, {
    children
  });
};
var transformHeight = function transformHeight2(pageArea, height5) {
  var match = matchPercent(height5);
  return match ? match.percent * pageArea : height5;
};
var getPageArea = function getPageArea2(page) {
  var _page$style, _page$style2;
  var pageHeight = page.style.height;
  var pagePaddingTop = ((_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.paddingTop) || 0;
  var pagePaddingBottom = ((_page$style2 = page.style) === null || _page$style2 === void 0 ? void 0 : _page$style2.paddingBottom) || 0;
  return pageHeight - pagePaddingTop - pagePaddingBottom;
};
var resolveNodePercentHeight = function resolveNodePercentHeight2(page, node) {
  var _page$style3, _node$style;
  if (isNil((_page$style3 = page.style) === null || _page$style3 === void 0 ? void 0 : _page$style3.height)) return node;
  if (isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.height)) return node;
  var pageArea = getPageArea(page);
  var height5 = transformHeight(pageArea, node.style.height);
  var style = Object.assign({}, node.style, {
    height: height5
  });
  return Object.assign({}, node, {
    style
  });
};
var resolvePagePercentHeight = function resolvePagePercentHeight2(page) {
  if (!page.children) return page;
  var resolveChild = function resolveChild2(child) {
    return resolveNodePercentHeight(page, child);
  };
  var children = page.children.map(resolveChild);
  return Object.assign({}, page, {
    children
  });
};
var resolvePercentHeight = function resolvePercentHeight2(root) {
  if (!root.children) return root;
  var children = root.children.map(resolvePagePercentHeight);
  return Object.assign({}, root, {
    children
  });
};
var isType4 = function isType5(type2) {
  return function(node) {
    return node.type === type2;
  };
};
var isLink2 = isType4(Link);
var isText3 = isType4(Text);
var isTextInstance3 = isType4(TextInstance);
var hasRenderProp = function hasRenderProp2(node) {
  var _node$props;
  return !!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.render);
};
var isTextType = function isTextType2(node) {
  return isText3(node) || isTextInstance3(node);
};
var isTextLink = function isTextLink2(node) {
  var children = node.children || [];
  if (children.every(isTextInstance3)) return true;
  if (children.every(isText3)) return false;
  return children.every(isTextType);
};
var wrapText = function wrapText2(node) {
  var textElement = {
    type: Text,
    props: {},
    style: {},
    box: {},
    children: node.children
  };
  return Object.assign({}, node, {
    children: [textElement]
  });
};
var transformLink = function transformLink2(node) {
  if (!isLink2(node)) return node;
  if (hasRenderProp(node)) return Object.assign({}, node, {
    type: Text
  });
  if (isTextLink(node)) return wrapText(node);
  return node;
};
var resolveLinkSubstitution = function resolveLinkSubstitution2(node) {
  if (!node.children) return node;
  var resolveChild = compose(transformLink, resolveLinkSubstitution2);
  var children = node.children.map(resolveChild);
  return Object.assign({}, node, {
    children
  });
};
var layout = asyncCompose(resolveZIndex, resolveOrigin, resolveAssets, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles3, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes, resolveYoga);

// ../../.yarn/__virtual__/@react-pdf-renderer-virtual-d7c75e74a5/0/cache/@react-pdf-renderer-npm-3.4.4-a00abab2ca-b5feebcf97.zip/node_modules/@react-pdf/renderer/lib/react-pdf.browser.js
var import_object_assign = __toESM(require_object_assign());
var scheduler = __toESM(require_scheduler());
var import_jsx_runtime = __toESM(require_jsx_runtime());
function getDefaultExportFromCjs3(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace3(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a2.prototype = f.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a2;
}
var reactReconciler_production_min = { exports: {} };
var require$$22 = getAugmentedNamespace3(scheduler);
(function(module2) {
  module2.exports = function $$$reconciler($$$hostConfig) {
    var aa = import_object_assign.default, ba = import_react.default, m2 = require$$22;
    function n(a2) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b += "&args[]=" + encodeURIComponent(arguments[c2]);
      return "Minified React error #" + a2 + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var q2 = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    q2.hasOwnProperty("ReactCurrentDispatcher") || (q2.ReactCurrentDispatcher = {
      current: null
    });
    q2.hasOwnProperty("ReactCurrentBatchConfig") || (q2.ReactCurrentBatchConfig = {
      suspense: null
    });
    var u = "function" === typeof Symbol && Symbol.for, ca = u ? Symbol.for("react.element") : 60103, da = u ? Symbol.for("react.portal") : 60106, ea = u ? Symbol.for("react.fragment") : 60107, fa = u ? Symbol.for("react.strict_mode") : 60108, ha = u ? Symbol.for("react.profiler") : 60114, ia = u ? Symbol.for("react.provider") : 60109, ja = u ? Symbol.for("react.context") : 60110, ka = u ? Symbol.for("react.concurrent_mode") : 60111, la = u ? Symbol.for("react.forward_ref") : 60112, ma = u ? Symbol.for("react.suspense") : 60113, na = u ? Symbol.for("react.suspense_list") : 60120, oa = u ? Symbol.for("react.memo") : 60115, pa = u ? Symbol.for("react.lazy") : 60116;
    var qa = "function" === typeof Symbol && Symbol.iterator;
    function ra(a2) {
      if (null === a2 || "object" !== typeof a2) return null;
      a2 = qa && a2[qa] || a2["@@iterator"];
      return "function" === typeof a2 ? a2 : null;
    }
    function sa(a2) {
      if (-1 === a2._status) {
        a2._status = 0;
        var b = a2._ctor;
        b = b();
        a2._result = b;
        b.then(function(b2) {
          0 === a2._status && (b2 = b2.default, a2._status = 1, a2._result = b2);
        }, function(b2) {
          0 === a2._status && (a2._status = 2, a2._result = b2);
        });
      }
    }
    function ta(a2) {
      if (null == a2) return null;
      if ("function" === typeof a2) return a2.displayName || a2.name || null;
      if ("string" === typeof a2) return a2;
      switch (a2) {
        case ea:
          return "Fragment";
        case da:
          return "Portal";
        case ha:
          return "Profiler";
        case fa:
          return "StrictMode";
        case ma:
          return "Suspense";
        case na:
          return "SuspenseList";
      }
      if ("object" === typeof a2) switch (a2.$$typeof) {
        case ja:
          return "Context.Consumer";
        case ia:
          return "Context.Provider";
        case la:
          var b = a2.render;
          b = b.displayName || b.name || "";
          return a2.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");
        case oa:
          return ta(a2.type);
        case pa:
          if (a2 = 1 === a2._status ? a2._result : null) return ta(a2);
      }
      return null;
    }
    function ua(a2) {
      var b = a2, c2 = a2;
      if (a2.alternate) for (; b.return; ) b = b.return;
      else {
        a2 = b;
        do
          b = a2, 0 !== (b.effectTag & 1026) && (c2 = b.return), a2 = b.return;
        while (a2);
      }
      return 3 === b.tag ? c2 : null;
    }
    function va(a2) {
      if (ua(a2) !== a2) throw Error(n(188));
    }
    function wa(a2) {
      var b = a2.alternate;
      if (!b) {
        b = ua(a2);
        if (null === b) throw Error(n(188));
        return b !== a2 ? null : a2;
      }
      for (var c2 = a2, d = b; ; ) {
        var e = c2.return;
        if (null === e) break;
        var f = e.alternate;
        if (null === f) {
          d = e.return;
          if (null !== d) {
            c2 = d;
            continue;
          }
          break;
        }
        if (e.child === f.child) {
          for (f = e.child; f; ) {
            if (f === c2) return va(e), a2;
            if (f === d) return va(e), b;
            f = f.sibling;
          }
          throw Error(n(188));
        }
        if (c2.return !== d.return) c2 = e, d = f;
        else {
          for (var g = false, l2 = e.child; l2; ) {
            if (l2 === c2) {
              g = true;
              c2 = e;
              d = f;
              break;
            }
            if (l2 === d) {
              g = true;
              d = e;
              c2 = f;
              break;
            }
            l2 = l2.sibling;
          }
          if (!g) {
            for (l2 = f.child; l2; ) {
              if (l2 === c2) {
                g = true;
                c2 = f;
                d = e;
                break;
              }
              if (l2 === d) {
                g = true;
                d = f;
                c2 = e;
                break;
              }
              l2 = l2.sibling;
            }
            if (!g) throw Error(n(189));
          }
        }
        if (c2.alternate !== d) throw Error(n(190));
      }
      if (3 !== c2.tag) throw Error(n(188));
      return c2.stateNode.current === c2 ? a2 : b;
    }
    function xa(a2) {
      a2 = wa(a2);
      if (!a2) return null;
      for (var b = a2; ; ) {
        if (5 === b.tag || 6 === b.tag) return b;
        if (b.child) b.child.return = b, b = b.child;
        else {
          if (b === a2) break;
          for (; !b.sibling; ) {
            if (!b.return || b.return === a2) return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return null;
    }
    function ya(a2) {
      a2 = wa(a2);
      if (!a2) return null;
      for (var b = a2; ; ) {
        if (5 === b.tag || 6 === b.tag) return b;
        if (b.child && 4 !== b.tag) b.child.return = b, b = b.child;
        else {
          if (b === a2) break;
          for (; !b.sibling; ) {
            if (!b.return || b.return === a2) return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return null;
    }
    var za = $$$hostConfig.getPublicInstance, Aa = $$$hostConfig.getRootHostContext, Ba = $$$hostConfig.getChildHostContext, Ca = $$$hostConfig.prepareForCommit, Da = $$$hostConfig.resetAfterCommit, Ea = $$$hostConfig.createInstance, Fa = $$$hostConfig.appendInitialChild, Ga = $$$hostConfig.finalizeInitialChildren, Ia = $$$hostConfig.prepareUpdate, Ja = $$$hostConfig.shouldSetTextContent, Ka = $$$hostConfig.shouldDeprioritizeSubtree, La = $$$hostConfig.createTextInstance, Ma = $$$hostConfig.setTimeout, Na = $$$hostConfig.clearTimeout, Oa = $$$hostConfig.noTimeout, Pa = $$$hostConfig.isPrimaryRenderer, Qa = $$$hostConfig.supportsMutation, Ra = $$$hostConfig.supportsPersistence, Sa = $$$hostConfig.supportsHydration, Ta = $$$hostConfig.appendChild, Ua = $$$hostConfig.appendChildToContainer, Va = $$$hostConfig.commitTextUpdate, Wa = $$$hostConfig.commitMount, Xa = $$$hostConfig.commitUpdate, Ya = $$$hostConfig.insertBefore, Za = $$$hostConfig.insertInContainerBefore, $a = $$$hostConfig.removeChild, ab = $$$hostConfig.removeChildFromContainer, bb = $$$hostConfig.resetTextContent, cb = $$$hostConfig.hideInstance, db = $$$hostConfig.hideTextInstance, eb = $$$hostConfig.unhideInstance, fb = $$$hostConfig.unhideTextInstance, gb = $$$hostConfig.cloneInstance, hb = $$$hostConfig.createContainerChildSet, ib = $$$hostConfig.appendChildToContainerChildSet, kb = $$$hostConfig.finalizeContainerChildren, lb = $$$hostConfig.replaceContainerChildren, mb = $$$hostConfig.cloneHiddenInstance, nb = $$$hostConfig.cloneHiddenTextInstance, ob = $$$hostConfig.canHydrateInstance, pb = $$$hostConfig.canHydrateTextInstance, qb = $$$hostConfig.isSuspenseInstancePending, rb = $$$hostConfig.isSuspenseInstanceFallback, sb = $$$hostConfig.getNextHydratableSibling, tb = $$$hostConfig.getFirstHydratableChild, ub = $$$hostConfig.hydrateInstance, vb = $$$hostConfig.hydrateTextInstance, wb = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance, xb = $$$hostConfig.commitHydratedContainer, yb = $$$hostConfig.commitHydratedSuspenseInstance, zb = /^(.*)[\\\/]/;
    function Ab(a2) {
      var b = "";
      do {
        a: switch (a2.tag) {
          case 3:
          case 4:
          case 6:
          case 7:
          case 10:
          case 9:
            var c2 = "";
            break a;
          default:
            var d = a2._debugOwner, e = a2._debugSource, f = ta(a2.type);
            c2 = null;
            d && (c2 = ta(d.type));
            d = f;
            f = "";
            e ? f = " (at " + e.fileName.replace(zb, "") + ":" + e.lineNumber + ")" : c2 && (f = " (created by " + c2 + ")");
            c2 = "\n    in " + (d || "Unknown") + f;
        }
        b += c2;
        a2 = a2.return;
      } while (a2);
      return b;
    }
    var Bb = [], Cb = -1;
    function y(a2) {
      0 > Cb || (a2.current = Bb[Cb], Bb[Cb] = null, Cb--);
    }
    function z2(a2, b) {
      Cb++;
      Bb[Cb] = a2.current;
      a2.current = b;
    }
    var Db = {}, A2 = {
      current: Db
    }, B = {
      current: false
    }, Eb = Db;
    function Fb(a2, b) {
      var c2 = a2.type.contextTypes;
      if (!c2) return Db;
      var d = a2.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f;
      for (f in c2) e[f] = b[f];
      d && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b, a2.__reactInternalMemoizedMaskedChildContext = e);
      return e;
    }
    function C2(a2) {
      a2 = a2.childContextTypes;
      return null !== a2 && void 0 !== a2;
    }
    function Gb(a2) {
      y(B);
      y(A2);
    }
    function Hb(a2) {
      y(B);
      y(A2);
    }
    function Ib(a2, b, c2) {
      if (A2.current !== Db) throw Error(n(168));
      z2(A2, b);
      z2(B, c2);
    }
    function Jb(a2, b, c2) {
      var d = a2.stateNode;
      a2 = b.childContextTypes;
      if ("function" !== typeof d.getChildContext) return c2;
      d = d.getChildContext();
      for (var e in d) if (!(e in a2)) throw Error(n(108, ta(b) || "Unknown", e));
      return aa({}, c2, {}, d);
    }
    function Kb(a2) {
      var b = a2.stateNode;
      b = b && b.__reactInternalMemoizedMergedChildContext || Db;
      Eb = A2.current;
      z2(A2, b);
      z2(B, B.current);
      return true;
    }
    function Lb(a2, b, c2) {
      var d = a2.stateNode;
      if (!d) throw Error(n(169));
      c2 ? (b = Jb(a2, b, Eb), d.__reactInternalMemoizedMergedChildContext = b, y(B), y(A2), z2(A2, b)) : y(B);
      z2(B, c2);
    }
    var Mb = m2.unstable_runWithPriority, Nb = m2.unstable_scheduleCallback, Ob = m2.unstable_cancelCallback, Pb = m2.unstable_shouldYield, Qb = m2.unstable_requestPaint, Tb = m2.unstable_now, Ub = m2.unstable_getCurrentPriorityLevel, Vb = m2.unstable_ImmediatePriority, Wb = m2.unstable_UserBlockingPriority, Xb = m2.unstable_NormalPriority, Yb = m2.unstable_LowPriority, Zb = m2.unstable_IdlePriority, $b = {}, ac = void 0 !== Qb ? Qb : function() {
    }, bc = null, cc = null, dc = false, ec = Tb(), E = 1e4 > ec ? Tb : function() {
      return Tb() - ec;
    };
    function fc() {
      switch (Ub()) {
        case Vb:
          return 99;
        case Wb:
          return 98;
        case Xb:
          return 97;
        case Yb:
          return 96;
        case Zb:
          return 95;
        default:
          throw Error(n(332));
      }
    }
    function gc(a2) {
      switch (a2) {
        case 99:
          return Vb;
        case 98:
          return Wb;
        case 97:
          return Xb;
        case 96:
          return Yb;
        case 95:
          return Zb;
        default:
          throw Error(n(332));
      }
    }
    function hc(a2, b) {
      a2 = gc(a2);
      return Mb(a2, b);
    }
    function ic(a2, b, c2) {
      a2 = gc(a2);
      return Nb(a2, b, c2);
    }
    function jc(a2) {
      null === bc ? (bc = [a2], cc = Nb(Vb, kc)) : bc.push(a2);
      return $b;
    }
    function F() {
      if (null !== cc) {
        var a2 = cc;
        cc = null;
        Ob(a2);
      }
      kc();
    }
    function kc() {
      if (!dc && null !== bc) {
        dc = true;
        var a2 = 0;
        try {
          var b = bc;
          hc(99, function() {
            for (; a2 < b.length; a2++) {
              var c2 = b[a2];
              do
                c2 = c2(true);
              while (null !== c2);
            }
          });
          bc = null;
        } catch (c2) {
          throw null !== bc && (bc = bc.slice(a2 + 1)), Nb(Vb, F), c2;
        } finally {
          dc = false;
        }
      }
    }
    var lc = 3;
    function mc(a2, b, c2) {
      c2 /= 10;
      return 1073741821 - (((1073741821 - a2 + b / 10) / c2 | 0) + 1) * c2;
    }
    function nc(a2, b) {
      return a2 === b && (0 !== a2 || 1 / a2 === 1 / b) || a2 !== a2 && b !== b;
    }
    var oc = "function" === typeof Object.is ? Object.is : nc, pc = Object.prototype.hasOwnProperty;
    function qc(a2, b) {
      if (oc(a2, b)) return true;
      if ("object" !== typeof a2 || null === a2 || "object" !== typeof b || null === b) return false;
      var c2 = Object.keys(a2), d = Object.keys(b);
      if (c2.length !== d.length) return false;
      for (d = 0; d < c2.length; d++) if (!pc.call(b, c2[d]) || !oc(a2[c2[d]], b[c2[d]])) return false;
      return true;
    }
    function rc(a2, b) {
      if (a2 && a2.defaultProps) {
        b = aa({}, b);
        a2 = a2.defaultProps;
        for (var c2 in a2) void 0 === b[c2] && (b[c2] = a2[c2]);
      }
      return b;
    }
    var sc = {
      current: null
    }, tc = null, uc = null, vc = null;
    function wc() {
      vc = uc = tc = null;
    }
    function xc(a2, b) {
      var c2 = a2.type._context;
      Pa ? (z2(sc, c2._currentValue), c2._currentValue = b) : (z2(sc, c2._currentValue2), c2._currentValue2 = b);
    }
    function yc(a2) {
      var b = sc.current;
      y(sc);
      a2 = a2.type._context;
      Pa ? a2._currentValue = b : a2._currentValue2 = b;
    }
    function zc(a2, b) {
      for (; null !== a2; ) {
        var c2 = a2.alternate;
        if (a2.childExpirationTime < b) a2.childExpirationTime = b, null !== c2 && c2.childExpirationTime < b && (c2.childExpirationTime = b);
        else if (null !== c2 && c2.childExpirationTime < b) c2.childExpirationTime = b;
        else break;
        a2 = a2.return;
      }
    }
    function Ac(a2, b) {
      tc = a2;
      vc = uc = null;
      a2 = a2.dependencies;
      null !== a2 && null !== a2.firstContext && (a2.expirationTime >= b && (Bc = true), a2.firstContext = null);
    }
    function Cc(a2, b) {
      if (vc !== a2 && false !== b && 0 !== b) {
        if ("number" !== typeof b || 1073741823 === b) vc = a2, b = 1073741823;
        b = {
          context: a2,
          observedBits: b,
          next: null
        };
        if (null === uc) {
          if (null === tc) throw Error(n(308));
          uc = b;
          tc.dependencies = {
            expirationTime: 0,
            firstContext: b,
            responders: null
          };
        } else uc = uc.next = b;
      }
      return Pa ? a2._currentValue : a2._currentValue2;
    }
    var Dc = false;
    function Ec(a2) {
      return {
        baseState: a2,
        firstUpdate: null,
        lastUpdate: null,
        firstCapturedUpdate: null,
        lastCapturedUpdate: null,
        firstEffect: null,
        lastEffect: null,
        firstCapturedEffect: null,
        lastCapturedEffect: null
      };
    }
    function Fc(a2) {
      return {
        baseState: a2.baseState,
        firstUpdate: a2.firstUpdate,
        lastUpdate: a2.lastUpdate,
        firstCapturedUpdate: null,
        lastCapturedUpdate: null,
        firstEffect: null,
        lastEffect: null,
        firstCapturedEffect: null,
        lastCapturedEffect: null
      };
    }
    function Gc(a2, b) {
      return {
        expirationTime: a2,
        suspenseConfig: b,
        tag: 0,
        payload: null,
        callback: null,
        next: null,
        nextEffect: null
      };
    }
    function Hc(a2, b) {
      null === a2.lastUpdate ? a2.firstUpdate = a2.lastUpdate = b : (a2.lastUpdate.next = b, a2.lastUpdate = b);
    }
    function Ic(a2, b) {
      var c2 = a2.alternate;
      if (null === c2) {
        var d = a2.updateQueue;
        var e = null;
        null === d && (d = a2.updateQueue = Ec(a2.memoizedState));
      } else d = a2.updateQueue, e = c2.updateQueue, null === d ? null === e ? (d = a2.updateQueue = Ec(a2.memoizedState), e = c2.updateQueue = Ec(c2.memoizedState)) : d = a2.updateQueue = Fc(e) : null === e && (e = c2.updateQueue = Fc(d));
      null === e || d === e ? Hc(d, b) : null === d.lastUpdate || null === e.lastUpdate ? (Hc(d, b), Hc(e, b)) : (Hc(d, b), e.lastUpdate = b);
    }
    function Jc(a2, b) {
      var c2 = a2.updateQueue;
      c2 = null === c2 ? a2.updateQueue = Ec(a2.memoizedState) : Kc(a2, c2);
      null === c2.lastCapturedUpdate ? c2.firstCapturedUpdate = c2.lastCapturedUpdate = b : (c2.lastCapturedUpdate.next = b, c2.lastCapturedUpdate = b);
    }
    function Kc(a2, b) {
      var c2 = a2.alternate;
      null !== c2 && b === c2.updateQueue && (b = a2.updateQueue = Fc(b));
      return b;
    }
    function Lc(a2, b, c2, d, e, f) {
      switch (c2.tag) {
        case 1:
          return a2 = c2.payload, "function" === typeof a2 ? a2.call(f, d, e) : a2;
        case 3:
          a2.effectTag = a2.effectTag & -4097 | 64;
        case 0:
          a2 = c2.payload;
          e = "function" === typeof a2 ? a2.call(f, d, e) : a2;
          if (null === e || void 0 === e) break;
          return aa({}, d, e);
        case 2:
          Dc = true;
      }
      return d;
    }
    function Nc(a2, b, c2, d, e) {
      Dc = false;
      b = Kc(a2, b);
      for (var f = b.baseState, g = null, l2 = 0, h2 = b.firstUpdate, k = f; null !== h2; ) {
        var p = h2.expirationTime;
        p < e ? (null === g && (g = h2, f = k), l2 < p && (l2 = p)) : (Oc(p, h2.suspenseConfig), k = Lc(a2, b, h2, k, c2, d), null !== h2.callback && (a2.effectTag |= 32, h2.nextEffect = null, null === b.lastEffect ? b.firstEffect = b.lastEffect = h2 : (b.lastEffect.nextEffect = h2, b.lastEffect = h2)));
        h2 = h2.next;
      }
      p = null;
      for (h2 = b.firstCapturedUpdate; null !== h2; ) {
        var D = h2.expirationTime;
        D < e ? (null === p && (p = h2, null === g && (f = k)), l2 < D && (l2 = D)) : (k = Lc(a2, b, h2, k, c2, d), null !== h2.callback && (a2.effectTag |= 32, h2.nextEffect = null, null === b.lastCapturedEffect ? b.firstCapturedEffect = b.lastCapturedEffect = h2 : (b.lastCapturedEffect.nextEffect = h2, b.lastCapturedEffect = h2)));
        h2 = h2.next;
      }
      null === g && (b.lastUpdate = null);
      null === p ? b.lastCapturedUpdate = null : a2.effectTag |= 32;
      null === g && null === p && (f = k);
      b.baseState = f;
      b.firstUpdate = g;
      b.firstCapturedUpdate = p;
      Pc(l2);
      a2.expirationTime = l2;
      a2.memoizedState = k;
    }
    function Qc(a2, b, c2) {
      null !== b.firstCapturedUpdate && (null !== b.lastUpdate && (b.lastUpdate.next = b.firstCapturedUpdate, b.lastUpdate = b.lastCapturedUpdate), b.firstCapturedUpdate = b.lastCapturedUpdate = null);
      Rc(b.firstEffect, c2);
      b.firstEffect = b.lastEffect = null;
      Rc(b.firstCapturedEffect, c2);
      b.firstCapturedEffect = b.lastCapturedEffect = null;
    }
    function Rc(a2, b) {
      for (; null !== a2; ) {
        var c2 = a2.callback;
        if (null !== c2) {
          a2.callback = null;
          var d = b;
          if ("function" !== typeof c2) throw Error(n(191, c2));
          c2.call(d);
        }
        a2 = a2.nextEffect;
      }
    }
    var Sc = q2.ReactCurrentBatchConfig, Tc = new ba.Component().refs;
    function Uc(a2, b, c2, d) {
      b = a2.memoizedState;
      c2 = c2(d, b);
      c2 = null === c2 || void 0 === c2 ? b : aa({}, b, c2);
      a2.memoizedState = c2;
      d = a2.updateQueue;
      null !== d && 0 === a2.expirationTime && (d.baseState = c2);
    }
    var Xc = {
      isMounted: function isMounted(a2) {
        return (a2 = a2._reactInternalFiber) ? ua(a2) === a2 : false;
      },
      enqueueSetState: function enqueueSetState(a2, b, c2) {
        a2 = a2._reactInternalFiber;
        var d = G2(), e = Sc.suspense;
        d = Vc(d, a2, e);
        e = Gc(d, e);
        e.payload = b;
        void 0 !== c2 && null !== c2 && (e.callback = c2);
        Ic(a2, e);
        Wc(a2, d);
      },
      enqueueReplaceState: function enqueueReplaceState(a2, b, c2) {
        a2 = a2._reactInternalFiber;
        var d = G2(), e = Sc.suspense;
        d = Vc(d, a2, e);
        e = Gc(d, e);
        e.tag = 1;
        e.payload = b;
        void 0 !== c2 && null !== c2 && (e.callback = c2);
        Ic(a2, e);
        Wc(a2, d);
      },
      enqueueForceUpdate: function enqueueForceUpdate(a2, b) {
        a2 = a2._reactInternalFiber;
        var c2 = G2(), d = Sc.suspense;
        c2 = Vc(c2, a2, d);
        d = Gc(c2, d);
        d.tag = 2;
        void 0 !== b && null !== b && (d.callback = b);
        Ic(a2, d);
        Wc(a2, c2);
      }
    };
    function Yc(a2, b, c2, d, e, f, g) {
      a2 = a2.stateNode;
      return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !qc(c2, d) || !qc(e, f) : true;
    }
    function Zc(a2, b, c2) {
      var d = false, e = Db;
      var f = b.contextType;
      "object" === typeof f && null !== f ? f = Cc(f) : (e = C2(b) ? Eb : A2.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Fb(a2, e) : Db);
      b = new b(c2, f);
      a2.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
      b.updater = Xc;
      a2.stateNode = b;
      b._reactInternalFiber = a2;
      d && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e, a2.__reactInternalMemoizedMaskedChildContext = f);
      return b;
    }
    function $c(a2, b, c2, d) {
      a2 = b.state;
      "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c2, d);
      "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c2, d);
      b.state !== a2 && Xc.enqueueReplaceState(b, b.state, null);
    }
    function ad(a2, b, c2, d) {
      var e = a2.stateNode;
      e.props = c2;
      e.state = a2.memoizedState;
      e.refs = Tc;
      var f = b.contextType;
      "object" === typeof f && null !== f ? e.context = Cc(f) : (f = C2(b) ? Eb : A2.current, e.context = Fb(a2, f));
      f = a2.updateQueue;
      null !== f && (Nc(a2, f, c2, e, d), e.state = a2.memoizedState);
      f = b.getDerivedStateFromProps;
      "function" === typeof f && (Uc(a2, b, f, c2), e.state = a2.memoizedState);
      "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Xc.enqueueReplaceState(e, e.state, null), f = a2.updateQueue, null !== f && (Nc(a2, f, c2, e, d), e.state = a2.memoizedState));
      "function" === typeof e.componentDidMount && (a2.effectTag |= 4);
    }
    var bd = Array.isArray;
    function cd(a2, b, c2) {
      a2 = c2.ref;
      if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
        if (c2._owner) {
          c2 = c2._owner;
          if (c2) {
            if (1 !== c2.tag) throw Error(n(309));
            var d = c2.stateNode;
          }
          if (!d) throw Error(n(147, a2));
          var e = "" + a2;
          if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e) return b.ref;
          b = function b2(_b) {
            var a3 = d.refs;
            a3 === Tc && (a3 = d.refs = {});
            null === _b ? delete a3[e] : a3[e] = _b;
          };
          b._stringRef = e;
          return b;
        }
        if ("string" !== typeof a2) throw Error(n(284));
        if (!c2._owner) throw Error(n(290, a2));
      }
      return a2;
    }
    function dd(a2, b) {
      if ("textarea" !== a2.type) throw Error(n(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, ""));
    }
    function ed(a2) {
      function b(b2, c3) {
        if (a2) {
          var d2 = b2.lastEffect;
          null !== d2 ? (d2.nextEffect = c3, b2.lastEffect = c3) : b2.firstEffect = b2.lastEffect = c3;
          c3.nextEffect = null;
          c3.effectTag = 8;
        }
      }
      function c2(c3, d2) {
        if (!a2) return null;
        for (; null !== d2; ) b(c3, d2), d2 = d2.sibling;
        return null;
      }
      function d(b2, a3) {
        for (b2 = /* @__PURE__ */ new Map(); null !== a3; ) null !== a3.key ? b2.set(a3.key, a3) : b2.set(a3.index, a3), a3 = a3.sibling;
        return b2;
      }
      function e(b2, a3, c3) {
        b2 = fd(b2, a3);
        b2.index = 0;
        b2.sibling = null;
        return b2;
      }
      function f(b2, c3, d2) {
        b2.index = d2;
        if (!a2) return c3;
        d2 = b2.alternate;
        if (null !== d2) return d2 = d2.index, d2 < c3 ? (b2.effectTag = 2, c3) : d2;
        b2.effectTag = 2;
        return c3;
      }
      function g(b2) {
        a2 && null === b2.alternate && (b2.effectTag = 2);
        return b2;
      }
      function l2(b2, a3, c3, d2) {
        if (null === a3 || 6 !== a3.tag) return a3 = gd(c3, b2.mode, d2), a3.return = b2, a3;
        a3 = e(a3, c3);
        a3.return = b2;
        return a3;
      }
      function h2(b2, a3, c3, d2) {
        if (null !== a3 && a3.elementType === c3.type) return d2 = e(a3, c3.props), d2.ref = cd(b2, a3, c3), d2.return = b2, d2;
        d2 = hd(c3.type, c3.key, c3.props, null, b2.mode, d2);
        d2.ref = cd(b2, a3, c3);
        d2.return = b2;
        return d2;
      }
      function k(b2, a3, c3, d2) {
        if (null === a3 || 4 !== a3.tag || a3.stateNode.containerInfo !== c3.containerInfo || a3.stateNode.implementation !== c3.implementation) return a3 = id(c3, b2.mode, d2), a3.return = b2, a3;
        a3 = e(a3, c3.children || []);
        a3.return = b2;
        return a3;
      }
      function p(b2, a3, c3, d2, f2) {
        if (null === a3 || 7 !== a3.tag) return a3 = jd(c3, b2.mode, d2, f2), a3.return = b2, a3;
        a3 = e(a3, c3);
        a3.return = b2;
        return a3;
      }
      function D(b2, a3, c3) {
        if ("string" === typeof a3 || "number" === typeof a3) return a3 = gd("" + a3, b2.mode, c3), a3.return = b2, a3;
        if ("object" === typeof a3 && null !== a3) {
          switch (a3.$$typeof) {
            case ca:
              return c3 = hd(a3.type, a3.key, a3.props, null, b2.mode, c3), c3.ref = cd(b2, null, a3), c3.return = b2, c3;
            case da:
              return a3 = id(a3, b2.mode, c3), a3.return = b2, a3;
          }
          if (bd(a3) || ra(a3)) return a3 = jd(a3, b2.mode, c3, null), a3.return = b2, a3;
          dd(b2, a3);
        }
        return null;
      }
      function x(b2, a3, c3, d2) {
        var e2 = null !== a3 ? a3.key : null;
        if ("string" === typeof c3 || "number" === typeof c3) return null !== e2 ? null : l2(b2, a3, "" + c3, d2);
        if ("object" === typeof c3 && null !== c3) {
          switch (c3.$$typeof) {
            case ca:
              return c3.key === e2 ? c3.type === ea ? p(b2, a3, c3.props.children, d2, e2) : h2(b2, a3, c3, d2) : null;
            case da:
              return c3.key === e2 ? k(b2, a3, c3, d2) : null;
          }
          if (bd(c3) || ra(c3)) return null !== e2 ? null : p(b2, a3, c3, d2, null);
          dd(b2, c3);
        }
        return null;
      }
      function K(b2, a3, c3, d2, e2) {
        if ("string" === typeof d2 || "number" === typeof d2) return b2 = b2.get(c3) || null, l2(a3, b2, "" + d2, e2);
        if ("object" === typeof d2 && null !== d2) {
          switch (d2.$$typeof) {
            case ca:
              return b2 = b2.get(null === d2.key ? c3 : d2.key) || null, d2.type === ea ? p(a3, b2, d2.props.children, e2, d2.key) : h2(a3, b2, d2, e2);
            case da:
              return b2 = b2.get(null === d2.key ? c3 : d2.key) || null, k(a3, b2, d2, e2);
          }
          if (bd(d2) || ra(d2)) return b2 = b2.get(c3) || null, p(a3, b2, d2, e2, null);
          dd(a3, d2);
        }
        return null;
      }
      function Ha(e2, g2, h3, l3) {
        for (var k2 = null, w = null, t2 = g2, r = g2 = 0, p2 = null; null !== t2 && r < h3.length; r++) {
          t2.index > r ? (p2 = t2, t2 = null) : p2 = t2.sibling;
          var v2 = x(e2, t2, h3[r], l3);
          if (null === v2) {
            null === t2 && (t2 = p2);
            break;
          }
          a2 && t2 && null === v2.alternate && b(e2, t2);
          g2 = f(v2, g2, r);
          null === w ? k2 = v2 : w.sibling = v2;
          w = v2;
          t2 = p2;
        }
        if (r === h3.length) return c2(e2, t2), k2;
        if (null === t2) {
          for (; r < h3.length; r++) t2 = D(e2, h3[r], l3), null !== t2 && (g2 = f(t2, g2, r), null === w ? k2 = t2 : w.sibling = t2, w = t2);
          return k2;
        }
        for (t2 = d(e2, t2); r < h3.length; r++) p2 = K(t2, e2, r, h3[r], l3), null !== p2 && (a2 && null !== p2.alternate && t2.delete(null === p2.key ? r : p2.key), g2 = f(p2, g2, r), null === w ? k2 = p2 : w.sibling = p2, w = p2);
        a2 && t2.forEach(function(a3) {
          return b(e2, a3);
        });
        return k2;
      }
      function O(e2, g2, h3, l3) {
        var k2 = ra(h3);
        if ("function" !== typeof k2) throw Error(n(150));
        h3 = k2.call(h3);
        if (null == h3) throw Error(n(151));
        for (var t2 = k2 = null, r = g2, w = g2 = 0, p2 = null, v2 = h3.next(); null !== r && !v2.done; w++, v2 = h3.next()) {
          r.index > w ? (p2 = r, r = null) : p2 = r.sibling;
          var N = x(e2, r, v2.value, l3);
          if (null === N) {
            null === r && (r = p2);
            break;
          }
          a2 && r && null === N.alternate && b(e2, r);
          g2 = f(N, g2, w);
          null === t2 ? k2 = N : t2.sibling = N;
          t2 = N;
          r = p2;
        }
        if (v2.done) return c2(e2, r), k2;
        if (null === r) {
          for (; !v2.done; w++, v2 = h3.next()) v2 = D(e2, v2.value, l3), null !== v2 && (g2 = f(v2, g2, w), null === t2 ? k2 = v2 : t2.sibling = v2, t2 = v2);
          return k2;
        }
        for (r = d(e2, r); !v2.done; w++, v2 = h3.next()) v2 = K(r, e2, w, v2.value, l3), null !== v2 && (a2 && null !== v2.alternate && r.delete(null === v2.key ? w : v2.key), g2 = f(v2, g2, w), null === t2 ? k2 = v2 : t2.sibling = v2, t2 = v2);
        a2 && r.forEach(function(a3) {
          return b(e2, a3);
        });
        return k2;
      }
      return function(a3, d2, f2, h3) {
        var k2 = "object" === typeof f2 && null !== f2 && f2.type === ea && null === f2.key;
        k2 && (f2 = f2.props.children);
        var l3 = "object" === typeof f2 && null !== f2;
        if (l3) switch (f2.$$typeof) {
          case ca:
            a: {
              l3 = f2.key;
              for (k2 = d2; null !== k2; ) {
                if (k2.key === l3) {
                  if (7 === k2.tag ? f2.type === ea : k2.elementType === f2.type) {
                    c2(a3, k2.sibling);
                    d2 = e(k2, f2.type === ea ? f2.props.children : f2.props);
                    d2.ref = cd(a3, k2, f2);
                    d2.return = a3;
                    a3 = d2;
                    break a;
                  } else {
                    c2(a3, k2);
                    break;
                  }
                } else b(a3, k2);
                k2 = k2.sibling;
              }
              f2.type === ea ? (d2 = jd(f2.props.children, a3.mode, h3, f2.key), d2.return = a3, a3 = d2) : (h3 = hd(f2.type, f2.key, f2.props, null, a3.mode, h3), h3.ref = cd(a3, d2, f2), h3.return = a3, a3 = h3);
            }
            return g(a3);
          case da:
            a: {
              for (k2 = f2.key; null !== d2; ) {
                if (d2.key === k2) {
                  if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                    c2(a3, d2.sibling);
                    d2 = e(d2, f2.children || []);
                    d2.return = a3;
                    a3 = d2;
                    break a;
                  } else {
                    c2(a3, d2);
                    break;
                  }
                } else b(a3, d2);
                d2 = d2.sibling;
              }
              d2 = id(f2, a3.mode, h3);
              d2.return = a3;
              a3 = d2;
            }
            return g(a3);
        }
        if ("string" === typeof f2 || "number" === typeof f2) return f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c2(a3, d2.sibling), d2 = e(d2, f2), d2.return = a3, a3 = d2) : (c2(a3, d2), d2 = gd(f2, a3.mode, h3), d2.return = a3, a3 = d2), g(a3);
        if (bd(f2)) return Ha(a3, d2, f2, h3);
        if (ra(f2)) return O(a3, d2, f2, h3);
        l3 && dd(a3, f2);
        if ("undefined" === typeof f2 && !k2) switch (a3.tag) {
          case 1:
          case 0:
            throw a3 = a3.type, Error(n(152, a3.displayName || a3.name || "Component"));
        }
        return c2(a3, d2);
      };
    }
    var kd = ed(true), ld = ed(false), md = {}, H2 = {
      current: md
    }, nd = {
      current: md
    }, od = {
      current: md
    };
    function pd(a2) {
      if (a2 === md) throw Error(n(174));
      return a2;
    }
    function qd(a2, b) {
      z2(od, b);
      z2(nd, a2);
      z2(H2, md);
      b = Aa(b);
      y(H2);
      z2(H2, b);
    }
    function rd(a2) {
      y(H2);
      y(nd);
      y(od);
    }
    function sd(a2) {
      var b = pd(od.current), c2 = pd(H2.current);
      b = Ba(c2, a2.type, b);
      c2 !== b && (z2(nd, a2), z2(H2, b));
    }
    function td(a2) {
      nd.current === a2 && (y(H2), y(nd));
    }
    var I = {
      current: 0
    };
    function ud(a2) {
      for (var b = a2; null !== b; ) {
        if (13 === b.tag) {
          var c2 = b.memoizedState;
          if (null !== c2 && (c2 = c2.dehydrated, null === c2 || qb(c2) || rb(c2))) return b;
        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
          if (0 !== (b.effectTag & 64)) return b;
        } else if (null !== b.child) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a2) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a2) return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    function vd(a2, b) {
      return {
        responder: a2,
        props: b
      };
    }
    var wd = q2.ReactCurrentDispatcher, J = q2.ReactCurrentBatchConfig, xd = 0, yd = null, L2 = null, zd = null, Ad = null, M2 = null, Bd = null, Cd = 0, Dd = null, Ed = 0, Fd = false, Gd = null, Hd = 0;
    function P() {
      throw Error(n(321));
    }
    function Id(a2, b) {
      if (null === b) return false;
      for (var c2 = 0; c2 < b.length && c2 < a2.length; c2++) if (!oc(a2[c2], b[c2])) return false;
      return true;
    }
    function Jd(a2, b, c2, d, e, f) {
      xd = f;
      yd = b;
      zd = null !== a2 ? a2.memoizedState : null;
      wd.current = null === zd ? Kd : Ld;
      b = c2(d, e);
      if (Fd) {
        do
          Fd = false, Hd += 1, zd = null !== a2 ? a2.memoizedState : null, Bd = Ad, Dd = M2 = L2 = null, wd.current = Ld, b = c2(d, e);
        while (Fd);
        Gd = null;
        Hd = 0;
      }
      wd.current = Md;
      a2 = yd;
      a2.memoizedState = Ad;
      a2.expirationTime = Cd;
      a2.updateQueue = Dd;
      a2.effectTag |= Ed;
      a2 = null !== L2 && null !== L2.next;
      xd = 0;
      Bd = M2 = Ad = zd = L2 = yd = null;
      Cd = 0;
      Dd = null;
      Ed = 0;
      if (a2) throw Error(n(300));
      return b;
    }
    function Nd() {
      wd.current = Md;
      xd = 0;
      Bd = M2 = Ad = zd = L2 = yd = null;
      Cd = 0;
      Dd = null;
      Ed = 0;
      Fd = false;
      Gd = null;
      Hd = 0;
    }
    function Od() {
      var a2 = {
        memoizedState: null,
        baseState: null,
        queue: null,
        baseUpdate: null,
        next: null
      };
      null === M2 ? Ad = M2 = a2 : M2 = M2.next = a2;
      return M2;
    }
    function Pd() {
      if (null !== Bd) M2 = Bd, Bd = M2.next, L2 = zd, zd = null !== L2 ? L2.next : null;
      else {
        if (null === zd) throw Error(n(310));
        L2 = zd;
        var a2 = {
          memoizedState: L2.memoizedState,
          baseState: L2.baseState,
          queue: L2.queue,
          baseUpdate: L2.baseUpdate,
          next: null
        };
        M2 = null === M2 ? Ad = a2 : M2.next = a2;
        zd = L2.next;
      }
      return M2;
    }
    function Qd(a2, b) {
      return "function" === typeof b ? b(a2) : b;
    }
    function Rd(a2) {
      var b = Pd(), c2 = b.queue;
      if (null === c2) throw Error(n(311));
      c2.lastRenderedReducer = a2;
      if (0 < Hd) {
        var d = c2.dispatch;
        if (null !== Gd) {
          var e = Gd.get(c2);
          if (void 0 !== e) {
            Gd.delete(c2);
            var f = b.memoizedState;
            do
              f = a2(f, e.action), e = e.next;
            while (null !== e);
            oc(f, b.memoizedState) || (Bc = true);
            b.memoizedState = f;
            b.baseUpdate === c2.last && (b.baseState = f);
            c2.lastRenderedState = f;
            return [f, d];
          }
        }
        return [b.memoizedState, d];
      }
      d = c2.last;
      var g = b.baseUpdate;
      f = b.baseState;
      null !== g ? (null !== d && (d.next = null), d = g.next) : d = null !== d ? d.next : null;
      if (null !== d) {
        var l2 = e = null, h2 = d, k = false;
        do {
          var p = h2.expirationTime;
          p < xd ? (k || (k = true, l2 = g, e = f), p > Cd && (Cd = p, Pc(Cd))) : (Oc(p, h2.suspenseConfig), f = h2.eagerReducer === a2 ? h2.eagerState : a2(f, h2.action));
          g = h2;
          h2 = h2.next;
        } while (null !== h2 && h2 !== d);
        k || (l2 = g, e = f);
        oc(f, b.memoizedState) || (Bc = true);
        b.memoizedState = f;
        b.baseUpdate = l2;
        b.baseState = e;
        c2.lastRenderedState = f;
      }
      return [b.memoizedState, c2.dispatch];
    }
    function Sd(a2) {
      var b = Od();
      "function" === typeof a2 && (a2 = a2());
      b.memoizedState = b.baseState = a2;
      a2 = b.queue = {
        last: null,
        dispatch: null,
        lastRenderedReducer: Qd,
        lastRenderedState: a2
      };
      a2 = a2.dispatch = Td.bind(null, yd, a2);
      return [b.memoizedState, a2];
    }
    function Ud(a2) {
      return Rd(Qd);
    }
    function Vd(a2, b, c2, d) {
      a2 = {
        tag: a2,
        create: b,
        destroy: c2,
        deps: d,
        next: null
      };
      null === Dd ? (Dd = {
        lastEffect: null
      }, Dd.lastEffect = a2.next = a2) : (b = Dd.lastEffect, null === b ? Dd.lastEffect = a2.next = a2 : (c2 = b.next, b.next = a2, a2.next = c2, Dd.lastEffect = a2));
      return a2;
    }
    function Wd(a2, b, c2, d) {
      var e = Od();
      Ed |= a2;
      e.memoizedState = Vd(b, c2, void 0, void 0 === d ? null : d);
    }
    function Xd(a2, b, c2, d) {
      var e = Pd();
      d = void 0 === d ? null : d;
      var f = void 0;
      if (null !== L2) {
        var g = L2.memoizedState;
        f = g.destroy;
        if (null !== d && Id(d, g.deps)) {
          Vd(0, c2, f, d);
          return;
        }
      }
      Ed |= a2;
      e.memoizedState = Vd(b, c2, f, d);
    }
    function Yd(a2, b) {
      return Wd(516, 192, a2, b);
    }
    function Zd(a2, b) {
      return Xd(516, 192, a2, b);
    }
    function $d(a2, b) {
      if ("function" === typeof b) return a2 = a2(), b(a2), function() {
        b(null);
      };
      if (null !== b && void 0 !== b) return a2 = a2(), b.current = a2, function() {
        b.current = null;
      };
    }
    function ae() {
    }
    function be(a2, b) {
      Od().memoizedState = [a2, void 0 === b ? null : b];
      return a2;
    }
    function ce(a2, b) {
      var c2 = Pd();
      b = void 0 === b ? null : b;
      var d = c2.memoizedState;
      if (null !== d && null !== b && Id(b, d[1])) return d[0];
      c2.memoizedState = [a2, b];
      return a2;
    }
    function Td(a2, b, c2) {
      if (!(25 > Hd)) throw Error(n(301));
      var d = a2.alternate;
      if (a2 === yd || null !== d && d === yd) {
        if (Fd = true, a2 = {
          expirationTime: xd,
          suspenseConfig: null,
          action: c2,
          eagerReducer: null,
          eagerState: null,
          next: null
        }, null === Gd && (Gd = /* @__PURE__ */ new Map()), c2 = Gd.get(b), void 0 === c2) Gd.set(b, a2);
        else {
          for (b = c2; null !== b.next; ) b = b.next;
          b.next = a2;
        }
      } else {
        var e = G2(), f = Sc.suspense;
        e = Vc(e, a2, f);
        f = {
          expirationTime: e,
          suspenseConfig: f,
          action: c2,
          eagerReducer: null,
          eagerState: null,
          next: null
        };
        var g = b.last;
        if (null === g) f.next = f;
        else {
          var l2 = g.next;
          null !== l2 && (f.next = l2);
          g.next = f;
        }
        b.last = f;
        if (0 === a2.expirationTime && (null === d || 0 === d.expirationTime) && (d = b.lastRenderedReducer, null !== d)) try {
          var h2 = b.lastRenderedState, k = d(h2, c2);
          f.eagerReducer = d;
          f.eagerState = k;
          if (oc(k, h2)) return;
        } catch (p) {
        } finally {
        }
        Wc(a2, e);
      }
    }
    var Md = {
      readContext: Cc,
      useCallback: P,
      useContext: P,
      useEffect: P,
      useImperativeHandle: P,
      useLayoutEffect: P,
      useMemo: P,
      useReducer: P,
      useRef: P,
      useState: P,
      useDebugValue: P,
      useResponder: P,
      useDeferredValue: P,
      useTransition: P
    }, Kd = {
      readContext: Cc,
      useCallback: be,
      useContext: Cc,
      useEffect: Yd,
      useImperativeHandle: function useImperativeHandle(a2, b, c2) {
        c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
        return Wd(4, 36, $d.bind(null, b, a2), c2);
      },
      useLayoutEffect: function useLayoutEffect(a2, b) {
        return Wd(4, 36, a2, b);
      },
      useMemo: function useMemo(a2, b) {
        var c2 = Od();
        b = void 0 === b ? null : b;
        a2 = a2();
        c2.memoizedState = [a2, b];
        return a2;
      },
      useReducer: function useReducer(a2, b, c2) {
        var d = Od();
        b = void 0 !== c2 ? c2(b) : b;
        d.memoizedState = d.baseState = b;
        a2 = d.queue = {
          last: null,
          dispatch: null,
          lastRenderedReducer: a2,
          lastRenderedState: b
        };
        a2 = a2.dispatch = Td.bind(null, yd, a2);
        return [d.memoizedState, a2];
      },
      useRef: function useRef2(a2) {
        var b = Od();
        a2 = {
          current: a2
        };
        return b.memoizedState = a2;
      },
      useState: Sd,
      useDebugValue: ae,
      useResponder: vd,
      useDeferredValue: function useDeferredValue(a2, b) {
        var c2 = Sd(a2), d = c2[0], e = c2[1];
        Yd(function() {
          m2.unstable_next(function() {
            var c3 = J.suspense;
            J.suspense = void 0 === b ? null : b;
            try {
              e(a2);
            } finally {
              J.suspense = c3;
            }
          });
        }, [a2, b]);
        return d;
      },
      useTransition: function useTransition(a2) {
        var b = Sd(false), c2 = b[0], d = b[1];
        return [be(function(b2) {
          d(true);
          m2.unstable_next(function() {
            var c3 = J.suspense;
            J.suspense = void 0 === a2 ? null : a2;
            try {
              d(false), b2();
            } finally {
              J.suspense = c3;
            }
          });
        }, [a2, c2]), c2];
      }
    }, Ld = {
      readContext: Cc,
      useCallback: ce,
      useContext: Cc,
      useEffect: Zd,
      useImperativeHandle: function useImperativeHandle(a2, b, c2) {
        c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
        return Xd(4, 36, $d.bind(null, b, a2), c2);
      },
      useLayoutEffect: function useLayoutEffect(a2, b) {
        return Xd(4, 36, a2, b);
      },
      useMemo: function useMemo(a2, b) {
        var c2 = Pd();
        b = void 0 === b ? null : b;
        var d = c2.memoizedState;
        if (null !== d && null !== b && Id(b, d[1])) return d[0];
        a2 = a2();
        c2.memoizedState = [a2, b];
        return a2;
      },
      useReducer: Rd,
      useRef: function useRef2() {
        return Pd().memoizedState;
      },
      useState: Ud,
      useDebugValue: ae,
      useResponder: vd,
      useDeferredValue: function useDeferredValue(a2, b) {
        var c2 = Ud(), d = c2[0], e = c2[1];
        Zd(function() {
          m2.unstable_next(function() {
            var c3 = J.suspense;
            J.suspense = void 0 === b ? null : b;
            try {
              e(a2);
            } finally {
              J.suspense = c3;
            }
          });
        }, [a2, b]);
        return d;
      },
      useTransition: function useTransition(a2) {
        var b = Ud(), c2 = b[0], d = b[1];
        return [ce(function(b2) {
          d(true);
          m2.unstable_next(function() {
            var c3 = J.suspense;
            J.suspense = void 0 === a2 ? null : a2;
            try {
              d(false), b2();
            } finally {
              J.suspense = c3;
            }
          });
        }, [a2, c2]), c2];
      }
    }, de = null, ee = null, fe = false;
    function ge(a2, b) {
      var c2 = he(5, null, null, 0);
      c2.elementType = "DELETED";
      c2.type = "DELETED";
      c2.stateNode = b;
      c2.return = a2;
      c2.effectTag = 8;
      null !== a2.lastEffect ? (a2.lastEffect.nextEffect = c2, a2.lastEffect = c2) : a2.firstEffect = a2.lastEffect = c2;
    }
    function ie(a2, b) {
      switch (a2.tag) {
        case 5:
          return b = ob(b, a2.type, a2.pendingProps), null !== b ? (a2.stateNode = b, true) : false;
        case 6:
          return b = pb(b, a2.pendingProps), null !== b ? (a2.stateNode = b, true) : false;
        case 13:
          return false;
        default:
          return false;
      }
    }
    function je(a2) {
      if (fe) {
        var b = ee;
        if (b) {
          var c2 = b;
          if (!ie(a2, b)) {
            b = sb(c2);
            if (!b || !ie(a2, b)) {
              a2.effectTag = a2.effectTag & -1025 | 2;
              fe = false;
              de = a2;
              return;
            }
            ge(de, c2);
          }
          de = a2;
          ee = tb(b);
        } else a2.effectTag = a2.effectTag & -1025 | 2, fe = false, de = a2;
      }
    }
    function ke(a2) {
      for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
      de = a2;
    }
    function ne(a2) {
      if (!Sa || a2 !== de) return false;
      if (!fe) return ke(a2), fe = true, false;
      var b = a2.type;
      if (5 !== a2.tag || "head" !== b && "body" !== b && !Ja(b, a2.memoizedProps)) for (b = ee; b; ) ge(a2, b), b = sb(b);
      ke(a2);
      if (13 === a2.tag) {
        if (!Sa) throw Error(n(316));
        a2 = a2.memoizedState;
        a2 = null !== a2 ? a2.dehydrated : null;
        if (!a2) throw Error(n(317));
        ee = wb(a2);
      } else ee = de ? sb(a2.stateNode) : null;
      return true;
    }
    function oe() {
      Sa && (ee = de = null, fe = false);
    }
    var pe = q2.ReactCurrentOwner, Bc = false;
    function Q2(a2, b, c2, d) {
      b.child = null === a2 ? ld(b, null, c2, d) : kd(b, a2.child, c2, d);
    }
    function qe(a2, b, c2, d, e) {
      c2 = c2.render;
      var f = b.ref;
      Ac(b, e);
      d = Jd(a2, b, c2, d, f, e);
      if (null !== a2 && !Bc) return b.updateQueue = a2.updateQueue, b.effectTag &= -517, a2.expirationTime <= e && (a2.expirationTime = 0), re(a2, b, e);
      b.effectTag |= 1;
      Q2(a2, b, d, e);
      return b.child;
    }
    function se(a2, b, c2, d, e, f) {
      if (null === a2) {
        var g = c2.type;
        if ("function" === typeof g && !te(g) && void 0 === g.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b.tag = 15, b.type = g, ue(a2, b, g, d, e, f);
        a2 = hd(c2.type, null, d, null, b.mode, f);
        a2.ref = b.ref;
        a2.return = b;
        return b.child = a2;
      }
      g = a2.child;
      if (e < f && (e = g.memoizedProps, c2 = c2.compare, c2 = null !== c2 ? c2 : qc, c2(e, d) && a2.ref === b.ref)) return re(a2, b, f);
      b.effectTag |= 1;
      a2 = fd(g, d);
      a2.ref = b.ref;
      a2.return = b;
      return b.child = a2;
    }
    function ue(a2, b, c2, d, e, f) {
      return null !== a2 && qc(a2.memoizedProps, d) && a2.ref === b.ref && (Bc = false, e < f) ? re(a2, b, f) : ve(a2, b, c2, d, f);
    }
    function we(a2, b) {
      var c2 = b.ref;
      if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2) b.effectTag |= 128;
    }
    function ve(a2, b, c2, d, e) {
      var f = C2(c2) ? Eb : A2.current;
      f = Fb(b, f);
      Ac(b, e);
      c2 = Jd(a2, b, c2, d, f, e);
      if (null !== a2 && !Bc) return b.updateQueue = a2.updateQueue, b.effectTag &= -517, a2.expirationTime <= e && (a2.expirationTime = 0), re(a2, b, e);
      b.effectTag |= 1;
      Q2(a2, b, c2, e);
      return b.child;
    }
    function xe(a2, b, c2, d, e) {
      if (C2(c2)) {
        var f = true;
        Kb(b);
      } else f = false;
      Ac(b, e);
      if (null === b.stateNode) null !== a2 && (a2.alternate = null, b.alternate = null, b.effectTag |= 2), Zc(b, c2, d), ad(b, c2, d, e), d = true;
      else if (null === a2) {
        var g = b.stateNode, l2 = b.memoizedProps;
        g.props = l2;
        var h2 = g.context, k = c2.contextType;
        "object" === typeof k && null !== k ? k = Cc(k) : (k = C2(c2) ? Eb : A2.current, k = Fb(b, k));
        var p = c2.getDerivedStateFromProps, D = "function" === typeof p || "function" === typeof g.getSnapshotBeforeUpdate;
        D || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (l2 !== d || h2 !== k) && $c(b, g, d, k);
        Dc = false;
        var x = b.memoizedState;
        h2 = g.state = x;
        var K = b.updateQueue;
        null !== K && (Nc(b, K, d, g, e), h2 = b.memoizedState);
        l2 !== d || x !== h2 || B.current || Dc ? ("function" === typeof p && (Uc(b, c2, p, d), h2 = b.memoizedState), (l2 = Dc || Yc(b, c2, l2, d, x, h2, k)) ? (D || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.effectTag |= 4)) : ("function" === typeof g.componentDidMount && (b.effectTag |= 4), b.memoizedProps = d, b.memoizedState = h2), g.props = d, g.state = h2, g.context = k, d = l2) : ("function" === typeof g.componentDidMount && (b.effectTag |= 4), d = false);
      } else g = b.stateNode, l2 = b.memoizedProps, g.props = b.type === b.elementType ? l2 : rc(b.type, l2), h2 = g.context, k = c2.contextType, "object" === typeof k && null !== k ? k = Cc(k) : (k = C2(c2) ? Eb : A2.current, k = Fb(b, k)), p = c2.getDerivedStateFromProps, (D = "function" === typeof p || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (l2 !== d || h2 !== k) && $c(b, g, d, k), Dc = false, h2 = b.memoizedState, x = g.state = h2, K = b.updateQueue, null !== K && (Nc(b, K, d, g, e), x = b.memoizedState), l2 !== d || h2 !== x || B.current || Dc ? ("function" === typeof p && (Uc(b, c2, p, d), x = b.memoizedState), (p = Dc || Yc(b, c2, l2, d, h2, x, k)) ? (D || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, x, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, x, k)), "function" === typeof g.componentDidUpdate && (b.effectTag |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.effectTag |= 256)) : ("function" !== typeof g.componentDidUpdate || l2 === a2.memoizedProps && h2 === a2.memoizedState || (b.effectTag |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || l2 === a2.memoizedProps && h2 === a2.memoizedState || (b.effectTag |= 256), b.memoizedProps = d, b.memoizedState = x), g.props = d, g.state = x, g.context = k, d = p) : ("function" !== typeof g.componentDidUpdate || l2 === a2.memoizedProps && h2 === a2.memoizedState || (b.effectTag |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || l2 === a2.memoizedProps && h2 === a2.memoizedState || (b.effectTag |= 256), d = false);
      return ye(a2, b, c2, d, f, e);
    }
    function ye(a2, b, c2, d, e, f) {
      we(a2, b);
      var g = 0 !== (b.effectTag & 64);
      if (!d && !g) return e && Lb(b, c2, false), re(a2, b, f);
      d = b.stateNode;
      pe.current = b;
      var l2 = g && "function" !== typeof c2.getDerivedStateFromError ? null : d.render();
      b.effectTag |= 1;
      null !== a2 && g ? (b.child = kd(b, a2.child, null, f), b.child = kd(b, null, l2, f)) : Q2(a2, b, l2, f);
      b.memoizedState = d.state;
      e && Lb(b, c2, true);
      return b.child;
    }
    function ze(a2) {
      var b = a2.stateNode;
      b.pendingContext ? Ib(a2, b.pendingContext, b.pendingContext !== b.context) : b.context && Ib(a2, b.context, false);
      qd(a2, b.containerInfo);
    }
    var Ae = {
      dehydrated: null,
      retryTime: 0
    };
    function Be(a2, b, c2) {
      var d = b.mode, e = b.pendingProps, f = I.current, g = false, l2;
      (l2 = 0 !== (b.effectTag & 64)) || (l2 = 0 !== (f & 2) && (null === a2 || null !== a2.memoizedState));
      l2 ? (g = true, b.effectTag &= -65) : null !== a2 && null === a2.memoizedState || void 0 === e.fallback || true === e.unstable_avoidThisFallback || (f |= 1);
      z2(I, f & 1);
      if (null === a2) {
        void 0 !== e.fallback && je(b);
        if (g) {
          g = e.fallback;
          e = jd(null, d, 0, null);
          e.return = b;
          if (0 === (b.mode & 2)) for (a2 = null !== b.memoizedState ? b.child.child : b.child, e.child = a2; null !== a2; ) a2.return = e, a2 = a2.sibling;
          c2 = jd(g, d, c2, null);
          c2.return = b;
          e.sibling = c2;
          b.memoizedState = Ae;
          b.child = e;
          return c2;
        }
        d = e.children;
        b.memoizedState = null;
        return b.child = ld(b, null, d, c2);
      }
      if (null !== a2.memoizedState) {
        a2 = a2.child;
        d = a2.sibling;
        if (g) {
          e = e.fallback;
          c2 = fd(a2, a2.pendingProps);
          c2.return = b;
          if (0 === (b.mode & 2) && (g = null !== b.memoizedState ? b.child.child : b.child, g !== a2.child)) for (c2.child = g; null !== g; ) g.return = c2, g = g.sibling;
          d = fd(d, e, d.expirationTime);
          d.return = b;
          c2.sibling = d;
          c2.childExpirationTime = 0;
          b.memoizedState = Ae;
          b.child = c2;
          return d;
        }
        c2 = kd(b, a2.child, e.children, c2);
        b.memoizedState = null;
        return b.child = c2;
      }
      a2 = a2.child;
      if (g) {
        g = e.fallback;
        e = jd(null, d, 0, null);
        e.return = b;
        e.child = a2;
        null !== a2 && (a2.return = e);
        if (0 === (b.mode & 2)) for (a2 = null !== b.memoizedState ? b.child.child : b.child, e.child = a2; null !== a2; ) a2.return = e, a2 = a2.sibling;
        c2 = jd(g, d, c2, null);
        c2.return = b;
        e.sibling = c2;
        c2.effectTag |= 2;
        e.childExpirationTime = 0;
        b.memoizedState = Ae;
        b.child = e;
        return c2;
      }
      b.memoizedState = null;
      return b.child = kd(b, a2, e.children, c2);
    }
    function Ce(a2, b) {
      a2.expirationTime < b && (a2.expirationTime = b);
      var c2 = a2.alternate;
      null !== c2 && c2.expirationTime < b && (c2.expirationTime = b);
      zc(a2.return, b);
    }
    function De(a2, b, c2, d, e, f) {
      var g = a2.memoizedState;
      null === g ? a2.memoizedState = {
        isBackwards: b,
        rendering: null,
        last: d,
        tail: c2,
        tailExpiration: 0,
        tailMode: e,
        lastEffect: f
      } : (g.isBackwards = b, g.rendering = null, g.last = d, g.tail = c2, g.tailExpiration = 0, g.tailMode = e, g.lastEffect = f);
    }
    function Ee(a2, b, c2) {
      var d = b.pendingProps, e = d.revealOrder, f = d.tail;
      Q2(a2, b, d.children, c2);
      d = I.current;
      if (0 !== (d & 2)) d = d & 1 | 2, b.effectTag |= 64;
      else {
        if (null !== a2 && 0 !== (a2.effectTag & 64)) a: for (a2 = b.child; null !== a2; ) {
          if (13 === a2.tag) null !== a2.memoizedState && Ce(a2, c2);
          else if (19 === a2.tag) Ce(a2, c2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b) break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b) break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
        d &= 1;
      }
      z2(I, d);
      if (0 === (b.mode & 2)) b.memoizedState = null;
      else switch (e) {
        case "forwards":
          c2 = b.child;
          for (e = null; null !== c2; ) a2 = c2.alternate, null !== a2 && null === ud(a2) && (e = c2), c2 = c2.sibling;
          c2 = e;
          null === c2 ? (e = b.child, b.child = null) : (e = c2.sibling, c2.sibling = null);
          De(b, false, e, c2, f, b.lastEffect);
          break;
        case "backwards":
          c2 = null;
          e = b.child;
          for (b.child = null; null !== e; ) {
            a2 = e.alternate;
            if (null !== a2 && null === ud(a2)) {
              b.child = e;
              break;
            }
            a2 = e.sibling;
            e.sibling = c2;
            c2 = e;
            e = a2;
          }
          De(b, true, c2, null, f, b.lastEffect);
          break;
        case "together":
          De(b, false, null, null, void 0, b.lastEffect);
          break;
        default:
          b.memoizedState = null;
      }
      return b.child;
    }
    function re(a2, b, c2) {
      null !== a2 && (b.dependencies = a2.dependencies);
      var d = b.expirationTime;
      0 !== d && Pc(d);
      if (b.childExpirationTime < c2) return null;
      if (null !== a2 && b.child !== a2.child) throw Error(n(153));
      if (null !== b.child) {
        a2 = b.child;
        c2 = fd(a2, a2.pendingProps, a2.expirationTime);
        b.child = c2;
        for (c2.return = b; null !== a2.sibling; ) a2 = a2.sibling, c2 = c2.sibling = fd(a2, a2.pendingProps, a2.expirationTime), c2.return = b;
        c2.sibling = null;
      }
      return b.child;
    }
    function Fe(a2) {
      a2.effectTag |= 4;
    }
    var _Ge, He, Ie, Je;
    if (Qa) _Ge = function Ge(a2, b) {
      for (var c2 = b.child; null !== c2; ) {
        if (5 === c2.tag || 6 === c2.tag) Fa(a2, c2.stateNode);
        else if (4 !== c2.tag && null !== c2.child) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === b) break;
        for (; null === c2.sibling; ) {
          if (null === c2.return || c2.return === b) return;
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    }, He = function He2() {
    }, Ie = function Ie2(a2, b, c2, d, e) {
      a2 = a2.memoizedProps;
      if (a2 !== d) {
        var f = b.stateNode, g = pd(H2.current);
        c2 = Ia(f, c2, a2, d, e, g);
        (b.updateQueue = c2) && Fe(b);
      }
    }, Je = function Je2(a2, b, c2, d) {
      c2 !== d && Fe(b);
    };
    else if (Ra) {
      _Ge = function Ge(a2, b, c2, d) {
        for (var e = b.child; null !== e; ) {
          if (5 === e.tag) {
            var f = e.stateNode;
            c2 && d && (f = mb(f, e.type, e.memoizedProps, e));
            Fa(a2, f);
          } else if (6 === e.tag) f = e.stateNode, c2 && d && (f = nb(f, e.memoizedProps, e)), Fa(a2, f);
          else if (4 !== e.tag) {
            if (13 === e.tag && 0 !== (e.effectTag & 4) && (f = null !== e.memoizedState)) {
              var g = e.child;
              if (null !== g && (null !== g.child && (g.child.return = g, _Ge(a2, g, true, f)), f = g.sibling, null !== f)) {
                f.return = e;
                e = f;
                continue;
              }
            }
            if (null !== e.child) {
              e.child.return = e;
              e = e.child;
              continue;
            }
          }
          if (e === b) break;
          for (; null === e.sibling; ) {
            if (null === e.return || e.return === b) return;
            e = e.return;
          }
          e.sibling.return = e.return;
          e = e.sibling;
        }
      };
      var Ke = function Ke2(a2, b, c2, d) {
        for (var e = b.child; null !== e; ) {
          if (5 === e.tag) {
            var f = e.stateNode;
            c2 && d && (f = mb(f, e.type, e.memoizedProps, e));
            ib(a2, f);
          } else if (6 === e.tag) f = e.stateNode, c2 && d && (f = nb(f, e.memoizedProps, e)), ib(a2, f);
          else if (4 !== e.tag) {
            if (13 === e.tag && 0 !== (e.effectTag & 4) && (f = null !== e.memoizedState)) {
              var g = e.child;
              if (null !== g && (null !== g.child && (g.child.return = g, Ke2(a2, g, true, f)), f = g.sibling, null !== f)) {
                f.return = e;
                e = f;
                continue;
              }
            }
            if (null !== e.child) {
              e.child.return = e;
              e = e.child;
              continue;
            }
          }
          if (e === b) break;
          for (; null === e.sibling; ) {
            if (null === e.return || e.return === b) return;
            e = e.return;
          }
          e.sibling.return = e.return;
          e = e.sibling;
        }
      };
      He = function He2(a2) {
        var b = a2.stateNode;
        if (null !== a2.firstEffect) {
          var c2 = b.containerInfo, d = hb(c2);
          Ke(d, a2, false, false);
          b.pendingChildren = d;
          Fe(a2);
          kb(c2, d);
        }
      };
      Ie = function Ie2(a2, b, c2, d, e) {
        var f = a2.stateNode, g = a2.memoizedProps;
        if ((a2 = null === b.firstEffect) && g === d) b.stateNode = f;
        else {
          var l2 = b.stateNode, h2 = pd(H2.current), k = null;
          g !== d && (k = Ia(l2, c2, g, d, e, h2));
          a2 && null === k ? b.stateNode = f : (f = gb(f, k, c2, g, d, b, a2, l2), Ga(f, c2, d, e, h2) && Fe(b), b.stateNode = f, a2 ? Fe(b) : _Ge(f, b, false, false));
        }
      };
      Je = function Je2(a2, b, c2, d) {
        c2 !== d && (a2 = pd(od.current), c2 = pd(H2.current), b.stateNode = La(d, a2, c2, b), Fe(b));
      };
    } else He = function He2() {
    }, Ie = function Ie2() {
    }, Je = function Je2() {
    };
    function Le(a2, b) {
      switch (a2.tailMode) {
        case "hidden":
          b = a2.tail;
          for (var c2 = null; null !== b; ) null !== b.alternate && (c2 = b), b = b.sibling;
          null === c2 ? a2.tail = null : c2.sibling = null;
          break;
        case "collapsed":
          c2 = a2.tail;
          for (var d = null; null !== c2; ) null !== c2.alternate && (d = c2), c2 = c2.sibling;
          null === d ? b || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d.sibling = null;
      }
    }
    function Me(a2) {
      switch (a2.tag) {
        case 1:
          C2(a2.type) && Gb();
          var b = a2.effectTag;
          return b & 4096 ? (a2.effectTag = b & -4097 | 64, a2) : null;
        case 3:
          rd();
          Hb();
          b = a2.effectTag;
          if (0 !== (b & 64)) throw Error(n(285));
          a2.effectTag = b & -4097 | 64;
          return a2;
        case 5:
          return td(a2), null;
        case 13:
          return y(I), b = a2.effectTag, b & 4096 ? (a2.effectTag = b & -4097 | 64, a2) : null;
        case 19:
          return y(I), null;
        case 4:
          return rd(), null;
        case 10:
          return yc(a2), null;
        default:
          return null;
      }
    }
    function Ne(a2, b) {
      return {
        value: a2,
        source: b,
        stack: Ab(b)
      };
    }
    var Oe = "function" === typeof WeakSet ? WeakSet : Set;
    function Pe(a2, b) {
      var c2 = b.source, d = b.stack;
      null === d && null !== c2 && (d = Ab(c2));
      null !== c2 && ta(c2.type);
      b = b.value;
      null !== a2 && 1 === a2.tag && ta(a2.type);
      try {
        console.error(b);
      } catch (e) {
        setTimeout(function() {
          throw e;
        });
      }
    }
    function Qe(a2, b) {
      try {
        b.props = a2.memoizedProps, b.state = a2.memoizedState, b.componentWillUnmount();
      } catch (c2) {
        Re(a2, c2);
      }
    }
    function Se(a2) {
      var b = a2.ref;
      if (null !== b) if ("function" === typeof b) try {
        b(null);
      } catch (c2) {
        Re(a2, c2);
      }
      else b.current = null;
    }
    function Te(a2, b) {
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
          Ue(2, 0, b);
          break;
        case 1:
          if (b.effectTag & 256 && null !== a2) {
            var c2 = a2.memoizedProps, d = a2.memoizedState;
            a2 = b.stateNode;
            b = a2.getSnapshotBeforeUpdate(b.elementType === b.type ? c2 : rc(b.type, c2), d);
            a2.__reactInternalSnapshotBeforeUpdate = b;
          }
          break;
        case 3:
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(n(163));
      }
    }
    function Ue(a2, b, c2) {
      c2 = c2.updateQueue;
      c2 = null !== c2 ? c2.lastEffect : null;
      if (null !== c2) {
        var d = c2 = c2.next;
        do {
          if (0 !== (d.tag & a2)) {
            var e = d.destroy;
            d.destroy = void 0;
            void 0 !== e && e();
          }
          0 !== (d.tag & b) && (e = d.create, d.destroy = e());
          d = d.next;
        } while (d !== c2);
      }
    }
    function Ve(a2, b, c2) {
      "function" === typeof We && We(b);
      switch (b.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          a2 = b.updateQueue;
          if (null !== a2 && (a2 = a2.lastEffect, null !== a2)) {
            var d = a2.next;
            hc(97 < c2 ? 97 : c2, function() {
              var a3 = d;
              do {
                var c3 = a3.destroy;
                if (void 0 !== c3) {
                  var g = b;
                  try {
                    c3();
                  } catch (l2) {
                    Re(g, l2);
                  }
                }
                a3 = a3.next;
              } while (a3 !== d);
            });
          }
          break;
        case 1:
          Se(b);
          c2 = b.stateNode;
          "function" === typeof c2.componentWillUnmount && Qe(b, c2);
          break;
        case 5:
          Se(b);
          break;
        case 4:
          Qa ? Xe(a2, b, c2) : Ra && Ye(b);
      }
    }
    function Ze(a2, b, c2) {
      for (var d = b; ; ) if (Ve(a2, d, c2), null === d.child || Qa && 4 === d.tag) {
        if (d === b) break;
        for (; null === d.sibling; ) {
          if (null === d.return || d.return === b) return;
          d = d.return;
        }
        d.sibling.return = d.return;
        d = d.sibling;
      } else d.child.return = d, d = d.child;
    }
    function $e(a2) {
      var b = a2.alternate;
      a2.return = null;
      a2.child = null;
      a2.memoizedState = null;
      a2.updateQueue = null;
      a2.dependencies = null;
      a2.alternate = null;
      a2.firstEffect = null;
      a2.lastEffect = null;
      a2.pendingProps = null;
      a2.memoizedProps = null;
      null !== b && $e(b);
    }
    function Ye(a2) {
      if (Ra) {
        a2 = a2.stateNode.containerInfo;
        var b = hb(a2);
        lb(a2, b);
      }
    }
    function af(a2) {
      return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
    }
    function bf(a2) {
      if (Qa) {
        a: {
          for (var b = a2.return; null !== b; ) {
            if (af(b)) {
              var c2 = b;
              break a;
            }
            b = b.return;
          }
          throw Error(n(160));
        }
        b = c2.stateNode;
        switch (c2.tag) {
          case 5:
            var d = false;
            break;
          case 3:
            b = b.containerInfo;
            d = true;
            break;
          case 4:
            b = b.containerInfo;
            d = true;
            break;
          default:
            throw Error(n(161));
        }
        c2.effectTag & 16 && (bb(b), c2.effectTag &= -17);
        a: b: for (c2 = a2; ; ) {
          for (; null === c2.sibling; ) {
            if (null === c2.return || af(c2.return)) {
              c2 = null;
              break a;
            }
            c2 = c2.return;
          }
          c2.sibling.return = c2.return;
          for (c2 = c2.sibling; 5 !== c2.tag && 6 !== c2.tag && 18 !== c2.tag; ) {
            if (c2.effectTag & 2) continue b;
            if (null === c2.child || 4 === c2.tag) continue b;
            else c2.child.return = c2, c2 = c2.child;
          }
          if (!(c2.effectTag & 2)) {
            c2 = c2.stateNode;
            break a;
          }
        }
        for (var e = a2; ; ) {
          var f = 5 === e.tag || 6 === e.tag;
          if (f) f = f ? e.stateNode : e.stateNode.instance, c2 ? d ? Za(b, f, c2) : Ya(b, f, c2) : d ? Ua(b, f) : Ta(b, f);
          else if (4 !== e.tag && null !== e.child) {
            e.child.return = e;
            e = e.child;
            continue;
          }
          if (e === a2) break;
          for (; null === e.sibling; ) {
            if (null === e.return || e.return === a2) return;
            e = e.return;
          }
          e.sibling.return = e.return;
          e = e.sibling;
        }
      }
    }
    function Xe(a2, b, c2) {
      for (var d = b, e = false, f, g; ; ) {
        if (!e) {
          e = d.return;
          a: for (; ; ) {
            if (null === e) throw Error(n(160));
            f = e.stateNode;
            switch (e.tag) {
              case 5:
                g = false;
                break a;
              case 3:
                f = f.containerInfo;
                g = true;
                break a;
              case 4:
                f = f.containerInfo;
                g = true;
                break a;
            }
            e = e.return;
          }
          e = true;
        }
        if (5 === d.tag || 6 === d.tag) Ze(a2, d, c2), g ? ab(f, d.stateNode) : $a(f, d.stateNode);
        else if (4 === d.tag) {
          if (null !== d.child) {
            f = d.stateNode.containerInfo;
            g = true;
            d.child.return = d;
            d = d.child;
            continue;
          }
        } else if (Ve(a2, d, c2), null !== d.child) {
          d.child.return = d;
          d = d.child;
          continue;
        }
        if (d === b) break;
        for (; null === d.sibling; ) {
          if (null === d.return || d.return === b) return;
          d = d.return;
          4 === d.tag && (e = false);
        }
        d.sibling.return = d.return;
        d = d.sibling;
      }
    }
    function cf(a2, b) {
      if (Qa) switch (b.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ue(4, 8, b);
          break;
        case 1:
          break;
        case 5:
          var c2 = b.stateNode;
          if (null != c2) {
            var d = b.memoizedProps;
            a2 = null !== a2 ? a2.memoizedProps : d;
            var e = b.type, f = b.updateQueue;
            b.updateQueue = null;
            null !== f && Xa(c2, f, e, a2, d, b);
          }
          break;
        case 6:
          if (null === b.stateNode) throw Error(n(162));
          c2 = b.memoizedProps;
          Va(b.stateNode, null !== a2 ? a2.memoizedProps : c2, c2);
          break;
        case 3:
          Sa && (b = b.stateNode, b.hydrate && (b.hydrate = false, xb(b.containerInfo)));
          break;
        case 12:
          break;
        case 13:
          df(b);
          ef(b);
          break;
        case 19:
          ef(b);
          break;
        case 17:
          break;
        case 20:
          break;
        case 21:
          break;
        default:
          throw Error(n(163));
      }
      else {
        switch (b.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            Ue(4, 8, b);
            return;
          case 12:
            return;
          case 13:
            df(b);
            ef(b);
            return;
          case 19:
            ef(b);
            return;
          case 3:
            Sa && (c2 = b.stateNode, c2.hydrate && (c2.hydrate = false, xb(c2.containerInfo)));
        }
        a: if (Ra) switch (b.tag) {
          case 1:
          case 5:
          case 6:
          case 20:
            break a;
          case 3:
          case 4:
            b = b.stateNode;
            lb(b.containerInfo, b.pendingChildren);
            break a;
          default:
            throw Error(n(163));
        }
      }
    }
    function df(a2) {
      var b = a2;
      if (null === a2.memoizedState) var c2 = false;
      else c2 = true, b = a2.child, ff = E();
      if (Qa && null !== b) {
        a: if (a2 = b, Qa) for (b = a2; ; ) {
          if (5 === b.tag) {
            var d = b.stateNode;
            c2 ? cb(d) : eb(b.stateNode, b.memoizedProps);
          } else if (6 === b.tag) d = b.stateNode, c2 ? db(d) : fb(d, b.memoizedProps);
          else if (13 === b.tag && null !== b.memoizedState && null === b.memoizedState.dehydrated) {
            d = b.child.sibling;
            d.return = b;
            b = d;
            continue;
          } else if (null !== b.child) {
            b.child.return = b;
            b = b.child;
            continue;
          }
          if (b === a2) break a;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a2) break a;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
    }
    function ef(a2) {
      var b = a2.updateQueue;
      if (null !== b) {
        a2.updateQueue = null;
        var c2 = a2.stateNode;
        null === c2 && (c2 = a2.stateNode = new Oe());
        b.forEach(function(b2) {
          var d = gf.bind(null, a2, b2);
          c2.has(b2) || (c2.add(b2), b2.then(d, d));
        });
      }
    }
    var hf = "function" === typeof WeakMap ? WeakMap : Map;
    function jf(a2, b, c2) {
      c2 = Gc(c2, null);
      c2.tag = 3;
      c2.payload = {
        element: null
      };
      var d = b.value;
      c2.callback = function() {
        kf || (kf = true, lf = d);
        Pe(a2, b);
      };
      return c2;
    }
    function mf(a2, b, c2) {
      c2 = Gc(c2, null);
      c2.tag = 3;
      var d = a2.type.getDerivedStateFromError;
      if ("function" === typeof d) {
        var e = b.value;
        c2.payload = function() {
          Pe(a2, b);
          return d(e);
        };
      }
      var f = a2.stateNode;
      null !== f && "function" === typeof f.componentDidCatch && (c2.callback = function() {
        "function" !== typeof d && (null === nf ? nf = /* @__PURE__ */ new Set([this]) : nf.add(this), Pe(a2, b));
        var c3 = b.stack;
        this.componentDidCatch(b.value, {
          componentStack: null !== c3 ? c3 : ""
        });
      });
      return c2;
    }
    var of = Math.ceil, pf = q2.ReactCurrentDispatcher, qf = q2.ReactCurrentOwner, R = 0, rf = 8, S2 = 16, sf = 32, tf = 0, uf = 1, vf = 2, wf = 3, xf = 4, yf = 5, T2 = R, U = null, V2 = null, W = 0, X = tf, zf = null, Af = 1073741823, Bf = 1073741823, Cf = null, Df = 0, Ef = false, ff = 0, Ff = 500, Y = null, kf = false, lf = null, nf = null, Gf = false, Hf = null, If = 90, Jf = null, Kf = 0, Lf = null, Mf = 0;
    function G2() {
      return (T2 & (S2 | sf)) !== R ? 1073741821 - (E() / 10 | 0) : 0 !== Mf ? Mf : Mf = 1073741821 - (E() / 10 | 0);
    }
    function Vc(a2, b, c2) {
      b = b.mode;
      if (0 === (b & 2)) return 1073741823;
      var d = fc();
      if (0 === (b & 4)) return 99 === d ? 1073741823 : 1073741822;
      if ((T2 & S2) !== R) return W;
      if (null !== c2) a2 = mc(a2, c2.timeoutMs | 0 || 5e3, 250);
      else switch (d) {
        case 99:
          a2 = 1073741823;
          break;
        case 98:
          a2 = mc(a2, 150, 100);
          break;
        case 97:
        case 96:
          a2 = mc(a2, 5e3, 250);
          break;
        case 95:
          a2 = 2;
          break;
        default:
          throw Error(n(326));
      }
      null !== U && a2 === W && --a2;
      return a2;
    }
    function Wc(a2, b) {
      if (50 < Kf) throw Kf = 0, Lf = null, Error(n(185));
      a2 = Nf(a2, b);
      if (null !== a2) {
        var c2 = fc();
        1073741823 === b ? (T2 & rf) !== R && (T2 & (S2 | sf)) === R ? Of(a2) : (Z2(a2), T2 === R && F()) : Z2(a2);
        (T2 & 4) === R || 98 !== c2 && 99 !== c2 || (null === Jf ? Jf = /* @__PURE__ */ new Map([[a2, b]]) : (c2 = Jf.get(a2), (void 0 === c2 || c2 > b) && Jf.set(a2, b)));
      }
    }
    function Nf(a2, b) {
      a2.expirationTime < b && (a2.expirationTime = b);
      var c2 = a2.alternate;
      null !== c2 && c2.expirationTime < b && (c2.expirationTime = b);
      var d = a2.return, e = null;
      if (null === d && 3 === a2.tag) e = a2.stateNode;
      else for (; null !== d; ) {
        c2 = d.alternate;
        d.childExpirationTime < b && (d.childExpirationTime = b);
        null !== c2 && c2.childExpirationTime < b && (c2.childExpirationTime = b);
        if (null === d.return && 3 === d.tag) {
          e = d.stateNode;
          break;
        }
        d = d.return;
      }
      null !== e && (U === e && (Pc(b), X === xf && Pf(e, W)), Qf(e, b));
      return e;
    }
    function Rf(a2) {
      var b = a2.lastExpiredTime;
      if (0 !== b) return b;
      b = a2.firstPendingTime;
      if (!Sf(a2, b)) return b;
      b = a2.lastPingedTime;
      a2 = a2.nextKnownPendingLevel;
      return b > a2 ? b : a2;
    }
    function Z2(a2) {
      if (0 !== a2.lastExpiredTime) a2.callbackExpirationTime = 1073741823, a2.callbackPriority = 99, a2.callbackNode = jc(Of.bind(null, a2));
      else {
        var b = Rf(a2), c2 = a2.callbackNode;
        if (0 === b) null !== c2 && (a2.callbackNode = null, a2.callbackExpirationTime = 0, a2.callbackPriority = 90);
        else {
          var d = G2();
          1073741823 === b ? d = 99 : 1 === b || 2 === b ? d = 95 : (d = 10 * (1073741821 - b) - 10 * (1073741821 - d), d = 0 >= d ? 99 : 250 >= d ? 98 : 5250 >= d ? 97 : 95);
          if (null !== c2) {
            var e = a2.callbackPriority;
            if (a2.callbackExpirationTime === b && e >= d) return;
            c2 !== $b && Ob(c2);
          }
          a2.callbackExpirationTime = b;
          a2.callbackPriority = d;
          b = 1073741823 === b ? jc(Of.bind(null, a2)) : ic(d, Tf.bind(null, a2), {
            timeout: 10 * (1073741821 - b) - E()
          });
          a2.callbackNode = b;
        }
      }
    }
    function Tf(a2, b) {
      Mf = 0;
      if (b) return b = G2(), Uf(a2, b), Z2(a2), null;
      var c2 = Rf(a2);
      if (0 !== c2) {
        b = a2.callbackNode;
        if ((T2 & (S2 | sf)) !== R) throw Error(n(327));
        Vf();
        a2 === U && c2 === W || Wf(a2, c2);
        if (null !== V2) {
          var d = T2;
          T2 |= S2;
          var e = Xf();
          do
            try {
              Yf();
              break;
            } catch (l2) {
              Zf(a2, l2);
            }
          while (1);
          wc();
          T2 = d;
          pf.current = e;
          if (X === uf) throw b = zf, Wf(a2, c2), Pf(a2, c2), Z2(a2), b;
          if (null === V2) switch (e = a2.finishedWork = a2.current.alternate, a2.finishedExpirationTime = c2, d = X, U = null, d) {
            case tf:
            case uf:
              throw Error(n(345));
            case vf:
              Uf(a2, 2 < c2 ? 2 : c2);
              break;
            case wf:
              Pf(a2, c2);
              d = a2.lastSuspendedTime;
              c2 === d && (a2.nextKnownPendingLevel = $f(e));
              if (1073741823 === Af && (e = ff + Ff - E(), 10 < e)) {
                if (Ef) {
                  var f = a2.lastPingedTime;
                  if (0 === f || f >= c2) {
                    a2.lastPingedTime = c2;
                    Wf(a2, c2);
                    break;
                  }
                }
                f = Rf(a2);
                if (0 !== f && f !== c2) break;
                if (0 !== d && d !== c2) {
                  a2.lastPingedTime = d;
                  break;
                }
                a2.timeoutHandle = Ma(ag.bind(null, a2), e);
                break;
              }
              ag(a2);
              break;
            case xf:
              Pf(a2, c2);
              d = a2.lastSuspendedTime;
              c2 === d && (a2.nextKnownPendingLevel = $f(e));
              if (Ef && (e = a2.lastPingedTime, 0 === e || e >= c2)) {
                a2.lastPingedTime = c2;
                Wf(a2, c2);
                break;
              }
              e = Rf(a2);
              if (0 !== e && e !== c2) break;
              if (0 !== d && d !== c2) {
                a2.lastPingedTime = d;
                break;
              }
              1073741823 !== Bf ? d = 10 * (1073741821 - Bf) - E() : 1073741823 === Af ? d = 0 : (d = 10 * (1073741821 - Af) - 5e3, e = E(), c2 = 10 * (1073741821 - c2) - e, d = e - d, 0 > d && (d = 0), d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * of(d / 1960)) - d, c2 < d && (d = c2));
              if (10 < d) {
                a2.timeoutHandle = Ma(ag.bind(null, a2), d);
                break;
              }
              ag(a2);
              break;
            case yf:
              if (1073741823 !== Af && null !== Cf) {
                f = Af;
                var g = Cf;
                d = g.busyMinDurationMs | 0;
                0 >= d ? d = 0 : (e = g.busyDelayMs | 0, f = E() - (10 * (1073741821 - f) - (g.timeoutMs | 0 || 5e3)), d = f <= e ? 0 : e + d - f);
                if (10 < d) {
                  Pf(a2, c2);
                  a2.timeoutHandle = Ma(ag.bind(null, a2), d);
                  break;
                }
              }
              ag(a2);
              break;
            default:
              throw Error(n(329));
          }
          Z2(a2);
          if (a2.callbackNode === b) return Tf.bind(null, a2);
        }
      }
      return null;
    }
    function Of(a2) {
      var b = a2.lastExpiredTime;
      b = 0 !== b ? b : 1073741823;
      if (a2.finishedExpirationTime === b) ag(a2);
      else {
        if ((T2 & (S2 | sf)) !== R) throw Error(n(327));
        Vf();
        a2 === U && b === W || Wf(a2, b);
        if (null !== V2) {
          var c2 = T2;
          T2 |= S2;
          var d = Xf();
          do
            try {
              bg();
              break;
            } catch (e) {
              Zf(a2, e);
            }
          while (1);
          wc();
          T2 = c2;
          pf.current = d;
          if (X === uf) throw c2 = zf, Wf(a2, b), Pf(a2, b), Z2(a2), c2;
          if (null !== V2) throw Error(n(261));
          a2.finishedWork = a2.current.alternate;
          a2.finishedExpirationTime = b;
          U = null;
          ag(a2);
          Z2(a2);
        }
      }
      return null;
    }
    function cg(a2, b) {
      Uf(a2, b);
      Z2(a2);
      (T2 & (S2 | sf)) === R && F();
    }
    function dg() {
      if (null !== Jf) {
        var a2 = Jf;
        Jf = null;
        a2.forEach(function(a3, c2) {
          Uf(c2, a3);
          Z2(c2);
        });
        F();
      }
    }
    function eg(a2, b) {
      if ((T2 & (S2 | sf)) !== R) throw Error(n(187));
      var c2 = T2;
      T2 |= 1;
      try {
        return hc(99, a2.bind(null, b));
      } finally {
        T2 = c2, F();
      }
    }
    function Wf(a2, b) {
      a2.finishedWork = null;
      a2.finishedExpirationTime = 0;
      var c2 = a2.timeoutHandle;
      c2 !== Oa && (a2.timeoutHandle = Oa, Na(c2));
      if (null !== V2) for (c2 = V2.return; null !== c2; ) {
        var d = c2;
        switch (d.tag) {
          case 1:
            var e = d.type.childContextTypes;
            null !== e && void 0 !== e && Gb();
            break;
          case 3:
            rd();
            Hb();
            break;
          case 5:
            td(d);
            break;
          case 4:
            rd();
            break;
          case 13:
            y(I);
            break;
          case 19:
            y(I);
            break;
          case 10:
            yc(d);
        }
        c2 = c2.return;
      }
      U = a2;
      V2 = fd(a2.current, null);
      W = b;
      X = tf;
      zf = null;
      Bf = Af = 1073741823;
      Cf = null;
      Df = 0;
      Ef = false;
    }
    function Zf(a2, b) {
      do {
        try {
          wc();
          Nd();
          if (null === V2 || null === V2.return) return X = uf, zf = b, null;
          a: {
            var c2 = a2, d = V2.return, e = V2, f = b;
            b = W;
            e.effectTag |= 2048;
            e.firstEffect = e.lastEffect = null;
            if (null !== f && "object" === typeof f && "function" === typeof f.then) {
              var g = f, l2 = 0 !== (I.current & 1), h2 = d;
              do {
                var k;
                if (k = 13 === h2.tag) {
                  var p = h2.memoizedState;
                  if (null !== p) k = null !== p.dehydrated ? true : false;
                  else {
                    var D = h2.memoizedProps;
                    k = void 0 === D.fallback ? false : true !== D.unstable_avoidThisFallback ? true : l2 ? false : true;
                  }
                }
                if (k) {
                  var x = h2.updateQueue;
                  if (null === x) {
                    var K = /* @__PURE__ */ new Set();
                    K.add(g);
                    h2.updateQueue = K;
                  } else x.add(g);
                  if (0 === (h2.mode & 2)) {
                    h2.effectTag |= 64;
                    e.effectTag &= -2981;
                    if (1 === e.tag) if (null === e.alternate) e.tag = 17;
                    else {
                      var Ha = Gc(1073741823, null);
                      Ha.tag = 2;
                      Ic(e, Ha);
                    }
                    e.expirationTime = 1073741823;
                    break a;
                  }
                  f = void 0;
                  e = b;
                  var O = c2.pingCache;
                  null === O ? (O = c2.pingCache = new hf(), f = /* @__PURE__ */ new Set(), O.set(g, f)) : (f = O.get(g), void 0 === f && (f = /* @__PURE__ */ new Set(), O.set(g, f)));
                  if (!f.has(e)) {
                    f.add(e);
                    var w = fg.bind(null, c2, g, e);
                    g.then(w, w);
                  }
                  h2.effectTag |= 4096;
                  h2.expirationTime = b;
                  break a;
                }
                h2 = h2.return;
              } while (null !== h2);
              f = Error((ta(e.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + Ab(e));
            }
            X !== yf && (X = vf);
            f = Ne(f, e);
            h2 = d;
            do {
              switch (h2.tag) {
                case 3:
                  g = f;
                  h2.effectTag |= 4096;
                  h2.expirationTime = b;
                  var r = jf(h2, g, b);
                  Jc(h2, r);
                  break a;
                case 1:
                  g = f;
                  var t2 = h2.type, N = h2.stateNode;
                  if (0 === (h2.effectTag & 64) && ("function" === typeof t2.getDerivedStateFromError || null !== N && "function" === typeof N.componentDidCatch && (null === nf || !nf.has(N)))) {
                    h2.effectTag |= 4096;
                    h2.expirationTime = b;
                    var Mc = mf(h2, g, b);
                    Jc(h2, Mc);
                    break a;
                  }
              }
              h2 = h2.return;
            } while (null !== h2);
          }
          V2 = gg(V2);
        } catch (Rb) {
          b = Rb;
          continue;
        }
        break;
      } while (1);
    }
    function Xf() {
      var a2 = pf.current;
      pf.current = Md;
      return null === a2 ? Md : a2;
    }
    function Oc(a2, b) {
      a2 < Af && 2 < a2 && (Af = a2);
      null !== b && a2 < Bf && 2 < a2 && (Bf = a2, Cf = b);
    }
    function Pc(a2) {
      a2 > Df && (Df = a2);
    }
    function bg() {
      for (; null !== V2; ) V2 = hg(V2);
    }
    function Yf() {
      for (; null !== V2 && !Pb(); ) V2 = hg(V2);
    }
    function hg(a2) {
      var b = ig(a2.alternate, a2, W);
      a2.memoizedProps = a2.pendingProps;
      null === b && (b = gg(a2));
      qf.current = null;
      return b;
    }
    function gg(a2) {
      V2 = a2;
      do {
        var b = V2.alternate;
        a2 = V2.return;
        if (0 === (V2.effectTag & 2048)) {
          a: {
            var c2 = b;
            b = V2;
            var d = W, e = b.pendingProps;
            switch (b.tag) {
              case 2:
                break;
              case 16:
                break;
              case 15:
              case 0:
                break;
              case 1:
                C2(b.type) && Gb();
                break;
              case 3:
                rd();
                Hb();
                e = b.stateNode;
                e.pendingContext && (e.context = e.pendingContext, e.pendingContext = null);
                (null === c2 || null === c2.child) && ne(b) && Fe(b);
                He(b);
                break;
              case 5:
                td(b);
                var f = pd(od.current);
                d = b.type;
                if (null !== c2 && null != b.stateNode) Ie(c2, b, d, e, f), c2.ref !== b.ref && (b.effectTag |= 128);
                else if (e) {
                  c2 = pd(H2.current);
                  if (ne(b)) {
                    e = b;
                    if (!Sa) throw Error(n(175));
                    c2 = ub(e.stateNode, e.type, e.memoizedProps, f, c2, e);
                    e.updateQueue = c2;
                    c2 = null !== c2 ? true : false;
                    c2 && Fe(b);
                  } else {
                    var g = Ea(d, e, f, c2, b);
                    _Ge(g, b, false, false);
                    b.stateNode = g;
                    Ga(g, d, e, f, c2) && Fe(b);
                  }
                  null !== b.ref && (b.effectTag |= 128);
                } else if (null === b.stateNode) throw Error(n(166));
                break;
              case 6:
                if (c2 && null != b.stateNode) Je(c2, b, c2.memoizedProps, e);
                else {
                  if ("string" !== typeof e && null === b.stateNode) throw Error(n(166));
                  c2 = pd(od.current);
                  f = pd(H2.current);
                  if (ne(b)) {
                    c2 = b;
                    if (!Sa) throw Error(n(176));
                    (c2 = vb(c2.stateNode, c2.memoizedProps, c2)) && Fe(b);
                  } else b.stateNode = La(e, c2, f, b);
                }
                break;
              case 11:
                break;
              case 13:
                y(I);
                e = b.memoizedState;
                if (0 !== (b.effectTag & 64)) {
                  b.expirationTime = d;
                  break a;
                }
                e = null !== e;
                f = false;
                null === c2 ? void 0 !== b.memoizedProps.fallback && ne(b) : (d = c2.memoizedState, f = null !== d, e || null === d || (d = c2.child.sibling, null !== d && (g = b.firstEffect, null !== g ? (b.firstEffect = d, d.nextEffect = g) : (b.firstEffect = b.lastEffect = d, d.nextEffect = null), d.effectTag = 8)));
                if (e && !f && 0 !== (b.mode & 2)) if (null === c2 && true !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (I.current & 1)) X === tf && (X = wf);
                else {
                  if (X === tf || X === wf) X = xf;
                  0 !== Df && null !== U && (Pf(U, W), Qf(U, Df));
                }
                Ra && e && (b.effectTag |= 4);
                Qa && (e || f) && (b.effectTag |= 4);
                break;
              case 7:
                break;
              case 8:
                break;
              case 12:
                break;
              case 4:
                rd();
                He(b);
                break;
              case 10:
                yc(b);
                break;
              case 9:
                break;
              case 14:
                break;
              case 17:
                C2(b.type) && Gb();
                break;
              case 19:
                y(I);
                e = b.memoizedState;
                if (null === e) break;
                f = 0 !== (b.effectTag & 64);
                g = e.rendering;
                if (null === g) {
                  if (f) Le(e, false);
                  else {
                    if (X !== tf || null !== c2 && 0 !== (c2.effectTag & 64)) for (c2 = b.child; null !== c2; ) {
                      g = ud(c2);
                      if (null !== g) {
                        b.effectTag |= 64;
                        Le(e, false);
                        c2 = g.updateQueue;
                        null !== c2 && (b.updateQueue = c2, b.effectTag |= 4);
                        null === e.lastEffect && (b.firstEffect = null);
                        b.lastEffect = e.lastEffect;
                        c2 = d;
                        for (e = b.child; null !== e; ) f = e, d = c2, f.effectTag &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, null === g ? (f.childExpirationTime = 0, f.expirationTime = d, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null) : (f.childExpirationTime = g.childExpirationTime, f.expirationTime = g.expirationTime, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, d = g.dependencies, f.dependencies = null === d ? null : {
                          expirationTime: d.expirationTime,
                          firstContext: d.firstContext,
                          responders: d.responders
                        }), e = e.sibling;
                        z2(I, I.current & 1 | 2);
                        b = b.child;
                        break a;
                      }
                      c2 = c2.sibling;
                    }
                  }
                } else {
                  if (!f) if (c2 = ud(g), null !== c2) {
                    if (b.effectTag |= 64, f = true, c2 = c2.updateQueue, null !== c2 && (b.updateQueue = c2, b.effectTag |= 4), Le(e, true), null === e.tail && "hidden" === e.tailMode) {
                      b = b.lastEffect = e.lastEffect;
                      null !== b && (b.nextEffect = null);
                      break;
                    }
                  } else E() > e.tailExpiration && 1 < d && (b.effectTag |= 64, f = true, Le(e, false), b.expirationTime = b.childExpirationTime = d - 1);
                  e.isBackwards ? (g.sibling = b.child, b.child = g) : (c2 = e.last, null !== c2 ? c2.sibling = g : b.child = g, e.last = g);
                }
                if (null !== e.tail) {
                  0 === e.tailExpiration && (e.tailExpiration = E() + 500);
                  c2 = e.tail;
                  e.rendering = c2;
                  e.tail = c2.sibling;
                  e.lastEffect = b.lastEffect;
                  c2.sibling = null;
                  e = I.current;
                  e = f ? e & 1 | 2 : e & 1;
                  z2(I, e);
                  b = c2;
                  break a;
                }
                break;
              case 20:
                break;
              case 21:
                break;
              default:
                throw Error(n(156, b.tag));
            }
            b = null;
          }
          c2 = V2;
          if (1 === W || 1 !== c2.childExpirationTime) {
            e = 0;
            for (f = c2.child; null !== f; ) d = f.expirationTime, g = f.childExpirationTime, d > e && (e = d), g > e && (e = g), f = f.sibling;
            c2.childExpirationTime = e;
          }
          if (null !== b) return b;
          null !== a2 && 0 === (a2.effectTag & 2048) && (null === a2.firstEffect && (a2.firstEffect = V2.firstEffect), null !== V2.lastEffect && (null !== a2.lastEffect && (a2.lastEffect.nextEffect = V2.firstEffect), a2.lastEffect = V2.lastEffect), 1 < V2.effectTag && (null !== a2.lastEffect ? a2.lastEffect.nextEffect = V2 : a2.firstEffect = V2, a2.lastEffect = V2));
        } else {
          b = Me(V2);
          if (null !== b) return b.effectTag &= 2047, b;
          null !== a2 && (a2.firstEffect = a2.lastEffect = null, a2.effectTag |= 2048);
        }
        b = V2.sibling;
        if (null !== b) return b;
        V2 = a2;
      } while (null !== V2);
      X === tf && (X = yf);
      return null;
    }
    function $f(a2) {
      var b = a2.expirationTime;
      a2 = a2.childExpirationTime;
      return b > a2 ? b : a2;
    }
    function ag(a2) {
      var b = fc();
      hc(99, jg.bind(null, a2, b));
      return null;
    }
    function jg(a2, b) {
      Vf();
      if ((T2 & (S2 | sf)) !== R) throw Error(n(327));
      var c2 = a2.finishedWork, d = a2.finishedExpirationTime;
      if (null === c2) return null;
      a2.finishedWork = null;
      a2.finishedExpirationTime = 0;
      if (c2 === a2.current) throw Error(n(177));
      a2.callbackNode = null;
      a2.callbackExpirationTime = 0;
      a2.callbackPriority = 90;
      a2.nextKnownPendingLevel = 0;
      var e = $f(c2);
      a2.firstPendingTime = e;
      d <= a2.lastSuspendedTime ? a2.firstSuspendedTime = a2.lastSuspendedTime = a2.nextKnownPendingLevel = 0 : d <= a2.firstSuspendedTime && (a2.firstSuspendedTime = d - 1);
      d <= a2.lastPingedTime && (a2.lastPingedTime = 0);
      d <= a2.lastExpiredTime && (a2.lastExpiredTime = 0);
      a2 === U && (V2 = U = null, W = 0);
      1 < c2.effectTag ? null !== c2.lastEffect ? (c2.lastEffect.nextEffect = c2, e = c2.firstEffect) : e = c2 : e = c2.firstEffect;
      if (null !== e) {
        var f = T2;
        T2 |= sf;
        qf.current = null;
        Ca(a2.containerInfo);
        Y = e;
        do
          try {
            kg();
          } catch (jb) {
            if (null === Y) throw Error(n(330));
            Re(Y, jb);
            Y = Y.nextEffect;
          }
        while (null !== Y);
        Y = e;
        do
          try {
            for (var g = a2, l2 = b; null !== Y; ) {
              var h2 = Y.effectTag;
              h2 & 16 && Qa && bb(Y.stateNode);
              if (h2 & 128) {
                var k = Y.alternate;
                if (null !== k) {
                  var p = k.ref;
                  null !== p && ("function" === typeof p ? p(null) : p.current = null);
                }
              }
              switch (h2 & 1038) {
                case 2:
                  bf(Y);
                  Y.effectTag &= -3;
                  break;
                case 6:
                  bf(Y);
                  Y.effectTag &= -3;
                  cf(Y.alternate, Y);
                  break;
                case 1024:
                  Y.effectTag &= -1025;
                  break;
                case 1028:
                  Y.effectTag &= -1025;
                  cf(Y.alternate, Y);
                  break;
                case 4:
                  cf(Y.alternate, Y);
                  break;
                case 8:
                  var D = g, x = Y, K = l2;
                  Qa ? Xe(D, x, K) : Ze(D, x, K);
                  $e(x);
              }
              Y = Y.nextEffect;
            }
          } catch (jb) {
            if (null === Y) throw Error(n(330));
            Re(Y, jb);
            Y = Y.nextEffect;
          }
        while (null !== Y);
        Da(a2.containerInfo);
        a2.current = c2;
        Y = e;
        do
          try {
            for (h2 = d; null !== Y; ) {
              var Ha = Y.effectTag;
              if (Ha & 36) {
                var O = Y.alternate;
                k = Y;
                p = h2;
                switch (k.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Ue(16, 32, k);
                    break;
                  case 1:
                    var w = k.stateNode;
                    if (k.effectTag & 4) if (null === O) w.componentDidMount();
                    else {
                      var r = k.elementType === k.type ? O.memoizedProps : rc(k.type, O.memoizedProps);
                      w.componentDidUpdate(r, O.memoizedState, w.__reactInternalSnapshotBeforeUpdate);
                    }
                    var t2 = k.updateQueue;
                    null !== t2 && Qc(k, t2, w, p);
                    break;
                  case 3:
                    var N = k.updateQueue;
                    if (null !== N) {
                      g = null;
                      if (null !== k.child) switch (k.child.tag) {
                        case 5:
                          g = za(k.child.stateNode);
                          break;
                        case 1:
                          g = k.child.stateNode;
                      }
                      Qc(k, N, g, p);
                    }
                    break;
                  case 5:
                    var Mc = k.stateNode;
                    null === O && k.effectTag & 4 && Wa(Mc, k.type, k.memoizedProps, k);
                    break;
                  case 6:
                    break;
                  case 4:
                    break;
                  case 12:
                    break;
                  case 13:
                    if (Sa && null === k.memoizedState) {
                      var Rb = k.alternate;
                      if (null !== Rb) {
                        var le = Rb.memoizedState;
                        if (null !== le) {
                          var me = le.dehydrated;
                          null !== me && yb(me);
                        }
                      }
                    }
                    break;
                  case 19:
                  case 17:
                  case 20:
                  case 21:
                    break;
                  default:
                    throw Error(n(163));
                }
              }
              if (Ha & 128) {
                k = void 0;
                var Sb = Y.ref;
                if (null !== Sb) {
                  var v2 = Y.stateNode;
                  switch (Y.tag) {
                    case 5:
                      k = za(v2);
                      break;
                    default:
                      k = v2;
                  }
                  "function" === typeof Sb ? Sb(k) : Sb.current = k;
                }
              }
              Y = Y.nextEffect;
            }
          } catch (jb) {
            if (null === Y) throw Error(n(330));
            Re(Y, jb);
            Y = Y.nextEffect;
          }
        while (null !== Y);
        Y = null;
        ac();
        T2 = f;
      } else a2.current = c2;
      if (Gf) Gf = false, Hf = a2, If = b;
      else for (Y = e; null !== Y; ) b = Y.nextEffect, Y.nextEffect = null, Y = b;
      b = a2.firstPendingTime;
      0 === b && (nf = null);
      1073741823 === b ? a2 === Lf ? Kf++ : (Kf = 0, Lf = a2) : Kf = 0;
      "function" === typeof lg && lg(c2.stateNode, d);
      Z2(a2);
      if (kf) throw kf = false, a2 = lf, lf = null, a2;
      if ((T2 & rf) !== R) return null;
      F();
      return null;
    }
    function kg() {
      for (; null !== Y; ) {
        var a2 = Y.effectTag;
        0 !== (a2 & 256) && Te(Y.alternate, Y);
        0 === (a2 & 512) || Gf || (Gf = true, ic(97, function() {
          Vf();
          return null;
        }));
        Y = Y.nextEffect;
      }
    }
    function Vf() {
      if (90 !== If) {
        var a2 = 97 < If ? 97 : If;
        If = 90;
        return hc(a2, mg);
      }
    }
    function mg() {
      if (null === Hf) return false;
      var a2 = Hf;
      Hf = null;
      if ((T2 & (S2 | sf)) !== R) throw Error(n(331));
      var b = T2;
      T2 |= sf;
      for (a2 = a2.current.firstEffect; null !== a2; ) {
        try {
          var c2 = a2;
          if (0 !== (c2.effectTag & 512)) switch (c2.tag) {
            case 0:
            case 11:
            case 15:
              Ue(128, 0, c2), Ue(0, 64, c2);
          }
        } catch (d) {
          if (null === a2) throw Error(n(330));
          Re(a2, d);
        }
        c2 = a2.nextEffect;
        a2.nextEffect = null;
        a2 = c2;
      }
      T2 = b;
      F();
      return true;
    }
    function ng(a2, b, c2) {
      b = Ne(c2, b);
      b = jf(a2, b, 1073741823);
      Ic(a2, b);
      a2 = Nf(a2, 1073741823);
      null !== a2 && Z2(a2);
    }
    function Re(a2, b) {
      if (3 === a2.tag) ng(a2, a2, b);
      else for (var c2 = a2.return; null !== c2; ) {
        if (3 === c2.tag) {
          ng(c2, a2, b);
          break;
        } else if (1 === c2.tag) {
          var d = c2.stateNode;
          if ("function" === typeof c2.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === nf || !nf.has(d))) {
            a2 = Ne(b, a2);
            a2 = mf(c2, a2, 1073741823);
            Ic(c2, a2);
            c2 = Nf(c2, 1073741823);
            null !== c2 && Z2(c2);
            break;
          }
        }
        c2 = c2.return;
      }
    }
    function fg(a2, b, c2) {
      var d = a2.pingCache;
      null !== d && d.delete(b);
      U === a2 && W === c2 ? X === xf || X === wf && 1073741823 === Af && E() - ff < Ff ? Wf(a2, W) : Ef = true : Sf(a2, c2) && (b = a2.lastPingedTime, 0 !== b && b < c2 || (a2.lastPingedTime = c2, a2.finishedExpirationTime === c2 && (a2.finishedExpirationTime = 0, a2.finishedWork = null), Z2(a2)));
    }
    function gf(a2, b) {
      var c2 = a2.stateNode;
      null !== c2 && c2.delete(b);
      b = 0;
      0 === b && (b = G2(), b = Vc(b, a2, null));
      a2 = Nf(a2, b);
      null !== a2 && Z2(a2);
    }
    var ig;
    ig = function ig2(a2, b, c2) {
      var d = b.expirationTime;
      if (null !== a2) {
        var e = b.pendingProps;
        if (a2.memoizedProps !== e || B.current) Bc = true;
        else {
          if (d < c2) {
            Bc = false;
            switch (b.tag) {
              case 3:
                ze(b);
                oe();
                break;
              case 5:
                sd(b);
                if (b.mode & 4 && 1 !== c2 && Ka(b.type, e)) return b.expirationTime = b.childExpirationTime = 1, null;
                break;
              case 1:
                C2(b.type) && Kb(b);
                break;
              case 4:
                qd(b, b.stateNode.containerInfo);
                break;
              case 10:
                xc(b, b.memoizedProps.value);
                break;
              case 13:
                if (null !== b.memoizedState) {
                  d = b.child.childExpirationTime;
                  if (0 !== d && d >= c2) return Be(a2, b, c2);
                  z2(I, I.current & 1);
                  b = re(a2, b, c2);
                  return null !== b ? b.sibling : null;
                }
                z2(I, I.current & 1);
                break;
              case 19:
                d = b.childExpirationTime >= c2;
                if (0 !== (a2.effectTag & 64)) {
                  if (d) return Ee(a2, b, c2);
                  b.effectTag |= 64;
                }
                e = b.memoizedState;
                null !== e && (e.rendering = null, e.tail = null);
                z2(I, I.current);
                if (!d) return null;
            }
            return re(a2, b, c2);
          }
          Bc = false;
        }
      } else Bc = false;
      b.expirationTime = 0;
      switch (b.tag) {
        case 2:
          d = b.type;
          null !== a2 && (a2.alternate = null, b.alternate = null, b.effectTag |= 2);
          a2 = b.pendingProps;
          e = Fb(b, A2.current);
          Ac(b, c2);
          e = Jd(null, b, d, a2, e, c2);
          b.effectTag |= 1;
          if ("object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
            b.tag = 1;
            Nd();
            if (C2(d)) {
              var f = true;
              Kb(b);
            } else f = false;
            b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;
            var g = d.getDerivedStateFromProps;
            "function" === typeof g && Uc(b, d, g, a2);
            e.updater = Xc;
            b.stateNode = e;
            e._reactInternalFiber = b;
            ad(b, d, a2, c2);
            b = ye(null, b, d, true, f, c2);
          } else b.tag = 0, Q2(null, b, e, c2), b = b.child;
          return b;
        case 16:
          e = b.elementType;
          null !== a2 && (a2.alternate = null, b.alternate = null, b.effectTag |= 2);
          a2 = b.pendingProps;
          sa(e);
          if (1 !== e._status) throw e._result;
          e = e._result;
          b.type = e;
          f = b.tag = og(e);
          a2 = rc(e, a2);
          switch (f) {
            case 0:
              b = ve(null, b, e, a2, c2);
              break;
            case 1:
              b = xe(null, b, e, a2, c2);
              break;
            case 11:
              b = qe(null, b, e, a2, c2);
              break;
            case 14:
              b = se(null, b, e, rc(e.type, a2), d, c2);
              break;
            default:
              throw Error(n(306, e, ""));
          }
          return b;
        case 0:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), ve(a2, b, d, e, c2);
        case 1:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), xe(a2, b, d, e, c2);
        case 3:
          ze(b);
          d = b.updateQueue;
          if (null === d) throw Error(n(282));
          e = b.memoizedState;
          e = null !== e ? e.element : null;
          Nc(b, d, b.pendingProps, null, c2);
          d = b.memoizedState.element;
          if (d === e) oe(), b = re(a2, b, c2);
          else {
            if (e = b.stateNode.hydrate) Sa ? (ee = tb(b.stateNode.containerInfo), de = b, e = fe = true) : e = false;
            if (e) for (c2 = ld(b, null, d, c2), b.child = c2; c2; ) c2.effectTag = c2.effectTag & -3 | 1024, c2 = c2.sibling;
            else Q2(a2, b, d, c2), oe();
            b = b.child;
          }
          return b;
        case 5:
          return sd(b), null === a2 && je(b), d = b.type, e = b.pendingProps, f = null !== a2 ? a2.memoizedProps : null, g = e.children, Ja(d, e) ? g = null : null !== f && Ja(d, f) && (b.effectTag |= 16), we(a2, b), b.mode & 4 && 1 !== c2 && Ka(d, e) ? (b.expirationTime = b.childExpirationTime = 1, b = null) : (Q2(a2, b, g, c2), b = b.child), b;
        case 6:
          return null === a2 && je(b), null;
        case 13:
          return Be(a2, b, c2);
        case 4:
          return qd(b, b.stateNode.containerInfo), d = b.pendingProps, null === a2 ? b.child = kd(b, null, d, c2) : Q2(a2, b, d, c2), b.child;
        case 11:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), qe(a2, b, d, e, c2);
        case 7:
          return Q2(a2, b, b.pendingProps, c2), b.child;
        case 8:
          return Q2(a2, b, b.pendingProps.children, c2), b.child;
        case 12:
          return Q2(a2, b, b.pendingProps.children, c2), b.child;
        case 10:
          a: {
            d = b.type._context;
            e = b.pendingProps;
            g = b.memoizedProps;
            f = e.value;
            xc(b, f);
            if (null !== g) {
              var l2 = g.value;
              f = oc(l2, f) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(l2, f) : 1073741823) | 0;
              if (0 === f) {
                if (g.children === e.children && !B.current) {
                  b = re(a2, b, c2);
                  break a;
                }
              } else for (l2 = b.child, null !== l2 && (l2.return = b); null !== l2; ) {
                var h2 = l2.dependencies;
                if (null !== h2) {
                  g = l2.child;
                  for (var k = h2.firstContext; null !== k; ) {
                    if (k.context === d && 0 !== (k.observedBits & f)) {
                      1 === l2.tag && (k = Gc(c2, null), k.tag = 2, Ic(l2, k));
                      l2.expirationTime < c2 && (l2.expirationTime = c2);
                      k = l2.alternate;
                      null !== k && k.expirationTime < c2 && (k.expirationTime = c2);
                      zc(l2.return, c2);
                      h2.expirationTime < c2 && (h2.expirationTime = c2);
                      break;
                    }
                    k = k.next;
                  }
                } else g = 10 === l2.tag ? l2.type === b.type ? null : l2.child : l2.child;
                if (null !== g) g.return = l2;
                else for (g = l2; null !== g; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  l2 = g.sibling;
                  if (null !== l2) {
                    l2.return = g.return;
                    g = l2;
                    break;
                  }
                  g = g.return;
                }
                l2 = g;
              }
            }
            Q2(a2, b, e.children, c2);
            b = b.child;
          }
          return b;
        case 9:
          return e = b.type, f = b.pendingProps, d = f.children, Ac(b, c2), e = Cc(e, f.unstable_observedBits), d = d(e), b.effectTag |= 1, Q2(a2, b, d, c2), b.child;
        case 14:
          return e = b.type, f = rc(e, b.pendingProps), f = rc(e.type, f), se(a2, b, e, f, d, c2);
        case 15:
          return ue(a2, b, b.type, b.pendingProps, d, c2);
        case 17:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), null !== a2 && (a2.alternate = null, b.alternate = null, b.effectTag |= 2), b.tag = 1, C2(d) ? (a2 = true, Kb(b)) : a2 = false, Ac(b, c2), Zc(b, d, e), ad(b, d, e, c2), ye(null, b, d, true, a2, c2);
        case 19:
          return Ee(a2, b, c2);
      }
      throw Error(n(156, b.tag));
    };
    var lg = null, We = null;
    function pg(a2) {
      if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
      var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (b.isDisabled || !b.supportsFiber) return true;
      try {
        var c2 = b.inject(a2);
        lg = function lg2(a3) {
          try {
            b.onCommitFiberRoot(c2, a3, void 0, 64 === (a3.current.effectTag & 64));
          } catch (e) {
          }
        };
        We = function We2(a3) {
          try {
            b.onCommitFiberUnmount(c2, a3);
          } catch (e) {
          }
        };
      } catch (d) {
      }
      return true;
    }
    function qg(a2, b, c2, d) {
      this.tag = a2;
      this.key = c2;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d;
      this.effectTag = 0;
      this.lastEffect = this.firstEffect = this.nextEffect = null;
      this.childExpirationTime = this.expirationTime = 0;
      this.alternate = null;
    }
    function he(a2, b, c2, d) {
      return new qg(a2, b, c2, d);
    }
    function te(a2) {
      a2 = a2.prototype;
      return !(!a2 || !a2.isReactComponent);
    }
    function og(a2) {
      if ("function" === typeof a2) return te(a2) ? 1 : 0;
      if (void 0 !== a2 && null !== a2) {
        a2 = a2.$$typeof;
        if (a2 === la) return 11;
        if (a2 === oa) return 14;
      }
      return 2;
    }
    function fd(a2, b) {
      var c2 = a2.alternate;
      null === c2 ? (c2 = he(a2.tag, b, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b, c2.effectTag = 0, c2.nextEffect = null, c2.firstEffect = null, c2.lastEffect = null);
      c2.childExpirationTime = a2.childExpirationTime;
      c2.expirationTime = a2.expirationTime;
      c2.child = a2.child;
      c2.memoizedProps = a2.memoizedProps;
      c2.memoizedState = a2.memoizedState;
      c2.updateQueue = a2.updateQueue;
      b = a2.dependencies;
      c2.dependencies = null === b ? null : {
        expirationTime: b.expirationTime,
        firstContext: b.firstContext,
        responders: b.responders
      };
      c2.sibling = a2.sibling;
      c2.index = a2.index;
      c2.ref = a2.ref;
      return c2;
    }
    function hd(a2, b, c2, d, e, f) {
      var g = 2;
      d = a2;
      if ("function" === typeof a2) te(a2) && (g = 1);
      else if ("string" === typeof a2) g = 5;
      else a: switch (a2) {
        case ea:
          return jd(c2.children, e, f, b);
        case ka:
          g = 8;
          e |= 7;
          break;
        case fa:
          g = 8;
          e |= 1;
          break;
        case ha:
          return a2 = he(12, c2, b, e | 8), a2.elementType = ha, a2.type = ha, a2.expirationTime = f, a2;
        case ma:
          return a2 = he(13, c2, b, e), a2.type = ma, a2.elementType = ma, a2.expirationTime = f, a2;
        case na:
          return a2 = he(19, c2, b, e), a2.elementType = na, a2.expirationTime = f, a2;
        default:
          if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
            case ia:
              g = 10;
              break a;
            case ja:
              g = 9;
              break a;
            case la:
              g = 11;
              break a;
            case oa:
              g = 14;
              break a;
            case pa:
              g = 16;
              d = null;
              break a;
          }
          throw Error(n(130, null == a2 ? a2 : typeof a2, ""));
      }
      b = he(g, c2, b, e);
      b.elementType = a2;
      b.type = d;
      b.expirationTime = f;
      return b;
    }
    function jd(a2, b, c2, d) {
      a2 = he(7, a2, d, b);
      a2.expirationTime = c2;
      return a2;
    }
    function gd(a2, b, c2) {
      a2 = he(6, a2, null, b);
      a2.expirationTime = c2;
      return a2;
    }
    function id(a2, b, c2) {
      b = he(4, null !== a2.children ? a2.children : [], a2.key, b);
      b.expirationTime = c2;
      b.stateNode = {
        containerInfo: a2.containerInfo,
        pendingChildren: null,
        implementation: a2.implementation
      };
      return b;
    }
    function rg(a2, b, c2) {
      this.tag = b;
      this.current = null;
      this.containerInfo = a2;
      this.pingCache = this.pendingChildren = null;
      this.finishedExpirationTime = 0;
      this.finishedWork = null;
      this.timeoutHandle = Oa;
      this.pendingContext = this.context = null;
      this.hydrate = c2;
      this.callbackNode = null;
      this.callbackPriority = 90;
      this.lastExpiredTime = this.lastPingedTime = this.nextKnownPendingLevel = this.lastSuspendedTime = this.firstSuspendedTime = this.firstPendingTime = 0;
    }
    function Sf(a2, b) {
      var c2 = a2.firstSuspendedTime;
      a2 = a2.lastSuspendedTime;
      return 0 !== c2 && c2 >= b && a2 <= b;
    }
    function Pf(a2, b) {
      var c2 = a2.firstSuspendedTime, d = a2.lastSuspendedTime;
      c2 < b && (a2.firstSuspendedTime = b);
      if (d > b || 0 === c2) a2.lastSuspendedTime = b;
      b <= a2.lastPingedTime && (a2.lastPingedTime = 0);
      b <= a2.lastExpiredTime && (a2.lastExpiredTime = 0);
    }
    function Qf(a2, b) {
      b > a2.firstPendingTime && (a2.firstPendingTime = b);
      var c2 = a2.firstSuspendedTime;
      0 !== c2 && (b >= c2 ? a2.firstSuspendedTime = a2.lastSuspendedTime = a2.nextKnownPendingLevel = 0 : b >= a2.lastSuspendedTime && (a2.lastSuspendedTime = b + 1), b > a2.nextKnownPendingLevel && (a2.nextKnownPendingLevel = b));
    }
    function Uf(a2, b) {
      var c2 = a2.lastExpiredTime;
      if (0 === c2 || c2 > b) a2.lastExpiredTime = b;
    }
    function sg(a2) {
      var b = a2._reactInternalFiber;
      if (void 0 === b) {
        if ("function" === typeof a2.render) throw Error(n(188));
        throw Error(n(268, Object.keys(a2)));
      }
      a2 = xa(b);
      return null === a2 ? null : a2.stateNode;
    }
    function tg(a2, b) {
      a2 = a2.memoizedState;
      null !== a2 && null !== a2.dehydrated && a2.retryTime < b && (a2.retryTime = b);
    }
    function ug(a2, b) {
      tg(a2, b);
      (a2 = a2.alternate) && tg(a2, b);
    }
    var vg = {
      createContainer: function createContainer(a2, b, c2) {
        a2 = new rg(a2, b, c2);
        b = he(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
        a2.current = b;
        return b.stateNode = a2;
      },
      updateContainer: function updateContainer(a2, b, c2, d) {
        var e = b.current, f = G2(), g = Sc.suspense;
        f = Vc(f, e, g);
        a: if (c2) {
          c2 = c2._reactInternalFiber;
          b: {
            if (ua(c2) !== c2 || 1 !== c2.tag) throw Error(n(170));
            var l2 = c2;
            do {
              switch (l2.tag) {
                case 3:
                  l2 = l2.stateNode.context;
                  break b;
                case 1:
                  if (C2(l2.type)) {
                    l2 = l2.stateNode.__reactInternalMemoizedMergedChildContext;
                    break b;
                  }
              }
              l2 = l2.return;
            } while (null !== l2);
            throw Error(n(171));
          }
          if (1 === c2.tag) {
            var h2 = c2.type;
            if (C2(h2)) {
              c2 = Jb(c2, h2, l2);
              break a;
            }
          }
          c2 = l2;
        } else c2 = Db;
        null === b.context ? b.context = c2 : b.pendingContext = c2;
        b = Gc(f, g);
        b.payload = {
          element: a2
        };
        d = void 0 === d ? null : d;
        null !== d && (b.callback = d);
        Ic(e, b);
        Wc(e, f);
        return f;
      },
      batchedEventUpdates: function batchedEventUpdates(a2, b) {
        var c2 = T2;
        T2 |= 2;
        try {
          return a2(b);
        } finally {
          T2 = c2, T2 === R && F();
        }
      },
      batchedUpdates: function batchedUpdates(a2, b) {
        var c2 = T2;
        T2 |= 1;
        try {
          return a2(b);
        } finally {
          T2 = c2, T2 === R && F();
        }
      },
      unbatchedUpdates: function unbatchedUpdates(a2, b) {
        var c2 = T2;
        T2 &= -2;
        T2 |= rf;
        try {
          return a2(b);
        } finally {
          T2 = c2, T2 === R && F();
        }
      },
      deferredUpdates: function deferredUpdates(a2) {
        return hc(97, a2);
      },
      syncUpdates: function syncUpdates(a2, b, c2, d) {
        return hc(99, a2.bind(null, b, c2, d));
      },
      discreteUpdates: function discreteUpdates(a2, b, c2, d) {
        var e = T2;
        T2 |= 4;
        try {
          return hc(98, a2.bind(null, b, c2, d));
        } finally {
          T2 = e, T2 === R && F();
        }
      },
      flushDiscreteUpdates: function flushDiscreteUpdates() {
        (T2 & (1 | S2 | sf)) === R && (dg(), Vf());
      },
      flushControlled: function flushControlled(a2) {
        var b = T2;
        T2 |= 1;
        try {
          hc(99, a2);
        } finally {
          T2 = b, T2 === R && F();
        }
      },
      flushSync: eg,
      flushPassiveEffects: Vf,
      IsThisRendererActing: {
        current: false
      },
      getPublicRootInstance: function getPublicRootInstance(a2) {
        a2 = a2.current;
        if (!a2.child) return null;
        switch (a2.child.tag) {
          case 5:
            return za(a2.child.stateNode);
          default:
            return a2.child.stateNode;
        }
      },
      attemptSynchronousHydration: function attemptSynchronousHydration(a2) {
        switch (a2.tag) {
          case 3:
            var b = a2.stateNode;
            b.hydrate && cg(b, b.firstPendingTime);
            break;
          case 13:
            eg(function() {
              return Wc(a2, 1073741823);
            }), b = mc(G2(), 150, 100), ug(a2, b);
        }
      },
      attemptUserBlockingHydration: function attemptUserBlockingHydration(a2) {
        if (13 === a2.tag) {
          var b = mc(G2(), 150, 100);
          Wc(a2, b);
          ug(a2, b);
        }
      },
      attemptContinuousHydration: function attemptContinuousHydration(a2) {
        if (13 === a2.tag) {
          G2();
          var b = lc++;
          Wc(a2, b);
          ug(a2, b);
        }
      },
      attemptHydrationAtCurrentPriority: function attemptHydrationAtCurrentPriority(a2) {
        if (13 === a2.tag) {
          var b = G2();
          b = Vc(b, a2, null);
          Wc(a2, b);
          ug(a2, b);
        }
      },
      findHostInstance: sg,
      findHostInstanceWithWarning: function findHostInstanceWithWarning(a2) {
        return sg(a2);
      },
      findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(a2) {
        a2 = ya(a2);
        return null === a2 ? null : 20 === a2.tag ? a2.stateNode.instance : a2.stateNode;
      },
      shouldSuspend: function shouldSuspend() {
        return false;
      },
      injectIntoDevTools: function injectIntoDevTools(a2) {
        var b = a2.findFiberByHostInstance;
        return pg(aa({}, a2, {
          overrideHookState: null,
          overrideProps: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: q2.ReactCurrentDispatcher,
          findHostInstanceByFiber: function findHostInstanceByFiber(a3) {
            a3 = xa(a3);
            return null === a3 ? null : a3.stateNode;
          },
          findFiberByHostInstance: function findFiberByHostInstance(a3) {
            return b ? b(a3) : null;
          },
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null
        }));
      }
    };
    module2.exports = vg.default || vg;
    var $$$renderer = module2.exports;
    module2.exports = $$$reconciler;
    return $$$renderer;
  };
})(reactReconciler_production_min);
var reactReconciler_production_minExports = reactReconciler_production_min.exports;
var ReactFiberReconciler = getDefaultExportFromCjs3(reactReconciler_production_minExports);
var propsEqual = function propsEqual2(a2, b) {
  var oldPropsKeys = Object.keys(a2);
  var newPropsKeys = Object.keys(b);
  if (oldPropsKeys.length !== newPropsKeys.length) {
    return false;
  }
  for (var i = 0; i < oldPropsKeys.length; i += 1) {
    var propName = oldPropsKeys[i];
    if (propName === "render" && !a2[propName] !== !b[propName]) {
      return false;
    }
    if (propName !== "children" && a2[propName] !== b[propName]) {
      if (typeof a2[propName] === "object" && typeof b[propName] === "object" && propsEqual2(a2[propName], b[propName])) {
        continue;
      }
      return false;
    }
    if (propName === "children" && (typeof a2[propName] === "string" || typeof b[propName] === "string")) {
      return a2[propName] === b[propName];
    }
  }
  return true;
};
var _excluded$2 = ["style", "children"];
var _excluded22 = ["style"];
var emptyObject = {};
var appendChild = function appendChild2(parentInstance, child) {
  var isParentText = parentInstance.type === "TEXT" || parentInstance.type === "LINK" || parentInstance.type === "TSPAN";
  var isChildTextInstance = child.type === "TEXT_INSTANCE";
  var isOrphanTextInstance = isChildTextInstance && !isParentText;
  if (isOrphanTextInstance) {
    console.warn("Invalid '" + child.value + "' string child outside <Text> component");
    return;
  }
  parentInstance.children.push(child);
};
var createRenderer = function createRenderer2(_ref) {
  var _ref$onChange = _ref.onChange, onChange = _ref$onChange === void 0 ? function() {
  } : _ref$onChange;
  return ReactFiberReconciler({
    schedulePassiveEffects: scheduler.unstable_scheduleCallback,
    cancelPassiveEffects: scheduler.unstable_cancelCallback,
    supportsMutation: true,
    isPrimaryRenderer: false,
    warnsIfNotActing: false,
    appendInitialChild: appendChild,
    createInstance: function createInstance(type2, _ref2) {
      var style = _ref2.style;
      _ref2.children;
      var props = _objectWithoutPropertiesLoose(_ref2, _excluded$2);
      return {
        type: type2,
        box: {},
        style: style || {},
        props: props || {},
        children: []
      };
    },
    createTextInstance: function createTextInstance(text2, rootContainerInstance) {
      return {
        type: "TEXT_INSTANCE",
        value: text2
      };
    },
    finalizeInitialChildren: function finalizeInitialChildren(element, type2, props) {
      return false;
    },
    getPublicInstance: function getPublicInstance(instance) {
      return instance;
    },
    prepareForCommit: function prepareForCommit() {
    },
    clearContainer: function clearContainer() {
    },
    prepareUpdate: function prepareUpdate(element, type2, oldProps, newProps) {
      return !propsEqual(oldProps, newProps);
    },
    resetAfterCommit: onChange,
    resetTextContent: function resetTextContent(element) {
    },
    getRootHostContext: function getRootHostContext() {
      return emptyObject;
    },
    getChildHostContext: function getChildHostContext() {
      return emptyObject;
    },
    shouldSetTextContent: function shouldSetTextContent(type2, props) {
      return false;
    },
    now: Date.now,
    useSyncScheduling: true,
    appendChild,
    appendChildToContainer: function appendChildToContainer(parentInstance, child) {
      if (parentInstance.type === "ROOT") {
        parentInstance.document = child;
      } else {
        appendChild(parentInstance, child);
      }
    },
    insertBefore: function insertBefore(parentInstance, child, beforeChild) {
      var _parentInstance$child;
      var index2 = (_parentInstance$child = parentInstance.children) === null || _parentInstance$child === void 0 ? void 0 : _parentInstance$child.indexOf(beforeChild);
      if (index2 === void 0) return;
      if (index2 !== -1 && child) parentInstance.children.splice(index2, 0, child);
    },
    removeChild: function removeChild(parentInstance, child) {
      var _parentInstance$child2;
      var index2 = (_parentInstance$child2 = parentInstance.children) === null || _parentInstance$child2 === void 0 ? void 0 : _parentInstance$child2.indexOf(child);
      if (index2 === void 0) return;
      if (index2 !== -1) parentInstance.children.splice(index2, 1);
    },
    removeChildFromContainer: function removeChildFromContainer(parentInstance, child) {
      var _parentInstance$child3;
      var index2 = (_parentInstance$child3 = parentInstance.children) === null || _parentInstance$child3 === void 0 ? void 0 : _parentInstance$child3.indexOf(child);
      if (index2 === void 0) return;
      if (index2 !== -1) parentInstance.children.splice(index2, 1);
    },
    commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {
      textInstance.value = newText;
    },
    commitUpdate: function commitUpdate(instance, updatePayload, type2, oldProps, newProps) {
      var style = newProps.style, props = _objectWithoutPropertiesLoose(newProps, _excluded22);
      instance.props = props;
      instance.style = style;
    }
  });
};
var name = "@react-pdf/renderer";
var version$1 = "3.4.4";
var license = "MIT";
var description = "Create PDF files on the browser and server";
var author = "Diego Muracciole <diegomuracciole@gmail.com>";
var homepage = "https://github.com/diegomura/react-pdf#readme";
var type = "module";
var main = "./lib/react-pdf.cjs";
var module = "./lib/react-pdf.js";
var browser3 = {
  "./lib/react-pdf.js": "./lib/react-pdf.browser.js",
  "./lib/react-pdf.cjs": "./lib/react-pdf.browser.cjs"
};
var exports = {
  ".": {
    "import": "./lib/react-pdf.js",
    require: "./lib/react-pdf.cjs",
    "default": "./lib/react-pdf.js"
  }
};
var repository = {
  type: "git",
  url: "https://github.com/diegomura/react-pdf.git",
  directory: "packages/renderer"
};
var scripts = {
  build: "rimraf ./lib && rollup -c",
  watch: "rimraf ./lib && rollup -c -w",
  size: "size-limit",
  lint: "eslint src",
  test: "vitest && vitest --config vitest.browser.config.js"
};
var dependencies = {
  "@babel/runtime": "^7.20.13",
  "@react-pdf/font": "^2.5.1",
  "@react-pdf/layout": "^3.12.1",
  "@react-pdf/pdfkit": "^3.1.10",
  "@react-pdf/primitives": "^3.1.1",
  "@react-pdf/render": "^3.4.4",
  "@react-pdf/types": "^2.5.0",
  events: "^3.3.0",
  "object-assign": "^4.1.1",
  "prop-types": "^15.6.2",
  queue: "^6.0.1",
  scheduler: "^0.17.0"
};
var peerDependencies = {
  react: "^16.8.0 || ^17.0.0 || ^18.0.0"
};
var files = [
  "lib",
  "index.d.ts"
];
var collective = {
  type: "opencollective",
  url: "https://opencollective.com/react-pdf",
  logo: "https://opencollective.com/opencollective/logo.txt"
};
var devDependencies = {
  "@size-limit/preset-big-lib": "^11.0.1",
  assert: "^2.0.0",
  "browserify-zlib": "^0.2.0",
  buffer: "^6.0.3",
  process: "^0.11.10",
  "react-reconciler": "0.23.0",
  "size-limit": "^11.0.1",
  util: "^0.12.4"
};
var packageJson = {
  name,
  version: version$1,
  license,
  description,
  author,
  homepage,
  type,
  main,
  module,
  browser: browser3,
  exports,
  repository,
  scripts,
  dependencies,
  peerDependencies,
  "lint-staged": {
    "*.js": [
      "yarn lint",
      "prettier --write"
    ]
  },
  files,
  collective,
  devDependencies
};
var version3 = packageJson.version;
var fontStore = new FontStore();
var renderer;
var events = {};
var pdf = function pdf2(initialValue) {
  var onChange = function onChange2() {
    var _events$change;
    var listeners3 = ((_events$change = events.change) === null || _events$change === void 0 ? void 0 : _events$change.slice()) || [];
    for (var i = 0; i < listeners3.length; i += 1) listeners3[i]();
  };
  var container = {
    type: "ROOT",
    document: null
  };
  renderer = renderer || createRenderer({
    onChange
  });
  var mountNode = renderer.createContainer(container);
  var updateContainer = function updateContainer2(doc, callback) {
    renderer.updateContainer(doc, mountNode, null, callback);
  };
  if (initialValue) updateContainer(initialValue);
  var render5 = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(compress) {
      var props, pdfVersion, language, pageLayout, pageMode, ctx, layout2, fileStream;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (compress === void 0) {
              compress = true;
            }
            props = container.document.props || {};
            pdfVersion = props.pdfVersion, language = props.language, pageLayout = props.pageLayout, pageMode = props.pageMode;
            ctx = new PDFDocument({
              compress,
              pdfVersion,
              lang: language,
              displayTitle: true,
              autoFirstPage: false,
              pageLayout,
              pageMode
            });
            _context.next = 6;
            return layout(container.document, fontStore);
          case 6:
            layout2 = _context.sent;
            fileStream = render(ctx, layout2);
            return _context.abrupt("return", {
              layout: layout2,
              fileStream
            });
          case 9:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function render6(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  var callOnRender = function callOnRender2(params) {
    if (params === void 0) {
      params = {};
    }
    if (container.document.props.onRender) {
      container.document.props.onRender(params);
    }
  };
  var toBlob = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2() {
      var chunks, _yield$render, _INTERNAL__LAYOUT__DATA_, instance;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            chunks = [];
            _context2.next = 3;
            return render5();
          case 3:
            _yield$render = _context2.sent;
            _INTERNAL__LAYOUT__DATA_ = _yield$render.layout;
            instance = _yield$render.fileStream;
            return _context2.abrupt("return", new Promise(function(resolve3, reject) {
              instance.on("data", function(chunk) {
                chunks.push(chunk instanceof Uint8Array ? chunk : new Uint8Array(chunk));
              });
              instance.on("end", function() {
                try {
                  var blob = new Blob(chunks, {
                    type: "application/pdf"
                  });
                  callOnRender({
                    blob,
                    _INTERNAL__LAYOUT__DATA_
                  });
                  resolve3(blob);
                } catch (error) {
                  reject(error);
                }
              });
            }));
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function toBlob2() {
      return _ref2.apply(this, arguments);
    };
  }();
  var toBuffer = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3() {
      var _yield$render2, _INTERNAL__LAYOUT__DATA_, fileStream;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return render5();
          case 2:
            _yield$render2 = _context3.sent;
            _INTERNAL__LAYOUT__DATA_ = _yield$render2.layout;
            fileStream = _yield$render2.fileStream;
            callOnRender({
              _INTERNAL__LAYOUT__DATA_
            });
            return _context3.abrupt("return", fileStream);
          case 7:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function toBuffer2() {
      return _ref3.apply(this, arguments);
    };
  }();
  var toString7 = function() {
    var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4() {
      var result, _yield$render3, instance;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            if (true) {
              console.warn("`toString` is deprecated and will be removed in next major release");
            }
            result = "";
            _context4.next = 4;
            return render5(false);
          case 4:
            _yield$render3 = _context4.sent;
            instance = _yield$render3.fileStream;
            return _context4.abrupt("return", new Promise(function(resolve3, reject) {
              try {
                instance.on("data", function(buffer) {
                  result += buffer;
                });
                instance.on("end", function() {
                  callOnRender();
                  resolve3(result);
                });
              } catch (error) {
                reject(error);
              }
            }));
          case 7:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return function toString8() {
      return _ref4.apply(this, arguments);
    };
  }();
  var on3 = function on4(event, listener) {
    if (!events[event]) events[event] = [];
    events[event].push(listener);
  };
  var removeListener5 = function removeListener6(event, listener) {
    if (!events[event]) return;
    var idx = events[event].indexOf(listener);
    if (idx > -1) events[event].splice(idx, 1);
  };
  return {
    on: on3,
    container,
    toBlob,
    toBuffer,
    toString: toString7,
    removeListener: removeListener5,
    updateContainer
  };
};
var Font2 = fontStore;
var StyleSheet = {
  create: function create(s2) {
    return s2;
  }
};
var usePDF = function usePDF2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, document2 = _ref.document;
  var pdfInstance = (0, import_react.useRef)(null);
  var _useState = (0, import_react.useState)({
    url: null,
    blob: null,
    error: null,
    loading: !!document2
  }), state2 = _useState[0], setState = _useState[1];
  (0, import_react.useEffect)(function() {
    var renderQueue = (0, import_queue.default)({
      autostart: true,
      concurrency: 1
    });
    var queueDocumentRender = function queueDocumentRender2() {
      setState(function(prev) {
        return _extends({}, prev, {
          loading: true
        });
      });
      renderQueue.splice(0, renderQueue.length, function() {
        return state2.error ? Promise.resolve() : pdfInstance.current.toBlob();
      });
    };
    var onRenderFailed = function onRenderFailed2(error) {
      console.error(error);
      setState(function(prev) {
        return _extends({}, prev, {
          loading: false,
          error
        });
      });
    };
    var onRenderSuccessful = function onRenderSuccessful2(blob) {
      setState({
        blob,
        error: null,
        loading: false,
        url: URL.createObjectURL(blob)
      });
    };
    pdfInstance.current = pdf();
    pdfInstance.current.on("change", queueDocumentRender);
    if (document2) {
      pdfInstance.current.updateContainer(document2);
    }
    renderQueue.on("error", onRenderFailed);
    renderQueue.on("success", onRenderSuccessful);
    return function() {
      renderQueue.end();
      pdfInstance.current.removeListener("change", queueDocumentRender);
    };
  }, []);
  (0, import_react.useEffect)(function() {
    return function() {
      if (state2.url) {
        URL.revokeObjectURL(state2.url);
      }
    };
  }, [state2.url]);
  var update = (0, import_react.useCallback)(function(newDoc) {
    pdfInstance.current.updateContainer(newDoc);
  }, []);
  return [state2, update];
};
var _excluded$1 = ["title", "style", "className", "children", "innerRef", "showToolbar"];
var PDFViewer = function PDFViewer2(_ref) {
  var title3 = _ref.title, style = _ref.style, className = _ref.className, children = _ref.children, innerRef = _ref.innerRef, _ref$showToolbar = _ref.showToolbar, showToolbar = _ref$showToolbar === void 0 ? true : _ref$showToolbar, props = _objectWithoutPropertiesLoose(_ref, _excluded$1);
  var _usePDF = usePDF(), instance = _usePDF[0], updateInstance = _usePDF[1];
  (0, import_react.useEffect)(function() {
    return updateInstance(children);
  }, [children]);
  var src = instance.url ? instance.url + "#toolbar=" + (showToolbar ? 1 : 0) : null;
  return (0, import_jsx_runtime.jsx)("iframe", _extends({
    src,
    title: title3,
    ref: innerRef,
    style,
    className
  }, props));
};
var BlobProvider = function BlobProvider2(_ref) {
  var doc = _ref.document, children = _ref.children;
  var _usePDF = usePDF(), instance = _usePDF[0], updateInstance = _usePDF[1];
  (0, import_react.useEffect)(function() {
    return updateInstance(doc);
  }, [doc]);
  if (!doc) {
    console.warn("You should pass a valid document to BlobProvider");
    return null;
  }
  return children(instance);
};
var _excluded4 = ["fileName", "document", "children", "onClick", "href"];
var PDFDownloadLink = function PDFDownloadLink2(_ref) {
  var _ref$fileName = _ref.fileName, fileName = _ref$fileName === void 0 ? "document.pdf" : _ref$fileName, doc = _ref.document, children = _ref.children, onClick = _ref.onClick;
  _ref.href;
  var rest = _objectWithoutPropertiesLoose(_ref, _excluded4);
  var _usePDF = usePDF(), instance = _usePDF[0], updateInstance = _usePDF[1];
  (0, import_react.useEffect)(function() {
    return updateInstance(doc);
  }, [doc]);
  if (!doc) {
    console.warn("You should pass a valid document to PDFDownloadLink");
    return null;
  }
  var handleDownloadIE = function handleDownloadIE2() {
    if (window.navigator.msSaveBlob) {
      window.navigator.msSaveBlob(instance.blob, fileName);
    }
  };
  var handleClick = function handleClick2(event) {
    handleDownloadIE();
    if (typeof onClick === "function") onClick(event, instance);
  };
  return (0, import_jsx_runtime.jsx)("a", _extends({
    href: instance.url,
    download: fileName,
    onClick: handleClick
  }, rest, {
    children: typeof children === "function" ? children(instance) : children
  }));
};
var throwEnvironmentError = function throwEnvironmentError2(name2) {
  throw new Error(name2 + " is a Node specific API. You're either using this method in a browser, or your bundler is not loading react-pdf from the appropriate web build.");
};
var renderToStream = function renderToStream2() {
  throwEnvironmentError("renderToStream");
};
var renderToBuffer = function renderToBuffer2() {
  throwEnvironmentError("renderToBuffer");
};
var renderToString = function renderToString2() {
  throwEnvironmentError("renderToString");
};
var renderToFile = function renderToFile2() {
  throwEnvironmentError("renderToFile");
};
var render3 = function render4() {
  throwEnvironmentError("render");
};
var index = _extends({
  pdf,
  usePDF,
  Font: Font2,
  version: version3,
  StyleSheet,
  PDFViewer,
  BlobProvider,
  PDFDownloadLink,
  renderToStream,
  renderToString,
  renderToFile,
  render: render3
}, src_exports);
export {
  BlobProvider,
  Canvas,
  Circle,
  ClipPath,
  Defs,
  Document,
  Ellipse,
  Font2 as Font,
  G,
  Image,
  Line,
  LinearGradient,
  Link,
  Note,
  PDFDownloadLink,
  PDFViewer,
  Page,
  Path,
  Polygon,
  Polyline,
  RadialGradient,
  Rect,
  Stop,
  StyleSheet,
  Svg,
  Text,
  TextInstance,
  Tspan,
  View,
  createRenderer,
  index as default,
  pdf,
  render3 as render,
  renderToBuffer,
  renderToFile,
  renderToStream,
  renderToString,
  usePDF,
  version3 as version
};
/*! Bundled license information:

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

scheduler/cjs/scheduler.development.js:
  (** @license React v0.17.0
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@babel/runtime/helpers/esm/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

@react-pdf/png-js/lib/png-js.browser.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

@react-pdf/pdfkit/lib/pdfkit.browser.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

@react-pdf/textkit/lib/textkit.js:
  (**
   * @param {Object[]} nodes
   * @param {number[]} lines
   * @param {Object} settings
   * @preserve Knuth and Plass line breaking algorithm in JavaScript
   *
   * Licensed under the new BSD License.
   * Copyright 2009-2010, Bram Stein
   * All rights reserved.
   *)

@react-pdf/image/lib/index.browser.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

@react-pdf/renderer/lib/react-pdf.browser.js:
  (** @license React v0.23.0
   * react-reconciler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@react-pdf_renderer.js.map
